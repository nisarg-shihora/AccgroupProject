https://www.javatpoint.com/stone-game-in-java Stone Game in Java - Javatpoint ? SCROLL TO TOP Home Java Programs OOPs String Exception Multithreading Collections JavaFX JSP Spring Spring Boot Projects Interview Questions Java Tutorial What is Java History of Java Features of Java C++ vs Java Hello Java Program Program Internal How to set path? JDK, JRE and JVM JVM: Java Virtual Machine Java Variables Java Data Types Unicode System Operators Keywords Control Statements Java Control Statements Java If-else Java Switch Java For Loop Java While Loop Java Do While Loop Java Break Java Continue Java Comments Java Programs Java Object Class Java OOPs Concepts Naming Convention Object and Class Method Constructor static keyword this keyword Java Inheritance Inheritance(IS-A) Aggregation(HAS-A) Java Polymorphism Method Overloading Method Overriding Covariant Return Type super keyword Instance Initializer block final keyword Runtime Polymorphism Dynamic Binding instanceof operator Java Abstraction Abstract class Interface Abstract vs Interface Java Encapsulation Package Access Modifiers Encapsulation Java Array Java Array Java OOPs Misc Object class Object Cloning Math class Wrapper Class Java Recursion Call By Value strictfp keyword javadoc tool Command Line Arg Object vs Class Overloading vs Overriding Java String Java Regex Exception Handling Java Inner classes Java Multithreading Java I/O Java Networking Java AWT & Events Java Swing JavaFX Java Applet Java Reflection Java Date Java Conversion Java Collection Java JDBC Java Misc Java New Features RMI Internationalization Interview Questions Java MCQ next ? ? prev Stone Game in Java In this game, stones are placed in a row (an input array is given). Two players are assigned the task of picking the stones of the maximum values. The player who collects stones of the maximum value wins the game. Player 1 will play first. After that, player two will play, and so on. At a time, a player can choose either 1 or 2 or 3 stones. The stones must be chosen from the left side only. Note that a player has to pick at least one stone. Our task is to decide which player will win the game if both the players play optimally. Example 1: int arr[] = {4, 3, 9, 16} Output: It is a tie between player 1 and player2 Explanation: Since stones are chosen from the left side and at max, only three stones are chosen, player 1 can only choose stones 1, 2 & 3. Thus, the total values of the stones chosen is 4 + 3 + 9 = 16. Now, it is the term of player 2. Player 2 can choose stone 4, which is of the value 16. Thus, both the players got the same value. Hence, it is a tie. Example 2: int arr[] = {8, -1, -1, 7} Output: Player 1 wins the game. Explanation: Player 1 plays optimally. Player 1 picks only the 1st stone from the left and leaves the rest. Thus, player 1 has a total value 8. Now, it is player 2 turn to pick the stones. Since players can only pick stones from the left only; therefore, player 2 has to pick stones of the values -1, -1, and 7. Thus, total value picked by the player 2 is -1 + -1 + 7 = 5, which is less than 8. Hence, player 1 wins. Example 3: int arr[] = {-7, 2, 6, 3} Output: Player 2 wins the game. Explanation: To gain the maximum value, player 1 picks stones 1, 2, and 3. Thus, collecting the maximum value of -7 + 2 + 6 = 1. There is only one stone left which is picked by player 2. The stone is of the value 3. Thus, player 2 wins the game. Example 4: int arr[] = {1, 2, 0, 3, 6, 7, 4} Output: Player 1 wins the game. Explanation: To gain the maximum value, player 1 picks stones 1 and 2 only. Thus, collecting the maximum value of 1 + 2 = 3. Now, it is the turn of player 2, and the player 2 picks stones of the values 0, 3, and 6 (total values 0 + 3 + 6 = 9). Again, it is the turn of player 1, and player 1 picks 7 and 4. Thus, total value collected by the player 1 is 3 + 7 + 4 = 14, which is greater than 9. Hence, player 1 wins the game. Approach: Using Recursion It is a brute force approach, where we consider each possible scenario for the player. The first scenario is when the player picks only one stone. The second scenario is when the player picks the two stones. The third scenario is when the player picks three stones. The maximum of these three scenarios is the value collected by the player. Observe the following program. FileName: StoneGame.java 
public class StoneGame 
{
    private int solve(int j, int[] nums)
    {
        // size of the array
        int size = nums.length;
        
        // handling the base case
        if(j >= size)
        {
            return 0;
        }
        // if we pick only one stone
        int one = Integer.MIN_VALUE;
        // if we pick two stones
        int two = Integer.MIN_VALUE;
        // if we pick three stones
        int three = Integer.MIN_VALUE;
        // picked one stone and performing the 
        // further computation
        one = nums[j] - solve(j + 1, nums);
        if((j + 1) < size)
        {
            // picked two stones at a time and performing 
            // the further computation
            two = nums[j] + nums[j + 1] - solve(j + 2, nums);
        }
        if((j + 2) < size)
        {
            // picked 3 stones at a time and performing the further
            // computation
            three = nums[j] + nums[j + 1] + nums[j + 2] - solve(j + 3, nums);
        }
        // picking the maximum between one, two and three
        return Math.max(one, Math.max(two, three));
    }
    public int stoneGameSol(int[] stoneVal) 
    {
        int ans = solve(0, stoneVal);
        if(ans == 0)
        {
            // 0 means its a tie
            return 0;
        }
        if(ans > 0)
        {
            // 1 means player 1 wins the game
            return 1;
        }
        // 2 means player 2 wins the game
        return 2;
    }
    // main method
public static void main(String[] argvs) 
{
// creating an object of the class StoneGame
StoneGame obj = new StoneGame();
// input 1
int arr[] = {4, 3, 9, 16};
int size = arr.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr[i] + " ");
}
System.out.println();
int ans = obj.stoneGameSol(arr);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 2
int arr1[] = {8, -1, -1, 7};
size = arr1.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr1[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr1);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 3
int arr2[] = {-7, 2, 6, 3};
size = arr2.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr2[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr2);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 4
int arr3[] = {1, 2, 0, 3, 6, 7, 4};
size = arr3.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr3[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr3);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
}
}
 Output: For the stones of the following values: 
4 3 9 16 
It is a tie between player 1 and player 2

For the stones of the following values: 
8 -1 -1 7 
Player 1 wins the game.

For the stones of the following values: 
-7 2 6 3 
Player 2 wins the game.

For the stones of the following values: 
1 2 0 3 6 7 4 
Player 1 wins the game.
 Complexity Analysis: The time complexity of the program is exponential as there are recursive calls for all the scenarios. The above program is not suitable for larger input as it will take a lot of time because of its high time complexity. Approach: Using Iteration (Dynamic Programming) We will assume that the dp[j] is the maximum value player 1 can get. Since player 1 can take 1 to 3 stones, player 2 can begin from either dp[j + 1], dp[j + 2], dp[j + 3]. Player 2 can also take 1 to 3 stones. Thus, resulting in the minimum of dp[j + 2 to 4], dp[j + 3 to 5], and dp[j + 4 to 6]. Thus, 
Dp[j] = max
(
                    stoneArr[j : j + 1] + min(dp[j + 2], dp[j + 3], dp[j + 4]),
                    stoneArr[j : j + 2] + min(dp[j + 3], dp[j + 4], dp[j + 5]),
                    stoneArr[j : j + 3] + min(dp[j + 4], dp[j + 5], dp[j + 6])
              )
 If any of the indexes are out of bounds, then it means the value is 0. The resulting score is stored dp[0]. FileName: StoneGame1.java 
public class StoneGame1 
{
public int stoneGameSol(int storeArr[]) 
{
// computing the size of the array
int n = storeArr.length;
int dp[] = new int[n];
// contains the sum of the values of 
// the stones present in the array stoneArr
int sums[] = new int[n+1];
for (int j = 0; j < n; j++) 
{
sums[j + 1] = sums[j] + storeArr[j];
}
dp[n - 1] = storeArr[n - 1];
if (n > 1) 
{
dp[n - 2] = storeArr[n - 2] + Math.max(storeArr[n - 1], 0);
for (int j = n - 3; j >= 0; j--) 
{
dp[j] = Integer.MIN_VALUE;
for (int k = 1; k <= 3; k++) 
{
// score is the sum of values of the
// stone taken by the player
// for k = 1 only one stone is taken
// for k = 2, two stones are taken
// for k = 3, three stones are taken
int score = sums[j + k] - sums[j];
int a1 = j + k + 1 < n ? dp[j + k + 1] : 0;
int a2 = j + k + 2 < n ? dp[j + k + 2] : 0;
int a3 = j + k + 3 < n ? dp[j + k + 3] : 0;
// the players are playing optimally. Hence, we have to pick
// the minimum between a1, a2, a3
dp[j] = Math.max(dp[j], score + Math.min(a1, Math.min(a2, a3)));
}
}
}
if ((2 * dp[0]) > sums[n]) 
{
return 1;
}
else if ((2 * dp[0]) < sums[n]) 
{
return 2;
}
else 
{
return 0;
}
}
// main method
public static void main(String[] argvs) 
{
// creating an object of the class StoneGame1
StoneGame1 obj = new StoneGame1();
// input 1
int arr[] = {4, 3, 9, 16};
int size = arr.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr[i] + " ");
}
System.out.println();
int ans = obj.stoneGameSol(arr);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 2
int arr1[] = {8, -1, -1, 7};
size = arr1.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr1[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr1);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 3
int arr2[] = {-7, 2, 6, 3};
size = arr2.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr2[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr2);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 4
int arr3[] = {1, 2, 0, 3, 6, 7, 4};
size = arr3.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr3[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr3);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
}
}
 Output: For the stones of the following values: 
4 3 9 16 
It is a tie between player 1 and player 2

For the stones of the following values: 
8 -1 -1 7 
Player 1 wins the game.

For the stones of the following values: 
-7 2 6 3 
Player 2 wins the game.

For the stones of the following values: 
1 2 0 3 6 7 4 
Player 1 wins the game.
 Complexity Analysis: The time complexity of the program is O(3 * N). In terms of the asymptotic time complexity, it is O(N). As the program uses two auxiliary arrays for storing the answer and the sum of values of stones, the space complexity of the program is O(N + N), which is O(2 *N). In terms of asymptotic time, it is again O(N), where N is the total number of elements present in the stone array. The space complexity of the program can be further reduced. We can use variables instead of arrays, and it is evident in the following program. FileName: StoneGame1.java 
public class StoneGame1 
{
public int stoneGameSol(int storeArr[]) 
{
// computing the size of the array
int size = storeArr.length;
int first = 0; // contains the answer
int second = 0;
int third = 0;
for(int j = size - 1; j >= 0; j--)
{
// one for picking only one stone
int one = Integer.MIN_VALUE;
// two for picking two stones
int two = Integer.MIN_VALUE;
// three for picking three stones
int three = Integer.MIN_VALUE;
one = storeArr[j]- first;
if((j + 1) < size)
{
two = storeArr[j] + storeArr[j + 1] - second;
}
if((j + 2) < size)
{
three = storeArr[j] + storeArr[j + 1] + storeArr[j + 2] - third;
}
int tmp = Math.max(one, Math.max(two, three));
third = second;
second = first;
first = tmp;
}
if(first == 0) 
{
return 0;
}
else if(first > 0) 
{
return 1;
}
else 
{
return 2;
}
}
    // main method
public static void main(String[] argvs) 
{
// creating an object of the class StoneGame1
StoneGame1 obj = new StoneGame1();
// input 1
int arr[] = {4, 3, 9, 16};
int size = arr.length;

System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr[i] + " ");
}
System.out.println();
int ans = obj.stoneGameSol(arr);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 2
int arr1[] = {8, -1, -1, 7};
size = arr1.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr1[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr1);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 3
int arr2[] = {-7, 2, 6, 3};
size = arr2.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr2[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr2);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 4
int arr3[] = {1, 2, 0, 3, 6, 7, 4};
size = arr3.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr3[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr3);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
}
}
 Output: For the stones of the following values: 
4 3 9 16 
It is a tie between player 1 and player 2

For the stones of the following values: 
8 -1 -1 7 
Player 1 wins the game.

For the stones of the following values: 
-7 2 6 3 
Player 2 wins the game.

For the stones of the following values: 
1 2 0 3 6 7 4 
Player 1 wins the game.
 Complexity Analysis: The time complexity of the program is the same as the previous program. Since the program is only using variables and not arrays, the space complexity of the program is constant, i.e., O(1). Next TopicTypeErasure in Java ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/stone-game-in-java Stone Game in Java - Javatpoint ? SCROLL TO TOP Home Java Programs OOPs String Exception Multithreading Collections JavaFX JSP Spring Spring Boot Projects Interview Questions Java Tutorial What is Java History of Java Features of Java C++ vs Java Hello Java Program Program Internal How to set path? JDK, JRE and JVM JVM: Java Virtual Machine Java Variables Java Data Types Unicode System Operators Keywords Control Statements Java Control Statements Java If-else Java Switch Java For Loop Java While Loop Java Do While Loop Java Break Java Continue Java Comments Java Programs Java Object Class Java OOPs Concepts Naming Convention Object and Class Method Constructor static keyword this keyword Java Inheritance Inheritance(IS-A) Aggregation(HAS-A) Java Polymorphism Method Overloading Method Overriding Covariant Return Type super keyword Instance Initializer block final keyword Runtime Polymorphism Dynamic Binding instanceof operator Java Abstraction Abstract class Interface Abstract vs Interface Java Encapsulation Package Access Modifiers Encapsulation Java Array Java Array Java OOPs Misc Object class Object Cloning Math class Wrapper Class Java Recursion Call By Value strictfp keyword javadoc tool Command Line Arg Object vs Class Overloading vs Overriding Java String Java Regex Exception Handling Java Inner classes Java Multithreading Java I/O Java Networking Java AWT & Events Java Swing JavaFX Java Applet Java Reflection Java Date Java Conversion Java Collection Java JDBC Java Misc Java New Features RMI Internationalization Interview Questions Java MCQ next ? ? prev Stone Game in Java In this game, stones are placed in a row (an input array is given). Two players are assigned the task of picking the stones of the maximum values. The player who collects stones of the maximum value wins the game. Player 1 will play first. After that, player two will play, and so on. At a time, a player can choose either 1 or 2 or 3 stones. The stones must be chosen from the left side only. Note that a player has to pick at least one stone. Our task is to decide which player will win the game if both the players play optimally. Example 1: int arr[] = {4, 3, 9, 16} Output: It is a tie between player 1 and player2 Explanation: Since stones are chosen from the left side and at max, only three stones are chosen, player 1 can only choose stones 1, 2 & 3. Thus, the total values of the stones chosen is 4 + 3 + 9 = 16. Now, it is the term of player 2. Player 2 can choose stone 4, which is of the value 16. Thus, both the players got the same value. Hence, it is a tie. Example 2: int arr[] = {8, -1, -1, 7} Output: Player 1 wins the game. Explanation: Player 1 plays optimally. Player 1 picks only the 1st stone from the left and leaves the rest. Thus, player 1 has a total value 8. Now, it is player 2 turn to pick the stones. Since players can only pick stones from the left only; therefore, player 2 has to pick stones of the values -1, -1, and 7. Thus, total value picked by the player 2 is -1 + -1 + 7 = 5, which is less than 8. Hence, player 1 wins. Example 3: int arr[] = {-7, 2, 6, 3} Output: Player 2 wins the game. Explanation: To gain the maximum value, player 1 picks stones 1, 2, and 3. Thus, collecting the maximum value of -7 + 2 + 6 = 1. There is only one stone left which is picked by player 2. The stone is of the value 3. Thus, player 2 wins the game. Example 4: int arr[] = {1, 2, 0, 3, 6, 7, 4} Output: Player 1 wins the game. Explanation: To gain the maximum value, player 1 picks stones 1 and 2 only. Thus, collecting the maximum value of 1 + 2 = 3. Now, it is the turn of player 2, and the player 2 picks stones of the values 0, 3, and 6 (total values 0 + 3 + 6 = 9). Again, it is the turn of player 1, and player 1 picks 7 and 4. Thus, total value collected by the player 1 is 3 + 7 + 4 = 14, which is greater than 9. Hence, player 1 wins the game. Approach: Using Recursion It is a brute force approach, where we consider each possible scenario for the player. The first scenario is when the player picks only one stone. The second scenario is when the player picks the two stones. The third scenario is when the player picks three stones. The maximum of these three scenarios is the value collected by the player. Observe the following program. FileName: StoneGame.java 
public class StoneGame 
{
    private int solve(int j, int[] nums)
    {
        // size of the array
        int size = nums.length;
        
        // handling the base case
        if(j >= size)
        {
            return 0;
        }
        // if we pick only one stone
        int one = Integer.MIN_VALUE;
        // if we pick two stones
        int two = Integer.MIN_VALUE;
        // if we pick three stones
        int three = Integer.MIN_VALUE;
        // picked one stone and performing the 
        // further computation
        one = nums[j] - solve(j + 1, nums);
        if((j + 1) < size)
        {
            // picked two stones at a time and performing 
            // the further computation
            two = nums[j] + nums[j + 1] - solve(j + 2, nums);
        }
        if((j + 2) < size)
        {
            // picked 3 stones at a time and performing the further
            // computation
            three = nums[j] + nums[j + 1] + nums[j + 2] - solve(j + 3, nums);
        }
        // picking the maximum between one, two and three
        return Math.max(one, Math.max(two, three));
    }
    public int stoneGameSol(int[] stoneVal) 
    {
        int ans = solve(0, stoneVal);
        if(ans == 0)
        {
            // 0 means its a tie
            return 0;
        }
        if(ans > 0)
        {
            // 1 means player 1 wins the game
            return 1;
        }
        // 2 means player 2 wins the game
        return 2;
    }
    // main method
public static void main(String[] argvs) 
{
// creating an object of the class StoneGame
StoneGame obj = new StoneGame();
// input 1
int arr[] = {4, 3, 9, 16};
int size = arr.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr[i] + " ");
}
System.out.println();
int ans = obj.stoneGameSol(arr);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 2
int arr1[] = {8, -1, -1, 7};
size = arr1.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr1[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr1);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 3
int arr2[] = {-7, 2, 6, 3};
size = arr2.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr2[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr2);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 4
int arr3[] = {1, 2, 0, 3, 6, 7, 4};
size = arr3.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr3[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr3);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
}
}
 Output: For the stones of the following values: 
4 3 9 16 
It is a tie between player 1 and player 2

For the stones of the following values: 
8 -1 -1 7 
Player 1 wins the game.

For the stones of the following values: 
-7 2 6 3 
Player 2 wins the game.

For the stones of the following values: 
1 2 0 3 6 7 4 
Player 1 wins the game.
 Complexity Analysis: The time complexity of the program is exponential as there are recursive calls for all the scenarios. The above program is not suitable for larger input as it will take a lot of time because of its high time complexity. Approach: Using Iteration (Dynamic Programming) We will assume that the dp[j] is the maximum value player 1 can get. Since player 1 can take 1 to 3 stones, player 2 can begin from either dp[j + 1], dp[j + 2], dp[j + 3]. Player 2 can also take 1 to 3 stones. Thus, resulting in the minimum of dp[j + 2 to 4], dp[j + 3 to 5], and dp[j + 4 to 6]. Thus, 
Dp[j] = max
(
                    stoneArr[j : j + 1] + min(dp[j + 2], dp[j + 3], dp[j + 4]),
                    stoneArr[j : j + 2] + min(dp[j + 3], dp[j + 4], dp[j + 5]),
                    stoneArr[j : j + 3] + min(dp[j + 4], dp[j + 5], dp[j + 6])
              )
 If any of the indexes are out of bounds, then it means the value is 0. The resulting score is stored dp[0]. FileName: StoneGame1.java 
public class StoneGame1 
{
public int stoneGameSol(int storeArr[]) 
{
// computing the size of the array
int n = storeArr.length;
int dp[] = new int[n];
// contains the sum of the values of 
// the stones present in the array stoneArr
int sums[] = new int[n+1];
for (int j = 0; j < n; j++) 
{
sums[j + 1] = sums[j] + storeArr[j];
}
dp[n - 1] = storeArr[n - 1];
if (n > 1) 
{
dp[n - 2] = storeArr[n - 2] + Math.max(storeArr[n - 1], 0);
for (int j = n - 3; j >= 0; j--) 
{
dp[j] = Integer.MIN_VALUE;
for (int k = 1; k <= 3; k++) 
{
// score is the sum of values of the
// stone taken by the player
// for k = 1 only one stone is taken
// for k = 2, two stones are taken
// for k = 3, three stones are taken
int score = sums[j + k] - sums[j];
int a1 = j + k + 1 < n ? dp[j + k + 1] : 0;
int a2 = j + k + 2 < n ? dp[j + k + 2] : 0;
int a3 = j + k + 3 < n ? dp[j + k + 3] : 0;
// the players are playing optimally. Hence, we have to pick
// the minimum between a1, a2, a3
dp[j] = Math.max(dp[j], score + Math.min(a1, Math.min(a2, a3)));
}
}
}
if ((2 * dp[0]) > sums[n]) 
{
return 1;
}
else if ((2 * dp[0]) < sums[n]) 
{
return 2;
}
else 
{
return 0;
}
}
// main method
public static void main(String[] argvs) 
{
// creating an object of the class StoneGame1
StoneGame1 obj = new StoneGame1();
// input 1
int arr[] = {4, 3, 9, 16};
int size = arr.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr[i] + " ");
}
System.out.println();
int ans = obj.stoneGameSol(arr);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 2
int arr1[] = {8, -1, -1, 7};
size = arr1.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr1[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr1);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 3
int arr2[] = {-7, 2, 6, 3};
size = arr2.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr2[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr2);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 4
int arr3[] = {1, 2, 0, 3, 6, 7, 4};
size = arr3.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr3[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr3);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
}
}
 Output: For the stones of the following values: 
4 3 9 16 
It is a tie between player 1 and player 2

For the stones of the following values: 
8 -1 -1 7 
Player 1 wins the game.

For the stones of the following values: 
-7 2 6 3 
Player 2 wins the game.

For the stones of the following values: 
1 2 0 3 6 7 4 
Player 1 wins the game.
 Complexity Analysis: The time complexity of the program is O(3 * N). In terms of the asymptotic time complexity, it is O(N). As the program uses two auxiliary arrays for storing the answer and the sum of values of stones, the space complexity of the program is O(N + N), which is O(2 *N). In terms of asymptotic time, it is again O(N), where N is the total number of elements present in the stone array. The space complexity of the program can be further reduced. We can use variables instead of arrays, and it is evident in the following program. FileName: StoneGame1.java 
public class StoneGame1 
{
public int stoneGameSol(int storeArr[]) 
{
// computing the size of the array
int size = storeArr.length;
int first = 0; // contains the answer
int second = 0;
int third = 0;
for(int j = size - 1; j >= 0; j--)
{
// one for picking only one stone
int one = Integer.MIN_VALUE;
// two for picking two stones
int two = Integer.MIN_VALUE;
// three for picking three stones
int three = Integer.MIN_VALUE;
one = storeArr[j]- first;
if((j + 1) < size)
{
two = storeArr[j] + storeArr[j + 1] - second;
}
if((j + 2) < size)
{
three = storeArr[j] + storeArr[j + 1] + storeArr[j + 2] - third;
}
int tmp = Math.max(one, Math.max(two, three));
third = second;
second = first;
first = tmp;
}
if(first == 0) 
{
return 0;
}
else if(first > 0) 
{
return 1;
}
else 
{
return 2;
}
}
    // main method
public static void main(String[] argvs) 
{
// creating an object of the class StoneGame1
StoneGame1 obj = new StoneGame1();
// input 1
int arr[] = {4, 3, 9, 16};
int size = arr.length;

System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr[i] + " ");
}
System.out.println();
int ans = obj.stoneGameSol(arr);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 2
int arr1[] = {8, -1, -1, 7};
size = arr1.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr1[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr1);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 3
int arr2[] = {-7, 2, 6, 3};
size = arr2.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr2[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr2);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 4
int arr3[] = {1, 2, 0, 3, 6, 7, 4};
size = arr3.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr3[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr3);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
}
}
 Output: For the stones of the following values: 
4 3 9 16 
It is a tie between player 1 and player 2

For the stones of the following values: 
8 -1 -1 7 
Player 1 wins the game.

For the stones of the following values: 
-7 2 6 3 
Player 2 wins the game.

For the stones of the following values: 
1 2 0 3 6 7 4 
Player 1 wins the game.
 Complexity Analysis: The time complexity of the program is the same as the previous program. Since the program is only using variables and not arrays, the space complexity of the program is constant, i.e., O(1). Next TopicTypeErasure in Java ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/stone-game-in-java Stone Game in Java - Javatpoint ? SCROLL TO TOP Home Java Programs OOPs String Exception Multithreading Collections JavaFX JSP Spring Spring Boot Projects Interview Questions Java Tutorial What is Java History of Java Features of Java C++ vs Java Hello Java Program Program Internal How to set path? JDK, JRE and JVM JVM: Java Virtual Machine Java Variables Java Data Types Unicode System Operators Keywords Control Statements Java Control Statements Java If-else Java Switch Java For Loop Java While Loop Java Do While Loop Java Break Java Continue Java Comments Java Programs Java Object Class Java OOPs Concepts Naming Convention Object and Class Method Constructor static keyword this keyword Java Inheritance Inheritance(IS-A) Aggregation(HAS-A) Java Polymorphism Method Overloading Method Overriding Covariant Return Type super keyword Instance Initializer block final keyword Runtime Polymorphism Dynamic Binding instanceof operator Java Abstraction Abstract class Interface Abstract vs Interface Java Encapsulation Package Access Modifiers Encapsulation Java Array Java Array Java OOPs Misc Object class Object Cloning Math class Wrapper Class Java Recursion Call By Value strictfp keyword javadoc tool Command Line Arg Object vs Class Overloading vs Overriding Java String Java Regex Exception Handling Java Inner classes Java Multithreading Java I/O Java Networking Java AWT & Events Java Swing JavaFX Java Applet Java Reflection Java Date Java Conversion Java Collection Java JDBC Java Misc Java New Features RMI Internationalization Interview Questions Java MCQ next ? ? prev Stone Game in Java In this game, stones are placed in a row (an input array is given). Two players are assigned the task of picking the stones of the maximum values. The player who collects stones of the maximum value wins the game. Player 1 will play first. After that, player two will play, and so on. At a time, a player can choose either 1 or 2 or 3 stones. The stones must be chosen from the left side only. Note that a player has to pick at least one stone. Our task is to decide which player will win the game if both the players play optimally. Example 1: int arr[] = {4, 3, 9, 16} Output: It is a tie between player 1 and player2 Explanation: Since stones are chosen from the left side and at max, only three stones are chosen, player 1 can only choose stones 1, 2 & 3. Thus, the total values of the stones chosen is 4 + 3 + 9 = 16. Now, it is the term of player 2. Player 2 can choose stone 4, which is of the value 16. Thus, both the players got the same value. Hence, it is a tie. Example 2: int arr[] = {8, -1, -1, 7} Output: Player 1 wins the game. Explanation: Player 1 plays optimally. Player 1 picks only the 1st stone from the left and leaves the rest. Thus, player 1 has a total value 8. Now, it is player 2 turn to pick the stones. Since players can only pick stones from the left only; therefore, player 2 has to pick stones of the values -1, -1, and 7. Thus, total value picked by the player 2 is -1 + -1 + 7 = 5, which is less than 8. Hence, player 1 wins. Example 3: int arr[] = {-7, 2, 6, 3} Output: Player 2 wins the game. Explanation: To gain the maximum value, player 1 picks stones 1, 2, and 3. Thus, collecting the maximum value of -7 + 2 + 6 = 1. There is only one stone left which is picked by player 2. The stone is of the value 3. Thus, player 2 wins the game. Example 4: int arr[] = {1, 2, 0, 3, 6, 7, 4} Output: Player 1 wins the game. Explanation: To gain the maximum value, player 1 picks stones 1 and 2 only. Thus, collecting the maximum value of 1 + 2 = 3. Now, it is the turn of player 2, and the player 2 picks stones of the values 0, 3, and 6 (total values 0 + 3 + 6 = 9). Again, it is the turn of player 1, and player 1 picks 7 and 4. Thus, total value collected by the player 1 is 3 + 7 + 4 = 14, which is greater than 9. Hence, player 1 wins the game. Approach: Using Recursion It is a brute force approach, where we consider each possible scenario for the player. The first scenario is when the player picks only one stone. The second scenario is when the player picks the two stones. The third scenario is when the player picks three stones. The maximum of these three scenarios is the value collected by the player. Observe the following program. FileName: StoneGame.java 
public class StoneGame 
{
    private int solve(int j, int[] nums)
    {
        // size of the array
        int size = nums.length;
        
        // handling the base case
        if(j >= size)
        {
            return 0;
        }
        // if we pick only one stone
        int one = Integer.MIN_VALUE;
        // if we pick two stones
        int two = Integer.MIN_VALUE;
        // if we pick three stones
        int three = Integer.MIN_VALUE;
        // picked one stone and performing the 
        // further computation
        one = nums[j] - solve(j + 1, nums);
        if((j + 1) < size)
        {
            // picked two stones at a time and performing 
            // the further computation
            two = nums[j] + nums[j + 1] - solve(j + 2, nums);
        }
        if((j + 2) < size)
        {
            // picked 3 stones at a time and performing the further
            // computation
            three = nums[j] + nums[j + 1] + nums[j + 2] - solve(j + 3, nums);
        }
        // picking the maximum between one, two and three
        return Math.max(one, Math.max(two, three));
    }
    public int stoneGameSol(int[] stoneVal) 
    {
        int ans = solve(0, stoneVal);
        if(ans == 0)
        {
            // 0 means its a tie
            return 0;
        }
        if(ans > 0)
        {
            // 1 means player 1 wins the game
            return 1;
        }
        // 2 means player 2 wins the game
        return 2;
    }
    // main method
public static void main(String[] argvs) 
{
// creating an object of the class StoneGame
StoneGame obj = new StoneGame();
// input 1
int arr[] = {4, 3, 9, 16};
int size = arr.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr[i] + " ");
}
System.out.println();
int ans = obj.stoneGameSol(arr);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 2
int arr1[] = {8, -1, -1, 7};
size = arr1.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr1[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr1);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 3
int arr2[] = {-7, 2, 6, 3};
size = arr2.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr2[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr2);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 4
int arr3[] = {1, 2, 0, 3, 6, 7, 4};
size = arr3.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr3[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr3);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
}
}
 Output: For the stones of the following values: 
4 3 9 16 
It is a tie between player 1 and player 2

For the stones of the following values: 
8 -1 -1 7 
Player 1 wins the game.

For the stones of the following values: 
-7 2 6 3 
Player 2 wins the game.

For the stones of the following values: 
1 2 0 3 6 7 4 
Player 1 wins the game.
 Complexity Analysis: The time complexity of the program is exponential as there are recursive calls for all the scenarios. The above program is not suitable for larger input as it will take a lot of time because of its high time complexity. Approach: Using Iteration (Dynamic Programming) We will assume that the dp[j] is the maximum value player 1 can get. Since player 1 can take 1 to 3 stones, player 2 can begin from either dp[j + 1], dp[j + 2], dp[j + 3]. Player 2 can also take 1 to 3 stones. Thus, resulting in the minimum of dp[j + 2 to 4], dp[j + 3 to 5], and dp[j + 4 to 6]. Thus, 
Dp[j] = max
(
                    stoneArr[j : j + 1] + min(dp[j + 2], dp[j + 3], dp[j + 4]),
                    stoneArr[j : j + 2] + min(dp[j + 3], dp[j + 4], dp[j + 5]),
                    stoneArr[j : j + 3] + min(dp[j + 4], dp[j + 5], dp[j + 6])
              )
 If any of the indexes are out of bounds, then it means the value is 0. The resulting score is stored dp[0]. FileName: StoneGame1.java 
public class StoneGame1 
{
public int stoneGameSol(int storeArr[]) 
{
// computing the size of the array
int n = storeArr.length;
int dp[] = new int[n];
// contains the sum of the values of 
// the stones present in the array stoneArr
int sums[] = new int[n+1];
for (int j = 0; j < n; j++) 
{
sums[j + 1] = sums[j] + storeArr[j];
}
dp[n - 1] = storeArr[n - 1];
if (n > 1) 
{
dp[n - 2] = storeArr[n - 2] + Math.max(storeArr[n - 1], 0);
for (int j = n - 3; j >= 0; j--) 
{
dp[j] = Integer.MIN_VALUE;
for (int k = 1; k <= 3; k++) 
{
// score is the sum of values of the
// stone taken by the player
// for k = 1 only one stone is taken
// for k = 2, two stones are taken
// for k = 3, three stones are taken
int score = sums[j + k] - sums[j];
int a1 = j + k + 1 < n ? dp[j + k + 1] : 0;
int a2 = j + k + 2 < n ? dp[j + k + 2] : 0;
int a3 = j + k + 3 < n ? dp[j + k + 3] : 0;
// the players are playing optimally. Hence, we have to pick
// the minimum between a1, a2, a3
dp[j] = Math.max(dp[j], score + Math.min(a1, Math.min(a2, a3)));
}
}
}
if ((2 * dp[0]) > sums[n]) 
{
return 1;
}
else if ((2 * dp[0]) < sums[n]) 
{
return 2;
}
else 
{
return 0;
}
}
// main method
public static void main(String[] argvs) 
{
// creating an object of the class StoneGame1
StoneGame1 obj = new StoneGame1();
// input 1
int arr[] = {4, 3, 9, 16};
int size = arr.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr[i] + " ");
}
System.out.println();
int ans = obj.stoneGameSol(arr);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 2
int arr1[] = {8, -1, -1, 7};
size = arr1.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr1[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr1);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 3
int arr2[] = {-7, 2, 6, 3};
size = arr2.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr2[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr2);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 4
int arr3[] = {1, 2, 0, 3, 6, 7, 4};
size = arr3.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr3[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr3);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
}
}
 Output: For the stones of the following values: 
4 3 9 16 
It is a tie between player 1 and player 2

For the stones of the following values: 
8 -1 -1 7 
Player 1 wins the game.

For the stones of the following values: 
-7 2 6 3 
Player 2 wins the game.

For the stones of the following values: 
1 2 0 3 6 7 4 
Player 1 wins the game.
 Complexity Analysis: The time complexity of the program is O(3 * N). In terms of the asymptotic time complexity, it is O(N). As the program uses two auxiliary arrays for storing the answer and the sum of values of stones, the space complexity of the program is O(N + N), which is O(2 *N). In terms of asymptotic time, it is again O(N), where N is the total number of elements present in the stone array. The space complexity of the program can be further reduced. We can use variables instead of arrays, and it is evident in the following program. FileName: StoneGame1.java 
public class StoneGame1 
{
public int stoneGameSol(int storeArr[]) 
{
// computing the size of the array
int size = storeArr.length;
int first = 0; // contains the answer
int second = 0;
int third = 0;
for(int j = size - 1; j >= 0; j--)
{
// one for picking only one stone
int one = Integer.MIN_VALUE;
// two for picking two stones
int two = Integer.MIN_VALUE;
// three for picking three stones
int three = Integer.MIN_VALUE;
one = storeArr[j]- first;
if((j + 1) < size)
{
two = storeArr[j] + storeArr[j + 1] - second;
}
if((j + 2) < size)
{
three = storeArr[j] + storeArr[j + 1] + storeArr[j + 2] - third;
}
int tmp = Math.max(one, Math.max(two, three));
third = second;
second = first;
first = tmp;
}
if(first == 0) 
{
return 0;
}
else if(first > 0) 
{
return 1;
}
else 
{
return 2;
}
}
    // main method
public static void main(String[] argvs) 
{
// creating an object of the class StoneGame1
StoneGame1 obj = new StoneGame1();
// input 1
int arr[] = {4, 3, 9, 16};
int size = arr.length;

System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr[i] + " ");
}
System.out.println();
int ans = obj.stoneGameSol(arr);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 2
int arr1[] = {8, -1, -1, 7};
size = arr1.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr1[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr1);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 3
int arr2[] = {-7, 2, 6, 3};
size = arr2.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr2[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr2);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 4
int arr3[] = {1, 2, 0, 3, 6, 7, 4};
size = arr3.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr3[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr3);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
}
}
 Output: For the stones of the following values: 
4 3 9 16 
It is a tie between player 1 and player 2

For the stones of the following values: 
8 -1 -1 7 
Player 1 wins the game.

For the stones of the following values: 
-7 2 6 3 
Player 2 wins the game.

For the stones of the following values: 
1 2 0 3 6 7 4 
Player 1 wins the game.
 Complexity Analysis: The time complexity of the program is the same as the previous program. Since the program is only using variables and not arrays, the space complexity of the program is constant, i.e., O(1). Next TopicTypeErasure in Java ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/stone-game-in-java Stone Game in Java - Javatpoint ? SCROLL TO TOP Home Java Programs OOPs String Exception Multithreading Collections JavaFX JSP Spring Spring Boot Projects Interview Questions Java Tutorial What is Java History of Java Features of Java C++ vs Java Hello Java Program Program Internal How to set path? JDK, JRE and JVM JVM: Java Virtual Machine Java Variables Java Data Types Unicode System Operators Keywords Control Statements Java Control Statements Java If-else Java Switch Java For Loop Java While Loop Java Do While Loop Java Break Java Continue Java Comments Java Programs Java Object Class Java OOPs Concepts Naming Convention Object and Class Method Constructor static keyword this keyword Java Inheritance Inheritance(IS-A) Aggregation(HAS-A) Java Polymorphism Method Overloading Method Overriding Covariant Return Type super keyword Instance Initializer block final keyword Runtime Polymorphism Dynamic Binding instanceof operator Java Abstraction Abstract class Interface Abstract vs Interface Java Encapsulation Package Access Modifiers Encapsulation Java Array Java Array Java OOPs Misc Object class Object Cloning Math class Wrapper Class Java Recursion Call By Value strictfp keyword javadoc tool Command Line Arg Object vs Class Overloading vs Overriding Java String Java Regex Exception Handling Java Inner classes Java Multithreading Java I/O Java Networking Java AWT & Events Java Swing JavaFX Java Applet Java Reflection Java Date Java Conversion Java Collection Java JDBC Java Misc Java New Features RMI Internationalization Interview Questions Java MCQ next ? ? prev Stone Game in Java In this game, stones are placed in a row (an input array is given). Two players are assigned the task of picking the stones of the maximum values. The player who collects stones of the maximum value wins the game. Player 1 will play first. After that, player two will play, and so on. At a time, a player can choose either 1 or 2 or 3 stones. The stones must be chosen from the left side only. Note that a player has to pick at least one stone. Our task is to decide which player will win the game if both the players play optimally. Example 1: int arr[] = {4, 3, 9, 16} Output: It is a tie between player 1 and player2 Explanation: Since stones are chosen from the left side and at max, only three stones are chosen, player 1 can only choose stones 1, 2 & 3. Thus, the total values of the stones chosen is 4 + 3 + 9 = 16. Now, it is the term of player 2. Player 2 can choose stone 4, which is of the value 16. Thus, both the players got the same value. Hence, it is a tie. Example 2: int arr[] = {8, -1, -1, 7} Output: Player 1 wins the game. Explanation: Player 1 plays optimally. Player 1 picks only the 1st stone from the left and leaves the rest. Thus, player 1 has a total value 8. Now, it is player 2 turn to pick the stones. Since players can only pick stones from the left only; therefore, player 2 has to pick stones of the values -1, -1, and 7. Thus, total value picked by the player 2 is -1 + -1 + 7 = 5, which is less than 8. Hence, player 1 wins. Example 3: int arr[] = {-7, 2, 6, 3} Output: Player 2 wins the game. Explanation: To gain the maximum value, player 1 picks stones 1, 2, and 3. Thus, collecting the maximum value of -7 + 2 + 6 = 1. There is only one stone left which is picked by player 2. The stone is of the value 3. Thus, player 2 wins the game. Example 4: int arr[] = {1, 2, 0, 3, 6, 7, 4} Output: Player 1 wins the game. Explanation: To gain the maximum value, player 1 picks stones 1 and 2 only. Thus, collecting the maximum value of 1 + 2 = 3. Now, it is the turn of player 2, and the player 2 picks stones of the values 0, 3, and 6 (total values 0 + 3 + 6 = 9). Again, it is the turn of player 1, and player 1 picks 7 and 4. Thus, total value collected by the player 1 is 3 + 7 + 4 = 14, which is greater than 9. Hence, player 1 wins the game. Approach: Using Recursion It is a brute force approach, where we consider each possible scenario for the player. The first scenario is when the player picks only one stone. The second scenario is when the player picks the two stones. The third scenario is when the player picks three stones. The maximum of these three scenarios is the value collected by the player. Observe the following program. FileName: StoneGame.java 
public class StoneGame 
{
    private int solve(int j, int[] nums)
    {
        // size of the array
        int size = nums.length;
        
        // handling the base case
        if(j >= size)
        {
            return 0;
        }
        // if we pick only one stone
        int one = Integer.MIN_VALUE;
        // if we pick two stones
        int two = Integer.MIN_VALUE;
        // if we pick three stones
        int three = Integer.MIN_VALUE;
        // picked one stone and performing the 
        // further computation
        one = nums[j] - solve(j + 1, nums);
        if((j + 1) < size)
        {
            // picked two stones at a time and performing 
            // the further computation
            two = nums[j] + nums[j + 1] - solve(j + 2, nums);
        }
        if((j + 2) < size)
        {
            // picked 3 stones at a time and performing the further
            // computation
            three = nums[j] + nums[j + 1] + nums[j + 2] - solve(j + 3, nums);
        }
        // picking the maximum between one, two and three
        return Math.max(one, Math.max(two, three));
    }
    public int stoneGameSol(int[] stoneVal) 
    {
        int ans = solve(0, stoneVal);
        if(ans == 0)
        {
            // 0 means its a tie
            return 0;
        }
        if(ans > 0)
        {
            // 1 means player 1 wins the game
            return 1;
        }
        // 2 means player 2 wins the game
        return 2;
    }
    // main method
public static void main(String[] argvs) 
{
// creating an object of the class StoneGame
StoneGame obj = new StoneGame();
// input 1
int arr[] = {4, 3, 9, 16};
int size = arr.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr[i] + " ");
}
System.out.println();
int ans = obj.stoneGameSol(arr);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 2
int arr1[] = {8, -1, -1, 7};
size = arr1.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr1[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr1);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 3
int arr2[] = {-7, 2, 6, 3};
size = arr2.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr2[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr2);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 4
int arr3[] = {1, 2, 0, 3, 6, 7, 4};
size = arr3.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr3[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr3);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
}
}
 Output: For the stones of the following values: 
4 3 9 16 
It is a tie between player 1 and player 2

For the stones of the following values: 
8 -1 -1 7 
Player 1 wins the game.

For the stones of the following values: 
-7 2 6 3 
Player 2 wins the game.

For the stones of the following values: 
1 2 0 3 6 7 4 
Player 1 wins the game.
 Complexity Analysis: The time complexity of the program is exponential as there are recursive calls for all the scenarios. The above program is not suitable for larger input as it will take a lot of time because of its high time complexity. Approach: Using Iteration (Dynamic Programming) We will assume that the dp[j] is the maximum value player 1 can get. Since player 1 can take 1 to 3 stones, player 2 can begin from either dp[j + 1], dp[j + 2], dp[j + 3]. Player 2 can also take 1 to 3 stones. Thus, resulting in the minimum of dp[j + 2 to 4], dp[j + 3 to 5], and dp[j + 4 to 6]. Thus, 
Dp[j] = max
(
                    stoneArr[j : j + 1] + min(dp[j + 2], dp[j + 3], dp[j + 4]),
                    stoneArr[j : j + 2] + min(dp[j + 3], dp[j + 4], dp[j + 5]),
                    stoneArr[j : j + 3] + min(dp[j + 4], dp[j + 5], dp[j + 6])
              )
 If any of the indexes are out of bounds, then it means the value is 0. The resulting score is stored dp[0]. FileName: StoneGame1.java 
public class StoneGame1 
{
public int stoneGameSol(int storeArr[]) 
{
// computing the size of the array
int n = storeArr.length;
int dp[] = new int[n];
// contains the sum of the values of 
// the stones present in the array stoneArr
int sums[] = new int[n+1];
for (int j = 0; j < n; j++) 
{
sums[j + 1] = sums[j] + storeArr[j];
}
dp[n - 1] = storeArr[n - 1];
if (n > 1) 
{
dp[n - 2] = storeArr[n - 2] + Math.max(storeArr[n - 1], 0);
for (int j = n - 3; j >= 0; j--) 
{
dp[j] = Integer.MIN_VALUE;
for (int k = 1; k <= 3; k++) 
{
// score is the sum of values of the
// stone taken by the player
// for k = 1 only one stone is taken
// for k = 2, two stones are taken
// for k = 3, three stones are taken
int score = sums[j + k] - sums[j];
int a1 = j + k + 1 < n ? dp[j + k + 1] : 0;
int a2 = j + k + 2 < n ? dp[j + k + 2] : 0;
int a3 = j + k + 3 < n ? dp[j + k + 3] : 0;
// the players are playing optimally. Hence, we have to pick
// the minimum between a1, a2, a3
dp[j] = Math.max(dp[j], score + Math.min(a1, Math.min(a2, a3)));
}
}
}
if ((2 * dp[0]) > sums[n]) 
{
return 1;
}
else if ((2 * dp[0]) < sums[n]) 
{
return 2;
}
else 
{
return 0;
}
}
// main method
public static void main(String[] argvs) 
{
// creating an object of the class StoneGame1
StoneGame1 obj = new StoneGame1();
// input 1
int arr[] = {4, 3, 9, 16};
int size = arr.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr[i] + " ");
}
System.out.println();
int ans = obj.stoneGameSol(arr);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 2
int arr1[] = {8, -1, -1, 7};
size = arr1.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr1[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr1);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 3
int arr2[] = {-7, 2, 6, 3};
size = arr2.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr2[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr2);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 4
int arr3[] = {1, 2, 0, 3, 6, 7, 4};
size = arr3.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr3[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr3);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
}
}
 Output: For the stones of the following values: 
4 3 9 16 
It is a tie between player 1 and player 2

For the stones of the following values: 
8 -1 -1 7 
Player 1 wins the game.

For the stones of the following values: 
-7 2 6 3 
Player 2 wins the game.

For the stones of the following values: 
1 2 0 3 6 7 4 
Player 1 wins the game.
 Complexity Analysis: The time complexity of the program is O(3 * N). In terms of the asymptotic time complexity, it is O(N). As the program uses two auxiliary arrays for storing the answer and the sum of values of stones, the space complexity of the program is O(N + N), which is O(2 *N). In terms of asymptotic time, it is again O(N), where N is the total number of elements present in the stone array. The space complexity of the program can be further reduced. We can use variables instead of arrays, and it is evident in the following program. FileName: StoneGame1.java 
public class StoneGame1 
{
public int stoneGameSol(int storeArr[]) 
{
// computing the size of the array
int size = storeArr.length;
int first = 0; // contains the answer
int second = 0;
int third = 0;
for(int j = size - 1; j >= 0; j--)
{
// one for picking only one stone
int one = Integer.MIN_VALUE;
// two for picking two stones
int two = Integer.MIN_VALUE;
// three for picking three stones
int three = Integer.MIN_VALUE;
one = storeArr[j]- first;
if((j + 1) < size)
{
two = storeArr[j] + storeArr[j + 1] - second;
}
if((j + 2) < size)
{
three = storeArr[j] + storeArr[j + 1] + storeArr[j + 2] - third;
}
int tmp = Math.max(one, Math.max(two, three));
third = second;
second = first;
first = tmp;
}
if(first == 0) 
{
return 0;
}
else if(first > 0) 
{
return 1;
}
else 
{
return 2;
}
}
    // main method
public static void main(String[] argvs) 
{
// creating an object of the class StoneGame1
StoneGame1 obj = new StoneGame1();
// input 1
int arr[] = {4, 3, 9, 16};
int size = arr.length;

System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr[i] + " ");
}
System.out.println();
int ans = obj.stoneGameSol(arr);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 2
int arr1[] = {8, -1, -1, 7};
size = arr1.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr1[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr1);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 3
int arr2[] = {-7, 2, 6, 3};
size = arr2.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr2[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr2);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 4
int arr3[] = {1, 2, 0, 3, 6, 7, 4};
size = arr3.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr3[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr3);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
}
}
 Output: For the stones of the following values: 
4 3 9 16 
It is a tie between player 1 and player 2

For the stones of the following values: 
8 -1 -1 7 
Player 1 wins the game.

For the stones of the following values: 
-7 2 6 3 
Player 2 wins the game.

For the stones of the following values: 
1 2 0 3 6 7 4 
Player 1 wins the game.
 Complexity Analysis: The time complexity of the program is the same as the previous program. Since the program is only using variables and not arrays, the space complexity of the program is constant, i.e., O(1). Next TopicTypeErasure in Java ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/stone-game-in-java Stone Game in Java - Javatpoint ? SCROLL TO TOP Home Java Programs OOPs String Exception Multithreading Collections JavaFX JSP Spring Spring Boot Projects Interview Questions Java Tutorial What is Java History of Java Features of Java C++ vs Java Hello Java Program Program Internal How to set path? JDK, JRE and JVM JVM: Java Virtual Machine Java Variables Java Data Types Unicode System Operators Keywords Control Statements Java Control Statements Java If-else Java Switch Java For Loop Java While Loop Java Do While Loop Java Break Java Continue Java Comments Java Programs Java Object Class Java OOPs Concepts Naming Convention Object and Class Method Constructor static keyword this keyword Java Inheritance Inheritance(IS-A) Aggregation(HAS-A) Java Polymorphism Method Overloading Method Overriding Covariant Return Type super keyword Instance Initializer block final keyword Runtime Polymorphism Dynamic Binding instanceof operator Java Abstraction Abstract class Interface Abstract vs Interface Java Encapsulation Package Access Modifiers Encapsulation Java Array Java Array Java OOPs Misc Object class Object Cloning Math class Wrapper Class Java Recursion Call By Value strictfp keyword javadoc tool Command Line Arg Object vs Class Overloading vs Overriding Java String Java Regex Exception Handling Java Inner classes Java Multithreading Java I/O Java Networking Java AWT & Events Java Swing JavaFX Java Applet Java Reflection Java Date Java Conversion Java Collection Java JDBC Java Misc Java New Features RMI Internationalization Interview Questions Java MCQ next ? ? prev Stone Game in Java In this game, stones are placed in a row (an input array is given). Two players are assigned the task of picking the stones of the maximum values. The player who collects stones of the maximum value wins the game. Player 1 will play first. After that, player two will play, and so on. At a time, a player can choose either 1 or 2 or 3 stones. The stones must be chosen from the left side only. Note that a player has to pick at least one stone. Our task is to decide which player will win the game if both the players play optimally. Example 1: int arr[] = {4, 3, 9, 16} Output: It is a tie between player 1 and player2 Explanation: Since stones are chosen from the left side and at max, only three stones are chosen, player 1 can only choose stones 1, 2 & 3. Thus, the total values of the stones chosen is 4 + 3 + 9 = 16. Now, it is the term of player 2. Player 2 can choose stone 4, which is of the value 16. Thus, both the players got the same value. Hence, it is a tie. Example 2: int arr[] = {8, -1, -1, 7} Output: Player 1 wins the game. Explanation: Player 1 plays optimally. Player 1 picks only the 1st stone from the left and leaves the rest. Thus, player 1 has a total value 8. Now, it is player 2 turn to pick the stones. Since players can only pick stones from the left only; therefore, player 2 has to pick stones of the values -1, -1, and 7. Thus, total value picked by the player 2 is -1 + -1 + 7 = 5, which is less than 8. Hence, player 1 wins. Example 3: int arr[] = {-7, 2, 6, 3} Output: Player 2 wins the game. Explanation: To gain the maximum value, player 1 picks stones 1, 2, and 3. Thus, collecting the maximum value of -7 + 2 + 6 = 1. There is only one stone left which is picked by player 2. The stone is of the value 3. Thus, player 2 wins the game. Example 4: int arr[] = {1, 2, 0, 3, 6, 7, 4} Output: Player 1 wins the game. Explanation: To gain the maximum value, player 1 picks stones 1 and 2 only. Thus, collecting the maximum value of 1 + 2 = 3. Now, it is the turn of player 2, and the player 2 picks stones of the values 0, 3, and 6 (total values 0 + 3 + 6 = 9). Again, it is the turn of player 1, and player 1 picks 7 and 4. Thus, total value collected by the player 1 is 3 + 7 + 4 = 14, which is greater than 9. Hence, player 1 wins the game. Approach: Using Recursion It is a brute force approach, where we consider each possible scenario for the player. The first scenario is when the player picks only one stone. The second scenario is when the player picks the two stones. The third scenario is when the player picks three stones. The maximum of these three scenarios is the value collected by the player. Observe the following program. FileName: StoneGame.java 
public class StoneGame 
{
    private int solve(int j, int[] nums)
    {
        // size of the array
        int size = nums.length;
        
        // handling the base case
        if(j >= size)
        {
            return 0;
        }
        // if we pick only one stone
        int one = Integer.MIN_VALUE;
        // if we pick two stones
        int two = Integer.MIN_VALUE;
        // if we pick three stones
        int three = Integer.MIN_VALUE;
        // picked one stone and performing the 
        // further computation
        one = nums[j] - solve(j + 1, nums);
        if((j + 1) < size)
        {
            // picked two stones at a time and performing 
            // the further computation
            two = nums[j] + nums[j + 1] - solve(j + 2, nums);
        }
        if((j + 2) < size)
        {
            // picked 3 stones at a time and performing the further
            // computation
            three = nums[j] + nums[j + 1] + nums[j + 2] - solve(j + 3, nums);
        }
        // picking the maximum between one, two and three
        return Math.max(one, Math.max(two, three));
    }
    public int stoneGameSol(int[] stoneVal) 
    {
        int ans = solve(0, stoneVal);
        if(ans == 0)
        {
            // 0 means its a tie
            return 0;
        }
        if(ans > 0)
        {
            // 1 means player 1 wins the game
            return 1;
        }
        // 2 means player 2 wins the game
        return 2;
    }
    // main method
public static void main(String[] argvs) 
{
// creating an object of the class StoneGame
StoneGame obj = new StoneGame();
// input 1
int arr[] = {4, 3, 9, 16};
int size = arr.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr[i] + " ");
}
System.out.println();
int ans = obj.stoneGameSol(arr);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 2
int arr1[] = {8, -1, -1, 7};
size = arr1.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr1[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr1);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 3
int arr2[] = {-7, 2, 6, 3};
size = arr2.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr2[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr2);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 4
int arr3[] = {1, 2, 0, 3, 6, 7, 4};
size = arr3.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr3[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr3);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
}
}
 Output: For the stones of the following values: 
4 3 9 16 
It is a tie between player 1 and player 2

For the stones of the following values: 
8 -1 -1 7 
Player 1 wins the game.

For the stones of the following values: 
-7 2 6 3 
Player 2 wins the game.

For the stones of the following values: 
1 2 0 3 6 7 4 
Player 1 wins the game.
 Complexity Analysis: The time complexity of the program is exponential as there are recursive calls for all the scenarios. The above program is not suitable for larger input as it will take a lot of time because of its high time complexity. Approach: Using Iteration (Dynamic Programming) We will assume that the dp[j] is the maximum value player 1 can get. Since player 1 can take 1 to 3 stones, player 2 can begin from either dp[j + 1], dp[j + 2], dp[j + 3]. Player 2 can also take 1 to 3 stones. Thus, resulting in the minimum of dp[j + 2 to 4], dp[j + 3 to 5], and dp[j + 4 to 6]. Thus, 
Dp[j] = max
(
                    stoneArr[j : j + 1] + min(dp[j + 2], dp[j + 3], dp[j + 4]),
                    stoneArr[j : j + 2] + min(dp[j + 3], dp[j + 4], dp[j + 5]),
                    stoneArr[j : j + 3] + min(dp[j + 4], dp[j + 5], dp[j + 6])
              )
 If any of the indexes are out of bounds, then it means the value is 0. The resulting score is stored dp[0]. FileName: StoneGame1.java 
public class StoneGame1 
{
public int stoneGameSol(int storeArr[]) 
{
// computing the size of the array
int n = storeArr.length;
int dp[] = new int[n];
// contains the sum of the values of 
// the stones present in the array stoneArr
int sums[] = new int[n+1];
for (int j = 0; j < n; j++) 
{
sums[j + 1] = sums[j] + storeArr[j];
}
dp[n - 1] = storeArr[n - 1];
if (n > 1) 
{
dp[n - 2] = storeArr[n - 2] + Math.max(storeArr[n - 1], 0);
for (int j = n - 3; j >= 0; j--) 
{
dp[j] = Integer.MIN_VALUE;
for (int k = 1; k <= 3; k++) 
{
// score is the sum of values of the
// stone taken by the player
// for k = 1 only one stone is taken
// for k = 2, two stones are taken
// for k = 3, three stones are taken
int score = sums[j + k] - sums[j];
int a1 = j + k + 1 < n ? dp[j + k + 1] : 0;
int a2 = j + k + 2 < n ? dp[j + k + 2] : 0;
int a3 = j + k + 3 < n ? dp[j + k + 3] : 0;
// the players are playing optimally. Hence, we have to pick
// the minimum between a1, a2, a3
dp[j] = Math.max(dp[j], score + Math.min(a1, Math.min(a2, a3)));
}
}
}
if ((2 * dp[0]) > sums[n]) 
{
return 1;
}
else if ((2 * dp[0]) < sums[n]) 
{
return 2;
}
else 
{
return 0;
}
}
// main method
public static void main(String[] argvs) 
{
// creating an object of the class StoneGame1
StoneGame1 obj = new StoneGame1();
// input 1
int arr[] = {4, 3, 9, 16};
int size = arr.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr[i] + " ");
}
System.out.println();
int ans = obj.stoneGameSol(arr);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 2
int arr1[] = {8, -1, -1, 7};
size = arr1.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr1[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr1);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 3
int arr2[] = {-7, 2, 6, 3};
size = arr2.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr2[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr2);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 4
int arr3[] = {1, 2, 0, 3, 6, 7, 4};
size = arr3.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr3[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr3);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
}
}
 Output: For the stones of the following values: 
4 3 9 16 
It is a tie between player 1 and player 2

For the stones of the following values: 
8 -1 -1 7 
Player 1 wins the game.

For the stones of the following values: 
-7 2 6 3 
Player 2 wins the game.

For the stones of the following values: 
1 2 0 3 6 7 4 
Player 1 wins the game.
 Complexity Analysis: The time complexity of the program is O(3 * N). In terms of the asymptotic time complexity, it is O(N). As the program uses two auxiliary arrays for storing the answer and the sum of values of stones, the space complexity of the program is O(N + N), which is O(2 *N). In terms of asymptotic time, it is again O(N), where N is the total number of elements present in the stone array. The space complexity of the program can be further reduced. We can use variables instead of arrays, and it is evident in the following program. FileName: StoneGame1.java 
public class StoneGame1 
{
public int stoneGameSol(int storeArr[]) 
{
// computing the size of the array
int size = storeArr.length;
int first = 0; // contains the answer
int second = 0;
int third = 0;
for(int j = size - 1; j >= 0; j--)
{
// one for picking only one stone
int one = Integer.MIN_VALUE;
// two for picking two stones
int two = Integer.MIN_VALUE;
// three for picking three stones
int three = Integer.MIN_VALUE;
one = storeArr[j]- first;
if((j + 1) < size)
{
two = storeArr[j] + storeArr[j + 1] - second;
}
if((j + 2) < size)
{
three = storeArr[j] + storeArr[j + 1] + storeArr[j + 2] - third;
}
int tmp = Math.max(one, Math.max(two, three));
third = second;
second = first;
first = tmp;
}
if(first == 0) 
{
return 0;
}
else if(first > 0) 
{
return 1;
}
else 
{
return 2;
}
}
    // main method
public static void main(String[] argvs) 
{
// creating an object of the class StoneGame1
StoneGame1 obj = new StoneGame1();
// input 1
int arr[] = {4, 3, 9, 16};
int size = arr.length;

System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr[i] + " ");
}
System.out.println();
int ans = obj.stoneGameSol(arr);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 2
int arr1[] = {8, -1, -1, 7};
size = arr1.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr1[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr1);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 3
int arr2[] = {-7, 2, 6, 3};
size = arr2.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr2[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr2);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 4
int arr3[] = {1, 2, 0, 3, 6, 7, 4};
size = arr3.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr3[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr3);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
}
}
 Output: For the stones of the following values: 
4 3 9 16 
It is a tie between player 1 and player 2

For the stones of the following values: 
8 -1 -1 7 
Player 1 wins the game.

For the stones of the following values: 
-7 2 6 3 
Player 2 wins the game.

For the stones of the following values: 
1 2 0 3 6 7 4 
Player 1 wins the game.
 Complexity Analysis: The time complexity of the program is the same as the previous program. Since the program is only using variables and not arrays, the space complexity of the program is constant, i.e., O(1). Next TopicTypeErasure in Java ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/stone-game-in-java Stone Game in Java - Javatpoint ? SCROLL TO TOP Home Java Programs OOPs String Exception Multithreading Collections JavaFX JSP Spring Spring Boot Projects Interview Questions Java Tutorial What is Java History of Java Features of Java C++ vs Java Hello Java Program Program Internal How to set path? JDK, JRE and JVM JVM: Java Virtual Machine Java Variables Java Data Types Unicode System Operators Keywords Control Statements Java Control Statements Java If-else Java Switch Java For Loop Java While Loop Java Do While Loop Java Break Java Continue Java Comments Java Programs Java Object Class Java OOPs Concepts Naming Convention Object and Class Method Constructor static keyword this keyword Java Inheritance Inheritance(IS-A) Aggregation(HAS-A) Java Polymorphism Method Overloading Method Overriding Covariant Return Type super keyword Instance Initializer block final keyword Runtime Polymorphism Dynamic Binding instanceof operator Java Abstraction Abstract class Interface Abstract vs Interface Java Encapsulation Package Access Modifiers Encapsulation Java Array Java Array Java OOPs Misc Object class Object Cloning Math class Wrapper Class Java Recursion Call By Value strictfp keyword javadoc tool Command Line Arg Object vs Class Overloading vs Overriding Java String Java Regex Exception Handling Java Inner classes Java Multithreading Java I/O Java Networking Java AWT & Events Java Swing JavaFX Java Applet Java Reflection Java Date Java Conversion Java Collection Java JDBC Java Misc Java New Features RMI Internationalization Interview Questions Java MCQ next ? ? prev Stone Game in Java In this game, stones are placed in a row (an input array is given). Two players are assigned the task of picking the stones of the maximum values. The player who collects stones of the maximum value wins the game. Player 1 will play first. After that, player two will play, and so on. At a time, a player can choose either 1 or 2 or 3 stones. The stones must be chosen from the left side only. Note that a player has to pick at least one stone. Our task is to decide which player will win the game if both the players play optimally. Example 1: int arr[] = {4, 3, 9, 16} Output: It is a tie between player 1 and player2 Explanation: Since stones are chosen from the left side and at max, only three stones are chosen, player 1 can only choose stones 1, 2 & 3. Thus, the total values of the stones chosen is 4 + 3 + 9 = 16. Now, it is the term of player 2. Player 2 can choose stone 4, which is of the value 16. Thus, both the players got the same value. Hence, it is a tie. Example 2: int arr[] = {8, -1, -1, 7} Output: Player 1 wins the game. Explanation: Player 1 plays optimally. Player 1 picks only the 1st stone from the left and leaves the rest. Thus, player 1 has a total value 8. Now, it is player 2 turn to pick the stones. Since players can only pick stones from the left only; therefore, player 2 has to pick stones of the values -1, -1, and 7. Thus, total value picked by the player 2 is -1 + -1 + 7 = 5, which is less than 8. Hence, player 1 wins. Example 3: int arr[] = {-7, 2, 6, 3} Output: Player 2 wins the game. Explanation: To gain the maximum value, player 1 picks stones 1, 2, and 3. Thus, collecting the maximum value of -7 + 2 + 6 = 1. There is only one stone left which is picked by player 2. The stone is of the value 3. Thus, player 2 wins the game. Example 4: int arr[] = {1, 2, 0, 3, 6, 7, 4} Output: Player 1 wins the game. Explanation: To gain the maximum value, player 1 picks stones 1 and 2 only. Thus, collecting the maximum value of 1 + 2 = 3. Now, it is the turn of player 2, and the player 2 picks stones of the values 0, 3, and 6 (total values 0 + 3 + 6 = 9). Again, it is the turn of player 1, and player 1 picks 7 and 4. Thus, total value collected by the player 1 is 3 + 7 + 4 = 14, which is greater than 9. Hence, player 1 wins the game. Approach: Using Recursion It is a brute force approach, where we consider each possible scenario for the player. The first scenario is when the player picks only one stone. The second scenario is when the player picks the two stones. The third scenario is when the player picks three stones. The maximum of these three scenarios is the value collected by the player. Observe the following program. FileName: StoneGame.java 
public class StoneGame 
{
    private int solve(int j, int[] nums)
    {
        // size of the array
        int size = nums.length;
        
        // handling the base case
        if(j >= size)
        {
            return 0;
        }
        // if we pick only one stone
        int one = Integer.MIN_VALUE;
        // if we pick two stones
        int two = Integer.MIN_VALUE;
        // if we pick three stones
        int three = Integer.MIN_VALUE;
        // picked one stone and performing the 
        // further computation
        one = nums[j] - solve(j + 1, nums);
        if((j + 1) < size)
        {
            // picked two stones at a time and performing 
            // the further computation
            two = nums[j] + nums[j + 1] - solve(j + 2, nums);
        }
        if((j + 2) < size)
        {
            // picked 3 stones at a time and performing the further
            // computation
            three = nums[j] + nums[j + 1] + nums[j + 2] - solve(j + 3, nums);
        }
        // picking the maximum between one, two and three
        return Math.max(one, Math.max(two, three));
    }
    public int stoneGameSol(int[] stoneVal) 
    {
        int ans = solve(0, stoneVal);
        if(ans == 0)
        {
            // 0 means its a tie
            return 0;
        }
        if(ans > 0)
        {
            // 1 means player 1 wins the game
            return 1;
        }
        // 2 means player 2 wins the game
        return 2;
    }
    // main method
public static void main(String[] argvs) 
{
// creating an object of the class StoneGame
StoneGame obj = new StoneGame();
// input 1
int arr[] = {4, 3, 9, 16};
int size = arr.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr[i] + " ");
}
System.out.println();
int ans = obj.stoneGameSol(arr);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 2
int arr1[] = {8, -1, -1, 7};
size = arr1.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr1[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr1);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 3
int arr2[] = {-7, 2, 6, 3};
size = arr2.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr2[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr2);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 4
int arr3[] = {1, 2, 0, 3, 6, 7, 4};
size = arr3.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr3[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr3);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
}
}
 Output: For the stones of the following values: 
4 3 9 16 
It is a tie between player 1 and player 2

For the stones of the following values: 
8 -1 -1 7 
Player 1 wins the game.

For the stones of the following values: 
-7 2 6 3 
Player 2 wins the game.

For the stones of the following values: 
1 2 0 3 6 7 4 
Player 1 wins the game.
 Complexity Analysis: The time complexity of the program is exponential as there are recursive calls for all the scenarios. The above program is not suitable for larger input as it will take a lot of time because of its high time complexity. Approach: Using Iteration (Dynamic Programming) We will assume that the dp[j] is the maximum value player 1 can get. Since player 1 can take 1 to 3 stones, player 2 can begin from either dp[j + 1], dp[j + 2], dp[j + 3]. Player 2 can also take 1 to 3 stones. Thus, resulting in the minimum of dp[j + 2 to 4], dp[j + 3 to 5], and dp[j + 4 to 6]. Thus, 
Dp[j] = max
(
                    stoneArr[j : j + 1] + min(dp[j + 2], dp[j + 3], dp[j + 4]),
                    stoneArr[j : j + 2] + min(dp[j + 3], dp[j + 4], dp[j + 5]),
                    stoneArr[j : j + 3] + min(dp[j + 4], dp[j + 5], dp[j + 6])
              )
 If any of the indexes are out of bounds, then it means the value is 0. The resulting score is stored dp[0]. FileName: StoneGame1.java 
public class StoneGame1 
{
public int stoneGameSol(int storeArr[]) 
{
// computing the size of the array
int n = storeArr.length;
int dp[] = new int[n];
// contains the sum of the values of 
// the stones present in the array stoneArr
int sums[] = new int[n+1];
for (int j = 0; j < n; j++) 
{
sums[j + 1] = sums[j] + storeArr[j];
}
dp[n - 1] = storeArr[n - 1];
if (n > 1) 
{
dp[n - 2] = storeArr[n - 2] + Math.max(storeArr[n - 1], 0);
for (int j = n - 3; j >= 0; j--) 
{
dp[j] = Integer.MIN_VALUE;
for (int k = 1; k <= 3; k++) 
{
// score is the sum of values of the
// stone taken by the player
// for k = 1 only one stone is taken
// for k = 2, two stones are taken
// for k = 3, three stones are taken
int score = sums[j + k] - sums[j];
int a1 = j + k + 1 < n ? dp[j + k + 1] : 0;
int a2 = j + k + 2 < n ? dp[j + k + 2] : 0;
int a3 = j + k + 3 < n ? dp[j + k + 3] : 0;
// the players are playing optimally. Hence, we have to pick
// the minimum between a1, a2, a3
dp[j] = Math.max(dp[j], score + Math.min(a1, Math.min(a2, a3)));
}
}
}
if ((2 * dp[0]) > sums[n]) 
{
return 1;
}
else if ((2 * dp[0]) < sums[n]) 
{
return 2;
}
else 
{
return 0;
}
}
// main method
public static void main(String[] argvs) 
{
// creating an object of the class StoneGame1
StoneGame1 obj = new StoneGame1();
// input 1
int arr[] = {4, 3, 9, 16};
int size = arr.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr[i] + " ");
}
System.out.println();
int ans = obj.stoneGameSol(arr);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 2
int arr1[] = {8, -1, -1, 7};
size = arr1.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr1[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr1);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 3
int arr2[] = {-7, 2, 6, 3};
size = arr2.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr2[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr2);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 4
int arr3[] = {1, 2, 0, 3, 6, 7, 4};
size = arr3.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr3[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr3);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
}
}
 Output: For the stones of the following values: 
4 3 9 16 
It is a tie between player 1 and player 2

For the stones of the following values: 
8 -1 -1 7 
Player 1 wins the game.

For the stones of the following values: 
-7 2 6 3 
Player 2 wins the game.

For the stones of the following values: 
1 2 0 3 6 7 4 
Player 1 wins the game.
 Complexity Analysis: The time complexity of the program is O(3 * N). In terms of the asymptotic time complexity, it is O(N). As the program uses two auxiliary arrays for storing the answer and the sum of values of stones, the space complexity of the program is O(N + N), which is O(2 *N). In terms of asymptotic time, it is again O(N), where N is the total number of elements present in the stone array. The space complexity of the program can be further reduced. We can use variables instead of arrays, and it is evident in the following program. FileName: StoneGame1.java 
public class StoneGame1 
{
public int stoneGameSol(int storeArr[]) 
{
// computing the size of the array
int size = storeArr.length;
int first = 0; // contains the answer
int second = 0;
int third = 0;
for(int j = size - 1; j >= 0; j--)
{
// one for picking only one stone
int one = Integer.MIN_VALUE;
// two for picking two stones
int two = Integer.MIN_VALUE;
// three for picking three stones
int three = Integer.MIN_VALUE;
one = storeArr[j]- first;
if((j + 1) < size)
{
two = storeArr[j] + storeArr[j + 1] - second;
}
if((j + 2) < size)
{
three = storeArr[j] + storeArr[j + 1] + storeArr[j + 2] - third;
}
int tmp = Math.max(one, Math.max(two, three));
third = second;
second = first;
first = tmp;
}
if(first == 0) 
{
return 0;
}
else if(first > 0) 
{
return 1;
}
else 
{
return 2;
}
}
    // main method
public static void main(String[] argvs) 
{
// creating an object of the class StoneGame1
StoneGame1 obj = new StoneGame1();
// input 1
int arr[] = {4, 3, 9, 16};
int size = arr.length;

System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr[i] + " ");
}
System.out.println();
int ans = obj.stoneGameSol(arr);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 2
int arr1[] = {8, -1, -1, 7};
size = arr1.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr1[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr1);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 3
int arr2[] = {-7, 2, 6, 3};
size = arr2.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr2[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr2);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 4
int arr3[] = {1, 2, 0, 3, 6, 7, 4};
size = arr3.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr3[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr3);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
}
}
 Output: For the stones of the following values: 
4 3 9 16 
It is a tie between player 1 and player 2

For the stones of the following values: 
8 -1 -1 7 
Player 1 wins the game.

For the stones of the following values: 
-7 2 6 3 
Player 2 wins the game.

For the stones of the following values: 
1 2 0 3 6 7 4 
Player 1 wins the game.
 Complexity Analysis: The time complexity of the program is the same as the previous program. Since the program is only using variables and not arrays, the space complexity of the program is constant, i.e., O(1). Next TopicTypeErasure in Java ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/stone-game-in-java Stone Game in Java - Javatpoint ? SCROLL TO TOP Home Java Programs OOPs String Exception Multithreading Collections JavaFX JSP Spring Spring Boot Projects Interview Questions Java Tutorial What is Java History of Java Features of Java C++ vs Java Hello Java Program Program Internal How to set path? JDK, JRE and JVM JVM: Java Virtual Machine Java Variables Java Data Types Unicode System Operators Keywords Control Statements Java Control Statements Java If-else Java Switch Java For Loop Java While Loop Java Do While Loop Java Break Java Continue Java Comments Java Programs Java Object Class Java OOPs Concepts Naming Convention Object and Class Method Constructor static keyword this keyword Java Inheritance Inheritance(IS-A) Aggregation(HAS-A) Java Polymorphism Method Overloading Method Overriding Covariant Return Type super keyword Instance Initializer block final keyword Runtime Polymorphism Dynamic Binding instanceof operator Java Abstraction Abstract class Interface Abstract vs Interface Java Encapsulation Package Access Modifiers Encapsulation Java Array Java Array Java OOPs Misc Object class Object Cloning Math class Wrapper Class Java Recursion Call By Value strictfp keyword javadoc tool Command Line Arg Object vs Class Overloading vs Overriding Java String Java Regex Exception Handling Java Inner classes Java Multithreading Java I/O Java Networking Java AWT & Events Java Swing JavaFX Java Applet Java Reflection Java Date Java Conversion Java Collection Java JDBC Java Misc Java New Features RMI Internationalization Interview Questions Java MCQ next ? ? prev Stone Game in Java In this game, stones are placed in a row (an input array is given). Two players are assigned the task of picking the stones of the maximum values. The player who collects stones of the maximum value wins the game. Player 1 will play first. After that, player two will play, and so on. At a time, a player can choose either 1 or 2 or 3 stones. The stones must be chosen from the left side only. Note that a player has to pick at least one stone. Our task is to decide which player will win the game if both the players play optimally. Example 1: int arr[] = {4, 3, 9, 16} Output: It is a tie between player 1 and player2 Explanation: Since stones are chosen from the left side and at max, only three stones are chosen, player 1 can only choose stones 1, 2 & 3. Thus, the total values of the stones chosen is 4 + 3 + 9 = 16. Now, it is the term of player 2. Player 2 can choose stone 4, which is of the value 16. Thus, both the players got the same value. Hence, it is a tie. Example 2: int arr[] = {8, -1, -1, 7} Output: Player 1 wins the game. Explanation: Player 1 plays optimally. Player 1 picks only the 1st stone from the left and leaves the rest. Thus, player 1 has a total value 8. Now, it is player 2 turn to pick the stones. Since players can only pick stones from the left only; therefore, player 2 has to pick stones of the values -1, -1, and 7. Thus, total value picked by the player 2 is -1 + -1 + 7 = 5, which is less than 8. Hence, player 1 wins. Example 3: int arr[] = {-7, 2, 6, 3} Output: Player 2 wins the game. Explanation: To gain the maximum value, player 1 picks stones 1, 2, and 3. Thus, collecting the maximum value of -7 + 2 + 6 = 1. There is only one stone left which is picked by player 2. The stone is of the value 3. Thus, player 2 wins the game. Example 4: int arr[] = {1, 2, 0, 3, 6, 7, 4} Output: Player 1 wins the game. Explanation: To gain the maximum value, player 1 picks stones 1 and 2 only. Thus, collecting the maximum value of 1 + 2 = 3. Now, it is the turn of player 2, and the player 2 picks stones of the values 0, 3, and 6 (total values 0 + 3 + 6 = 9). Again, it is the turn of player 1, and player 1 picks 7 and 4. Thus, total value collected by the player 1 is 3 + 7 + 4 = 14, which is greater than 9. Hence, player 1 wins the game. Approach: Using Recursion It is a brute force approach, where we consider each possible scenario for the player. The first scenario is when the player picks only one stone. The second scenario is when the player picks the two stones. The third scenario is when the player picks three stones. The maximum of these three scenarios is the value collected by the player. Observe the following program. FileName: StoneGame.java 
public class StoneGame 
{
    private int solve(int j, int[] nums)
    {
        // size of the array
        int size = nums.length;
        
        // handling the base case
        if(j >= size)
        {
            return 0;
        }
        // if we pick only one stone
        int one = Integer.MIN_VALUE;
        // if we pick two stones
        int two = Integer.MIN_VALUE;
        // if we pick three stones
        int three = Integer.MIN_VALUE;
        // picked one stone and performing the 
        // further computation
        one = nums[j] - solve(j + 1, nums);
        if((j + 1) < size)
        {
            // picked two stones at a time and performing 
            // the further computation
            two = nums[j] + nums[j + 1] - solve(j + 2, nums);
        }
        if((j + 2) < size)
        {
            // picked 3 stones at a time and performing the further
            // computation
            three = nums[j] + nums[j + 1] + nums[j + 2] - solve(j + 3, nums);
        }
        // picking the maximum between one, two and three
        return Math.max(one, Math.max(two, three));
    }
    public int stoneGameSol(int[] stoneVal) 
    {
        int ans = solve(0, stoneVal);
        if(ans == 0)
        {
            // 0 means its a tie
            return 0;
        }
        if(ans > 0)
        {
            // 1 means player 1 wins the game
            return 1;
        }
        // 2 means player 2 wins the game
        return 2;
    }
    // main method
public static void main(String[] argvs) 
{
// creating an object of the class StoneGame
StoneGame obj = new StoneGame();
// input 1
int arr[] = {4, 3, 9, 16};
int size = arr.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr[i] + " ");
}
System.out.println();
int ans = obj.stoneGameSol(arr);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 2
int arr1[] = {8, -1, -1, 7};
size = arr1.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr1[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr1);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 3
int arr2[] = {-7, 2, 6, 3};
size = arr2.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr2[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr2);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 4
int arr3[] = {1, 2, 0, 3, 6, 7, 4};
size = arr3.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr3[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr3);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
}
}
 Output: For the stones of the following values: 
4 3 9 16 
It is a tie between player 1 and player 2

For the stones of the following values: 
8 -1 -1 7 
Player 1 wins the game.

For the stones of the following values: 
-7 2 6 3 
Player 2 wins the game.

For the stones of the following values: 
1 2 0 3 6 7 4 
Player 1 wins the game.
 Complexity Analysis: The time complexity of the program is exponential as there are recursive calls for all the scenarios. The above program is not suitable for larger input as it will take a lot of time because of its high time complexity. Approach: Using Iteration (Dynamic Programming) We will assume that the dp[j] is the maximum value player 1 can get. Since player 1 can take 1 to 3 stones, player 2 can begin from either dp[j + 1], dp[j + 2], dp[j + 3]. Player 2 can also take 1 to 3 stones. Thus, resulting in the minimum of dp[j + 2 to 4], dp[j + 3 to 5], and dp[j + 4 to 6]. Thus, 
Dp[j] = max
(
                    stoneArr[j : j + 1] + min(dp[j + 2], dp[j + 3], dp[j + 4]),
                    stoneArr[j : j + 2] + min(dp[j + 3], dp[j + 4], dp[j + 5]),
                    stoneArr[j : j + 3] + min(dp[j + 4], dp[j + 5], dp[j + 6])
              )
 If any of the indexes are out of bounds, then it means the value is 0. The resulting score is stored dp[0]. FileName: StoneGame1.java 
public class StoneGame1 
{
public int stoneGameSol(int storeArr[]) 
{
// computing the size of the array
int n = storeArr.length;
int dp[] = new int[n];
// contains the sum of the values of 
// the stones present in the array stoneArr
int sums[] = new int[n+1];
for (int j = 0; j < n; j++) 
{
sums[j + 1] = sums[j] + storeArr[j];
}
dp[n - 1] = storeArr[n - 1];
if (n > 1) 
{
dp[n - 2] = storeArr[n - 2] + Math.max(storeArr[n - 1], 0);
for (int j = n - 3; j >= 0; j--) 
{
dp[j] = Integer.MIN_VALUE;
for (int k = 1; k <= 3; k++) 
{
// score is the sum of values of the
// stone taken by the player
// for k = 1 only one stone is taken
// for k = 2, two stones are taken
// for k = 3, three stones are taken
int score = sums[j + k] - sums[j];
int a1 = j + k + 1 < n ? dp[j + k + 1] : 0;
int a2 = j + k + 2 < n ? dp[j + k + 2] : 0;
int a3 = j + k + 3 < n ? dp[j + k + 3] : 0;
// the players are playing optimally. Hence, we have to pick
// the minimum between a1, a2, a3
dp[j] = Math.max(dp[j], score + Math.min(a1, Math.min(a2, a3)));
}
}
}
if ((2 * dp[0]) > sums[n]) 
{
return 1;
}
else if ((2 * dp[0]) < sums[n]) 
{
return 2;
}
else 
{
return 0;
}
}
// main method
public static void main(String[] argvs) 
{
// creating an object of the class StoneGame1
StoneGame1 obj = new StoneGame1();
// input 1
int arr[] = {4, 3, 9, 16};
int size = arr.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr[i] + " ");
}
System.out.println();
int ans = obj.stoneGameSol(arr);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 2
int arr1[] = {8, -1, -1, 7};
size = arr1.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr1[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr1);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 3
int arr2[] = {-7, 2, 6, 3};
size = arr2.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr2[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr2);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 4
int arr3[] = {1, 2, 0, 3, 6, 7, 4};
size = arr3.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr3[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr3);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
}
}
 Output: For the stones of the following values: 
4 3 9 16 
It is a tie between player 1 and player 2

For the stones of the following values: 
8 -1 -1 7 
Player 1 wins the game.

For the stones of the following values: 
-7 2 6 3 
Player 2 wins the game.

For the stones of the following values: 
1 2 0 3 6 7 4 
Player 1 wins the game.
 Complexity Analysis: The time complexity of the program is O(3 * N). In terms of the asymptotic time complexity, it is O(N). As the program uses two auxiliary arrays for storing the answer and the sum of values of stones, the space complexity of the program is O(N + N), which is O(2 *N). In terms of asymptotic time, it is again O(N), where N is the total number of elements present in the stone array. The space complexity of the program can be further reduced. We can use variables instead of arrays, and it is evident in the following program. FileName: StoneGame1.java 
public class StoneGame1 
{
public int stoneGameSol(int storeArr[]) 
{
// computing the size of the array
int size = storeArr.length;
int first = 0; // contains the answer
int second = 0;
int third = 0;
for(int j = size - 1; j >= 0; j--)
{
// one for picking only one stone
int one = Integer.MIN_VALUE;
// two for picking two stones
int two = Integer.MIN_VALUE;
// three for picking three stones
int three = Integer.MIN_VALUE;
one = storeArr[j]- first;
if((j + 1) < size)
{
two = storeArr[j] + storeArr[j + 1] - second;
}
if((j + 2) < size)
{
three = storeArr[j] + storeArr[j + 1] + storeArr[j + 2] - third;
}
int tmp = Math.max(one, Math.max(two, three));
third = second;
second = first;
first = tmp;
}
if(first == 0) 
{
return 0;
}
else if(first > 0) 
{
return 1;
}
else 
{
return 2;
}
}
    // main method
public static void main(String[] argvs) 
{
// creating an object of the class StoneGame1
StoneGame1 obj = new StoneGame1();
// input 1
int arr[] = {4, 3, 9, 16};
int size = arr.length;

System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr[i] + " ");
}
System.out.println();
int ans = obj.stoneGameSol(arr);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 2
int arr1[] = {8, -1, -1, 7};
size = arr1.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr1[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr1);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 3
int arr2[] = {-7, 2, 6, 3};
size = arr2.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr2[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr2);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 4
int arr3[] = {1, 2, 0, 3, 6, 7, 4};
size = arr3.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr3[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr3);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
}
}
 Output: For the stones of the following values: 
4 3 9 16 
It is a tie between player 1 and player 2

For the stones of the following values: 
8 -1 -1 7 
Player 1 wins the game.

For the stones of the following values: 
-7 2 6 3 
Player 2 wins the game.

For the stones of the following values: 
1 2 0 3 6 7 4 
Player 1 wins the game.
 Complexity Analysis: The time complexity of the program is the same as the previous program. Since the program is only using variables and not arrays, the space complexity of the program is constant, i.e., O(1). Next TopicTypeErasure in Java ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/stone-game-in-java Stone Game in Java - Javatpoint ? SCROLL TO TOP Home Java Programs OOPs String Exception Multithreading Collections JavaFX JSP Spring Spring Boot Projects Interview Questions Java Tutorial What is Java History of Java Features of Java C++ vs Java Hello Java Program Program Internal How to set path? JDK, JRE and JVM JVM: Java Virtual Machine Java Variables Java Data Types Unicode System Operators Keywords Control Statements Java Control Statements Java If-else Java Switch Java For Loop Java While Loop Java Do While Loop Java Break Java Continue Java Comments Java Programs Java Object Class Java OOPs Concepts Naming Convention Object and Class Method Constructor static keyword this keyword Java Inheritance Inheritance(IS-A) Aggregation(HAS-A) Java Polymorphism Method Overloading Method Overriding Covariant Return Type super keyword Instance Initializer block final keyword Runtime Polymorphism Dynamic Binding instanceof operator Java Abstraction Abstract class Interface Abstract vs Interface Java Encapsulation Package Access Modifiers Encapsulation Java Array Java Array Java OOPs Misc Object class Object Cloning Math class Wrapper Class Java Recursion Call By Value strictfp keyword javadoc tool Command Line Arg Object vs Class Overloading vs Overriding Java String Java Regex Exception Handling Java Inner classes Java Multithreading Java I/O Java Networking Java AWT & Events Java Swing JavaFX Java Applet Java Reflection Java Date Java Conversion Java Collection Java JDBC Java Misc Java New Features RMI Internationalization Interview Questions Java MCQ next ? ? prev Stone Game in Java In this game, stones are placed in a row (an input array is given). Two players are assigned the task of picking the stones of the maximum values. The player who collects stones of the maximum value wins the game. Player 1 will play first. After that, player two will play, and so on. At a time, a player can choose either 1 or 2 or 3 stones. The stones must be chosen from the left side only. Note that a player has to pick at least one stone. Our task is to decide which player will win the game if both the players play optimally. Example 1: int arr[] = {4, 3, 9, 16} Output: It is a tie between player 1 and player2 Explanation: Since stones are chosen from the left side and at max, only three stones are chosen, player 1 can only choose stones 1, 2 & 3. Thus, the total values of the stones chosen is 4 + 3 + 9 = 16. Now, it is the term of player 2. Player 2 can choose stone 4, which is of the value 16. Thus, both the players got the same value. Hence, it is a tie. Example 2: int arr[] = {8, -1, -1, 7} Output: Player 1 wins the game. Explanation: Player 1 plays optimally. Player 1 picks only the 1st stone from the left and leaves the rest. Thus, player 1 has a total value 8. Now, it is player 2 turn to pick the stones. Since players can only pick stones from the left only; therefore, player 2 has to pick stones of the values -1, -1, and 7. Thus, total value picked by the player 2 is -1 + -1 + 7 = 5, which is less than 8. Hence, player 1 wins. Example 3: int arr[] = {-7, 2, 6, 3} Output: Player 2 wins the game. Explanation: To gain the maximum value, player 1 picks stones 1, 2, and 3. Thus, collecting the maximum value of -7 + 2 + 6 = 1. There is only one stone left which is picked by player 2. The stone is of the value 3. Thus, player 2 wins the game. Example 4: int arr[] = {1, 2, 0, 3, 6, 7, 4} Output: Player 1 wins the game. Explanation: To gain the maximum value, player 1 picks stones 1 and 2 only. Thus, collecting the maximum value of 1 + 2 = 3. Now, it is the turn of player 2, and the player 2 picks stones of the values 0, 3, and 6 (total values 0 + 3 + 6 = 9). Again, it is the turn of player 1, and player 1 picks 7 and 4. Thus, total value collected by the player 1 is 3 + 7 + 4 = 14, which is greater than 9. Hence, player 1 wins the game. Approach: Using Recursion It is a brute force approach, where we consider each possible scenario for the player. The first scenario is when the player picks only one stone. The second scenario is when the player picks the two stones. The third scenario is when the player picks three stones. The maximum of these three scenarios is the value collected by the player. Observe the following program. FileName: StoneGame.java 
public class StoneGame 
{
    private int solve(int j, int[] nums)
    {
        // size of the array
        int size = nums.length;
        
        // handling the base case
        if(j >= size)
        {
            return 0;
        }
        // if we pick only one stone
        int one = Integer.MIN_VALUE;
        // if we pick two stones
        int two = Integer.MIN_VALUE;
        // if we pick three stones
        int three = Integer.MIN_VALUE;
        // picked one stone and performing the 
        // further computation
        one = nums[j] - solve(j + 1, nums);
        if((j + 1) < size)
        {
            // picked two stones at a time and performing 
            // the further computation
            two = nums[j] + nums[j + 1] - solve(j + 2, nums);
        }
        if((j + 2) < size)
        {
            // picked 3 stones at a time and performing the further
            // computation
            three = nums[j] + nums[j + 1] + nums[j + 2] - solve(j + 3, nums);
        }
        // picking the maximum between one, two and three
        return Math.max(one, Math.max(two, three));
    }
    public int stoneGameSol(int[] stoneVal) 
    {
        int ans = solve(0, stoneVal);
        if(ans == 0)
        {
            // 0 means its a tie
            return 0;
        }
        if(ans > 0)
        {
            // 1 means player 1 wins the game
            return 1;
        }
        // 2 means player 2 wins the game
        return 2;
    }
    // main method
public static void main(String[] argvs) 
{
// creating an object of the class StoneGame
StoneGame obj = new StoneGame();
// input 1
int arr[] = {4, 3, 9, 16};
int size = arr.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr[i] + " ");
}
System.out.println();
int ans = obj.stoneGameSol(arr);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 2
int arr1[] = {8, -1, -1, 7};
size = arr1.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr1[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr1);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 3
int arr2[] = {-7, 2, 6, 3};
size = arr2.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr2[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr2);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 4
int arr3[] = {1, 2, 0, 3, 6, 7, 4};
size = arr3.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr3[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr3);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
}
}
 Output: For the stones of the following values: 
4 3 9 16 
It is a tie between player 1 and player 2

For the stones of the following values: 
8 -1 -1 7 
Player 1 wins the game.

For the stones of the following values: 
-7 2 6 3 
Player 2 wins the game.

For the stones of the following values: 
1 2 0 3 6 7 4 
Player 1 wins the game.
 Complexity Analysis: The time complexity of the program is exponential as there are recursive calls for all the scenarios. The above program is not suitable for larger input as it will take a lot of time because of its high time complexity. Approach: Using Iteration (Dynamic Programming) We will assume that the dp[j] is the maximum value player 1 can get. Since player 1 can take 1 to 3 stones, player 2 can begin from either dp[j + 1], dp[j + 2], dp[j + 3]. Player 2 can also take 1 to 3 stones. Thus, resulting in the minimum of dp[j + 2 to 4], dp[j + 3 to 5], and dp[j + 4 to 6]. Thus, 
Dp[j] = max
(
                    stoneArr[j : j + 1] + min(dp[j + 2], dp[j + 3], dp[j + 4]),
                    stoneArr[j : j + 2] + min(dp[j + 3], dp[j + 4], dp[j + 5]),
                    stoneArr[j : j + 3] + min(dp[j + 4], dp[j + 5], dp[j + 6])
              )
 If any of the indexes are out of bounds, then it means the value is 0. The resulting score is stored dp[0]. FileName: StoneGame1.java 
public class StoneGame1 
{
public int stoneGameSol(int storeArr[]) 
{
// computing the size of the array
int n = storeArr.length;
int dp[] = new int[n];
// contains the sum of the values of 
// the stones present in the array stoneArr
int sums[] = new int[n+1];
for (int j = 0; j < n; j++) 
{
sums[j + 1] = sums[j] + storeArr[j];
}
dp[n - 1] = storeArr[n - 1];
if (n > 1) 
{
dp[n - 2] = storeArr[n - 2] + Math.max(storeArr[n - 1], 0);
for (int j = n - 3; j >= 0; j--) 
{
dp[j] = Integer.MIN_VALUE;
for (int k = 1; k <= 3; k++) 
{
// score is the sum of values of the
// stone taken by the player
// for k = 1 only one stone is taken
// for k = 2, two stones are taken
// for k = 3, three stones are taken
int score = sums[j + k] - sums[j];
int a1 = j + k + 1 < n ? dp[j + k + 1] : 0;
int a2 = j + k + 2 < n ? dp[j + k + 2] : 0;
int a3 = j + k + 3 < n ? dp[j + k + 3] : 0;
// the players are playing optimally. Hence, we have to pick
// the minimum between a1, a2, a3
dp[j] = Math.max(dp[j], score + Math.min(a1, Math.min(a2, a3)));
}
}
}
if ((2 * dp[0]) > sums[n]) 
{
return 1;
}
else if ((2 * dp[0]) < sums[n]) 
{
return 2;
}
else 
{
return 0;
}
}
// main method
public static void main(String[] argvs) 
{
// creating an object of the class StoneGame1
StoneGame1 obj = new StoneGame1();
// input 1
int arr[] = {4, 3, 9, 16};
int size = arr.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr[i] + " ");
}
System.out.println();
int ans = obj.stoneGameSol(arr);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 2
int arr1[] = {8, -1, -1, 7};
size = arr1.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr1[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr1);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 3
int arr2[] = {-7, 2, 6, 3};
size = arr2.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr2[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr2);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 4
int arr3[] = {1, 2, 0, 3, 6, 7, 4};
size = arr3.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr3[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr3);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
}
}
 Output: For the stones of the following values: 
4 3 9 16 
It is a tie between player 1 and player 2

For the stones of the following values: 
8 -1 -1 7 
Player 1 wins the game.

For the stones of the following values: 
-7 2 6 3 
Player 2 wins the game.

For the stones of the following values: 
1 2 0 3 6 7 4 
Player 1 wins the game.
 Complexity Analysis: The time complexity of the program is O(3 * N). In terms of the asymptotic time complexity, it is O(N). As the program uses two auxiliary arrays for storing the answer and the sum of values of stones, the space complexity of the program is O(N + N), which is O(2 *N). In terms of asymptotic time, it is again O(N), where N is the total number of elements present in the stone array. The space complexity of the program can be further reduced. We can use variables instead of arrays, and it is evident in the following program. FileName: StoneGame1.java 
public class StoneGame1 
{
public int stoneGameSol(int storeArr[]) 
{
// computing the size of the array
int size = storeArr.length;
int first = 0; // contains the answer
int second = 0;
int third = 0;
for(int j = size - 1; j >= 0; j--)
{
// one for picking only one stone
int one = Integer.MIN_VALUE;
// two for picking two stones
int two = Integer.MIN_VALUE;
// three for picking three stones
int three = Integer.MIN_VALUE;
one = storeArr[j]- first;
if((j + 1) < size)
{
two = storeArr[j] + storeArr[j + 1] - second;
}
if((j + 2) < size)
{
three = storeArr[j] + storeArr[j + 1] + storeArr[j + 2] - third;
}
int tmp = Math.max(one, Math.max(two, three));
third = second;
second = first;
first = tmp;
}
if(first == 0) 
{
return 0;
}
else if(first > 0) 
{
return 1;
}
else 
{
return 2;
}
}
    // main method
public static void main(String[] argvs) 
{
// creating an object of the class StoneGame1
StoneGame1 obj = new StoneGame1();
// input 1
int arr[] = {4, 3, 9, 16};
int size = arr.length;

System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr[i] + " ");
}
System.out.println();
int ans = obj.stoneGameSol(arr);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 2
int arr1[] = {8, -1, -1, 7};
size = arr1.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr1[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr1);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 3
int arr2[] = {-7, 2, 6, 3};
size = arr2.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr2[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr2);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 4
int arr3[] = {1, 2, 0, 3, 6, 7, 4};
size = arr3.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr3[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr3);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
}
}
 Output: For the stones of the following values: 
4 3 9 16 
It is a tie between player 1 and player 2

For the stones of the following values: 
8 -1 -1 7 
Player 1 wins the game.

For the stones of the following values: 
-7 2 6 3 
Player 2 wins the game.

For the stones of the following values: 
1 2 0 3 6 7 4 
Player 1 wins the game.
 Complexity Analysis: The time complexity of the program is the same as the previous program. Since the program is only using variables and not arrays, the space complexity of the program is constant, i.e., O(1). Next TopicTypeErasure in Java ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/stone-game-in-java Stone Game in Java - Javatpoint ? SCROLL TO TOP Home Java Programs OOPs String Exception Multithreading Collections JavaFX JSP Spring Spring Boot Projects Interview Questions Java Tutorial What is Java History of Java Features of Java C++ vs Java Hello Java Program Program Internal How to set path? JDK, JRE and JVM JVM: Java Virtual Machine Java Variables Java Data Types Unicode System Operators Keywords Control Statements Java Control Statements Java If-else Java Switch Java For Loop Java While Loop Java Do While Loop Java Break Java Continue Java Comments Java Programs Java Object Class Java OOPs Concepts Naming Convention Object and Class Method Constructor static keyword this keyword Java Inheritance Inheritance(IS-A) Aggregation(HAS-A) Java Polymorphism Method Overloading Method Overriding Covariant Return Type super keyword Instance Initializer block final keyword Runtime Polymorphism Dynamic Binding instanceof operator Java Abstraction Abstract class Interface Abstract vs Interface Java Encapsulation Package Access Modifiers Encapsulation Java Array Java Array Java OOPs Misc Object class Object Cloning Math class Wrapper Class Java Recursion Call By Value strictfp keyword javadoc tool Command Line Arg Object vs Class Overloading vs Overriding Java String Java Regex Exception Handling Java Inner classes Java Multithreading Java I/O Java Networking Java AWT & Events Java Swing JavaFX Java Applet Java Reflection Java Date Java Conversion Java Collection Java JDBC Java Misc Java New Features RMI Internationalization Interview Questions Java MCQ next ? ? prev Stone Game in Java In this game, stones are placed in a row (an input array is given). Two players are assigned the task of picking the stones of the maximum values. The player who collects stones of the maximum value wins the game. Player 1 will play first. After that, player two will play, and so on. At a time, a player can choose either 1 or 2 or 3 stones. The stones must be chosen from the left side only. Note that a player has to pick at least one stone. Our task is to decide which player will win the game if both the players play optimally. Example 1: int arr[] = {4, 3, 9, 16} Output: It is a tie between player 1 and player2 Explanation: Since stones are chosen from the left side and at max, only three stones are chosen, player 1 can only choose stones 1, 2 & 3. Thus, the total values of the stones chosen is 4 + 3 + 9 = 16. Now, it is the term of player 2. Player 2 can choose stone 4, which is of the value 16. Thus, both the players got the same value. Hence, it is a tie. Example 2: int arr[] = {8, -1, -1, 7} Output: Player 1 wins the game. Explanation: Player 1 plays optimally. Player 1 picks only the 1st stone from the left and leaves the rest. Thus, player 1 has a total value 8. Now, it is player 2 turn to pick the stones. Since players can only pick stones from the left only; therefore, player 2 has to pick stones of the values -1, -1, and 7. Thus, total value picked by the player 2 is -1 + -1 + 7 = 5, which is less than 8. Hence, player 1 wins. Example 3: int arr[] = {-7, 2, 6, 3} Output: Player 2 wins the game. Explanation: To gain the maximum value, player 1 picks stones 1, 2, and 3. Thus, collecting the maximum value of -7 + 2 + 6 = 1. There is only one stone left which is picked by player 2. The stone is of the value 3. Thus, player 2 wins the game. Example 4: int arr[] = {1, 2, 0, 3, 6, 7, 4} Output: Player 1 wins the game. Explanation: To gain the maximum value, player 1 picks stones 1 and 2 only. Thus, collecting the maximum value of 1 + 2 = 3. Now, it is the turn of player 2, and the player 2 picks stones of the values 0, 3, and 6 (total values 0 + 3 + 6 = 9). Again, it is the turn of player 1, and player 1 picks 7 and 4. Thus, total value collected by the player 1 is 3 + 7 + 4 = 14, which is greater than 9. Hence, player 1 wins the game. Approach: Using Recursion It is a brute force approach, where we consider each possible scenario for the player. The first scenario is when the player picks only one stone. The second scenario is when the player picks the two stones. The third scenario is when the player picks three stones. The maximum of these three scenarios is the value collected by the player. Observe the following program. FileName: StoneGame.java 
public class StoneGame 
{
    private int solve(int j, int[] nums)
    {
        // size of the array
        int size = nums.length;
        
        // handling the base case
        if(j >= size)
        {
            return 0;
        }
        // if we pick only one stone
        int one = Integer.MIN_VALUE;
        // if we pick two stones
        int two = Integer.MIN_VALUE;
        // if we pick three stones
        int three = Integer.MIN_VALUE;
        // picked one stone and performing the 
        // further computation
        one = nums[j] - solve(j + 1, nums);
        if((j + 1) < size)
        {
            // picked two stones at a time and performing 
            // the further computation
            two = nums[j] + nums[j + 1] - solve(j + 2, nums);
        }
        if((j + 2) < size)
        {
            // picked 3 stones at a time and performing the further
            // computation
            three = nums[j] + nums[j + 1] + nums[j + 2] - solve(j + 3, nums);
        }
        // picking the maximum between one, two and three
        return Math.max(one, Math.max(two, three));
    }
    public int stoneGameSol(int[] stoneVal) 
    {
        int ans = solve(0, stoneVal);
        if(ans == 0)
        {
            // 0 means its a tie
            return 0;
        }
        if(ans > 0)
        {
            // 1 means player 1 wins the game
            return 1;
        }
        // 2 means player 2 wins the game
        return 2;
    }
    // main method
public static void main(String[] argvs) 
{
// creating an object of the class StoneGame
StoneGame obj = new StoneGame();
// input 1
int arr[] = {4, 3, 9, 16};
int size = arr.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr[i] + " ");
}
System.out.println();
int ans = obj.stoneGameSol(arr);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 2
int arr1[] = {8, -1, -1, 7};
size = arr1.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr1[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr1);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 3
int arr2[] = {-7, 2, 6, 3};
size = arr2.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr2[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr2);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 4
int arr3[] = {1, 2, 0, 3, 6, 7, 4};
size = arr3.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr3[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr3);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
}
}
 Output: For the stones of the following values: 
4 3 9 16 
It is a tie between player 1 and player 2

For the stones of the following values: 
8 -1 -1 7 
Player 1 wins the game.

For the stones of the following values: 
-7 2 6 3 
Player 2 wins the game.

For the stones of the following values: 
1 2 0 3 6 7 4 
Player 1 wins the game.
 Complexity Analysis: The time complexity of the program is exponential as there are recursive calls for all the scenarios. The above program is not suitable for larger input as it will take a lot of time because of its high time complexity. Approach: Using Iteration (Dynamic Programming) We will assume that the dp[j] is the maximum value player 1 can get. Since player 1 can take 1 to 3 stones, player 2 can begin from either dp[j + 1], dp[j + 2], dp[j + 3]. Player 2 can also take 1 to 3 stones. Thus, resulting in the minimum of dp[j + 2 to 4], dp[j + 3 to 5], and dp[j + 4 to 6]. Thus, 
Dp[j] = max
(
                    stoneArr[j : j + 1] + min(dp[j + 2], dp[j + 3], dp[j + 4]),
                    stoneArr[j : j + 2] + min(dp[j + 3], dp[j + 4], dp[j + 5]),
                    stoneArr[j : j + 3] + min(dp[j + 4], dp[j + 5], dp[j + 6])
              )
 If any of the indexes are out of bounds, then it means the value is 0. The resulting score is stored dp[0]. FileName: StoneGame1.java 
public class StoneGame1 
{
public int stoneGameSol(int storeArr[]) 
{
// computing the size of the array
int n = storeArr.length;
int dp[] = new int[n];
// contains the sum of the values of 
// the stones present in the array stoneArr
int sums[] = new int[n+1];
for (int j = 0; j < n; j++) 
{
sums[j + 1] = sums[j] + storeArr[j];
}
dp[n - 1] = storeArr[n - 1];
if (n > 1) 
{
dp[n - 2] = storeArr[n - 2] + Math.max(storeArr[n - 1], 0);
for (int j = n - 3; j >= 0; j--) 
{
dp[j] = Integer.MIN_VALUE;
for (int k = 1; k <= 3; k++) 
{
// score is the sum of values of the
// stone taken by the player
// for k = 1 only one stone is taken
// for k = 2, two stones are taken
// for k = 3, three stones are taken
int score = sums[j + k] - sums[j];
int a1 = j + k + 1 < n ? dp[j + k + 1] : 0;
int a2 = j + k + 2 < n ? dp[j + k + 2] : 0;
int a3 = j + k + 3 < n ? dp[j + k + 3] : 0;
// the players are playing optimally. Hence, we have to pick
// the minimum between a1, a2, a3
dp[j] = Math.max(dp[j], score + Math.min(a1, Math.min(a2, a3)));
}
}
}
if ((2 * dp[0]) > sums[n]) 
{
return 1;
}
else if ((2 * dp[0]) < sums[n]) 
{
return 2;
}
else 
{
return 0;
}
}
// main method
public static void main(String[] argvs) 
{
// creating an object of the class StoneGame1
StoneGame1 obj = new StoneGame1();
// input 1
int arr[] = {4, 3, 9, 16};
int size = arr.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr[i] + " ");
}
System.out.println();
int ans = obj.stoneGameSol(arr);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 2
int arr1[] = {8, -1, -1, 7};
size = arr1.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr1[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr1);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 3
int arr2[] = {-7, 2, 6, 3};
size = arr2.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr2[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr2);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 4
int arr3[] = {1, 2, 0, 3, 6, 7, 4};
size = arr3.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr3[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr3);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
}
}
 Output: For the stones of the following values: 
4 3 9 16 
It is a tie between player 1 and player 2

For the stones of the following values: 
8 -1 -1 7 
Player 1 wins the game.

For the stones of the following values: 
-7 2 6 3 
Player 2 wins the game.

For the stones of the following values: 
1 2 0 3 6 7 4 
Player 1 wins the game.
 Complexity Analysis: The time complexity of the program is O(3 * N). In terms of the asymptotic time complexity, it is O(N). As the program uses two auxiliary arrays for storing the answer and the sum of values of stones, the space complexity of the program is O(N + N), which is O(2 *N). In terms of asymptotic time, it is again O(N), where N is the total number of elements present in the stone array. The space complexity of the program can be further reduced. We can use variables instead of arrays, and it is evident in the following program. FileName: StoneGame1.java 
public class StoneGame1 
{
public int stoneGameSol(int storeArr[]) 
{
// computing the size of the array
int size = storeArr.length;
int first = 0; // contains the answer
int second = 0;
int third = 0;
for(int j = size - 1; j >= 0; j--)
{
// one for picking only one stone
int one = Integer.MIN_VALUE;
// two for picking two stones
int two = Integer.MIN_VALUE;
// three for picking three stones
int three = Integer.MIN_VALUE;
one = storeArr[j]- first;
if((j + 1) < size)
{
two = storeArr[j] + storeArr[j + 1] - second;
}
if((j + 2) < size)
{
three = storeArr[j] + storeArr[j + 1] + storeArr[j + 2] - third;
}
int tmp = Math.max(one, Math.max(two, three));
third = second;
second = first;
first = tmp;
}
if(first == 0) 
{
return 0;
}
else if(first > 0) 
{
return 1;
}
else 
{
return 2;
}
}
    // main method
public static void main(String[] argvs) 
{
// creating an object of the class StoneGame1
StoneGame1 obj = new StoneGame1();
// input 1
int arr[] = {4, 3, 9, 16};
int size = arr.length;

System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr[i] + " ");
}
System.out.println();
int ans = obj.stoneGameSol(arr);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 2
int arr1[] = {8, -1, -1, 7};
size = arr1.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr1[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr1);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 3
int arr2[] = {-7, 2, 6, 3};
size = arr2.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr2[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr2);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 4
int arr3[] = {1, 2, 0, 3, 6, 7, 4};
size = arr3.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr3[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr3);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
}
}
 Output: For the stones of the following values: 
4 3 9 16 
It is a tie between player 1 and player 2

For the stones of the following values: 
8 -1 -1 7 
Player 1 wins the game.

For the stones of the following values: 
-7 2 6 3 
Player 2 wins the game.

For the stones of the following values: 
1 2 0 3 6 7 4 
Player 1 wins the game.
 Complexity Analysis: The time complexity of the program is the same as the previous program. Since the program is only using variables and not arrays, the space complexity of the program is constant, i.e., O(1). Next TopicTypeErasure in Java ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/stone-game-in-java Stone Game in Java - Javatpoint ? SCROLL TO TOP Home Java Programs OOPs String Exception Multithreading Collections JavaFX JSP Spring Spring Boot Projects Interview Questions Java Tutorial What is Java History of Java Features of Java C++ vs Java Hello Java Program Program Internal How to set path? JDK, JRE and JVM JVM: Java Virtual Machine Java Variables Java Data Types Unicode System Operators Keywords Control Statements Java Control Statements Java If-else Java Switch Java For Loop Java While Loop Java Do While Loop Java Break Java Continue Java Comments Java Programs Java Object Class Java OOPs Concepts Naming Convention Object and Class Method Constructor static keyword this keyword Java Inheritance Inheritance(IS-A) Aggregation(HAS-A) Java Polymorphism Method Overloading Method Overriding Covariant Return Type super keyword Instance Initializer block final keyword Runtime Polymorphism Dynamic Binding instanceof operator Java Abstraction Abstract class Interface Abstract vs Interface Java Encapsulation Package Access Modifiers Encapsulation Java Array Java Array Java OOPs Misc Object class Object Cloning Math class Wrapper Class Java Recursion Call By Value strictfp keyword javadoc tool Command Line Arg Object vs Class Overloading vs Overriding Java String Java Regex Exception Handling Java Inner classes Java Multithreading Java I/O Java Networking Java AWT & Events Java Swing JavaFX Java Applet Java Reflection Java Date Java Conversion Java Collection Java JDBC Java Misc Java New Features RMI Internationalization Interview Questions Java MCQ next ? ? prev Stone Game in Java In this game, stones are placed in a row (an input array is given). Two players are assigned the task of picking the stones of the maximum values. The player who collects stones of the maximum value wins the game. Player 1 will play first. After that, player two will play, and so on. At a time, a player can choose either 1 or 2 or 3 stones. The stones must be chosen from the left side only. Note that a player has to pick at least one stone. Our task is to decide which player will win the game if both the players play optimally. Example 1: int arr[] = {4, 3, 9, 16} Output: It is a tie between player 1 and player2 Explanation: Since stones are chosen from the left side and at max, only three stones are chosen, player 1 can only choose stones 1, 2 & 3. Thus, the total values of the stones chosen is 4 + 3 + 9 = 16. Now, it is the term of player 2. Player 2 can choose stone 4, which is of the value 16. Thus, both the players got the same value. Hence, it is a tie. Example 2: int arr[] = {8, -1, -1, 7} Output: Player 1 wins the game. Explanation: Player 1 plays optimally. Player 1 picks only the 1st stone from the left and leaves the rest. Thus, player 1 has a total value 8. Now, it is player 2 turn to pick the stones. Since players can only pick stones from the left only; therefore, player 2 has to pick stones of the values -1, -1, and 7. Thus, total value picked by the player 2 is -1 + -1 + 7 = 5, which is less than 8. Hence, player 1 wins. Example 3: int arr[] = {-7, 2, 6, 3} Output: Player 2 wins the game. Explanation: To gain the maximum value, player 1 picks stones 1, 2, and 3. Thus, collecting the maximum value of -7 + 2 + 6 = 1. There is only one stone left which is picked by player 2. The stone is of the value 3. Thus, player 2 wins the game. Example 4: int arr[] = {1, 2, 0, 3, 6, 7, 4} Output: Player 1 wins the game. Explanation: To gain the maximum value, player 1 picks stones 1 and 2 only. Thus, collecting the maximum value of 1 + 2 = 3. Now, it is the turn of player 2, and the player 2 picks stones of the values 0, 3, and 6 (total values 0 + 3 + 6 = 9). Again, it is the turn of player 1, and player 1 picks 7 and 4. Thus, total value collected by the player 1 is 3 + 7 + 4 = 14, which is greater than 9. Hence, player 1 wins the game. Approach: Using Recursion It is a brute force approach, where we consider each possible scenario for the player. The first scenario is when the player picks only one stone. The second scenario is when the player picks the two stones. The third scenario is when the player picks three stones. The maximum of these three scenarios is the value collected by the player. Observe the following program. FileName: StoneGame.java 
public class StoneGame 
{
    private int solve(int j, int[] nums)
    {
        // size of the array
        int size = nums.length;
        
        // handling the base case
        if(j >= size)
        {
            return 0;
        }
        // if we pick only one stone
        int one = Integer.MIN_VALUE;
        // if we pick two stones
        int two = Integer.MIN_VALUE;
        // if we pick three stones
        int three = Integer.MIN_VALUE;
        // picked one stone and performing the 
        // further computation
        one = nums[j] - solve(j + 1, nums);
        if((j + 1) < size)
        {
            // picked two stones at a time and performing 
            // the further computation
            two = nums[j] + nums[j + 1] - solve(j + 2, nums);
        }
        if((j + 2) < size)
        {
            // picked 3 stones at a time and performing the further
            // computation
            three = nums[j] + nums[j + 1] + nums[j + 2] - solve(j + 3, nums);
        }
        // picking the maximum between one, two and three
        return Math.max(one, Math.max(two, three));
    }
    public int stoneGameSol(int[] stoneVal) 
    {
        int ans = solve(0, stoneVal);
        if(ans == 0)
        {
            // 0 means its a tie
            return 0;
        }
        if(ans > 0)
        {
            // 1 means player 1 wins the game
            return 1;
        }
        // 2 means player 2 wins the game
        return 2;
    }
    // main method
public static void main(String[] argvs) 
{
// creating an object of the class StoneGame
StoneGame obj = new StoneGame();
// input 1
int arr[] = {4, 3, 9, 16};
int size = arr.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr[i] + " ");
}
System.out.println();
int ans = obj.stoneGameSol(arr);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 2
int arr1[] = {8, -1, -1, 7};
size = arr1.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr1[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr1);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 3
int arr2[] = {-7, 2, 6, 3};
size = arr2.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr2[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr2);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 4
int arr3[] = {1, 2, 0, 3, 6, 7, 4};
size = arr3.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr3[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr3);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
}
}
 Output: For the stones of the following values: 
4 3 9 16 
It is a tie between player 1 and player 2

For the stones of the following values: 
8 -1 -1 7 
Player 1 wins the game.

For the stones of the following values: 
-7 2 6 3 
Player 2 wins the game.

For the stones of the following values: 
1 2 0 3 6 7 4 
Player 1 wins the game.
 Complexity Analysis: The time complexity of the program is exponential as there are recursive calls for all the scenarios. The above program is not suitable for larger input as it will take a lot of time because of its high time complexity. Approach: Using Iteration (Dynamic Programming) We will assume that the dp[j] is the maximum value player 1 can get. Since player 1 can take 1 to 3 stones, player 2 can begin from either dp[j + 1], dp[j + 2], dp[j + 3]. Player 2 can also take 1 to 3 stones. Thus, resulting in the minimum of dp[j + 2 to 4], dp[j + 3 to 5], and dp[j + 4 to 6]. Thus, 
Dp[j] = max
(
                    stoneArr[j : j + 1] + min(dp[j + 2], dp[j + 3], dp[j + 4]),
                    stoneArr[j : j + 2] + min(dp[j + 3], dp[j + 4], dp[j + 5]),
                    stoneArr[j : j + 3] + min(dp[j + 4], dp[j + 5], dp[j + 6])
              )
 If any of the indexes are out of bounds, then it means the value is 0. The resulting score is stored dp[0]. FileName: StoneGame1.java 
public class StoneGame1 
{
public int stoneGameSol(int storeArr[]) 
{
// computing the size of the array
int n = storeArr.length;
int dp[] = new int[n];
// contains the sum of the values of 
// the stones present in the array stoneArr
int sums[] = new int[n+1];
for (int j = 0; j < n; j++) 
{
sums[j + 1] = sums[j] + storeArr[j];
}
dp[n - 1] = storeArr[n - 1];
if (n > 1) 
{
dp[n - 2] = storeArr[n - 2] + Math.max(storeArr[n - 1], 0);
for (int j = n - 3; j >= 0; j--) 
{
dp[j] = Integer.MIN_VALUE;
for (int k = 1; k <= 3; k++) 
{
// score is the sum of values of the
// stone taken by the player
// for k = 1 only one stone is taken
// for k = 2, two stones are taken
// for k = 3, three stones are taken
int score = sums[j + k] - sums[j];
int a1 = j + k + 1 < n ? dp[j + k + 1] : 0;
int a2 = j + k + 2 < n ? dp[j + k + 2] : 0;
int a3 = j + k + 3 < n ? dp[j + k + 3] : 0;
// the players are playing optimally. Hence, we have to pick
// the minimum between a1, a2, a3
dp[j] = Math.max(dp[j], score + Math.min(a1, Math.min(a2, a3)));
}
}
}
if ((2 * dp[0]) > sums[n]) 
{
return 1;
}
else if ((2 * dp[0]) < sums[n]) 
{
return 2;
}
else 
{
return 0;
}
}
// main method
public static void main(String[] argvs) 
{
// creating an object of the class StoneGame1
StoneGame1 obj = new StoneGame1();
// input 1
int arr[] = {4, 3, 9, 16};
int size = arr.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr[i] + " ");
}
System.out.println();
int ans = obj.stoneGameSol(arr);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 2
int arr1[] = {8, -1, -1, 7};
size = arr1.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr1[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr1);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 3
int arr2[] = {-7, 2, 6, 3};
size = arr2.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr2[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr2);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 4
int arr3[] = {1, 2, 0, 3, 6, 7, 4};
size = arr3.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr3[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr3);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
}
}
 Output: For the stones of the following values: 
4 3 9 16 
It is a tie between player 1 and player 2

For the stones of the following values: 
8 -1 -1 7 
Player 1 wins the game.

For the stones of the following values: 
-7 2 6 3 
Player 2 wins the game.

For the stones of the following values: 
1 2 0 3 6 7 4 
Player 1 wins the game.
 Complexity Analysis: The time complexity of the program is O(3 * N). In terms of the asymptotic time complexity, it is O(N). As the program uses two auxiliary arrays for storing the answer and the sum of values of stones, the space complexity of the program is O(N + N), which is O(2 *N). In terms of asymptotic time, it is again O(N), where N is the total number of elements present in the stone array. The space complexity of the program can be further reduced. We can use variables instead of arrays, and it is evident in the following program. FileName: StoneGame1.java 
public class StoneGame1 
{
public int stoneGameSol(int storeArr[]) 
{
// computing the size of the array
int size = storeArr.length;
int first = 0; // contains the answer
int second = 0;
int third = 0;
for(int j = size - 1; j >= 0; j--)
{
// one for picking only one stone
int one = Integer.MIN_VALUE;
// two for picking two stones
int two = Integer.MIN_VALUE;
// three for picking three stones
int three = Integer.MIN_VALUE;
one = storeArr[j]- first;
if((j + 1) < size)
{
two = storeArr[j] + storeArr[j + 1] - second;
}
if((j + 2) < size)
{
three = storeArr[j] + storeArr[j + 1] + storeArr[j + 2] - third;
}
int tmp = Math.max(one, Math.max(two, three));
third = second;
second = first;
first = tmp;
}
if(first == 0) 
{
return 0;
}
else if(first > 0) 
{
return 1;
}
else 
{
return 2;
}
}
    // main method
public static void main(String[] argvs) 
{
// creating an object of the class StoneGame1
StoneGame1 obj = new StoneGame1();
// input 1
int arr[] = {4, 3, 9, 16};
int size = arr.length;

System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr[i] + " ");
}
System.out.println();
int ans = obj.stoneGameSol(arr);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 2
int arr1[] = {8, -1, -1, 7};
size = arr1.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr1[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr1);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 3
int arr2[] = {-7, 2, 6, 3};
size = arr2.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr2[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr2);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 4
int arr3[] = {1, 2, 0, 3, 6, 7, 4};
size = arr3.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr3[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr3);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
}
}
 Output: For the stones of the following values: 
4 3 9 16 
It is a tie between player 1 and player 2

For the stones of the following values: 
8 -1 -1 7 
Player 1 wins the game.

For the stones of the following values: 
-7 2 6 3 
Player 2 wins the game.

For the stones of the following values: 
1 2 0 3 6 7 4 
Player 1 wins the game.
 Complexity Analysis: The time complexity of the program is the same as the previous program. Since the program is only using variables and not arrays, the space complexity of the program is constant, i.e., O(1). Next TopicTypeErasure in Java ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/stone-game-in-java Stone Game in Java - Javatpoint ? SCROLL TO TOP Home Java Programs OOPs String Exception Multithreading Collections JavaFX JSP Spring Spring Boot Projects Interview Questions Java Tutorial What is Java History of Java Features of Java C++ vs Java Hello Java Program Program Internal How to set path? JDK, JRE and JVM JVM: Java Virtual Machine Java Variables Java Data Types Unicode System Operators Keywords Control Statements Java Control Statements Java If-else Java Switch Java For Loop Java While Loop Java Do While Loop Java Break Java Continue Java Comments Java Programs Java Object Class Java OOPs Concepts Naming Convention Object and Class Method Constructor static keyword this keyword Java Inheritance Inheritance(IS-A) Aggregation(HAS-A) Java Polymorphism Method Overloading Method Overriding Covariant Return Type super keyword Instance Initializer block final keyword Runtime Polymorphism Dynamic Binding instanceof operator Java Abstraction Abstract class Interface Abstract vs Interface Java Encapsulation Package Access Modifiers Encapsulation Java Array Java Array Java OOPs Misc Object class Object Cloning Math class Wrapper Class Java Recursion Call By Value strictfp keyword javadoc tool Command Line Arg Object vs Class Overloading vs Overriding Java String Java Regex Exception Handling Java Inner classes Java Multithreading Java I/O Java Networking Java AWT & Events Java Swing JavaFX Java Applet Java Reflection Java Date Java Conversion Java Collection Java JDBC Java Misc Java New Features RMI Internationalization Interview Questions Java MCQ next ? ? prev Stone Game in Java In this game, stones are placed in a row (an input array is given). Two players are assigned the task of picking the stones of the maximum values. The player who collects stones of the maximum value wins the game. Player 1 will play first. After that, player two will play, and so on. At a time, a player can choose either 1 or 2 or 3 stones. The stones must be chosen from the left side only. Note that a player has to pick at least one stone. Our task is to decide which player will win the game if both the players play optimally. Example 1: int arr[] = {4, 3, 9, 16} Output: It is a tie between player 1 and player2 Explanation: Since stones are chosen from the left side and at max, only three stones are chosen, player 1 can only choose stones 1, 2 & 3. Thus, the total values of the stones chosen is 4 + 3 + 9 = 16. Now, it is the term of player 2. Player 2 can choose stone 4, which is of the value 16. Thus, both the players got the same value. Hence, it is a tie. Example 2: int arr[] = {8, -1, -1, 7} Output: Player 1 wins the game. Explanation: Player 1 plays optimally. Player 1 picks only the 1st stone from the left and leaves the rest. Thus, player 1 has a total value 8. Now, it is player 2 turn to pick the stones. Since players can only pick stones from the left only; therefore, player 2 has to pick stones of the values -1, -1, and 7. Thus, total value picked by the player 2 is -1 + -1 + 7 = 5, which is less than 8. Hence, player 1 wins. Example 3: int arr[] = {-7, 2, 6, 3} Output: Player 2 wins the game. Explanation: To gain the maximum value, player 1 picks stones 1, 2, and 3. Thus, collecting the maximum value of -7 + 2 + 6 = 1. There is only one stone left which is picked by player 2. The stone is of the value 3. Thus, player 2 wins the game. Example 4: int arr[] = {1, 2, 0, 3, 6, 7, 4} Output: Player 1 wins the game. Explanation: To gain the maximum value, player 1 picks stones 1 and 2 only. Thus, collecting the maximum value of 1 + 2 = 3. Now, it is the turn of player 2, and the player 2 picks stones of the values 0, 3, and 6 (total values 0 + 3 + 6 = 9). Again, it is the turn of player 1, and player 1 picks 7 and 4. Thus, total value collected by the player 1 is 3 + 7 + 4 = 14, which is greater than 9. Hence, player 1 wins the game. Approach: Using Recursion It is a brute force approach, where we consider each possible scenario for the player. The first scenario is when the player picks only one stone. The second scenario is when the player picks the two stones. The third scenario is when the player picks three stones. The maximum of these three scenarios is the value collected by the player. Observe the following program. FileName: StoneGame.java 
public class StoneGame 
{
    private int solve(int j, int[] nums)
    {
        // size of the array
        int size = nums.length;
        
        // handling the base case
        if(j >= size)
        {
            return 0;
        }
        // if we pick only one stone
        int one = Integer.MIN_VALUE;
        // if we pick two stones
        int two = Integer.MIN_VALUE;
        // if we pick three stones
        int three = Integer.MIN_VALUE;
        // picked one stone and performing the 
        // further computation
        one = nums[j] - solve(j + 1, nums);
        if((j + 1) < size)
        {
            // picked two stones at a time and performing 
            // the further computation
            two = nums[j] + nums[j + 1] - solve(j + 2, nums);
        }
        if((j + 2) < size)
        {
            // picked 3 stones at a time and performing the further
            // computation
            three = nums[j] + nums[j + 1] + nums[j + 2] - solve(j + 3, nums);
        }
        // picking the maximum between one, two and three
        return Math.max(one, Math.max(two, three));
    }
    public int stoneGameSol(int[] stoneVal) 
    {
        int ans = solve(0, stoneVal);
        if(ans == 0)
        {
            // 0 means its a tie
            return 0;
        }
        if(ans > 0)
        {
            // 1 means player 1 wins the game
            return 1;
        }
        // 2 means player 2 wins the game
        return 2;
    }
    // main method
public static void main(String[] argvs) 
{
// creating an object of the class StoneGame
StoneGame obj = new StoneGame();
// input 1
int arr[] = {4, 3, 9, 16};
int size = arr.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr[i] + " ");
}
System.out.println();
int ans = obj.stoneGameSol(arr);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 2
int arr1[] = {8, -1, -1, 7};
size = arr1.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr1[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr1);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 3
int arr2[] = {-7, 2, 6, 3};
size = arr2.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr2[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr2);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 4
int arr3[] = {1, 2, 0, 3, 6, 7, 4};
size = arr3.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr3[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr3);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
}
}
 Output: For the stones of the following values: 
4 3 9 16 
It is a tie between player 1 and player 2

For the stones of the following values: 
8 -1 -1 7 
Player 1 wins the game.

For the stones of the following values: 
-7 2 6 3 
Player 2 wins the game.

For the stones of the following values: 
1 2 0 3 6 7 4 
Player 1 wins the game.
 Complexity Analysis: The time complexity of the program is exponential as there are recursive calls for all the scenarios. The above program is not suitable for larger input as it will take a lot of time because of its high time complexity. Approach: Using Iteration (Dynamic Programming) We will assume that the dp[j] is the maximum value player 1 can get. Since player 1 can take 1 to 3 stones, player 2 can begin from either dp[j + 1], dp[j + 2], dp[j + 3]. Player 2 can also take 1 to 3 stones. Thus, resulting in the minimum of dp[j + 2 to 4], dp[j + 3 to 5], and dp[j + 4 to 6]. Thus, 
Dp[j] = max
(
                    stoneArr[j : j + 1] + min(dp[j + 2], dp[j + 3], dp[j + 4]),
                    stoneArr[j : j + 2] + min(dp[j + 3], dp[j + 4], dp[j + 5]),
                    stoneArr[j : j + 3] + min(dp[j + 4], dp[j + 5], dp[j + 6])
              )
 If any of the indexes are out of bounds, then it means the value is 0. The resulting score is stored dp[0]. FileName: StoneGame1.java 
public class StoneGame1 
{
public int stoneGameSol(int storeArr[]) 
{
// computing the size of the array
int n = storeArr.length;
int dp[] = new int[n];
// contains the sum of the values of 
// the stones present in the array stoneArr
int sums[] = new int[n+1];
for (int j = 0; j < n; j++) 
{
sums[j + 1] = sums[j] + storeArr[j];
}
dp[n - 1] = storeArr[n - 1];
if (n > 1) 
{
dp[n - 2] = storeArr[n - 2] + Math.max(storeArr[n - 1], 0);
for (int j = n - 3; j >= 0; j--) 
{
dp[j] = Integer.MIN_VALUE;
for (int k = 1; k <= 3; k++) 
{
// score is the sum of values of the
// stone taken by the player
// for k = 1 only one stone is taken
// for k = 2, two stones are taken
// for k = 3, three stones are taken
int score = sums[j + k] - sums[j];
int a1 = j + k + 1 < n ? dp[j + k + 1] : 0;
int a2 = j + k + 2 < n ? dp[j + k + 2] : 0;
int a3 = j + k + 3 < n ? dp[j + k + 3] : 0;
// the players are playing optimally. Hence, we have to pick
// the minimum between a1, a2, a3
dp[j] = Math.max(dp[j], score + Math.min(a1, Math.min(a2, a3)));
}
}
}
if ((2 * dp[0]) > sums[n]) 
{
return 1;
}
else if ((2 * dp[0]) < sums[n]) 
{
return 2;
}
else 
{
return 0;
}
}
// main method
public static void main(String[] argvs) 
{
// creating an object of the class StoneGame1
StoneGame1 obj = new StoneGame1();
// input 1
int arr[] = {4, 3, 9, 16};
int size = arr.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr[i] + " ");
}
System.out.println();
int ans = obj.stoneGameSol(arr);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 2
int arr1[] = {8, -1, -1, 7};
size = arr1.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr1[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr1);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 3
int arr2[] = {-7, 2, 6, 3};
size = arr2.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr2[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr2);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 4
int arr3[] = {1, 2, 0, 3, 6, 7, 4};
size = arr3.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr3[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr3);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
}
}
 Output: For the stones of the following values: 
4 3 9 16 
It is a tie between player 1 and player 2

For the stones of the following values: 
8 -1 -1 7 
Player 1 wins the game.

For the stones of the following values: 
-7 2 6 3 
Player 2 wins the game.

For the stones of the following values: 
1 2 0 3 6 7 4 
Player 1 wins the game.
 Complexity Analysis: The time complexity of the program is O(3 * N). In terms of the asymptotic time complexity, it is O(N). As the program uses two auxiliary arrays for storing the answer and the sum of values of stones, the space complexity of the program is O(N + N), which is O(2 *N). In terms of asymptotic time, it is again O(N), where N is the total number of elements present in the stone array. The space complexity of the program can be further reduced. We can use variables instead of arrays, and it is evident in the following program. FileName: StoneGame1.java 
public class StoneGame1 
{
public int stoneGameSol(int storeArr[]) 
{
// computing the size of the array
int size = storeArr.length;
int first = 0; // contains the answer
int second = 0;
int third = 0;
for(int j = size - 1; j >= 0; j--)
{
// one for picking only one stone
int one = Integer.MIN_VALUE;
// two for picking two stones
int two = Integer.MIN_VALUE;
// three for picking three stones
int three = Integer.MIN_VALUE;
one = storeArr[j]- first;
if((j + 1) < size)
{
two = storeArr[j] + storeArr[j + 1] - second;
}
if((j + 2) < size)
{
three = storeArr[j] + storeArr[j + 1] + storeArr[j + 2] - third;
}
int tmp = Math.max(one, Math.max(two, three));
third = second;
second = first;
first = tmp;
}
if(first == 0) 
{
return 0;
}
else if(first > 0) 
{
return 1;
}
else 
{
return 2;
}
}
    // main method
public static void main(String[] argvs) 
{
// creating an object of the class StoneGame1
StoneGame1 obj = new StoneGame1();
// input 1
int arr[] = {4, 3, 9, 16};
int size = arr.length;

System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr[i] + " ");
}
System.out.println();
int ans = obj.stoneGameSol(arr);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 2
int arr1[] = {8, -1, -1, 7};
size = arr1.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr1[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr1);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 3
int arr2[] = {-7, 2, 6, 3};
size = arr2.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr2[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr2);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 4
int arr3[] = {1, 2, 0, 3, 6, 7, 4};
size = arr3.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr3[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr3);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
}
}
 Output: For the stones of the following values: 
4 3 9 16 
It is a tie between player 1 and player 2

For the stones of the following values: 
8 -1 -1 7 
Player 1 wins the game.

For the stones of the following values: 
-7 2 6 3 
Player 2 wins the game.

For the stones of the following values: 
1 2 0 3 6 7 4 
Player 1 wins the game.
 Complexity Analysis: The time complexity of the program is the same as the previous program. Since the program is only using variables and not arrays, the space complexity of the program is constant, i.e., O(1). Next TopicTypeErasure in Java ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/stone-game-in-java Stone Game in Java - Javatpoint ? SCROLL TO TOP Home Java Programs OOPs String Exception Multithreading Collections JavaFX JSP Spring Spring Boot Projects Interview Questions Java Tutorial What is Java History of Java Features of Java C++ vs Java Hello Java Program Program Internal How to set path? JDK, JRE and JVM JVM: Java Virtual Machine Java Variables Java Data Types Unicode System Operators Keywords Control Statements Java Control Statements Java If-else Java Switch Java For Loop Java While Loop Java Do While Loop Java Break Java Continue Java Comments Java Programs Java Object Class Java OOPs Concepts Naming Convention Object and Class Method Constructor static keyword this keyword Java Inheritance Inheritance(IS-A) Aggregation(HAS-A) Java Polymorphism Method Overloading Method Overriding Covariant Return Type super keyword Instance Initializer block final keyword Runtime Polymorphism Dynamic Binding instanceof operator Java Abstraction Abstract class Interface Abstract vs Interface Java Encapsulation Package Access Modifiers Encapsulation Java Array Java Array Java OOPs Misc Object class Object Cloning Math class Wrapper Class Java Recursion Call By Value strictfp keyword javadoc tool Command Line Arg Object vs Class Overloading vs Overriding Java String Java Regex Exception Handling Java Inner classes Java Multithreading Java I/O Java Networking Java AWT & Events Java Swing JavaFX Java Applet Java Reflection Java Date Java Conversion Java Collection Java JDBC Java Misc Java New Features RMI Internationalization Interview Questions Java MCQ next ? ? prev Stone Game in Java In this game, stones are placed in a row (an input array is given). Two players are assigned the task of picking the stones of the maximum values. The player who collects stones of the maximum value wins the game. Player 1 will play first. After that, player two will play, and so on. At a time, a player can choose either 1 or 2 or 3 stones. The stones must be chosen from the left side only. Note that a player has to pick at least one stone. Our task is to decide which player will win the game if both the players play optimally. Example 1: int arr[] = {4, 3, 9, 16} Output: It is a tie between player 1 and player2 Explanation: Since stones are chosen from the left side and at max, only three stones are chosen, player 1 can only choose stones 1, 2 & 3. Thus, the total values of the stones chosen is 4 + 3 + 9 = 16. Now, it is the term of player 2. Player 2 can choose stone 4, which is of the value 16. Thus, both the players got the same value. Hence, it is a tie. Example 2: int arr[] = {8, -1, -1, 7} Output: Player 1 wins the game. Explanation: Player 1 plays optimally. Player 1 picks only the 1st stone from the left and leaves the rest. Thus, player 1 has a total value 8. Now, it is player 2 turn to pick the stones. Since players can only pick stones from the left only; therefore, player 2 has to pick stones of the values -1, -1, and 7. Thus, total value picked by the player 2 is -1 + -1 + 7 = 5, which is less than 8. Hence, player 1 wins. Example 3: int arr[] = {-7, 2, 6, 3} Output: Player 2 wins the game. Explanation: To gain the maximum value, player 1 picks stones 1, 2, and 3. Thus, collecting the maximum value of -7 + 2 + 6 = 1. There is only one stone left which is picked by player 2. The stone is of the value 3. Thus, player 2 wins the game. Example 4: int arr[] = {1, 2, 0, 3, 6, 7, 4} Output: Player 1 wins the game. Explanation: To gain the maximum value, player 1 picks stones 1 and 2 only. Thus, collecting the maximum value of 1 + 2 = 3. Now, it is the turn of player 2, and the player 2 picks stones of the values 0, 3, and 6 (total values 0 + 3 + 6 = 9). Again, it is the turn of player 1, and player 1 picks 7 and 4. Thus, total value collected by the player 1 is 3 + 7 + 4 = 14, which is greater than 9. Hence, player 1 wins the game. Approach: Using Recursion It is a brute force approach, where we consider each possible scenario for the player. The first scenario is when the player picks only one stone. The second scenario is when the player picks the two stones. The third scenario is when the player picks three stones. The maximum of these three scenarios is the value collected by the player. Observe the following program. FileName: StoneGame.java 
public class StoneGame 
{
    private int solve(int j, int[] nums)
    {
        // size of the array
        int size = nums.length;
        
        // handling the base case
        if(j >= size)
        {
            return 0;
        }
        // if we pick only one stone
        int one = Integer.MIN_VALUE;
        // if we pick two stones
        int two = Integer.MIN_VALUE;
        // if we pick three stones
        int three = Integer.MIN_VALUE;
        // picked one stone and performing the 
        // further computation
        one = nums[j] - solve(j + 1, nums);
        if((j + 1) < size)
        {
            // picked two stones at a time and performing 
            // the further computation
            two = nums[j] + nums[j + 1] - solve(j + 2, nums);
        }
        if((j + 2) < size)
        {
            // picked 3 stones at a time and performing the further
            // computation
            three = nums[j] + nums[j + 1] + nums[j + 2] - solve(j + 3, nums);
        }
        // picking the maximum between one, two and three
        return Math.max(one, Math.max(two, three));
    }
    public int stoneGameSol(int[] stoneVal) 
    {
        int ans = solve(0, stoneVal);
        if(ans == 0)
        {
            // 0 means its a tie
            return 0;
        }
        if(ans > 0)
        {
            // 1 means player 1 wins the game
            return 1;
        }
        // 2 means player 2 wins the game
        return 2;
    }
    // main method
public static void main(String[] argvs) 
{
// creating an object of the class StoneGame
StoneGame obj = new StoneGame();
// input 1
int arr[] = {4, 3, 9, 16};
int size = arr.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr[i] + " ");
}
System.out.println();
int ans = obj.stoneGameSol(arr);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 2
int arr1[] = {8, -1, -1, 7};
size = arr1.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr1[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr1);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 3
int arr2[] = {-7, 2, 6, 3};
size = arr2.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr2[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr2);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 4
int arr3[] = {1, 2, 0, 3, 6, 7, 4};
size = arr3.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr3[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr3);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
}
}
 Output: For the stones of the following values: 
4 3 9 16 
It is a tie between player 1 and player 2

For the stones of the following values: 
8 -1 -1 7 
Player 1 wins the game.

For the stones of the following values: 
-7 2 6 3 
Player 2 wins the game.

For the stones of the following values: 
1 2 0 3 6 7 4 
Player 1 wins the game.
 Complexity Analysis: The time complexity of the program is exponential as there are recursive calls for all the scenarios. The above program is not suitable for larger input as it will take a lot of time because of its high time complexity. Approach: Using Iteration (Dynamic Programming) We will assume that the dp[j] is the maximum value player 1 can get. Since player 1 can take 1 to 3 stones, player 2 can begin from either dp[j + 1], dp[j + 2], dp[j + 3]. Player 2 can also take 1 to 3 stones. Thus, resulting in the minimum of dp[j + 2 to 4], dp[j + 3 to 5], and dp[j + 4 to 6]. Thus, 
Dp[j] = max
(
                    stoneArr[j : j + 1] + min(dp[j + 2], dp[j + 3], dp[j + 4]),
                    stoneArr[j : j + 2] + min(dp[j + 3], dp[j + 4], dp[j + 5]),
                    stoneArr[j : j + 3] + min(dp[j + 4], dp[j + 5], dp[j + 6])
              )
 If any of the indexes are out of bounds, then it means the value is 0. The resulting score is stored dp[0]. FileName: StoneGame1.java 
public class StoneGame1 
{
public int stoneGameSol(int storeArr[]) 
{
// computing the size of the array
int n = storeArr.length;
int dp[] = new int[n];
// contains the sum of the values of 
// the stones present in the array stoneArr
int sums[] = new int[n+1];
for (int j = 0; j < n; j++) 
{
sums[j + 1] = sums[j] + storeArr[j];
}
dp[n - 1] = storeArr[n - 1];
if (n > 1) 
{
dp[n - 2] = storeArr[n - 2] + Math.max(storeArr[n - 1], 0);
for (int j = n - 3; j >= 0; j--) 
{
dp[j] = Integer.MIN_VALUE;
for (int k = 1; k <= 3; k++) 
{
// score is the sum of values of the
// stone taken by the player
// for k = 1 only one stone is taken
// for k = 2, two stones are taken
// for k = 3, three stones are taken
int score = sums[j + k] - sums[j];
int a1 = j + k + 1 < n ? dp[j + k + 1] : 0;
int a2 = j + k + 2 < n ? dp[j + k + 2] : 0;
int a3 = j + k + 3 < n ? dp[j + k + 3] : 0;
// the players are playing optimally. Hence, we have to pick
// the minimum between a1, a2, a3
dp[j] = Math.max(dp[j], score + Math.min(a1, Math.min(a2, a3)));
}
}
}
if ((2 * dp[0]) > sums[n]) 
{
return 1;
}
else if ((2 * dp[0]) < sums[n]) 
{
return 2;
}
else 
{
return 0;
}
}
// main method
public static void main(String[] argvs) 
{
// creating an object of the class StoneGame1
StoneGame1 obj = new StoneGame1();
// input 1
int arr[] = {4, 3, 9, 16};
int size = arr.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr[i] + " ");
}
System.out.println();
int ans = obj.stoneGameSol(arr);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 2
int arr1[] = {8, -1, -1, 7};
size = arr1.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr1[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr1);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 3
int arr2[] = {-7, 2, 6, 3};
size = arr2.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr2[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr2);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 4
int arr3[] = {1, 2, 0, 3, 6, 7, 4};
size = arr3.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr3[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr3);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
}
}
 Output: For the stones of the following values: 
4 3 9 16 
It is a tie between player 1 and player 2

For the stones of the following values: 
8 -1 -1 7 
Player 1 wins the game.

For the stones of the following values: 
-7 2 6 3 
Player 2 wins the game.

For the stones of the following values: 
1 2 0 3 6 7 4 
Player 1 wins the game.
 Complexity Analysis: The time complexity of the program is O(3 * N). In terms of the asymptotic time complexity, it is O(N). As the program uses two auxiliary arrays for storing the answer and the sum of values of stones, the space complexity of the program is O(N + N), which is O(2 *N). In terms of asymptotic time, it is again O(N), where N is the total number of elements present in the stone array. The space complexity of the program can be further reduced. We can use variables instead of arrays, and it is evident in the following program. FileName: StoneGame1.java 
public class StoneGame1 
{
public int stoneGameSol(int storeArr[]) 
{
// computing the size of the array
int size = storeArr.length;
int first = 0; // contains the answer
int second = 0;
int third = 0;
for(int j = size - 1; j >= 0; j--)
{
// one for picking only one stone
int one = Integer.MIN_VALUE;
// two for picking two stones
int two = Integer.MIN_VALUE;
// three for picking three stones
int three = Integer.MIN_VALUE;
one = storeArr[j]- first;
if((j + 1) < size)
{
two = storeArr[j] + storeArr[j + 1] - second;
}
if((j + 2) < size)
{
three = storeArr[j] + storeArr[j + 1] + storeArr[j + 2] - third;
}
int tmp = Math.max(one, Math.max(two, three));
third = second;
second = first;
first = tmp;
}
if(first == 0) 
{
return 0;
}
else if(first > 0) 
{
return 1;
}
else 
{
return 2;
}
}
    // main method
public static void main(String[] argvs) 
{
// creating an object of the class StoneGame1
StoneGame1 obj = new StoneGame1();
// input 1
int arr[] = {4, 3, 9, 16};
int size = arr.length;

System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr[i] + " ");
}
System.out.println();
int ans = obj.stoneGameSol(arr);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 2
int arr1[] = {8, -1, -1, 7};
size = arr1.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr1[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr1);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 3
int arr2[] = {-7, 2, 6, 3};
size = arr2.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr2[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr2);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 4
int arr3[] = {1, 2, 0, 3, 6, 7, 4};
size = arr3.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr3[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr3);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
}
}
 Output: For the stones of the following values: 
4 3 9 16 
It is a tie between player 1 and player 2

For the stones of the following values: 
8 -1 -1 7 
Player 1 wins the game.

For the stones of the following values: 
-7 2 6 3 
Player 2 wins the game.

For the stones of the following values: 
1 2 0 3 6 7 4 
Player 1 wins the game.
 Complexity Analysis: The time complexity of the program is the same as the previous program. Since the program is only using variables and not arrays, the space complexity of the program is constant, i.e., O(1). Next TopicTypeErasure in Java ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/stone-game-in-java Stone Game in Java - Javatpoint ? SCROLL TO TOP Home Java Programs OOPs String Exception Multithreading Collections JavaFX JSP Spring Spring Boot Projects Interview Questions Java Tutorial What is Java History of Java Features of Java C++ vs Java Hello Java Program Program Internal How to set path? JDK, JRE and JVM JVM: Java Virtual Machine Java Variables Java Data Types Unicode System Operators Keywords Control Statements Java Control Statements Java If-else Java Switch Java For Loop Java While Loop Java Do While Loop Java Break Java Continue Java Comments Java Programs Java Object Class Java OOPs Concepts Naming Convention Object and Class Method Constructor static keyword this keyword Java Inheritance Inheritance(IS-A) Aggregation(HAS-A) Java Polymorphism Method Overloading Method Overriding Covariant Return Type super keyword Instance Initializer block final keyword Runtime Polymorphism Dynamic Binding instanceof operator Java Abstraction Abstract class Interface Abstract vs Interface Java Encapsulation Package Access Modifiers Encapsulation Java Array Java Array Java OOPs Misc Object class Object Cloning Math class Wrapper Class Java Recursion Call By Value strictfp keyword javadoc tool Command Line Arg Object vs Class Overloading vs Overriding Java String Java Regex Exception Handling Java Inner classes Java Multithreading Java I/O Java Networking Java AWT & Events Java Swing JavaFX Java Applet Java Reflection Java Date Java Conversion Java Collection Java JDBC Java Misc Java New Features RMI Internationalization Interview Questions Java MCQ next ? ? prev Stone Game in Java In this game, stones are placed in a row (an input array is given). Two players are assigned the task of picking the stones of the maximum values. The player who collects stones of the maximum value wins the game. Player 1 will play first. After that, player two will play, and so on. At a time, a player can choose either 1 or 2 or 3 stones. The stones must be chosen from the left side only. Note that a player has to pick at least one stone. Our task is to decide which player will win the game if both the players play optimally. Example 1: int arr[] = {4, 3, 9, 16} Output: It is a tie between player 1 and player2 Explanation: Since stones are chosen from the left side and at max, only three stones are chosen, player 1 can only choose stones 1, 2 & 3. Thus, the total values of the stones chosen is 4 + 3 + 9 = 16. Now, it is the term of player 2. Player 2 can choose stone 4, which is of the value 16. Thus, both the players got the same value. Hence, it is a tie. Example 2: int arr[] = {8, -1, -1, 7} Output: Player 1 wins the game. Explanation: Player 1 plays optimally. Player 1 picks only the 1st stone from the left and leaves the rest. Thus, player 1 has a total value 8. Now, it is player 2 turn to pick the stones. Since players can only pick stones from the left only; therefore, player 2 has to pick stones of the values -1, -1, and 7. Thus, total value picked by the player 2 is -1 + -1 + 7 = 5, which is less than 8. Hence, player 1 wins. Example 3: int arr[] = {-7, 2, 6, 3} Output: Player 2 wins the game. Explanation: To gain the maximum value, player 1 picks stones 1, 2, and 3. Thus, collecting the maximum value of -7 + 2 + 6 = 1. There is only one stone left which is picked by player 2. The stone is of the value 3. Thus, player 2 wins the game. Example 4: int arr[] = {1, 2, 0, 3, 6, 7, 4} Output: Player 1 wins the game. Explanation: To gain the maximum value, player 1 picks stones 1 and 2 only. Thus, collecting the maximum value of 1 + 2 = 3. Now, it is the turn of player 2, and the player 2 picks stones of the values 0, 3, and 6 (total values 0 + 3 + 6 = 9). Again, it is the turn of player 1, and player 1 picks 7 and 4. Thus, total value collected by the player 1 is 3 + 7 + 4 = 14, which is greater than 9. Hence, player 1 wins the game. Approach: Using Recursion It is a brute force approach, where we consider each possible scenario for the player. The first scenario is when the player picks only one stone. The second scenario is when the player picks the two stones. The third scenario is when the player picks three stones. The maximum of these three scenarios is the value collected by the player. Observe the following program. FileName: StoneGame.java 
public class StoneGame 
{
    private int solve(int j, int[] nums)
    {
        // size of the array
        int size = nums.length;
        
        // handling the base case
        if(j >= size)
        {
            return 0;
        }
        // if we pick only one stone
        int one = Integer.MIN_VALUE;
        // if we pick two stones
        int two = Integer.MIN_VALUE;
        // if we pick three stones
        int three = Integer.MIN_VALUE;
        // picked one stone and performing the 
        // further computation
        one = nums[j] - solve(j + 1, nums);
        if((j + 1) < size)
        {
            // picked two stones at a time and performing 
            // the further computation
            two = nums[j] + nums[j + 1] - solve(j + 2, nums);
        }
        if((j + 2) < size)
        {
            // picked 3 stones at a time and performing the further
            // computation
            three = nums[j] + nums[j + 1] + nums[j + 2] - solve(j + 3, nums);
        }
        // picking the maximum between one, two and three
        return Math.max(one, Math.max(two, three));
    }
    public int stoneGameSol(int[] stoneVal) 
    {
        int ans = solve(0, stoneVal);
        if(ans == 0)
        {
            // 0 means its a tie
            return 0;
        }
        if(ans > 0)
        {
            // 1 means player 1 wins the game
            return 1;
        }
        // 2 means player 2 wins the game
        return 2;
    }
    // main method
public static void main(String[] argvs) 
{
// creating an object of the class StoneGame
StoneGame obj = new StoneGame();
// input 1
int arr[] = {4, 3, 9, 16};
int size = arr.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr[i] + " ");
}
System.out.println();
int ans = obj.stoneGameSol(arr);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 2
int arr1[] = {8, -1, -1, 7};
size = arr1.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr1[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr1);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 3
int arr2[] = {-7, 2, 6, 3};
size = arr2.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr2[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr2);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 4
int arr3[] = {1, 2, 0, 3, 6, 7, 4};
size = arr3.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr3[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr3);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
}
}
 Output: For the stones of the following values: 
4 3 9 16 
It is a tie between player 1 and player 2

For the stones of the following values: 
8 -1 -1 7 
Player 1 wins the game.

For the stones of the following values: 
-7 2 6 3 
Player 2 wins the game.

For the stones of the following values: 
1 2 0 3 6 7 4 
Player 1 wins the game.
 Complexity Analysis: The time complexity of the program is exponential as there are recursive calls for all the scenarios. The above program is not suitable for larger input as it will take a lot of time because of its high time complexity. Approach: Using Iteration (Dynamic Programming) We will assume that the dp[j] is the maximum value player 1 can get. Since player 1 can take 1 to 3 stones, player 2 can begin from either dp[j + 1], dp[j + 2], dp[j + 3]. Player 2 can also take 1 to 3 stones. Thus, resulting in the minimum of dp[j + 2 to 4], dp[j + 3 to 5], and dp[j + 4 to 6]. Thus, 
Dp[j] = max
(
                    stoneArr[j : j + 1] + min(dp[j + 2], dp[j + 3], dp[j + 4]),
                    stoneArr[j : j + 2] + min(dp[j + 3], dp[j + 4], dp[j + 5]),
                    stoneArr[j : j + 3] + min(dp[j + 4], dp[j + 5], dp[j + 6])
              )
 If any of the indexes are out of bounds, then it means the value is 0. The resulting score is stored dp[0]. FileName: StoneGame1.java 
public class StoneGame1 
{
public int stoneGameSol(int storeArr[]) 
{
// computing the size of the array
int n = storeArr.length;
int dp[] = new int[n];
// contains the sum of the values of 
// the stones present in the array stoneArr
int sums[] = new int[n+1];
for (int j = 0; j < n; j++) 
{
sums[j + 1] = sums[j] + storeArr[j];
}
dp[n - 1] = storeArr[n - 1];
if (n > 1) 
{
dp[n - 2] = storeArr[n - 2] + Math.max(storeArr[n - 1], 0);
for (int j = n - 3; j >= 0; j--) 
{
dp[j] = Integer.MIN_VALUE;
for (int k = 1; k <= 3; k++) 
{
// score is the sum of values of the
// stone taken by the player
// for k = 1 only one stone is taken
// for k = 2, two stones are taken
// for k = 3, three stones are taken
int score = sums[j + k] - sums[j];
int a1 = j + k + 1 < n ? dp[j + k + 1] : 0;
int a2 = j + k + 2 < n ? dp[j + k + 2] : 0;
int a3 = j + k + 3 < n ? dp[j + k + 3] : 0;
// the players are playing optimally. Hence, we have to pick
// the minimum between a1, a2, a3
dp[j] = Math.max(dp[j], score + Math.min(a1, Math.min(a2, a3)));
}
}
}
if ((2 * dp[0]) > sums[n]) 
{
return 1;
}
else if ((2 * dp[0]) < sums[n]) 
{
return 2;
}
else 
{
return 0;
}
}
// main method
public static void main(String[] argvs) 
{
// creating an object of the class StoneGame1
StoneGame1 obj = new StoneGame1();
// input 1
int arr[] = {4, 3, 9, 16};
int size = arr.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr[i] + " ");
}
System.out.println();
int ans = obj.stoneGameSol(arr);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 2
int arr1[] = {8, -1, -1, 7};
size = arr1.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr1[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr1);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 3
int arr2[] = {-7, 2, 6, 3};
size = arr2.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr2[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr2);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 4
int arr3[] = {1, 2, 0, 3, 6, 7, 4};
size = arr3.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr3[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr3);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
}
}
 Output: For the stones of the following values: 
4 3 9 16 
It is a tie between player 1 and player 2

For the stones of the following values: 
8 -1 -1 7 
Player 1 wins the game.

For the stones of the following values: 
-7 2 6 3 
Player 2 wins the game.

For the stones of the following values: 
1 2 0 3 6 7 4 
Player 1 wins the game.
 Complexity Analysis: The time complexity of the program is O(3 * N). In terms of the asymptotic time complexity, it is O(N). As the program uses two auxiliary arrays for storing the answer and the sum of values of stones, the space complexity of the program is O(N + N), which is O(2 *N). In terms of asymptotic time, it is again O(N), where N is the total number of elements present in the stone array. The space complexity of the program can be further reduced. We can use variables instead of arrays, and it is evident in the following program. FileName: StoneGame1.java 
public class StoneGame1 
{
public int stoneGameSol(int storeArr[]) 
{
// computing the size of the array
int size = storeArr.length;
int first = 0; // contains the answer
int second = 0;
int third = 0;
for(int j = size - 1; j >= 0; j--)
{
// one for picking only one stone
int one = Integer.MIN_VALUE;
// two for picking two stones
int two = Integer.MIN_VALUE;
// three for picking three stones
int three = Integer.MIN_VALUE;
one = storeArr[j]- first;
if((j + 1) < size)
{
two = storeArr[j] + storeArr[j + 1] - second;
}
if((j + 2) < size)
{
three = storeArr[j] + storeArr[j + 1] + storeArr[j + 2] - third;
}
int tmp = Math.max(one, Math.max(two, three));
third = second;
second = first;
first = tmp;
}
if(first == 0) 
{
return 0;
}
else if(first > 0) 
{
return 1;
}
else 
{
return 2;
}
}
    // main method
public static void main(String[] argvs) 
{
// creating an object of the class StoneGame1
StoneGame1 obj = new StoneGame1();
// input 1
int arr[] = {4, 3, 9, 16};
int size = arr.length;

System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr[i] + " ");
}
System.out.println();
int ans = obj.stoneGameSol(arr);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 2
int arr1[] = {8, -1, -1, 7};
size = arr1.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr1[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr1);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 3
int arr2[] = {-7, 2, 6, 3};
size = arr2.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr2[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr2);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 4
int arr3[] = {1, 2, 0, 3, 6, 7, 4};
size = arr3.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr3[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr3);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
}
}
 Output: For the stones of the following values: 
4 3 9 16 
It is a tie between player 1 and player 2

For the stones of the following values: 
8 -1 -1 7 
Player 1 wins the game.

For the stones of the following values: 
-7 2 6 3 
Player 2 wins the game.

For the stones of the following values: 
1 2 0 3 6 7 4 
Player 1 wins the game.
 Complexity Analysis: The time complexity of the program is the same as the previous program. Since the program is only using variables and not arrays, the space complexity of the program is constant, i.e., O(1). Next TopicTypeErasure in Java ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/stone-game-in-java Stone Game in Java - Javatpoint ? SCROLL TO TOP Home Java Programs OOPs String Exception Multithreading Collections JavaFX JSP Spring Spring Boot Projects Interview Questions Java Tutorial What is Java History of Java Features of Java C++ vs Java Hello Java Program Program Internal How to set path? JDK, JRE and JVM JVM: Java Virtual Machine Java Variables Java Data Types Unicode System Operators Keywords Control Statements Java Control Statements Java If-else Java Switch Java For Loop Java While Loop Java Do While Loop Java Break Java Continue Java Comments Java Programs Java Object Class Java OOPs Concepts Naming Convention Object and Class Method Constructor static keyword this keyword Java Inheritance Inheritance(IS-A) Aggregation(HAS-A) Java Polymorphism Method Overloading Method Overriding Covariant Return Type super keyword Instance Initializer block final keyword Runtime Polymorphism Dynamic Binding instanceof operator Java Abstraction Abstract class Interface Abstract vs Interface Java Encapsulation Package Access Modifiers Encapsulation Java Array Java Array Java OOPs Misc Object class Object Cloning Math class Wrapper Class Java Recursion Call By Value strictfp keyword javadoc tool Command Line Arg Object vs Class Overloading vs Overriding Java String Java Regex Exception Handling Java Inner classes Java Multithreading Java I/O Java Networking Java AWT & Events Java Swing JavaFX Java Applet Java Reflection Java Date Java Conversion Java Collection Java JDBC Java Misc Java New Features RMI Internationalization Interview Questions Java MCQ next ? ? prev Stone Game in Java In this game, stones are placed in a row (an input array is given). Two players are assigned the task of picking the stones of the maximum values. The player who collects stones of the maximum value wins the game. Player 1 will play first. After that, player two will play, and so on. At a time, a player can choose either 1 or 2 or 3 stones. The stones must be chosen from the left side only. Note that a player has to pick at least one stone. Our task is to decide which player will win the game if both the players play optimally. Example 1: int arr[] = {4, 3, 9, 16} Output: It is a tie between player 1 and player2 Explanation: Since stones are chosen from the left side and at max, only three stones are chosen, player 1 can only choose stones 1, 2 & 3. Thus, the total values of the stones chosen is 4 + 3 + 9 = 16. Now, it is the term of player 2. Player 2 can choose stone 4, which is of the value 16. Thus, both the players got the same value. Hence, it is a tie. Example 2: int arr[] = {8, -1, -1, 7} Output: Player 1 wins the game. Explanation: Player 1 plays optimally. Player 1 picks only the 1st stone from the left and leaves the rest. Thus, player 1 has a total value 8. Now, it is player 2 turn to pick the stones. Since players can only pick stones from the left only; therefore, player 2 has to pick stones of the values -1, -1, and 7. Thus, total value picked by the player 2 is -1 + -1 + 7 = 5, which is less than 8. Hence, player 1 wins. Example 3: int arr[] = {-7, 2, 6, 3} Output: Player 2 wins the game. Explanation: To gain the maximum value, player 1 picks stones 1, 2, and 3. Thus, collecting the maximum value of -7 + 2 + 6 = 1. There is only one stone left which is picked by player 2. The stone is of the value 3. Thus, player 2 wins the game. Example 4: int arr[] = {1, 2, 0, 3, 6, 7, 4} Output: Player 1 wins the game. Explanation: To gain the maximum value, player 1 picks stones 1 and 2 only. Thus, collecting the maximum value of 1 + 2 = 3. Now, it is the turn of player 2, and the player 2 picks stones of the values 0, 3, and 6 (total values 0 + 3 + 6 = 9). Again, it is the turn of player 1, and player 1 picks 7 and 4. Thus, total value collected by the player 1 is 3 + 7 + 4 = 14, which is greater than 9. Hence, player 1 wins the game. Approach: Using Recursion It is a brute force approach, where we consider each possible scenario for the player. The first scenario is when the player picks only one stone. The second scenario is when the player picks the two stones. The third scenario is when the player picks three stones. The maximum of these three scenarios is the value collected by the player. Observe the following program. FileName: StoneGame.java 
public class StoneGame 
{
    private int solve(int j, int[] nums)
    {
        // size of the array
        int size = nums.length;
        
        // handling the base case
        if(j >= size)
        {
            return 0;
        }
        // if we pick only one stone
        int one = Integer.MIN_VALUE;
        // if we pick two stones
        int two = Integer.MIN_VALUE;
        // if we pick three stones
        int three = Integer.MIN_VALUE;
        // picked one stone and performing the 
        // further computation
        one = nums[j] - solve(j + 1, nums);
        if((j + 1) < size)
        {
            // picked two stones at a time and performing 
            // the further computation
            two = nums[j] + nums[j + 1] - solve(j + 2, nums);
        }
        if((j + 2) < size)
        {
            // picked 3 stones at a time and performing the further
            // computation
            three = nums[j] + nums[j + 1] + nums[j + 2] - solve(j + 3, nums);
        }
        // picking the maximum between one, two and three
        return Math.max(one, Math.max(two, three));
    }
    public int stoneGameSol(int[] stoneVal) 
    {
        int ans = solve(0, stoneVal);
        if(ans == 0)
        {
            // 0 means its a tie
            return 0;
        }
        if(ans > 0)
        {
            // 1 means player 1 wins the game
            return 1;
        }
        // 2 means player 2 wins the game
        return 2;
    }
    // main method
public static void main(String[] argvs) 
{
// creating an object of the class StoneGame
StoneGame obj = new StoneGame();
// input 1
int arr[] = {4, 3, 9, 16};
int size = arr.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr[i] + " ");
}
System.out.println();
int ans = obj.stoneGameSol(arr);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 2
int arr1[] = {8, -1, -1, 7};
size = arr1.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr1[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr1);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 3
int arr2[] = {-7, 2, 6, 3};
size = arr2.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr2[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr2);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 4
int arr3[] = {1, 2, 0, 3, 6, 7, 4};
size = arr3.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr3[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr3);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
}
}
 Output: For the stones of the following values: 
4 3 9 16 
It is a tie between player 1 and player 2

For the stones of the following values: 
8 -1 -1 7 
Player 1 wins the game.

For the stones of the following values: 
-7 2 6 3 
Player 2 wins the game.

For the stones of the following values: 
1 2 0 3 6 7 4 
Player 1 wins the game.
 Complexity Analysis: The time complexity of the program is exponential as there are recursive calls for all the scenarios. The above program is not suitable for larger input as it will take a lot of time because of its high time complexity. Approach: Using Iteration (Dynamic Programming) We will assume that the dp[j] is the maximum value player 1 can get. Since player 1 can take 1 to 3 stones, player 2 can begin from either dp[j + 1], dp[j + 2], dp[j + 3]. Player 2 can also take 1 to 3 stones. Thus, resulting in the minimum of dp[j + 2 to 4], dp[j + 3 to 5], and dp[j + 4 to 6]. Thus, 
Dp[j] = max
(
                    stoneArr[j : j + 1] + min(dp[j + 2], dp[j + 3], dp[j + 4]),
                    stoneArr[j : j + 2] + min(dp[j + 3], dp[j + 4], dp[j + 5]),
                    stoneArr[j : j + 3] + min(dp[j + 4], dp[j + 5], dp[j + 6])
              )
 If any of the indexes are out of bounds, then it means the value is 0. The resulting score is stored dp[0]. FileName: StoneGame1.java 
public class StoneGame1 
{
public int stoneGameSol(int storeArr[]) 
{
// computing the size of the array
int n = storeArr.length;
int dp[] = new int[n];
// contains the sum of the values of 
// the stones present in the array stoneArr
int sums[] = new int[n+1];
for (int j = 0; j < n; j++) 
{
sums[j + 1] = sums[j] + storeArr[j];
}
dp[n - 1] = storeArr[n - 1];
if (n > 1) 
{
dp[n - 2] = storeArr[n - 2] + Math.max(storeArr[n - 1], 0);
for (int j = n - 3; j >= 0; j--) 
{
dp[j] = Integer.MIN_VALUE;
for (int k = 1; k <= 3; k++) 
{
// score is the sum of values of the
// stone taken by the player
// for k = 1 only one stone is taken
// for k = 2, two stones are taken
// for k = 3, three stones are taken
int score = sums[j + k] - sums[j];
int a1 = j + k + 1 < n ? dp[j + k + 1] : 0;
int a2 = j + k + 2 < n ? dp[j + k + 2] : 0;
int a3 = j + k + 3 < n ? dp[j + k + 3] : 0;
// the players are playing optimally. Hence, we have to pick
// the minimum between a1, a2, a3
dp[j] = Math.max(dp[j], score + Math.min(a1, Math.min(a2, a3)));
}
}
}
if ((2 * dp[0]) > sums[n]) 
{
return 1;
}
else if ((2 * dp[0]) < sums[n]) 
{
return 2;
}
else 
{
return 0;
}
}
// main method
public static void main(String[] argvs) 
{
// creating an object of the class StoneGame1
StoneGame1 obj = new StoneGame1();
// input 1
int arr[] = {4, 3, 9, 16};
int size = arr.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr[i] + " ");
}
System.out.println();
int ans = obj.stoneGameSol(arr);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 2
int arr1[] = {8, -1, -1, 7};
size = arr1.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr1[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr1);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 3
int arr2[] = {-7, 2, 6, 3};
size = arr2.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr2[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr2);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 4
int arr3[] = {1, 2, 0, 3, 6, 7, 4};
size = arr3.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr3[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr3);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
}
}
 Output: For the stones of the following values: 
4 3 9 16 
It is a tie between player 1 and player 2

For the stones of the following values: 
8 -1 -1 7 
Player 1 wins the game.

For the stones of the following values: 
-7 2 6 3 
Player 2 wins the game.

For the stones of the following values: 
1 2 0 3 6 7 4 
Player 1 wins the game.
 Complexity Analysis: The time complexity of the program is O(3 * N). In terms of the asymptotic time complexity, it is O(N). As the program uses two auxiliary arrays for storing the answer and the sum of values of stones, the space complexity of the program is O(N + N), which is O(2 *N). In terms of asymptotic time, it is again O(N), where N is the total number of elements present in the stone array. The space complexity of the program can be further reduced. We can use variables instead of arrays, and it is evident in the following program. FileName: StoneGame1.java 
public class StoneGame1 
{
public int stoneGameSol(int storeArr[]) 
{
// computing the size of the array
int size = storeArr.length;
int first = 0; // contains the answer
int second = 0;
int third = 0;
for(int j = size - 1; j >= 0; j--)
{
// one for picking only one stone
int one = Integer.MIN_VALUE;
// two for picking two stones
int two = Integer.MIN_VALUE;
// three for picking three stones
int three = Integer.MIN_VALUE;
one = storeArr[j]- first;
if((j + 1) < size)
{
two = storeArr[j] + storeArr[j + 1] - second;
}
if((j + 2) < size)
{
three = storeArr[j] + storeArr[j + 1] + storeArr[j + 2] - third;
}
int tmp = Math.max(one, Math.max(two, three));
third = second;
second = first;
first = tmp;
}
if(first == 0) 
{
return 0;
}
else if(first > 0) 
{
return 1;
}
else 
{
return 2;
}
}
    // main method
public static void main(String[] argvs) 
{
// creating an object of the class StoneGame1
StoneGame1 obj = new StoneGame1();
// input 1
int arr[] = {4, 3, 9, 16};
int size = arr.length;

System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr[i] + " ");
}
System.out.println();
int ans = obj.stoneGameSol(arr);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 2
int arr1[] = {8, -1, -1, 7};
size = arr1.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr1[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr1);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 3
int arr2[] = {-7, 2, 6, 3};
size = arr2.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr2[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr2);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 4
int arr3[] = {1, 2, 0, 3, 6, 7, 4};
size = arr3.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr3[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr3);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
}
}
 Output: For the stones of the following values: 
4 3 9 16 
It is a tie between player 1 and player 2

For the stones of the following values: 
8 -1 -1 7 
Player 1 wins the game.

For the stones of the following values: 
-7 2 6 3 
Player 2 wins the game.

For the stones of the following values: 
1 2 0 3 6 7 4 
Player 1 wins the game.
 Complexity Analysis: The time complexity of the program is the same as the previous program. Since the program is only using variables and not arrays, the space complexity of the program is constant, i.e., O(1). Next TopicTypeErasure in Java ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/stone-game-in-java Stone Game in Java - Javatpoint ? SCROLL TO TOP Home Java Programs OOPs String Exception Multithreading Collections JavaFX JSP Spring Spring Boot Projects Interview Questions Java Tutorial What is Java History of Java Features of Java C++ vs Java Hello Java Program Program Internal How to set path? JDK, JRE and JVM JVM: Java Virtual Machine Java Variables Java Data Types Unicode System Operators Keywords Control Statements Java Control Statements Java If-else Java Switch Java For Loop Java While Loop Java Do While Loop Java Break Java Continue Java Comments Java Programs Java Object Class Java OOPs Concepts Naming Convention Object and Class Method Constructor static keyword this keyword Java Inheritance Inheritance(IS-A) Aggregation(HAS-A) Java Polymorphism Method Overloading Method Overriding Covariant Return Type super keyword Instance Initializer block final keyword Runtime Polymorphism Dynamic Binding instanceof operator Java Abstraction Abstract class Interface Abstract vs Interface Java Encapsulation Package Access Modifiers Encapsulation Java Array Java Array Java OOPs Misc Object class Object Cloning Math class Wrapper Class Java Recursion Call By Value strictfp keyword javadoc tool Command Line Arg Object vs Class Overloading vs Overriding Java String Java Regex Exception Handling Java Inner classes Java Multithreading Java I/O Java Networking Java AWT & Events Java Swing JavaFX Java Applet Java Reflection Java Date Java Conversion Java Collection Java JDBC Java Misc Java New Features RMI Internationalization Interview Questions Java MCQ next ? ? prev Stone Game in Java In this game, stones are placed in a row (an input array is given). Two players are assigned the task of picking the stones of the maximum values. The player who collects stones of the maximum value wins the game. Player 1 will play first. After that, player two will play, and so on. At a time, a player can choose either 1 or 2 or 3 stones. The stones must be chosen from the left side only. Note that a player has to pick at least one stone. Our task is to decide which player will win the game if both the players play optimally. Example 1: int arr[] = {4, 3, 9, 16} Output: It is a tie between player 1 and player2 Explanation: Since stones are chosen from the left side and at max, only three stones are chosen, player 1 can only choose stones 1, 2 & 3. Thus, the total values of the stones chosen is 4 + 3 + 9 = 16. Now, it is the term of player 2. Player 2 can choose stone 4, which is of the value 16. Thus, both the players got the same value. Hence, it is a tie. Example 2: int arr[] = {8, -1, -1, 7} Output: Player 1 wins the game. Explanation: Player 1 plays optimally. Player 1 picks only the 1st stone from the left and leaves the rest. Thus, player 1 has a total value 8. Now, it is player 2 turn to pick the stones. Since players can only pick stones from the left only; therefore, player 2 has to pick stones of the values -1, -1, and 7. Thus, total value picked by the player 2 is -1 + -1 + 7 = 5, which is less than 8. Hence, player 1 wins. Example 3: int arr[] = {-7, 2, 6, 3} Output: Player 2 wins the game. Explanation: To gain the maximum value, player 1 picks stones 1, 2, and 3. Thus, collecting the maximum value of -7 + 2 + 6 = 1. There is only one stone left which is picked by player 2. The stone is of the value 3. Thus, player 2 wins the game. Example 4: int arr[] = {1, 2, 0, 3, 6, 7, 4} Output: Player 1 wins the game. Explanation: To gain the maximum value, player 1 picks stones 1 and 2 only. Thus, collecting the maximum value of 1 + 2 = 3. Now, it is the turn of player 2, and the player 2 picks stones of the values 0, 3, and 6 (total values 0 + 3 + 6 = 9). Again, it is the turn of player 1, and player 1 picks 7 and 4. Thus, total value collected by the player 1 is 3 + 7 + 4 = 14, which is greater than 9. Hence, player 1 wins the game. Approach: Using Recursion It is a brute force approach, where we consider each possible scenario for the player. The first scenario is when the player picks only one stone. The second scenario is when the player picks the two stones. The third scenario is when the player picks three stones. The maximum of these three scenarios is the value collected by the player. Observe the following program. FileName: StoneGame.java 
public class StoneGame 
{
    private int solve(int j, int[] nums)
    {
        // size of the array
        int size = nums.length;
        
        // handling the base case
        if(j >= size)
        {
            return 0;
        }
        // if we pick only one stone
        int one = Integer.MIN_VALUE;
        // if we pick two stones
        int two = Integer.MIN_VALUE;
        // if we pick three stones
        int three = Integer.MIN_VALUE;
        // picked one stone and performing the 
        // further computation
        one = nums[j] - solve(j + 1, nums);
        if((j + 1) < size)
        {
            // picked two stones at a time and performing 
            // the further computation
            two = nums[j] + nums[j + 1] - solve(j + 2, nums);
        }
        if((j + 2) < size)
        {
            // picked 3 stones at a time and performing the further
            // computation
            three = nums[j] + nums[j + 1] + nums[j + 2] - solve(j + 3, nums);
        }
        // picking the maximum between one, two and three
        return Math.max(one, Math.max(two, three));
    }
    public int stoneGameSol(int[] stoneVal) 
    {
        int ans = solve(0, stoneVal);
        if(ans == 0)
        {
            // 0 means its a tie
            return 0;
        }
        if(ans > 0)
        {
            // 1 means player 1 wins the game
            return 1;
        }
        // 2 means player 2 wins the game
        return 2;
    }
    // main method
public static void main(String[] argvs) 
{
// creating an object of the class StoneGame
StoneGame obj = new StoneGame();
// input 1
int arr[] = {4, 3, 9, 16};
int size = arr.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr[i] + " ");
}
System.out.println();
int ans = obj.stoneGameSol(arr);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 2
int arr1[] = {8, -1, -1, 7};
size = arr1.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr1[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr1);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 3
int arr2[] = {-7, 2, 6, 3};
size = arr2.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr2[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr2);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 4
int arr3[] = {1, 2, 0, 3, 6, 7, 4};
size = arr3.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr3[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr3);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
}
}
 Output: For the stones of the following values: 
4 3 9 16 
It is a tie between player 1 and player 2

For the stones of the following values: 
8 -1 -1 7 
Player 1 wins the game.

For the stones of the following values: 
-7 2 6 3 
Player 2 wins the game.

For the stones of the following values: 
1 2 0 3 6 7 4 
Player 1 wins the game.
 Complexity Analysis: The time complexity of the program is exponential as there are recursive calls for all the scenarios. The above program is not suitable for larger input as it will take a lot of time because of its high time complexity. Approach: Using Iteration (Dynamic Programming) We will assume that the dp[j] is the maximum value player 1 can get. Since player 1 can take 1 to 3 stones, player 2 can begin from either dp[j + 1], dp[j + 2], dp[j + 3]. Player 2 can also take 1 to 3 stones. Thus, resulting in the minimum of dp[j + 2 to 4], dp[j + 3 to 5], and dp[j + 4 to 6]. Thus, 
Dp[j] = max
(
                    stoneArr[j : j + 1] + min(dp[j + 2], dp[j + 3], dp[j + 4]),
                    stoneArr[j : j + 2] + min(dp[j + 3], dp[j + 4], dp[j + 5]),
                    stoneArr[j : j + 3] + min(dp[j + 4], dp[j + 5], dp[j + 6])
              )
 If any of the indexes are out of bounds, then it means the value is 0. The resulting score is stored dp[0]. FileName: StoneGame1.java 
public class StoneGame1 
{
public int stoneGameSol(int storeArr[]) 
{
// computing the size of the array
int n = storeArr.length;
int dp[] = new int[n];
// contains the sum of the values of 
// the stones present in the array stoneArr
int sums[] = new int[n+1];
for (int j = 0; j < n; j++) 
{
sums[j + 1] = sums[j] + storeArr[j];
}
dp[n - 1] = storeArr[n - 1];
if (n > 1) 
{
dp[n - 2] = storeArr[n - 2] + Math.max(storeArr[n - 1], 0);
for (int j = n - 3; j >= 0; j--) 
{
dp[j] = Integer.MIN_VALUE;
for (int k = 1; k <= 3; k++) 
{
// score is the sum of values of the
// stone taken by the player
// for k = 1 only one stone is taken
// for k = 2, two stones are taken
// for k = 3, three stones are taken
int score = sums[j + k] - sums[j];
int a1 = j + k + 1 < n ? dp[j + k + 1] : 0;
int a2 = j + k + 2 < n ? dp[j + k + 2] : 0;
int a3 = j + k + 3 < n ? dp[j + k + 3] : 0;
// the players are playing optimally. Hence, we have to pick
// the minimum between a1, a2, a3
dp[j] = Math.max(dp[j], score + Math.min(a1, Math.min(a2, a3)));
}
}
}
if ((2 * dp[0]) > sums[n]) 
{
return 1;
}
else if ((2 * dp[0]) < sums[n]) 
{
return 2;
}
else 
{
return 0;
}
}
// main method
public static void main(String[] argvs) 
{
// creating an object of the class StoneGame1
StoneGame1 obj = new StoneGame1();
// input 1
int arr[] = {4, 3, 9, 16};
int size = arr.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr[i] + " ");
}
System.out.println();
int ans = obj.stoneGameSol(arr);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 2
int arr1[] = {8, -1, -1, 7};
size = arr1.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr1[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr1);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 3
int arr2[] = {-7, 2, 6, 3};
size = arr2.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr2[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr2);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 4
int arr3[] = {1, 2, 0, 3, 6, 7, 4};
size = arr3.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr3[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr3);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
}
}
 Output: For the stones of the following values: 
4 3 9 16 
It is a tie between player 1 and player 2

For the stones of the following values: 
8 -1 -1 7 
Player 1 wins the game.

For the stones of the following values: 
-7 2 6 3 
Player 2 wins the game.

For the stones of the following values: 
1 2 0 3 6 7 4 
Player 1 wins the game.
 Complexity Analysis: The time complexity of the program is O(3 * N). In terms of the asymptotic time complexity, it is O(N). As the program uses two auxiliary arrays for storing the answer and the sum of values of stones, the space complexity of the program is O(N + N), which is O(2 *N). In terms of asymptotic time, it is again O(N), where N is the total number of elements present in the stone array. The space complexity of the program can be further reduced. We can use variables instead of arrays, and it is evident in the following program. FileName: StoneGame1.java 
public class StoneGame1 
{
public int stoneGameSol(int storeArr[]) 
{
// computing the size of the array
int size = storeArr.length;
int first = 0; // contains the answer
int second = 0;
int third = 0;
for(int j = size - 1; j >= 0; j--)
{
// one for picking only one stone
int one = Integer.MIN_VALUE;
// two for picking two stones
int two = Integer.MIN_VALUE;
// three for picking three stones
int three = Integer.MIN_VALUE;
one = storeArr[j]- first;
if((j + 1) < size)
{
two = storeArr[j] + storeArr[j + 1] - second;
}
if((j + 2) < size)
{
three = storeArr[j] + storeArr[j + 1] + storeArr[j + 2] - third;
}
int tmp = Math.max(one, Math.max(two, three));
third = second;
second = first;
first = tmp;
}
if(first == 0) 
{
return 0;
}
else if(first > 0) 
{
return 1;
}
else 
{
return 2;
}
}
    // main method
public static void main(String[] argvs) 
{
// creating an object of the class StoneGame1
StoneGame1 obj = new StoneGame1();
// input 1
int arr[] = {4, 3, 9, 16};
int size = arr.length;

System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr[i] + " ");
}
System.out.println();
int ans = obj.stoneGameSol(arr);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 2
int arr1[] = {8, -1, -1, 7};
size = arr1.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr1[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr1);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 3
int arr2[] = {-7, 2, 6, 3};
size = arr2.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr2[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr2);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 4
int arr3[] = {1, 2, 0, 3, 6, 7, 4};
size = arr3.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr3[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr3);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
}
}
 Output: For the stones of the following values: 
4 3 9 16 
It is a tie between player 1 and player 2

For the stones of the following values: 
8 -1 -1 7 
Player 1 wins the game.

For the stones of the following values: 
-7 2 6 3 
Player 2 wins the game.

For the stones of the following values: 
1 2 0 3 6 7 4 
Player 1 wins the game.
 Complexity Analysis: The time complexity of the program is the same as the previous program. Since the program is only using variables and not arrays, the space complexity of the program is constant, i.e., O(1). Next TopicTypeErasure in Java ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/stone-game-in-java Stone Game in Java - Javatpoint ? SCROLL TO TOP Home Java Programs OOPs String Exception Multithreading Collections JavaFX JSP Spring Spring Boot Projects Interview Questions Java Tutorial What is Java History of Java Features of Java C++ vs Java Hello Java Program Program Internal How to set path? JDK, JRE and JVM JVM: Java Virtual Machine Java Variables Java Data Types Unicode System Operators Keywords Control Statements Java Control Statements Java If-else Java Switch Java For Loop Java While Loop Java Do While Loop Java Break Java Continue Java Comments Java Programs Java Object Class Java OOPs Concepts Naming Convention Object and Class Method Constructor static keyword this keyword Java Inheritance Inheritance(IS-A) Aggregation(HAS-A) Java Polymorphism Method Overloading Method Overriding Covariant Return Type super keyword Instance Initializer block final keyword Runtime Polymorphism Dynamic Binding instanceof operator Java Abstraction Abstract class Interface Abstract vs Interface Java Encapsulation Package Access Modifiers Encapsulation Java Array Java Array Java OOPs Misc Object class Object Cloning Math class Wrapper Class Java Recursion Call By Value strictfp keyword javadoc tool Command Line Arg Object vs Class Overloading vs Overriding Java String Java Regex Exception Handling Java Inner classes Java Multithreading Java I/O Java Networking Java AWT & Events Java Swing JavaFX Java Applet Java Reflection Java Date Java Conversion Java Collection Java JDBC Java Misc Java New Features RMI Internationalization Interview Questions Java MCQ next ? ? prev Stone Game in Java In this game, stones are placed in a row (an input array is given). Two players are assigned the task of picking the stones of the maximum values. The player who collects stones of the maximum value wins the game. Player 1 will play first. After that, player two will play, and so on. At a time, a player can choose either 1 or 2 or 3 stones. The stones must be chosen from the left side only. Note that a player has to pick at least one stone. Our task is to decide which player will win the game if both the players play optimally. Example 1: int arr[] = {4, 3, 9, 16} Output: It is a tie between player 1 and player2 Explanation: Since stones are chosen from the left side and at max, only three stones are chosen, player 1 can only choose stones 1, 2 & 3. Thus, the total values of the stones chosen is 4 + 3 + 9 = 16. Now, it is the term of player 2. Player 2 can choose stone 4, which is of the value 16. Thus, both the players got the same value. Hence, it is a tie. Example 2: int arr[] = {8, -1, -1, 7} Output: Player 1 wins the game. Explanation: Player 1 plays optimally. Player 1 picks only the 1st stone from the left and leaves the rest. Thus, player 1 has a total value 8. Now, it is player 2 turn to pick the stones. Since players can only pick stones from the left only; therefore, player 2 has to pick stones of the values -1, -1, and 7. Thus, total value picked by the player 2 is -1 + -1 + 7 = 5, which is less than 8. Hence, player 1 wins. Example 3: int arr[] = {-7, 2, 6, 3} Output: Player 2 wins the game. Explanation: To gain the maximum value, player 1 picks stones 1, 2, and 3. Thus, collecting the maximum value of -7 + 2 + 6 = 1. There is only one stone left which is picked by player 2. The stone is of the value 3. Thus, player 2 wins the game. Example 4: int arr[] = {1, 2, 0, 3, 6, 7, 4} Output: Player 1 wins the game. Explanation: To gain the maximum value, player 1 picks stones 1 and 2 only. Thus, collecting the maximum value of 1 + 2 = 3. Now, it is the turn of player 2, and the player 2 picks stones of the values 0, 3, and 6 (total values 0 + 3 + 6 = 9). Again, it is the turn of player 1, and player 1 picks 7 and 4. Thus, total value collected by the player 1 is 3 + 7 + 4 = 14, which is greater than 9. Hence, player 1 wins the game. Approach: Using Recursion It is a brute force approach, where we consider each possible scenario for the player. The first scenario is when the player picks only one stone. The second scenario is when the player picks the two stones. The third scenario is when the player picks three stones. The maximum of these three scenarios is the value collected by the player. Observe the following program. FileName: StoneGame.java 
public class StoneGame 
{
    private int solve(int j, int[] nums)
    {
        // size of the array
        int size = nums.length;
        
        // handling the base case
        if(j >= size)
        {
            return 0;
        }
        // if we pick only one stone
        int one = Integer.MIN_VALUE;
        // if we pick two stones
        int two = Integer.MIN_VALUE;
        // if we pick three stones
        int three = Integer.MIN_VALUE;
        // picked one stone and performing the 
        // further computation
        one = nums[j] - solve(j + 1, nums);
        if((j + 1) < size)
        {
            // picked two stones at a time and performing 
            // the further computation
            two = nums[j] + nums[j + 1] - solve(j + 2, nums);
        }
        if((j + 2) < size)
        {
            // picked 3 stones at a time and performing the further
            // computation
            three = nums[j] + nums[j + 1] + nums[j + 2] - solve(j + 3, nums);
        }
        // picking the maximum between one, two and three
        return Math.max(one, Math.max(two, three));
    }
    public int stoneGameSol(int[] stoneVal) 
    {
        int ans = solve(0, stoneVal);
        if(ans == 0)
        {
            // 0 means its a tie
            return 0;
        }
        if(ans > 0)
        {
            // 1 means player 1 wins the game
            return 1;
        }
        // 2 means player 2 wins the game
        return 2;
    }
    // main method
public static void main(String[] argvs) 
{
// creating an object of the class StoneGame
StoneGame obj = new StoneGame();
// input 1
int arr[] = {4, 3, 9, 16};
int size = arr.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr[i] + " ");
}
System.out.println();
int ans = obj.stoneGameSol(arr);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 2
int arr1[] = {8, -1, -1, 7};
size = arr1.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr1[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr1);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 3
int arr2[] = {-7, 2, 6, 3};
size = arr2.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr2[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr2);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 4
int arr3[] = {1, 2, 0, 3, 6, 7, 4};
size = arr3.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr3[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr3);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
}
}
 Output: For the stones of the following values: 
4 3 9 16 
It is a tie between player 1 and player 2

For the stones of the following values: 
8 -1 -1 7 
Player 1 wins the game.

For the stones of the following values: 
-7 2 6 3 
Player 2 wins the game.

For the stones of the following values: 
1 2 0 3 6 7 4 
Player 1 wins the game.
 Complexity Analysis: The time complexity of the program is exponential as there are recursive calls for all the scenarios. The above program is not suitable for larger input as it will take a lot of time because of its high time complexity. Approach: Using Iteration (Dynamic Programming) We will assume that the dp[j] is the maximum value player 1 can get. Since player 1 can take 1 to 3 stones, player 2 can begin from either dp[j + 1], dp[j + 2], dp[j + 3]. Player 2 can also take 1 to 3 stones. Thus, resulting in the minimum of dp[j + 2 to 4], dp[j + 3 to 5], and dp[j + 4 to 6]. Thus, 
Dp[j] = max
(
                    stoneArr[j : j + 1] + min(dp[j + 2], dp[j + 3], dp[j + 4]),
                    stoneArr[j : j + 2] + min(dp[j + 3], dp[j + 4], dp[j + 5]),
                    stoneArr[j : j + 3] + min(dp[j + 4], dp[j + 5], dp[j + 6])
              )
 If any of the indexes are out of bounds, then it means the value is 0. The resulting score is stored dp[0]. FileName: StoneGame1.java 
public class StoneGame1 
{
public int stoneGameSol(int storeArr[]) 
{
// computing the size of the array
int n = storeArr.length;
int dp[] = new int[n];
// contains the sum of the values of 
// the stones present in the array stoneArr
int sums[] = new int[n+1];
for (int j = 0; j < n; j++) 
{
sums[j + 1] = sums[j] + storeArr[j];
}
dp[n - 1] = storeArr[n - 1];
if (n > 1) 
{
dp[n - 2] = storeArr[n - 2] + Math.max(storeArr[n - 1], 0);
for (int j = n - 3; j >= 0; j--) 
{
dp[j] = Integer.MIN_VALUE;
for (int k = 1; k <= 3; k++) 
{
// score is the sum of values of the
// stone taken by the player
// for k = 1 only one stone is taken
// for k = 2, two stones are taken
// for k = 3, three stones are taken
int score = sums[j + k] - sums[j];
int a1 = j + k + 1 < n ? dp[j + k + 1] : 0;
int a2 = j + k + 2 < n ? dp[j + k + 2] : 0;
int a3 = j + k + 3 < n ? dp[j + k + 3] : 0;
// the players are playing optimally. Hence, we have to pick
// the minimum between a1, a2, a3
dp[j] = Math.max(dp[j], score + Math.min(a1, Math.min(a2, a3)));
}
}
}
if ((2 * dp[0]) > sums[n]) 
{
return 1;
}
else if ((2 * dp[0]) < sums[n]) 
{
return 2;
}
else 
{
return 0;
}
}
// main method
public static void main(String[] argvs) 
{
// creating an object of the class StoneGame1
StoneGame1 obj = new StoneGame1();
// input 1
int arr[] = {4, 3, 9, 16};
int size = arr.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr[i] + " ");
}
System.out.println();
int ans = obj.stoneGameSol(arr);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 2
int arr1[] = {8, -1, -1, 7};
size = arr1.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr1[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr1);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 3
int arr2[] = {-7, 2, 6, 3};
size = arr2.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr2[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr2);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 4
int arr3[] = {1, 2, 0, 3, 6, 7, 4};
size = arr3.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr3[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr3);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
}
}
 Output: For the stones of the following values: 
4 3 9 16 
It is a tie between player 1 and player 2

For the stones of the following values: 
8 -1 -1 7 
Player 1 wins the game.

For the stones of the following values: 
-7 2 6 3 
Player 2 wins the game.

For the stones of the following values: 
1 2 0 3 6 7 4 
Player 1 wins the game.
 Complexity Analysis: The time complexity of the program is O(3 * N). In terms of the asymptotic time complexity, it is O(N). As the program uses two auxiliary arrays for storing the answer and the sum of values of stones, the space complexity of the program is O(N + N), which is O(2 *N). In terms of asymptotic time, it is again O(N), where N is the total number of elements present in the stone array. The space complexity of the program can be further reduced. We can use variables instead of arrays, and it is evident in the following program. FileName: StoneGame1.java 
public class StoneGame1 
{
public int stoneGameSol(int storeArr[]) 
{
// computing the size of the array
int size = storeArr.length;
int first = 0; // contains the answer
int second = 0;
int third = 0;
for(int j = size - 1; j >= 0; j--)
{
// one for picking only one stone
int one = Integer.MIN_VALUE;
// two for picking two stones
int two = Integer.MIN_VALUE;
// three for picking three stones
int three = Integer.MIN_VALUE;
one = storeArr[j]- first;
if((j + 1) < size)
{
two = storeArr[j] + storeArr[j + 1] - second;
}
if((j + 2) < size)
{
three = storeArr[j] + storeArr[j + 1] + storeArr[j + 2] - third;
}
int tmp = Math.max(one, Math.max(two, three));
third = second;
second = first;
first = tmp;
}
if(first == 0) 
{
return 0;
}
else if(first > 0) 
{
return 1;
}
else 
{
return 2;
}
}
    // main method
public static void main(String[] argvs) 
{
// creating an object of the class StoneGame1
StoneGame1 obj = new StoneGame1();
// input 1
int arr[] = {4, 3, 9, 16};
int size = arr.length;

System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr[i] + " ");
}
System.out.println();
int ans = obj.stoneGameSol(arr);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 2
int arr1[] = {8, -1, -1, 7};
size = arr1.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr1[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr1);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 3
int arr2[] = {-7, 2, 6, 3};
size = arr2.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr2[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr2);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 4
int arr3[] = {1, 2, 0, 3, 6, 7, 4};
size = arr3.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr3[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr3);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
}
}
 Output: For the stones of the following values: 
4 3 9 16 
It is a tie between player 1 and player 2

For the stones of the following values: 
8 -1 -1 7 
Player 1 wins the game.

For the stones of the following values: 
-7 2 6 3 
Player 2 wins the game.

For the stones of the following values: 
1 2 0 3 6 7 4 
Player 1 wins the game.
 Complexity Analysis: The time complexity of the program is the same as the previous program. Since the program is only using variables and not arrays, the space complexity of the program is constant, i.e., O(1). Next TopicTypeErasure in Java ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/stone-game-in-java Stone Game in Java - Javatpoint ? SCROLL TO TOP Home Java Programs OOPs String Exception Multithreading Collections JavaFX JSP Spring Spring Boot Projects Interview Questions Java Tutorial What is Java History of Java Features of Java C++ vs Java Hello Java Program Program Internal How to set path? JDK, JRE and JVM JVM: Java Virtual Machine Java Variables Java Data Types Unicode System Operators Keywords Control Statements Java Control Statements Java If-else Java Switch Java For Loop Java While Loop Java Do While Loop Java Break Java Continue Java Comments Java Programs Java Object Class Java OOPs Concepts Naming Convention Object and Class Method Constructor static keyword this keyword Java Inheritance Inheritance(IS-A) Aggregation(HAS-A) Java Polymorphism Method Overloading Method Overriding Covariant Return Type super keyword Instance Initializer block final keyword Runtime Polymorphism Dynamic Binding instanceof operator Java Abstraction Abstract class Interface Abstract vs Interface Java Encapsulation Package Access Modifiers Encapsulation Java Array Java Array Java OOPs Misc Object class Object Cloning Math class Wrapper Class Java Recursion Call By Value strictfp keyword javadoc tool Command Line Arg Object vs Class Overloading vs Overriding Java String Java Regex Exception Handling Java Inner classes Java Multithreading Java I/O Java Networking Java AWT & Events Java Swing JavaFX Java Applet Java Reflection Java Date Java Conversion Java Collection Java JDBC Java Misc Java New Features RMI Internationalization Interview Questions Java MCQ next ? ? prev Stone Game in Java In this game, stones are placed in a row (an input array is given). Two players are assigned the task of picking the stones of the maximum values. The player who collects stones of the maximum value wins the game. Player 1 will play first. After that, player two will play, and so on. At a time, a player can choose either 1 or 2 or 3 stones. The stones must be chosen from the left side only. Note that a player has to pick at least one stone. Our task is to decide which player will win the game if both the players play optimally. Example 1: int arr[] = {4, 3, 9, 16} Output: It is a tie between player 1 and player2 Explanation: Since stones are chosen from the left side and at max, only three stones are chosen, player 1 can only choose stones 1, 2 & 3. Thus, the total values of the stones chosen is 4 + 3 + 9 = 16. Now, it is the term of player 2. Player 2 can choose stone 4, which is of the value 16. Thus, both the players got the same value. Hence, it is a tie. Example 2: int arr[] = {8, -1, -1, 7} Output: Player 1 wins the game. Explanation: Player 1 plays optimally. Player 1 picks only the 1st stone from the left and leaves the rest. Thus, player 1 has a total value 8. Now, it is player 2 turn to pick the stones. Since players can only pick stones from the left only; therefore, player 2 has to pick stones of the values -1, -1, and 7. Thus, total value picked by the player 2 is -1 + -1 + 7 = 5, which is less than 8. Hence, player 1 wins. Example 3: int arr[] = {-7, 2, 6, 3} Output: Player 2 wins the game. Explanation: To gain the maximum value, player 1 picks stones 1, 2, and 3. Thus, collecting the maximum value of -7 + 2 + 6 = 1. There is only one stone left which is picked by player 2. The stone is of the value 3. Thus, player 2 wins the game. Example 4: int arr[] = {1, 2, 0, 3, 6, 7, 4} Output: Player 1 wins the game. Explanation: To gain the maximum value, player 1 picks stones 1 and 2 only. Thus, collecting the maximum value of 1 + 2 = 3. Now, it is the turn of player 2, and the player 2 picks stones of the values 0, 3, and 6 (total values 0 + 3 + 6 = 9). Again, it is the turn of player 1, and player 1 picks 7 and 4. Thus, total value collected by the player 1 is 3 + 7 + 4 = 14, which is greater than 9. Hence, player 1 wins the game. Approach: Using Recursion It is a brute force approach, where we consider each possible scenario for the player. The first scenario is when the player picks only one stone. The second scenario is when the player picks the two stones. The third scenario is when the player picks three stones. The maximum of these three scenarios is the value collected by the player. Observe the following program. FileName: StoneGame.java 
public class StoneGame 
{
    private int solve(int j, int[] nums)
    {
        // size of the array
        int size = nums.length;
        
        // handling the base case
        if(j >= size)
        {
            return 0;
        }
        // if we pick only one stone
        int one = Integer.MIN_VALUE;
        // if we pick two stones
        int two = Integer.MIN_VALUE;
        // if we pick three stones
        int three = Integer.MIN_VALUE;
        // picked one stone and performing the 
        // further computation
        one = nums[j] - solve(j + 1, nums);
        if((j + 1) < size)
        {
            // picked two stones at a time and performing 
            // the further computation
            two = nums[j] + nums[j + 1] - solve(j + 2, nums);
        }
        if((j + 2) < size)
        {
            // picked 3 stones at a time and performing the further
            // computation
            three = nums[j] + nums[j + 1] + nums[j + 2] - solve(j + 3, nums);
        }
        // picking the maximum between one, two and three
        return Math.max(one, Math.max(two, three));
    }
    public int stoneGameSol(int[] stoneVal) 
    {
        int ans = solve(0, stoneVal);
        if(ans == 0)
        {
            // 0 means its a tie
            return 0;
        }
        if(ans > 0)
        {
            // 1 means player 1 wins the game
            return 1;
        }
        // 2 means player 2 wins the game
        return 2;
    }
    // main method
public static void main(String[] argvs) 
{
// creating an object of the class StoneGame
StoneGame obj = new StoneGame();
// input 1
int arr[] = {4, 3, 9, 16};
int size = arr.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr[i] + " ");
}
System.out.println();
int ans = obj.stoneGameSol(arr);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 2
int arr1[] = {8, -1, -1, 7};
size = arr1.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr1[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr1);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 3
int arr2[] = {-7, 2, 6, 3};
size = arr2.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr2[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr2);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 4
int arr3[] = {1, 2, 0, 3, 6, 7, 4};
size = arr3.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr3[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr3);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
}
}
 Output: For the stones of the following values: 
4 3 9 16 
It is a tie between player 1 and player 2

For the stones of the following values: 
8 -1 -1 7 
Player 1 wins the game.

For the stones of the following values: 
-7 2 6 3 
Player 2 wins the game.

For the stones of the following values: 
1 2 0 3 6 7 4 
Player 1 wins the game.
 Complexity Analysis: The time complexity of the program is exponential as there are recursive calls for all the scenarios. The above program is not suitable for larger input as it will take a lot of time because of its high time complexity. Approach: Using Iteration (Dynamic Programming) We will assume that the dp[j] is the maximum value player 1 can get. Since player 1 can take 1 to 3 stones, player 2 can begin from either dp[j + 1], dp[j + 2], dp[j + 3]. Player 2 can also take 1 to 3 stones. Thus, resulting in the minimum of dp[j + 2 to 4], dp[j + 3 to 5], and dp[j + 4 to 6]. Thus, 
Dp[j] = max
(
                    stoneArr[j : j + 1] + min(dp[j + 2], dp[j + 3], dp[j + 4]),
                    stoneArr[j : j + 2] + min(dp[j + 3], dp[j + 4], dp[j + 5]),
                    stoneArr[j : j + 3] + min(dp[j + 4], dp[j + 5], dp[j + 6])
              )
 If any of the indexes are out of bounds, then it means the value is 0. The resulting score is stored dp[0]. FileName: StoneGame1.java 
public class StoneGame1 
{
public int stoneGameSol(int storeArr[]) 
{
// computing the size of the array
int n = storeArr.length;
int dp[] = new int[n];
// contains the sum of the values of 
// the stones present in the array stoneArr
int sums[] = new int[n+1];
for (int j = 0; j < n; j++) 
{
sums[j + 1] = sums[j] + storeArr[j];
}
dp[n - 1] = storeArr[n - 1];
if (n > 1) 
{
dp[n - 2] = storeArr[n - 2] + Math.max(storeArr[n - 1], 0);
for (int j = n - 3; j >= 0; j--) 
{
dp[j] = Integer.MIN_VALUE;
for (int k = 1; k <= 3; k++) 
{
// score is the sum of values of the
// stone taken by the player
// for k = 1 only one stone is taken
// for k = 2, two stones are taken
// for k = 3, three stones are taken
int score = sums[j + k] - sums[j];
int a1 = j + k + 1 < n ? dp[j + k + 1] : 0;
int a2 = j + k + 2 < n ? dp[j + k + 2] : 0;
int a3 = j + k + 3 < n ? dp[j + k + 3] : 0;
// the players are playing optimally. Hence, we have to pick
// the minimum between a1, a2, a3
dp[j] = Math.max(dp[j], score + Math.min(a1, Math.min(a2, a3)));
}
}
}
if ((2 * dp[0]) > sums[n]) 
{
return 1;
}
else if ((2 * dp[0]) < sums[n]) 
{
return 2;
}
else 
{
return 0;
}
}
// main method
public static void main(String[] argvs) 
{
// creating an object of the class StoneGame1
StoneGame1 obj = new StoneGame1();
// input 1
int arr[] = {4, 3, 9, 16};
int size = arr.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr[i] + " ");
}
System.out.println();
int ans = obj.stoneGameSol(arr);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 2
int arr1[] = {8, -1, -1, 7};
size = arr1.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr1[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr1);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 3
int arr2[] = {-7, 2, 6, 3};
size = arr2.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr2[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr2);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 4
int arr3[] = {1, 2, 0, 3, 6, 7, 4};
size = arr3.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr3[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr3);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
}
}
 Output: For the stones of the following values: 
4 3 9 16 
It is a tie between player 1 and player 2

For the stones of the following values: 
8 -1 -1 7 
Player 1 wins the game.

For the stones of the following values: 
-7 2 6 3 
Player 2 wins the game.

For the stones of the following values: 
1 2 0 3 6 7 4 
Player 1 wins the game.
 Complexity Analysis: The time complexity of the program is O(3 * N). In terms of the asymptotic time complexity, it is O(N). As the program uses two auxiliary arrays for storing the answer and the sum of values of stones, the space complexity of the program is O(N + N), which is O(2 *N). In terms of asymptotic time, it is again O(N), where N is the total number of elements present in the stone array. The space complexity of the program can be further reduced. We can use variables instead of arrays, and it is evident in the following program. FileName: StoneGame1.java 
public class StoneGame1 
{
public int stoneGameSol(int storeArr[]) 
{
// computing the size of the array
int size = storeArr.length;
int first = 0; // contains the answer
int second = 0;
int third = 0;
for(int j = size - 1; j >= 0; j--)
{
// one for picking only one stone
int one = Integer.MIN_VALUE;
// two for picking two stones
int two = Integer.MIN_VALUE;
// three for picking three stones
int three = Integer.MIN_VALUE;
one = storeArr[j]- first;
if((j + 1) < size)
{
two = storeArr[j] + storeArr[j + 1] - second;
}
if((j + 2) < size)
{
three = storeArr[j] + storeArr[j + 1] + storeArr[j + 2] - third;
}
int tmp = Math.max(one, Math.max(two, three));
third = second;
second = first;
first = tmp;
}
if(first == 0) 
{
return 0;
}
else if(first > 0) 
{
return 1;
}
else 
{
return 2;
}
}
    // main method
public static void main(String[] argvs) 
{
// creating an object of the class StoneGame1
StoneGame1 obj = new StoneGame1();
// input 1
int arr[] = {4, 3, 9, 16};
int size = arr.length;

System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr[i] + " ");
}
System.out.println();
int ans = obj.stoneGameSol(arr);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 2
int arr1[] = {8, -1, -1, 7};
size = arr1.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr1[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr1);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 3
int arr2[] = {-7, 2, 6, 3};
size = arr2.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr2[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr2);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 4
int arr3[] = {1, 2, 0, 3, 6, 7, 4};
size = arr3.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr3[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr3);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
}
}
 Output: For the stones of the following values: 
4 3 9 16 
It is a tie between player 1 and player 2

For the stones of the following values: 
8 -1 -1 7 
Player 1 wins the game.

For the stones of the following values: 
-7 2 6 3 
Player 2 wins the game.

For the stones of the following values: 
1 2 0 3 6 7 4 
Player 1 wins the game.
 Complexity Analysis: The time complexity of the program is the same as the previous program. Since the program is only using variables and not arrays, the space complexity of the program is constant, i.e., O(1). Next TopicTypeErasure in Java ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/stone-game-in-java Stone Game in Java - Javatpoint ? SCROLL TO TOP Home Java Programs OOPs String Exception Multithreading Collections JavaFX JSP Spring Spring Boot Projects Interview Questions Java Tutorial What is Java History of Java Features of Java C++ vs Java Hello Java Program Program Internal How to set path? JDK, JRE and JVM JVM: Java Virtual Machine Java Variables Java Data Types Unicode System Operators Keywords Control Statements Java Control Statements Java If-else Java Switch Java For Loop Java While Loop Java Do While Loop Java Break Java Continue Java Comments Java Programs Java Object Class Java OOPs Concepts Naming Convention Object and Class Method Constructor static keyword this keyword Java Inheritance Inheritance(IS-A) Aggregation(HAS-A) Java Polymorphism Method Overloading Method Overriding Covariant Return Type super keyword Instance Initializer block final keyword Runtime Polymorphism Dynamic Binding instanceof operator Java Abstraction Abstract class Interface Abstract vs Interface Java Encapsulation Package Access Modifiers Encapsulation Java Array Java Array Java OOPs Misc Object class Object Cloning Math class Wrapper Class Java Recursion Call By Value strictfp keyword javadoc tool Command Line Arg Object vs Class Overloading vs Overriding Java String Java Regex Exception Handling Java Inner classes Java Multithreading Java I/O Java Networking Java AWT & Events Java Swing JavaFX Java Applet Java Reflection Java Date Java Conversion Java Collection Java JDBC Java Misc Java New Features RMI Internationalization Interview Questions Java MCQ next ? ? prev Stone Game in Java In this game, stones are placed in a row (an input array is given). Two players are assigned the task of picking the stones of the maximum values. The player who collects stones of the maximum value wins the game. Player 1 will play first. After that, player two will play, and so on. At a time, a player can choose either 1 or 2 or 3 stones. The stones must be chosen from the left side only. Note that a player has to pick at least one stone. Our task is to decide which player will win the game if both the players play optimally. Example 1: int arr[] = {4, 3, 9, 16} Output: It is a tie between player 1 and player2 Explanation: Since stones are chosen from the left side and at max, only three stones are chosen, player 1 can only choose stones 1, 2 & 3. Thus, the total values of the stones chosen is 4 + 3 + 9 = 16. Now, it is the term of player 2. Player 2 can choose stone 4, which is of the value 16. Thus, both the players got the same value. Hence, it is a tie. Example 2: int arr[] = {8, -1, -1, 7} Output: Player 1 wins the game. Explanation: Player 1 plays optimally. Player 1 picks only the 1st stone from the left and leaves the rest. Thus, player 1 has a total value 8. Now, it is player 2 turn to pick the stones. Since players can only pick stones from the left only; therefore, player 2 has to pick stones of the values -1, -1, and 7. Thus, total value picked by the player 2 is -1 + -1 + 7 = 5, which is less than 8. Hence, player 1 wins. Example 3: int arr[] = {-7, 2, 6, 3} Output: Player 2 wins the game. Explanation: To gain the maximum value, player 1 picks stones 1, 2, and 3. Thus, collecting the maximum value of -7 + 2 + 6 = 1. There is only one stone left which is picked by player 2. The stone is of the value 3. Thus, player 2 wins the game. Example 4: int arr[] = {1, 2, 0, 3, 6, 7, 4} Output: Player 1 wins the game. Explanation: To gain the maximum value, player 1 picks stones 1 and 2 only. Thus, collecting the maximum value of 1 + 2 = 3. Now, it is the turn of player 2, and the player 2 picks stones of the values 0, 3, and 6 (total values 0 + 3 + 6 = 9). Again, it is the turn of player 1, and player 1 picks 7 and 4. Thus, total value collected by the player 1 is 3 + 7 + 4 = 14, which is greater than 9. Hence, player 1 wins the game. Approach: Using Recursion It is a brute force approach, where we consider each possible scenario for the player. The first scenario is when the player picks only one stone. The second scenario is when the player picks the two stones. The third scenario is when the player picks three stones. The maximum of these three scenarios is the value collected by the player. Observe the following program. FileName: StoneGame.java 
public class StoneGame 
{
    private int solve(int j, int[] nums)
    {
        // size of the array
        int size = nums.length;
        
        // handling the base case
        if(j >= size)
        {
            return 0;
        }
        // if we pick only one stone
        int one = Integer.MIN_VALUE;
        // if we pick two stones
        int two = Integer.MIN_VALUE;
        // if we pick three stones
        int three = Integer.MIN_VALUE;
        // picked one stone and performing the 
        // further computation
        one = nums[j] - solve(j + 1, nums);
        if((j + 1) < size)
        {
            // picked two stones at a time and performing 
            // the further computation
            two = nums[j] + nums[j + 1] - solve(j + 2, nums);
        }
        if((j + 2) < size)
        {
            // picked 3 stones at a time and performing the further
            // computation
            three = nums[j] + nums[j + 1] + nums[j + 2] - solve(j + 3, nums);
        }
        // picking the maximum between one, two and three
        return Math.max(one, Math.max(two, three));
    }
    public int stoneGameSol(int[] stoneVal) 
    {
        int ans = solve(0, stoneVal);
        if(ans == 0)
        {
            // 0 means its a tie
            return 0;
        }
        if(ans > 0)
        {
            // 1 means player 1 wins the game
            return 1;
        }
        // 2 means player 2 wins the game
        return 2;
    }
    // main method
public static void main(String[] argvs) 
{
// creating an object of the class StoneGame
StoneGame obj = new StoneGame();
// input 1
int arr[] = {4, 3, 9, 16};
int size = arr.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr[i] + " ");
}
System.out.println();
int ans = obj.stoneGameSol(arr);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 2
int arr1[] = {8, -1, -1, 7};
size = arr1.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr1[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr1);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 3
int arr2[] = {-7, 2, 6, 3};
size = arr2.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr2[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr2);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 4
int arr3[] = {1, 2, 0, 3, 6, 7, 4};
size = arr3.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr3[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr3);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
}
}
 Output: For the stones of the following values: 
4 3 9 16 
It is a tie between player 1 and player 2

For the stones of the following values: 
8 -1 -1 7 
Player 1 wins the game.

For the stones of the following values: 
-7 2 6 3 
Player 2 wins the game.

For the stones of the following values: 
1 2 0 3 6 7 4 
Player 1 wins the game.
 Complexity Analysis: The time complexity of the program is exponential as there are recursive calls for all the scenarios. The above program is not suitable for larger input as it will take a lot of time because of its high time complexity. Approach: Using Iteration (Dynamic Programming) We will assume that the dp[j] is the maximum value player 1 can get. Since player 1 can take 1 to 3 stones, player 2 can begin from either dp[j + 1], dp[j + 2], dp[j + 3]. Player 2 can also take 1 to 3 stones. Thus, resulting in the minimum of dp[j + 2 to 4], dp[j + 3 to 5], and dp[j + 4 to 6]. Thus, 
Dp[j] = max
(
                    stoneArr[j : j + 1] + min(dp[j + 2], dp[j + 3], dp[j + 4]),
                    stoneArr[j : j + 2] + min(dp[j + 3], dp[j + 4], dp[j + 5]),
                    stoneArr[j : j + 3] + min(dp[j + 4], dp[j + 5], dp[j + 6])
              )
 If any of the indexes are out of bounds, then it means the value is 0. The resulting score is stored dp[0]. FileName: StoneGame1.java 
public class StoneGame1 
{
public int stoneGameSol(int storeArr[]) 
{
// computing the size of the array
int n = storeArr.length;
int dp[] = new int[n];
// contains the sum of the values of 
// the stones present in the array stoneArr
int sums[] = new int[n+1];
for (int j = 0; j < n; j++) 
{
sums[j + 1] = sums[j] + storeArr[j];
}
dp[n - 1] = storeArr[n - 1];
if (n > 1) 
{
dp[n - 2] = storeArr[n - 2] + Math.max(storeArr[n - 1], 0);
for (int j = n - 3; j >= 0; j--) 
{
dp[j] = Integer.MIN_VALUE;
for (int k = 1; k <= 3; k++) 
{
// score is the sum of values of the
// stone taken by the player
// for k = 1 only one stone is taken
// for k = 2, two stones are taken
// for k = 3, three stones are taken
int score = sums[j + k] - sums[j];
int a1 = j + k + 1 < n ? dp[j + k + 1] : 0;
int a2 = j + k + 2 < n ? dp[j + k + 2] : 0;
int a3 = j + k + 3 < n ? dp[j + k + 3] : 0;
// the players are playing optimally. Hence, we have to pick
// the minimum between a1, a2, a3
dp[j] = Math.max(dp[j], score + Math.min(a1, Math.min(a2, a3)));
}
}
}
if ((2 * dp[0]) > sums[n]) 
{
return 1;
}
else if ((2 * dp[0]) < sums[n]) 
{
return 2;
}
else 
{
return 0;
}
}
// main method
public static void main(String[] argvs) 
{
// creating an object of the class StoneGame1
StoneGame1 obj = new StoneGame1();
// input 1
int arr[] = {4, 3, 9, 16};
int size = arr.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr[i] + " ");
}
System.out.println();
int ans = obj.stoneGameSol(arr);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 2
int arr1[] = {8, -1, -1, 7};
size = arr1.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr1[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr1);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 3
int arr2[] = {-7, 2, 6, 3};
size = arr2.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr2[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr2);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 4
int arr3[] = {1, 2, 0, 3, 6, 7, 4};
size = arr3.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr3[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr3);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
}
}
 Output: For the stones of the following values: 
4 3 9 16 
It is a tie between player 1 and player 2

For the stones of the following values: 
8 -1 -1 7 
Player 1 wins the game.

For the stones of the following values: 
-7 2 6 3 
Player 2 wins the game.

For the stones of the following values: 
1 2 0 3 6 7 4 
Player 1 wins the game.
 Complexity Analysis: The time complexity of the program is O(3 * N). In terms of the asymptotic time complexity, it is O(N). As the program uses two auxiliary arrays for storing the answer and the sum of values of stones, the space complexity of the program is O(N + N), which is O(2 *N). In terms of asymptotic time, it is again O(N), where N is the total number of elements present in the stone array. The space complexity of the program can be further reduced. We can use variables instead of arrays, and it is evident in the following program. FileName: StoneGame1.java 
public class StoneGame1 
{
public int stoneGameSol(int storeArr[]) 
{
// computing the size of the array
int size = storeArr.length;
int first = 0; // contains the answer
int second = 0;
int third = 0;
for(int j = size - 1; j >= 0; j--)
{
// one for picking only one stone
int one = Integer.MIN_VALUE;
// two for picking two stones
int two = Integer.MIN_VALUE;
// three for picking three stones
int three = Integer.MIN_VALUE;
one = storeArr[j]- first;
if((j + 1) < size)
{
two = storeArr[j] + storeArr[j + 1] - second;
}
if((j + 2) < size)
{
three = storeArr[j] + storeArr[j + 1] + storeArr[j + 2] - third;
}
int tmp = Math.max(one, Math.max(two, three));
third = second;
second = first;
first = tmp;
}
if(first == 0) 
{
return 0;
}
else if(first > 0) 
{
return 1;
}
else 
{
return 2;
}
}
    // main method
public static void main(String[] argvs) 
{
// creating an object of the class StoneGame1
StoneGame1 obj = new StoneGame1();
// input 1
int arr[] = {4, 3, 9, 16};
int size = arr.length;

System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr[i] + " ");
}
System.out.println();
int ans = obj.stoneGameSol(arr);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 2
int arr1[] = {8, -1, -1, 7};
size = arr1.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr1[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr1);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 3
int arr2[] = {-7, 2, 6, 3};
size = arr2.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr2[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr2);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 4
int arr3[] = {1, 2, 0, 3, 6, 7, 4};
size = arr3.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr3[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr3);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
}
}
 Output: For the stones of the following values: 
4 3 9 16 
It is a tie between player 1 and player 2

For the stones of the following values: 
8 -1 -1 7 
Player 1 wins the game.

For the stones of the following values: 
-7 2 6 3 
Player 2 wins the game.

For the stones of the following values: 
1 2 0 3 6 7 4 
Player 1 wins the game.
 Complexity Analysis: The time complexity of the program is the same as the previous program. Since the program is only using variables and not arrays, the space complexity of the program is constant, i.e., O(1). Next TopicTypeErasure in Java ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/stone-game-in-java Stone Game in Java - Javatpoint ? SCROLL TO TOP Home Java Programs OOPs String Exception Multithreading Collections JavaFX JSP Spring Spring Boot Projects Interview Questions Java Tutorial What is Java History of Java Features of Java C++ vs Java Hello Java Program Program Internal How to set path? JDK, JRE and JVM JVM: Java Virtual Machine Java Variables Java Data Types Unicode System Operators Keywords Control Statements Java Control Statements Java If-else Java Switch Java For Loop Java While Loop Java Do While Loop Java Break Java Continue Java Comments Java Programs Java Object Class Java OOPs Concepts Naming Convention Object and Class Method Constructor static keyword this keyword Java Inheritance Inheritance(IS-A) Aggregation(HAS-A) Java Polymorphism Method Overloading Method Overriding Covariant Return Type super keyword Instance Initializer block final keyword Runtime Polymorphism Dynamic Binding instanceof operator Java Abstraction Abstract class Interface Abstract vs Interface Java Encapsulation Package Access Modifiers Encapsulation Java Array Java Array Java OOPs Misc Object class Object Cloning Math class Wrapper Class Java Recursion Call By Value strictfp keyword javadoc tool Command Line Arg Object vs Class Overloading vs Overriding Java String Java Regex Exception Handling Java Inner classes Java Multithreading Java I/O Java Networking Java AWT & Events Java Swing JavaFX Java Applet Java Reflection Java Date Java Conversion Java Collection Java JDBC Java Misc Java New Features RMI Internationalization Interview Questions Java MCQ next ? ? prev Stone Game in Java In this game, stones are placed in a row (an input array is given). Two players are assigned the task of picking the stones of the maximum values. The player who collects stones of the maximum value wins the game. Player 1 will play first. After that, player two will play, and so on. At a time, a player can choose either 1 or 2 or 3 stones. The stones must be chosen from the left side only. Note that a player has to pick at least one stone. Our task is to decide which player will win the game if both the players play optimally. Example 1: int arr[] = {4, 3, 9, 16} Output: It is a tie between player 1 and player2 Explanation: Since stones are chosen from the left side and at max, only three stones are chosen, player 1 can only choose stones 1, 2 & 3. Thus, the total values of the stones chosen is 4 + 3 + 9 = 16. Now, it is the term of player 2. Player 2 can choose stone 4, which is of the value 16. Thus, both the players got the same value. Hence, it is a tie. Example 2: int arr[] = {8, -1, -1, 7} Output: Player 1 wins the game. Explanation: Player 1 plays optimally. Player 1 picks only the 1st stone from the left and leaves the rest. Thus, player 1 has a total value 8. Now, it is player 2 turn to pick the stones. Since players can only pick stones from the left only; therefore, player 2 has to pick stones of the values -1, -1, and 7. Thus, total value picked by the player 2 is -1 + -1 + 7 = 5, which is less than 8. Hence, player 1 wins. Example 3: int arr[] = {-7, 2, 6, 3} Output: Player 2 wins the game. Explanation: To gain the maximum value, player 1 picks stones 1, 2, and 3. Thus, collecting the maximum value of -7 + 2 + 6 = 1. There is only one stone left which is picked by player 2. The stone is of the value 3. Thus, player 2 wins the game. Example 4: int arr[] = {1, 2, 0, 3, 6, 7, 4} Output: Player 1 wins the game. Explanation: To gain the maximum value, player 1 picks stones 1 and 2 only. Thus, collecting the maximum value of 1 + 2 = 3. Now, it is the turn of player 2, and the player 2 picks stones of the values 0, 3, and 6 (total values 0 + 3 + 6 = 9). Again, it is the turn of player 1, and player 1 picks 7 and 4. Thus, total value collected by the player 1 is 3 + 7 + 4 = 14, which is greater than 9. Hence, player 1 wins the game. Approach: Using Recursion It is a brute force approach, where we consider each possible scenario for the player. The first scenario is when the player picks only one stone. The second scenario is when the player picks the two stones. The third scenario is when the player picks three stones. The maximum of these three scenarios is the value collected by the player. Observe the following program. FileName: StoneGame.java 
public class StoneGame 
{
    private int solve(int j, int[] nums)
    {
        // size of the array
        int size = nums.length;
        
        // handling the base case
        if(j >= size)
        {
            return 0;
        }
        // if we pick only one stone
        int one = Integer.MIN_VALUE;
        // if we pick two stones
        int two = Integer.MIN_VALUE;
        // if we pick three stones
        int three = Integer.MIN_VALUE;
        // picked one stone and performing the 
        // further computation
        one = nums[j] - solve(j + 1, nums);
        if((j + 1) < size)
        {
            // picked two stones at a time and performing 
            // the further computation
            two = nums[j] + nums[j + 1] - solve(j + 2, nums);
        }
        if((j + 2) < size)
        {
            // picked 3 stones at a time and performing the further
            // computation
            three = nums[j] + nums[j + 1] + nums[j + 2] - solve(j + 3, nums);
        }
        // picking the maximum between one, two and three
        return Math.max(one, Math.max(two, three));
    }
    public int stoneGameSol(int[] stoneVal) 
    {
        int ans = solve(0, stoneVal);
        if(ans == 0)
        {
            // 0 means its a tie
            return 0;
        }
        if(ans > 0)
        {
            // 1 means player 1 wins the game
            return 1;
        }
        // 2 means player 2 wins the game
        return 2;
    }
    // main method
public static void main(String[] argvs) 
{
// creating an object of the class StoneGame
StoneGame obj = new StoneGame();
// input 1
int arr[] = {4, 3, 9, 16};
int size = arr.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr[i] + " ");
}
System.out.println();
int ans = obj.stoneGameSol(arr);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 2
int arr1[] = {8, -1, -1, 7};
size = arr1.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr1[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr1);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 3
int arr2[] = {-7, 2, 6, 3};
size = arr2.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr2[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr2);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 4
int arr3[] = {1, 2, 0, 3, 6, 7, 4};
size = arr3.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr3[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr3);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
}
}
 Output: For the stones of the following values: 
4 3 9 16 
It is a tie between player 1 and player 2

For the stones of the following values: 
8 -1 -1 7 
Player 1 wins the game.

For the stones of the following values: 
-7 2 6 3 
Player 2 wins the game.

For the stones of the following values: 
1 2 0 3 6 7 4 
Player 1 wins the game.
 Complexity Analysis: The time complexity of the program is exponential as there are recursive calls for all the scenarios. The above program is not suitable for larger input as it will take a lot of time because of its high time complexity. Approach: Using Iteration (Dynamic Programming) We will assume that the dp[j] is the maximum value player 1 can get. Since player 1 can take 1 to 3 stones, player 2 can begin from either dp[j + 1], dp[j + 2], dp[j + 3]. Player 2 can also take 1 to 3 stones. Thus, resulting in the minimum of dp[j + 2 to 4], dp[j + 3 to 5], and dp[j + 4 to 6]. Thus, 
Dp[j] = max
(
                    stoneArr[j : j + 1] + min(dp[j + 2], dp[j + 3], dp[j + 4]),
                    stoneArr[j : j + 2] + min(dp[j + 3], dp[j + 4], dp[j + 5]),
                    stoneArr[j : j + 3] + min(dp[j + 4], dp[j + 5], dp[j + 6])
              )
 If any of the indexes are out of bounds, then it means the value is 0. The resulting score is stored dp[0]. FileName: StoneGame1.java 
public class StoneGame1 
{
public int stoneGameSol(int storeArr[]) 
{
// computing the size of the array
int n = storeArr.length;
int dp[] = new int[n];
// contains the sum of the values of 
// the stones present in the array stoneArr
int sums[] = new int[n+1];
for (int j = 0; j < n; j++) 
{
sums[j + 1] = sums[j] + storeArr[j];
}
dp[n - 1] = storeArr[n - 1];
if (n > 1) 
{
dp[n - 2] = storeArr[n - 2] + Math.max(storeArr[n - 1], 0);
for (int j = n - 3; j >= 0; j--) 
{
dp[j] = Integer.MIN_VALUE;
for (int k = 1; k <= 3; k++) 
{
// score is the sum of values of the
// stone taken by the player
// for k = 1 only one stone is taken
// for k = 2, two stones are taken
// for k = 3, three stones are taken
int score = sums[j + k] - sums[j];
int a1 = j + k + 1 < n ? dp[j + k + 1] : 0;
int a2 = j + k + 2 < n ? dp[j + k + 2] : 0;
int a3 = j + k + 3 < n ? dp[j + k + 3] : 0;
// the players are playing optimally. Hence, we have to pick
// the minimum between a1, a2, a3
dp[j] = Math.max(dp[j], score + Math.min(a1, Math.min(a2, a3)));
}
}
}
if ((2 * dp[0]) > sums[n]) 
{
return 1;
}
else if ((2 * dp[0]) < sums[n]) 
{
return 2;
}
else 
{
return 0;
}
}
// main method
public static void main(String[] argvs) 
{
// creating an object of the class StoneGame1
StoneGame1 obj = new StoneGame1();
// input 1
int arr[] = {4, 3, 9, 16};
int size = arr.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr[i] + " ");
}
System.out.println();
int ans = obj.stoneGameSol(arr);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 2
int arr1[] = {8, -1, -1, 7};
size = arr1.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr1[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr1);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 3
int arr2[] = {-7, 2, 6, 3};
size = arr2.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr2[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr2);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 4
int arr3[] = {1, 2, 0, 3, 6, 7, 4};
size = arr3.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr3[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr3);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
}
}
 Output: For the stones of the following values: 
4 3 9 16 
It is a tie between player 1 and player 2

For the stones of the following values: 
8 -1 -1 7 
Player 1 wins the game.

For the stones of the following values: 
-7 2 6 3 
Player 2 wins the game.

For the stones of the following values: 
1 2 0 3 6 7 4 
Player 1 wins the game.
 Complexity Analysis: The time complexity of the program is O(3 * N). In terms of the asymptotic time complexity, it is O(N). As the program uses two auxiliary arrays for storing the answer and the sum of values of stones, the space complexity of the program is O(N + N), which is O(2 *N). In terms of asymptotic time, it is again O(N), where N is the total number of elements present in the stone array. The space complexity of the program can be further reduced. We can use variables instead of arrays, and it is evident in the following program. FileName: StoneGame1.java 
public class StoneGame1 
{
public int stoneGameSol(int storeArr[]) 
{
// computing the size of the array
int size = storeArr.length;
int first = 0; // contains the answer
int second = 0;
int third = 0;
for(int j = size - 1; j >= 0; j--)
{
// one for picking only one stone
int one = Integer.MIN_VALUE;
// two for picking two stones
int two = Integer.MIN_VALUE;
// three for picking three stones
int three = Integer.MIN_VALUE;
one = storeArr[j]- first;
if((j + 1) < size)
{
two = storeArr[j] + storeArr[j + 1] - second;
}
if((j + 2) < size)
{
three = storeArr[j] + storeArr[j + 1] + storeArr[j + 2] - third;
}
int tmp = Math.max(one, Math.max(two, three));
third = second;
second = first;
first = tmp;
}
if(first == 0) 
{
return 0;
}
else if(first > 0) 
{
return 1;
}
else 
{
return 2;
}
}
    // main method
public static void main(String[] argvs) 
{
// creating an object of the class StoneGame1
StoneGame1 obj = new StoneGame1();
// input 1
int arr[] = {4, 3, 9, 16};
int size = arr.length;

System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr[i] + " ");
}
System.out.println();
int ans = obj.stoneGameSol(arr);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 2
int arr1[] = {8, -1, -1, 7};
size = arr1.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr1[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr1);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 3
int arr2[] = {-7, 2, 6, 3};
size = arr2.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr2[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr2);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 4
int arr3[] = {1, 2, 0, 3, 6, 7, 4};
size = arr3.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr3[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr3);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
}
}
 Output: For the stones of the following values: 
4 3 9 16 
It is a tie between player 1 and player 2

For the stones of the following values: 
8 -1 -1 7 
Player 1 wins the game.

For the stones of the following values: 
-7 2 6 3 
Player 2 wins the game.

For the stones of the following values: 
1 2 0 3 6 7 4 
Player 1 wins the game.
 Complexity Analysis: The time complexity of the program is the same as the previous program. Since the program is only using variables and not arrays, the space complexity of the program is constant, i.e., O(1). Next TopicTypeErasure in Java ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/stone-game-in-java Stone Game in Java - Javatpoint ? SCROLL TO TOP Home Java Programs OOPs String Exception Multithreading Collections JavaFX JSP Spring Spring Boot Projects Interview Questions Java Tutorial What is Java History of Java Features of Java C++ vs Java Hello Java Program Program Internal How to set path? JDK, JRE and JVM JVM: Java Virtual Machine Java Variables Java Data Types Unicode System Operators Keywords Control Statements Java Control Statements Java If-else Java Switch Java For Loop Java While Loop Java Do While Loop Java Break Java Continue Java Comments Java Programs Java Object Class Java OOPs Concepts Naming Convention Object and Class Method Constructor static keyword this keyword Java Inheritance Inheritance(IS-A) Aggregation(HAS-A) Java Polymorphism Method Overloading Method Overriding Covariant Return Type super keyword Instance Initializer block final keyword Runtime Polymorphism Dynamic Binding instanceof operator Java Abstraction Abstract class Interface Abstract vs Interface Java Encapsulation Package Access Modifiers Encapsulation Java Array Java Array Java OOPs Misc Object class Object Cloning Math class Wrapper Class Java Recursion Call By Value strictfp keyword javadoc tool Command Line Arg Object vs Class Overloading vs Overriding Java String Java Regex Exception Handling Java Inner classes Java Multithreading Java I/O Java Networking Java AWT & Events Java Swing JavaFX Java Applet Java Reflection Java Date Java Conversion Java Collection Java JDBC Java Misc Java New Features RMI Internationalization Interview Questions Java MCQ next ? ? prev Stone Game in Java In this game, stones are placed in a row (an input array is given). Two players are assigned the task of picking the stones of the maximum values. The player who collects stones of the maximum value wins the game. Player 1 will play first. After that, player two will play, and so on. At a time, a player can choose either 1 or 2 or 3 stones. The stones must be chosen from the left side only. Note that a player has to pick at least one stone. Our task is to decide which player will win the game if both the players play optimally. Example 1: int arr[] = {4, 3, 9, 16} Output: It is a tie between player 1 and player2 Explanation: Since stones are chosen from the left side and at max, only three stones are chosen, player 1 can only choose stones 1, 2 & 3. Thus, the total values of the stones chosen is 4 + 3 + 9 = 16. Now, it is the term of player 2. Player 2 can choose stone 4, which is of the value 16. Thus, both the players got the same value. Hence, it is a tie. Example 2: int arr[] = {8, -1, -1, 7} Output: Player 1 wins the game. Explanation: Player 1 plays optimally. Player 1 picks only the 1st stone from the left and leaves the rest. Thus, player 1 has a total value 8. Now, it is player 2 turn to pick the stones. Since players can only pick stones from the left only; therefore, player 2 has to pick stones of the values -1, -1, and 7. Thus, total value picked by the player 2 is -1 + -1 + 7 = 5, which is less than 8. Hence, player 1 wins. Example 3: int arr[] = {-7, 2, 6, 3} Output: Player 2 wins the game. Explanation: To gain the maximum value, player 1 picks stones 1, 2, and 3. Thus, collecting the maximum value of -7 + 2 + 6 = 1. There is only one stone left which is picked by player 2. The stone is of the value 3. Thus, player 2 wins the game. Example 4: int arr[] = {1, 2, 0, 3, 6, 7, 4} Output: Player 1 wins the game. Explanation: To gain the maximum value, player 1 picks stones 1 and 2 only. Thus, collecting the maximum value of 1 + 2 = 3. Now, it is the turn of player 2, and the player 2 picks stones of the values 0, 3, and 6 (total values 0 + 3 + 6 = 9). Again, it is the turn of player 1, and player 1 picks 7 and 4. Thus, total value collected by the player 1 is 3 + 7 + 4 = 14, which is greater than 9. Hence, player 1 wins the game. Approach: Using Recursion It is a brute force approach, where we consider each possible scenario for the player. The first scenario is when the player picks only one stone. The second scenario is when the player picks the two stones. The third scenario is when the player picks three stones. The maximum of these three scenarios is the value collected by the player. Observe the following program. FileName: StoneGame.java 
public class StoneGame 
{
    private int solve(int j, int[] nums)
    {
        // size of the array
        int size = nums.length;
        
        // handling the base case
        if(j >= size)
        {
            return 0;
        }
        // if we pick only one stone
        int one = Integer.MIN_VALUE;
        // if we pick two stones
        int two = Integer.MIN_VALUE;
        // if we pick three stones
        int three = Integer.MIN_VALUE;
        // picked one stone and performing the 
        // further computation
        one = nums[j] - solve(j + 1, nums);
        if((j + 1) < size)
        {
            // picked two stones at a time and performing 
            // the further computation
            two = nums[j] + nums[j + 1] - solve(j + 2, nums);
        }
        if((j + 2) < size)
        {
            // picked 3 stones at a time and performing the further
            // computation
            three = nums[j] + nums[j + 1] + nums[j + 2] - solve(j + 3, nums);
        }
        // picking the maximum between one, two and three
        return Math.max(one, Math.max(two, three));
    }
    public int stoneGameSol(int[] stoneVal) 
    {
        int ans = solve(0, stoneVal);
        if(ans == 0)
        {
            // 0 means its a tie
            return 0;
        }
        if(ans > 0)
        {
            // 1 means player 1 wins the game
            return 1;
        }
        // 2 means player 2 wins the game
        return 2;
    }
    // main method
public static void main(String[] argvs) 
{
// creating an object of the class StoneGame
StoneGame obj = new StoneGame();
// input 1
int arr[] = {4, 3, 9, 16};
int size = arr.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr[i] + " ");
}
System.out.println();
int ans = obj.stoneGameSol(arr);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 2
int arr1[] = {8, -1, -1, 7};
size = arr1.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr1[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr1);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 3
int arr2[] = {-7, 2, 6, 3};
size = arr2.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr2[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr2);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 4
int arr3[] = {1, 2, 0, 3, 6, 7, 4};
size = arr3.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr3[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr3);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
}
}
 Output: For the stones of the following values: 
4 3 9 16 
It is a tie between player 1 and player 2

For the stones of the following values: 
8 -1 -1 7 
Player 1 wins the game.

For the stones of the following values: 
-7 2 6 3 
Player 2 wins the game.

For the stones of the following values: 
1 2 0 3 6 7 4 
Player 1 wins the game.
 Complexity Analysis: The time complexity of the program is exponential as there are recursive calls for all the scenarios. The above program is not suitable for larger input as it will take a lot of time because of its high time complexity. Approach: Using Iteration (Dynamic Programming) We will assume that the dp[j] is the maximum value player 1 can get. Since player 1 can take 1 to 3 stones, player 2 can begin from either dp[j + 1], dp[j + 2], dp[j + 3]. Player 2 can also take 1 to 3 stones. Thus, resulting in the minimum of dp[j + 2 to 4], dp[j + 3 to 5], and dp[j + 4 to 6]. Thus, 
Dp[j] = max
(
                    stoneArr[j : j + 1] + min(dp[j + 2], dp[j + 3], dp[j + 4]),
                    stoneArr[j : j + 2] + min(dp[j + 3], dp[j + 4], dp[j + 5]),
                    stoneArr[j : j + 3] + min(dp[j + 4], dp[j + 5], dp[j + 6])
              )
 If any of the indexes are out of bounds, then it means the value is 0. The resulting score is stored dp[0]. FileName: StoneGame1.java 
public class StoneGame1 
{
public int stoneGameSol(int storeArr[]) 
{
// computing the size of the array
int n = storeArr.length;
int dp[] = new int[n];
// contains the sum of the values of 
// the stones present in the array stoneArr
int sums[] = new int[n+1];
for (int j = 0; j < n; j++) 
{
sums[j + 1] = sums[j] + storeArr[j];
}
dp[n - 1] = storeArr[n - 1];
if (n > 1) 
{
dp[n - 2] = storeArr[n - 2] + Math.max(storeArr[n - 1], 0);
for (int j = n - 3; j >= 0; j--) 
{
dp[j] = Integer.MIN_VALUE;
for (int k = 1; k <= 3; k++) 
{
// score is the sum of values of the
// stone taken by the player
// for k = 1 only one stone is taken
// for k = 2, two stones are taken
// for k = 3, three stones are taken
int score = sums[j + k] - sums[j];
int a1 = j + k + 1 < n ? dp[j + k + 1] : 0;
int a2 = j + k + 2 < n ? dp[j + k + 2] : 0;
int a3 = j + k + 3 < n ? dp[j + k + 3] : 0;
// the players are playing optimally. Hence, we have to pick
// the minimum between a1, a2, a3
dp[j] = Math.max(dp[j], score + Math.min(a1, Math.min(a2, a3)));
}
}
}
if ((2 * dp[0]) > sums[n]) 
{
return 1;
}
else if ((2 * dp[0]) < sums[n]) 
{
return 2;
}
else 
{
return 0;
}
}
// main method
public static void main(String[] argvs) 
{
// creating an object of the class StoneGame1
StoneGame1 obj = new StoneGame1();
// input 1
int arr[] = {4, 3, 9, 16};
int size = arr.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr[i] + " ");
}
System.out.println();
int ans = obj.stoneGameSol(arr);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 2
int arr1[] = {8, -1, -1, 7};
size = arr1.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr1[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr1);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 3
int arr2[] = {-7, 2, 6, 3};
size = arr2.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr2[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr2);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 4
int arr3[] = {1, 2, 0, 3, 6, 7, 4};
size = arr3.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr3[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr3);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
}
}
 Output: For the stones of the following values: 
4 3 9 16 
It is a tie between player 1 and player 2

For the stones of the following values: 
8 -1 -1 7 
Player 1 wins the game.

For the stones of the following values: 
-7 2 6 3 
Player 2 wins the game.

For the stones of the following values: 
1 2 0 3 6 7 4 
Player 1 wins the game.
 Complexity Analysis: The time complexity of the program is O(3 * N). In terms of the asymptotic time complexity, it is O(N). As the program uses two auxiliary arrays for storing the answer and the sum of values of stones, the space complexity of the program is O(N + N), which is O(2 *N). In terms of asymptotic time, it is again O(N), where N is the total number of elements present in the stone array. The space complexity of the program can be further reduced. We can use variables instead of arrays, and it is evident in the following program. FileName: StoneGame1.java 
public class StoneGame1 
{
public int stoneGameSol(int storeArr[]) 
{
// computing the size of the array
int size = storeArr.length;
int first = 0; // contains the answer
int second = 0;
int third = 0;
for(int j = size - 1; j >= 0; j--)
{
// one for picking only one stone
int one = Integer.MIN_VALUE;
// two for picking two stones
int two = Integer.MIN_VALUE;
// three for picking three stones
int three = Integer.MIN_VALUE;
one = storeArr[j]- first;
if((j + 1) < size)
{
two = storeArr[j] + storeArr[j + 1] - second;
}
if((j + 2) < size)
{
three = storeArr[j] + storeArr[j + 1] + storeArr[j + 2] - third;
}
int tmp = Math.max(one, Math.max(two, three));
third = second;
second = first;
first = tmp;
}
if(first == 0) 
{
return 0;
}
else if(first > 0) 
{
return 1;
}
else 
{
return 2;
}
}
    // main method
public static void main(String[] argvs) 
{
// creating an object of the class StoneGame1
StoneGame1 obj = new StoneGame1();
// input 1
int arr[] = {4, 3, 9, 16};
int size = arr.length;

System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr[i] + " ");
}
System.out.println();
int ans = obj.stoneGameSol(arr);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 2
int arr1[] = {8, -1, -1, 7};
size = arr1.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr1[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr1);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 3
int arr2[] = {-7, 2, 6, 3};
size = arr2.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr2[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr2);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 4
int arr3[] = {1, 2, 0, 3, 6, 7, 4};
size = arr3.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr3[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr3);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
}
}
 Output: For the stones of the following values: 
4 3 9 16 
It is a tie between player 1 and player 2

For the stones of the following values: 
8 -1 -1 7 
Player 1 wins the game.

For the stones of the following values: 
-7 2 6 3 
Player 2 wins the game.

For the stones of the following values: 
1 2 0 3 6 7 4 
Player 1 wins the game.
 Complexity Analysis: The time complexity of the program is the same as the previous program. Since the program is only using variables and not arrays, the space complexity of the program is constant, i.e., O(1). Next TopicTypeErasure in Java ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/stone-game-in-java Stone Game in Java - Javatpoint ? SCROLL TO TOP Home Java Programs OOPs String Exception Multithreading Collections JavaFX JSP Spring Spring Boot Projects Interview Questions Java Tutorial What is Java History of Java Features of Java C++ vs Java Hello Java Program Program Internal How to set path? JDK, JRE and JVM JVM: Java Virtual Machine Java Variables Java Data Types Unicode System Operators Keywords Control Statements Java Control Statements Java If-else Java Switch Java For Loop Java While Loop Java Do While Loop Java Break Java Continue Java Comments Java Programs Java Object Class Java OOPs Concepts Naming Convention Object and Class Method Constructor static keyword this keyword Java Inheritance Inheritance(IS-A) Aggregation(HAS-A) Java Polymorphism Method Overloading Method Overriding Covariant Return Type super keyword Instance Initializer block final keyword Runtime Polymorphism Dynamic Binding instanceof operator Java Abstraction Abstract class Interface Abstract vs Interface Java Encapsulation Package Access Modifiers Encapsulation Java Array Java Array Java OOPs Misc Object class Object Cloning Math class Wrapper Class Java Recursion Call By Value strictfp keyword javadoc tool Command Line Arg Object vs Class Overloading vs Overriding Java String Java Regex Exception Handling Java Inner classes Java Multithreading Java I/O Java Networking Java AWT & Events Java Swing JavaFX Java Applet Java Reflection Java Date Java Conversion Java Collection Java JDBC Java Misc Java New Features RMI Internationalization Interview Questions Java MCQ next ? ? prev Stone Game in Java In this game, stones are placed in a row (an input array is given). Two players are assigned the task of picking the stones of the maximum values. The player who collects stones of the maximum value wins the game. Player 1 will play first. After that, player two will play, and so on. At a time, a player can choose either 1 or 2 or 3 stones. The stones must be chosen from the left side only. Note that a player has to pick at least one stone. Our task is to decide which player will win the game if both the players play optimally. Example 1: int arr[] = {4, 3, 9, 16} Output: It is a tie between player 1 and player2 Explanation: Since stones are chosen from the left side and at max, only three stones are chosen, player 1 can only choose stones 1, 2 & 3. Thus, the total values of the stones chosen is 4 + 3 + 9 = 16. Now, it is the term of player 2. Player 2 can choose stone 4, which is of the value 16. Thus, both the players got the same value. Hence, it is a tie. Example 2: int arr[] = {8, -1, -1, 7} Output: Player 1 wins the game. Explanation: Player 1 plays optimally. Player 1 picks only the 1st stone from the left and leaves the rest. Thus, player 1 has a total value 8. Now, it is player 2 turn to pick the stones. Since players can only pick stones from the left only; therefore, player 2 has to pick stones of the values -1, -1, and 7. Thus, total value picked by the player 2 is -1 + -1 + 7 = 5, which is less than 8. Hence, player 1 wins. Example 3: int arr[] = {-7, 2, 6, 3} Output: Player 2 wins the game. Explanation: To gain the maximum value, player 1 picks stones 1, 2, and 3. Thus, collecting the maximum value of -7 + 2 + 6 = 1. There is only one stone left which is picked by player 2. The stone is of the value 3. Thus, player 2 wins the game. Example 4: int arr[] = {1, 2, 0, 3, 6, 7, 4} Output: Player 1 wins the game. Explanation: To gain the maximum value, player 1 picks stones 1 and 2 only. Thus, collecting the maximum value of 1 + 2 = 3. Now, it is the turn of player 2, and the player 2 picks stones of the values 0, 3, and 6 (total values 0 + 3 + 6 = 9). Again, it is the turn of player 1, and player 1 picks 7 and 4. Thus, total value collected by the player 1 is 3 + 7 + 4 = 14, which is greater than 9. Hence, player 1 wins the game. Approach: Using Recursion It is a brute force approach, where we consider each possible scenario for the player. The first scenario is when the player picks only one stone. The second scenario is when the player picks the two stones. The third scenario is when the player picks three stones. The maximum of these three scenarios is the value collected by the player. Observe the following program. FileName: StoneGame.java 
public class StoneGame 
{
    private int solve(int j, int[] nums)
    {
        // size of the array
        int size = nums.length;
        
        // handling the base case
        if(j >= size)
        {
            return 0;
        }
        // if we pick only one stone
        int one = Integer.MIN_VALUE;
        // if we pick two stones
        int two = Integer.MIN_VALUE;
        // if we pick three stones
        int three = Integer.MIN_VALUE;
        // picked one stone and performing the 
        // further computation
        one = nums[j] - solve(j + 1, nums);
        if((j + 1) < size)
        {
            // picked two stones at a time and performing 
            // the further computation
            two = nums[j] + nums[j + 1] - solve(j + 2, nums);
        }
        if((j + 2) < size)
        {
            // picked 3 stones at a time and performing the further
            // computation
            three = nums[j] + nums[j + 1] + nums[j + 2] - solve(j + 3, nums);
        }
        // picking the maximum between one, two and three
        return Math.max(one, Math.max(two, three));
    }
    public int stoneGameSol(int[] stoneVal) 
    {
        int ans = solve(0, stoneVal);
        if(ans == 0)
        {
            // 0 means its a tie
            return 0;
        }
        if(ans > 0)
        {
            // 1 means player 1 wins the game
            return 1;
        }
        // 2 means player 2 wins the game
        return 2;
    }
    // main method
public static void main(String[] argvs) 
{
// creating an object of the class StoneGame
StoneGame obj = new StoneGame();
// input 1
int arr[] = {4, 3, 9, 16};
int size = arr.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr[i] + " ");
}
System.out.println();
int ans = obj.stoneGameSol(arr);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 2
int arr1[] = {8, -1, -1, 7};
size = arr1.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr1[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr1);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 3
int arr2[] = {-7, 2, 6, 3};
size = arr2.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr2[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr2);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 4
int arr3[] = {1, 2, 0, 3, 6, 7, 4};
size = arr3.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr3[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr3);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
}
}
 Output: For the stones of the following values: 
4 3 9 16 
It is a tie between player 1 and player 2

For the stones of the following values: 
8 -1 -1 7 
Player 1 wins the game.

For the stones of the following values: 
-7 2 6 3 
Player 2 wins the game.

For the stones of the following values: 
1 2 0 3 6 7 4 
Player 1 wins the game.
 Complexity Analysis: The time complexity of the program is exponential as there are recursive calls for all the scenarios. The above program is not suitable for larger input as it will take a lot of time because of its high time complexity. Approach: Using Iteration (Dynamic Programming) We will assume that the dp[j] is the maximum value player 1 can get. Since player 1 can take 1 to 3 stones, player 2 can begin from either dp[j + 1], dp[j + 2], dp[j + 3]. Player 2 can also take 1 to 3 stones. Thus, resulting in the minimum of dp[j + 2 to 4], dp[j + 3 to 5], and dp[j + 4 to 6]. Thus, 
Dp[j] = max
(
                    stoneArr[j : j + 1] + min(dp[j + 2], dp[j + 3], dp[j + 4]),
                    stoneArr[j : j + 2] + min(dp[j + 3], dp[j + 4], dp[j + 5]),
                    stoneArr[j : j + 3] + min(dp[j + 4], dp[j + 5], dp[j + 6])
              )
 If any of the indexes are out of bounds, then it means the value is 0. The resulting score is stored dp[0]. FileName: StoneGame1.java 
public class StoneGame1 
{
public int stoneGameSol(int storeArr[]) 
{
// computing the size of the array
int n = storeArr.length;
int dp[] = new int[n];
// contains the sum of the values of 
// the stones present in the array stoneArr
int sums[] = new int[n+1];
for (int j = 0; j < n; j++) 
{
sums[j + 1] = sums[j] + storeArr[j];
}
dp[n - 1] = storeArr[n - 1];
if (n > 1) 
{
dp[n - 2] = storeArr[n - 2] + Math.max(storeArr[n - 1], 0);
for (int j = n - 3; j >= 0; j--) 
{
dp[j] = Integer.MIN_VALUE;
for (int k = 1; k <= 3; k++) 
{
// score is the sum of values of the
// stone taken by the player
// for k = 1 only one stone is taken
// for k = 2, two stones are taken
// for k = 3, three stones are taken
int score = sums[j + k] - sums[j];
int a1 = j + k + 1 < n ? dp[j + k + 1] : 0;
int a2 = j + k + 2 < n ? dp[j + k + 2] : 0;
int a3 = j + k + 3 < n ? dp[j + k + 3] : 0;
// the players are playing optimally. Hence, we have to pick
// the minimum between a1, a2, a3
dp[j] = Math.max(dp[j], score + Math.min(a1, Math.min(a2, a3)));
}
}
}
if ((2 * dp[0]) > sums[n]) 
{
return 1;
}
else if ((2 * dp[0]) < sums[n]) 
{
return 2;
}
else 
{
return 0;
}
}
// main method
public static void main(String[] argvs) 
{
// creating an object of the class StoneGame1
StoneGame1 obj = new StoneGame1();
// input 1
int arr[] = {4, 3, 9, 16};
int size = arr.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr[i] + " ");
}
System.out.println();
int ans = obj.stoneGameSol(arr);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 2
int arr1[] = {8, -1, -1, 7};
size = arr1.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr1[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr1);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 3
int arr2[] = {-7, 2, 6, 3};
size = arr2.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr2[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr2);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 4
int arr3[] = {1, 2, 0, 3, 6, 7, 4};
size = arr3.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr3[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr3);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
}
}
 Output: For the stones of the following values: 
4 3 9 16 
It is a tie between player 1 and player 2

For the stones of the following values: 
8 -1 -1 7 
Player 1 wins the game.

For the stones of the following values: 
-7 2 6 3 
Player 2 wins the game.

For the stones of the following values: 
1 2 0 3 6 7 4 
Player 1 wins the game.
 Complexity Analysis: The time complexity of the program is O(3 * N). In terms of the asymptotic time complexity, it is O(N). As the program uses two auxiliary arrays for storing the answer and the sum of values of stones, the space complexity of the program is O(N + N), which is O(2 *N). In terms of asymptotic time, it is again O(N), where N is the total number of elements present in the stone array. The space complexity of the program can be further reduced. We can use variables instead of arrays, and it is evident in the following program. FileName: StoneGame1.java 
public class StoneGame1 
{
public int stoneGameSol(int storeArr[]) 
{
// computing the size of the array
int size = storeArr.length;
int first = 0; // contains the answer
int second = 0;
int third = 0;
for(int j = size - 1; j >= 0; j--)
{
// one for picking only one stone
int one = Integer.MIN_VALUE;
// two for picking two stones
int two = Integer.MIN_VALUE;
// three for picking three stones
int three = Integer.MIN_VALUE;
one = storeArr[j]- first;
if((j + 1) < size)
{
two = storeArr[j] + storeArr[j + 1] - second;
}
if((j + 2) < size)
{
three = storeArr[j] + storeArr[j + 1] + storeArr[j + 2] - third;
}
int tmp = Math.max(one, Math.max(two, three));
third = second;
second = first;
first = tmp;
}
if(first == 0) 
{
return 0;
}
else if(first > 0) 
{
return 1;
}
else 
{
return 2;
}
}
    // main method
public static void main(String[] argvs) 
{
// creating an object of the class StoneGame1
StoneGame1 obj = new StoneGame1();
// input 1
int arr[] = {4, 3, 9, 16};
int size = arr.length;

System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr[i] + " ");
}
System.out.println();
int ans = obj.stoneGameSol(arr);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 2
int arr1[] = {8, -1, -1, 7};
size = arr1.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr1[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr1);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 3
int arr2[] = {-7, 2, 6, 3};
size = arr2.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr2[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr2);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 4
int arr3[] = {1, 2, 0, 3, 6, 7, 4};
size = arr3.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr3[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr3);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
}
}
 Output: For the stones of the following values: 
4 3 9 16 
It is a tie between player 1 and player 2

For the stones of the following values: 
8 -1 -1 7 
Player 1 wins the game.

For the stones of the following values: 
-7 2 6 3 
Player 2 wins the game.

For the stones of the following values: 
1 2 0 3 6 7 4 
Player 1 wins the game.
 Complexity Analysis: The time complexity of the program is the same as the previous program. Since the program is only using variables and not arrays, the space complexity of the program is constant, i.e., O(1). Next TopicTypeErasure in Java ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/stone-game-in-java Stone Game in Java - Javatpoint ? SCROLL TO TOP Home Java Programs OOPs String Exception Multithreading Collections JavaFX JSP Spring Spring Boot Projects Interview Questions Java Tutorial What is Java History of Java Features of Java C++ vs Java Hello Java Program Program Internal How to set path? JDK, JRE and JVM JVM: Java Virtual Machine Java Variables Java Data Types Unicode System Operators Keywords Control Statements Java Control Statements Java If-else Java Switch Java For Loop Java While Loop Java Do While Loop Java Break Java Continue Java Comments Java Programs Java Object Class Java OOPs Concepts Naming Convention Object and Class Method Constructor static keyword this keyword Java Inheritance Inheritance(IS-A) Aggregation(HAS-A) Java Polymorphism Method Overloading Method Overriding Covariant Return Type super keyword Instance Initializer block final keyword Runtime Polymorphism Dynamic Binding instanceof operator Java Abstraction Abstract class Interface Abstract vs Interface Java Encapsulation Package Access Modifiers Encapsulation Java Array Java Array Java OOPs Misc Object class Object Cloning Math class Wrapper Class Java Recursion Call By Value strictfp keyword javadoc tool Command Line Arg Object vs Class Overloading vs Overriding Java String Java Regex Exception Handling Java Inner classes Java Multithreading Java I/O Java Networking Java AWT & Events Java Swing JavaFX Java Applet Java Reflection Java Date Java Conversion Java Collection Java JDBC Java Misc Java New Features RMI Internationalization Interview Questions Java MCQ next ? ? prev Stone Game in Java In this game, stones are placed in a row (an input array is given). Two players are assigned the task of picking the stones of the maximum values. The player who collects stones of the maximum value wins the game. Player 1 will play first. After that, player two will play, and so on. At a time, a player can choose either 1 or 2 or 3 stones. The stones must be chosen from the left side only. Note that a player has to pick at least one stone. Our task is to decide which player will win the game if both the players play optimally. Example 1: int arr[] = {4, 3, 9, 16} Output: It is a tie between player 1 and player2 Explanation: Since stones are chosen from the left side and at max, only three stones are chosen, player 1 can only choose stones 1, 2 & 3. Thus, the total values of the stones chosen is 4 + 3 + 9 = 16. Now, it is the term of player 2. Player 2 can choose stone 4, which is of the value 16. Thus, both the players got the same value. Hence, it is a tie. Example 2: int arr[] = {8, -1, -1, 7} Output: Player 1 wins the game. Explanation: Player 1 plays optimally. Player 1 picks only the 1st stone from the left and leaves the rest. Thus, player 1 has a total value 8. Now, it is player 2 turn to pick the stones. Since players can only pick stones from the left only; therefore, player 2 has to pick stones of the values -1, -1, and 7. Thus, total value picked by the player 2 is -1 + -1 + 7 = 5, which is less than 8. Hence, player 1 wins. Example 3: int arr[] = {-7, 2, 6, 3} Output: Player 2 wins the game. Explanation: To gain the maximum value, player 1 picks stones 1, 2, and 3. Thus, collecting the maximum value of -7 + 2 + 6 = 1. There is only one stone left which is picked by player 2. The stone is of the value 3. Thus, player 2 wins the game. Example 4: int arr[] = {1, 2, 0, 3, 6, 7, 4} Output: Player 1 wins the game. Explanation: To gain the maximum value, player 1 picks stones 1 and 2 only. Thus, collecting the maximum value of 1 + 2 = 3. Now, it is the turn of player 2, and the player 2 picks stones of the values 0, 3, and 6 (total values 0 + 3 + 6 = 9). Again, it is the turn of player 1, and player 1 picks 7 and 4. Thus, total value collected by the player 1 is 3 + 7 + 4 = 14, which is greater than 9. Hence, player 1 wins the game. Approach: Using Recursion It is a brute force approach, where we consider each possible scenario for the player. The first scenario is when the player picks only one stone. The second scenario is when the player picks the two stones. The third scenario is when the player picks three stones. The maximum of these three scenarios is the value collected by the player. Observe the following program. FileName: StoneGame.java 
public class StoneGame 
{
    private int solve(int j, int[] nums)
    {
        // size of the array
        int size = nums.length;
        
        // handling the base case
        if(j >= size)
        {
            return 0;
        }
        // if we pick only one stone
        int one = Integer.MIN_VALUE;
        // if we pick two stones
        int two = Integer.MIN_VALUE;
        // if we pick three stones
        int three = Integer.MIN_VALUE;
        // picked one stone and performing the 
        // further computation
        one = nums[j] - solve(j + 1, nums);
        if((j + 1) < size)
        {
            // picked two stones at a time and performing 
            // the further computation
            two = nums[j] + nums[j + 1] - solve(j + 2, nums);
        }
        if((j + 2) < size)
        {
            // picked 3 stones at a time and performing the further
            // computation
            three = nums[j] + nums[j + 1] + nums[j + 2] - solve(j + 3, nums);
        }
        // picking the maximum between one, two and three
        return Math.max(one, Math.max(two, three));
    }
    public int stoneGameSol(int[] stoneVal) 
    {
        int ans = solve(0, stoneVal);
        if(ans == 0)
        {
            // 0 means its a tie
            return 0;
        }
        if(ans > 0)
        {
            // 1 means player 1 wins the game
            return 1;
        }
        // 2 means player 2 wins the game
        return 2;
    }
    // main method
public static void main(String[] argvs) 
{
// creating an object of the class StoneGame
StoneGame obj = new StoneGame();
// input 1
int arr[] = {4, 3, 9, 16};
int size = arr.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr[i] + " ");
}
System.out.println();
int ans = obj.stoneGameSol(arr);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 2
int arr1[] = {8, -1, -1, 7};
size = arr1.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr1[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr1);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 3
int arr2[] = {-7, 2, 6, 3};
size = arr2.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr2[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr2);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 4
int arr3[] = {1, 2, 0, 3, 6, 7, 4};
size = arr3.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr3[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr3);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
}
}
 Output: For the stones of the following values: 
4 3 9 16 
It is a tie between player 1 and player 2

For the stones of the following values: 
8 -1 -1 7 
Player 1 wins the game.

For the stones of the following values: 
-7 2 6 3 
Player 2 wins the game.

For the stones of the following values: 
1 2 0 3 6 7 4 
Player 1 wins the game.
 Complexity Analysis: The time complexity of the program is exponential as there are recursive calls for all the scenarios. The above program is not suitable for larger input as it will take a lot of time because of its high time complexity. Approach: Using Iteration (Dynamic Programming) We will assume that the dp[j] is the maximum value player 1 can get. Since player 1 can take 1 to 3 stones, player 2 can begin from either dp[j + 1], dp[j + 2], dp[j + 3]. Player 2 can also take 1 to 3 stones. Thus, resulting in the minimum of dp[j + 2 to 4], dp[j + 3 to 5], and dp[j + 4 to 6]. Thus, 
Dp[j] = max
(
                    stoneArr[j : j + 1] + min(dp[j + 2], dp[j + 3], dp[j + 4]),
                    stoneArr[j : j + 2] + min(dp[j + 3], dp[j + 4], dp[j + 5]),
                    stoneArr[j : j + 3] + min(dp[j + 4], dp[j + 5], dp[j + 6])
              )
 If any of the indexes are out of bounds, then it means the value is 0. The resulting score is stored dp[0]. FileName: StoneGame1.java 
public class StoneGame1 
{
public int stoneGameSol(int storeArr[]) 
{
// computing the size of the array
int n = storeArr.length;
int dp[] = new int[n];
// contains the sum of the values of 
// the stones present in the array stoneArr
int sums[] = new int[n+1];
for (int j = 0; j < n; j++) 
{
sums[j + 1] = sums[j] + storeArr[j];
}
dp[n - 1] = storeArr[n - 1];
if (n > 1) 
{
dp[n - 2] = storeArr[n - 2] + Math.max(storeArr[n - 1], 0);
for (int j = n - 3; j >= 0; j--) 
{
dp[j] = Integer.MIN_VALUE;
for (int k = 1; k <= 3; k++) 
{
// score is the sum of values of the
// stone taken by the player
// for k = 1 only one stone is taken
// for k = 2, two stones are taken
// for k = 3, three stones are taken
int score = sums[j + k] - sums[j];
int a1 = j + k + 1 < n ? dp[j + k + 1] : 0;
int a2 = j + k + 2 < n ? dp[j + k + 2] : 0;
int a3 = j + k + 3 < n ? dp[j + k + 3] : 0;
// the players are playing optimally. Hence, we have to pick
// the minimum between a1, a2, a3
dp[j] = Math.max(dp[j], score + Math.min(a1, Math.min(a2, a3)));
}
}
}
if ((2 * dp[0]) > sums[n]) 
{
return 1;
}
else if ((2 * dp[0]) < sums[n]) 
{
return 2;
}
else 
{
return 0;
}
}
// main method
public static void main(String[] argvs) 
{
// creating an object of the class StoneGame1
StoneGame1 obj = new StoneGame1();
// input 1
int arr[] = {4, 3, 9, 16};
int size = arr.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr[i] + " ");
}
System.out.println();
int ans = obj.stoneGameSol(arr);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 2
int arr1[] = {8, -1, -1, 7};
size = arr1.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr1[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr1);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 3
int arr2[] = {-7, 2, 6, 3};
size = arr2.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr2[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr2);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 4
int arr3[] = {1, 2, 0, 3, 6, 7, 4};
size = arr3.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr3[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr3);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
}
}
 Output: For the stones of the following values: 
4 3 9 16 
It is a tie between player 1 and player 2

For the stones of the following values: 
8 -1 -1 7 
Player 1 wins the game.

For the stones of the following values: 
-7 2 6 3 
Player 2 wins the game.

For the stones of the following values: 
1 2 0 3 6 7 4 
Player 1 wins the game.
 Complexity Analysis: The time complexity of the program is O(3 * N). In terms of the asymptotic time complexity, it is O(N). As the program uses two auxiliary arrays for storing the answer and the sum of values of stones, the space complexity of the program is O(N + N), which is O(2 *N). In terms of asymptotic time, it is again O(N), where N is the total number of elements present in the stone array. The space complexity of the program can be further reduced. We can use variables instead of arrays, and it is evident in the following program. FileName: StoneGame1.java 
public class StoneGame1 
{
public int stoneGameSol(int storeArr[]) 
{
// computing the size of the array
int size = storeArr.length;
int first = 0; // contains the answer
int second = 0;
int third = 0;
for(int j = size - 1; j >= 0; j--)
{
// one for picking only one stone
int one = Integer.MIN_VALUE;
// two for picking two stones
int two = Integer.MIN_VALUE;
// three for picking three stones
int three = Integer.MIN_VALUE;
one = storeArr[j]- first;
if((j + 1) < size)
{
two = storeArr[j] + storeArr[j + 1] - second;
}
if((j + 2) < size)
{
three = storeArr[j] + storeArr[j + 1] + storeArr[j + 2] - third;
}
int tmp = Math.max(one, Math.max(two, three));
third = second;
second = first;
first = tmp;
}
if(first == 0) 
{
return 0;
}
else if(first > 0) 
{
return 1;
}
else 
{
return 2;
}
}
    // main method
public static void main(String[] argvs) 
{
// creating an object of the class StoneGame1
StoneGame1 obj = new StoneGame1();
// input 1
int arr[] = {4, 3, 9, 16};
int size = arr.length;

System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr[i] + " ");
}
System.out.println();
int ans = obj.stoneGameSol(arr);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 2
int arr1[] = {8, -1, -1, 7};
size = arr1.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr1[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr1);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 3
int arr2[] = {-7, 2, 6, 3};
size = arr2.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr2[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr2);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
System.out.println();
// input 4
int arr3[] = {1, 2, 0, 3, 6, 7, 4};
size = arr3.length;
System.out.println("For the stones of the following values: ");
for(int i = 0; i < size; i++)
{
    System.out.print(arr3[i] + " ");
}
System.out.println();
ans = obj.stoneGameSol(arr3);
if(ans == 0)
{
System.out.println("It is a tie between player 1 and player 2");
}
else if(ans == 1)
{
System.out.println("Player 1 wins the game.");
}
else 
{
System.out.println("Player 2 wins the game.");
}
}
}
 Output: For the stones of the following values: 
4 3 9 16 
It is a tie between player 1 and player 2

For the stones of the following values: 
8 -1 -1 7 
Player 1 wins the game.

For the stones of the following values: 
-7 2 6 3 
Player 2 wins the game.

For the stones of the following values: 
1 2 0 3 6 7 4 
Player 1 wins the game.
 Complexity Analysis: The time complexity of the program is the same as the previous program. Since the program is only using variables and not arrays, the space complexity of the program is constant, i.e., O(1). Next TopicTypeErasure in Java ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.