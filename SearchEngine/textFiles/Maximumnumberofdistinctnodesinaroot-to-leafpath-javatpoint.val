https://www.javatpoint.com/maximum-number-of-distinct-nodes-in-a-root-to-leaf-path Maximum number of distinct nodes in a root-to-leaf path - javatpoint ? SCROLL TO TOP Home Data Structure C C++ C# Java SQL HTML CSS JavaScript Ajax Android Cloud Design Pattern Quiz Projects Interview Q Comment Forum DS Tutorial DS Tutorial DS Introduction DS Algorithm Asymptotic Analysis DS Pointer DS Structure DS Array DS Array 2D Array DS Linked List Linked List Types of Linked List Singly Linked List Doubly Linked List Circular Linked List Circular Doubly List Skip list in DS DS Stack DS Stack Array Implementation Linked List Implementation DS Queue DS Queue Types of Queues Array Representation Linked List Representation Circular Queue Deque Priority Queue DS Tree DS Tree Binary Tree Binary Search Tree AVL Tree B Tree B+ Tree DS Graph DS Graph Graph Implementation BFS Algorithm DFS Algorithm Spanning Tree DS Searching Linear Search Binary Search DS Sorting Bubble Sort Bucket Sort Comb Sort Counting Sort Heap Sort Insertion Sort Merge Sort Quick Sort Radix Sort Selection Sort Shell Sort Bitonic Sort Cocktail Sort Cycle Sort Tim Sort Differences Linear vs non-linear Array vs linked list Stack vs queue Linear vs Circular Queue Linear Search vs Binary Search Singly Linked List vs Doubly Linked List Binary vs Binary Search Tree Tree vs Graph Binary Search tree vs AVL tree Red Black Tree vs AVL tree B tree vs B+ tree Quick Sort vs Merge Sort BFS vs DFS Stack vs Heap Bubble sort vs. Selection sort Stack vs Array Full Binary Tree vs Complete Binary Tree Binary Tree vs B Tree Primitive vs non-primitive data structure Data types vs data structure Misc Trie Data Structure Heap Data Structure Splay Tree Fundamental of the DS Hash Table Preorder Traversal Tree Traversal Implementation of Queue using Stacks Implementation of Stack using Queue Binomial Heap Postorder Traversal Sparse Matrix Detect loop in a Linked list Inorder Traversal Convert Infix to Postfix notation Convert infix to prefix notation Conversion of Prefix to Postfix expression Conversion of Postfix to Prefix expression Remove the loop in a Linked List Implement two stacks in an array Reverse a stack using recursion Detect cycle in a directed graph Optimal Binary Search Tree Priority Queue using Linked list Balanced Binary Search Tree Boundary Traversal of Binary tree Diagonal Traversal of Binary Tree Vertical Traversal of a Binary tree Graph Algorithms Time Complexity of Sorting Algorithms Applications of Stack in Data Structure Dictionary Data Structure Structured Data and Unstructured Data List Data Structure Types of Tree in Data Structure Abstract data type in data structure Disjoint set data structure Dynamic Data Structure Hash Function in Data Structure Complete Binary Tree Threaded Binary Tree Diameter of Binary Tree Height of Binary Tree Inorder Tree Traversal without Stack Enumeration of Binary Trees Maximum Width of a Binary Tree Types of Graph in Data Structure Primitive Data Type Semi-Structured Data Advance Data Structures Sort an Array of 0's, 1's, and 2's Stock Span Problem Implementation of Deque by Circular Array Rotate Operation in Linked List Subarray with given sum Self-organizing List Unrolled Linked List Types of Sparse Matrices Application of Linked List Topological Sorting Ternary Search Tree Stock Span Problem Treap Data Structure Quicksort on Doubly Linked List Inversion count Expression tree in DS Garbage Collection in DS Merge Sort on Doubly Linked List Sort Stack using Recursion LIFO Approach in data structure Big O Notation in DS Binary Tree Traversal in DS Queue Operations in DS What is a Non-Linear Data Structure FIFO Approach in data structure What are connected graphs in data structure Which Python data structure is immutable Which data structure is used by map What is iteration in data structure What are linear search and binary search in data structure Hash Table vs STL Map Recaman's Sequence Maximum area rectangle created by selecting four sides from an array Maximum number of distinct nodes in a root-to-leaf path DS MCQ Data Structure MCQ Advanced DS MCQ next ? ? prev Maximum number of distinct nodes in a root-to-leaf path Find the maximum number of distinct nodes in all root-to-leaf paths given a Binary Tree. Examples 
Input :   1
            /    \
           2      3
          / \    / \
        4   5  6   3
               \   \
                8   9 

Output : 4 
The root to leaf path with maximum distinct
nodes is 1-3-6-8.
 Exploring all root to leaf paths is a simple solution. Count distinct nodes along each root-to-leaf path and return the maximum number. Hashing is an efficient solution. We traverse the tree recursively, keeping track of the number of distinct nodes on the path from the root to the current node. We repeat for the left and right subtrees, returning the maximum of two values. The implementation of the above idea is shown below. Program in C++ 
// C++ program to find count of distinct nodes
// on a path with maximum distinct nodes.
#include <bits/stdc++.h>
using namespace std;

// A node of binary tree
struct Node {
	int data;
	struct Node *left, *right;
};

// A utility function to create a new Binary
// Tree node
Node* newNode(int data)
{
	Node* temp = new Node;
	temp->data = data;
	temp->left = temp->right = NULL;
	return temp;
}

int largestUinquePathUtil(Node* node, unordered_map<int, int> m)
{
	if (!node)
		return m.size();

	// put this node into hash
	m[node->data]++;

	int max_path = max(largestUinquePathUtil(node->left, m),
					largestUinquePathUtil(node->right, m));

	// remove current node from path "hash"
	m[node->data]--;

	// if we reached a condition where all duplicate value
	// of current node is deleted
	if (m[node->data] == 0)
		m.erase(node->data);

	return max_path;
}

// A utility function to find long unique value path
int largestUinquePath(Node* node)
{
	if (!node)
		return 0;

	// hash that store all node value
	unordered_map<int, int> hash;

	// return max length unique value path
	return largestUinquePathUtil(node, hash);
}

// Driver program to test above functions
int main()
{
	// Create binary tree shown in above figure
	Node* root = newNode(1);
	root->left = newNode(2);
	root->right = newNode(3);
	root->left->left = newNode(4);
	root->left->right = newNode(5);
	root->right->left = newNode(6);
	root->right->right = newNode(7);
	root->right->left->right = newNode(8);
	root->right->right->right = newNode(9);

	cout << largestUinquePath(root) << endl;

	return 0;
}
 Output 4
 Time Complexity : O (n) Next Topic# ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/maximum-number-of-distinct-nodes-in-a-root-to-leaf-path Maximum number of distinct nodes in a root-to-leaf path - javatpoint ? SCROLL TO TOP Home Data Structure C C++ C# Java SQL HTML CSS JavaScript Ajax Android Cloud Design Pattern Quiz Projects Interview Q Comment Forum DS Tutorial DS Tutorial DS Introduction DS Algorithm Asymptotic Analysis DS Pointer DS Structure DS Array DS Array 2D Array DS Linked List Linked List Types of Linked List Singly Linked List Doubly Linked List Circular Linked List Circular Doubly List Skip list in DS DS Stack DS Stack Array Implementation Linked List Implementation DS Queue DS Queue Types of Queues Array Representation Linked List Representation Circular Queue Deque Priority Queue DS Tree DS Tree Binary Tree Binary Search Tree AVL Tree B Tree B+ Tree DS Graph DS Graph Graph Implementation BFS Algorithm DFS Algorithm Spanning Tree DS Searching Linear Search Binary Search DS Sorting Bubble Sort Bucket Sort Comb Sort Counting Sort Heap Sort Insertion Sort Merge Sort Quick Sort Radix Sort Selection Sort Shell Sort Bitonic Sort Cocktail Sort Cycle Sort Tim Sort Differences Linear vs non-linear Array vs linked list Stack vs queue Linear vs Circular Queue Linear Search vs Binary Search Singly Linked List vs Doubly Linked List Binary vs Binary Search Tree Tree vs Graph Binary Search tree vs AVL tree Red Black Tree vs AVL tree B tree vs B+ tree Quick Sort vs Merge Sort BFS vs DFS Stack vs Heap Bubble sort vs. Selection sort Stack vs Array Full Binary Tree vs Complete Binary Tree Binary Tree vs B Tree Primitive vs non-primitive data structure Data types vs data structure Misc Trie Data Structure Heap Data Structure Splay Tree Fundamental of the DS Hash Table Preorder Traversal Tree Traversal Implementation of Queue using Stacks Implementation of Stack using Queue Binomial Heap Postorder Traversal Sparse Matrix Detect loop in a Linked list Inorder Traversal Convert Infix to Postfix notation Convert infix to prefix notation Conversion of Prefix to Postfix expression Conversion of Postfix to Prefix expression Remove the loop in a Linked List Implement two stacks in an array Reverse a stack using recursion Detect cycle in a directed graph Optimal Binary Search Tree Priority Queue using Linked list Balanced Binary Search Tree Boundary Traversal of Binary tree Diagonal Traversal of Binary Tree Vertical Traversal of a Binary tree Graph Algorithms Time Complexity of Sorting Algorithms Applications of Stack in Data Structure Dictionary Data Structure Structured Data and Unstructured Data List Data Structure Types of Tree in Data Structure Abstract data type in data structure Disjoint set data structure Dynamic Data Structure Hash Function in Data Structure Complete Binary Tree Threaded Binary Tree Diameter of Binary Tree Height of Binary Tree Inorder Tree Traversal without Stack Enumeration of Binary Trees Maximum Width of a Binary Tree Types of Graph in Data Structure Primitive Data Type Semi-Structured Data Advance Data Structures Sort an Array of 0's, 1's, and 2's Stock Span Problem Implementation of Deque by Circular Array Rotate Operation in Linked List Subarray with given sum Self-organizing List Unrolled Linked List Types of Sparse Matrices Application of Linked List Topological Sorting Ternary Search Tree Stock Span Problem Treap Data Structure Quicksort on Doubly Linked List Inversion count Expression tree in DS Garbage Collection in DS Merge Sort on Doubly Linked List Sort Stack using Recursion LIFO Approach in data structure Big O Notation in DS Binary Tree Traversal in DS Queue Operations in DS What is a Non-Linear Data Structure FIFO Approach in data structure What are connected graphs in data structure Which Python data structure is immutable Which data structure is used by map What is iteration in data structure What are linear search and binary search in data structure Hash Table vs STL Map Recaman's Sequence Maximum area rectangle created by selecting four sides from an array Maximum number of distinct nodes in a root-to-leaf path DS MCQ Data Structure MCQ Advanced DS MCQ next ? ? prev Maximum number of distinct nodes in a root-to-leaf path Find the maximum number of distinct nodes in all root-to-leaf paths given a Binary Tree. Examples 
Input :   1
            /    \
           2      3
          / \    / \
        4   5  6   3
               \   \
                8   9 

Output : 4 
The root to leaf path with maximum distinct
nodes is 1-3-6-8.
 Exploring all root to leaf paths is a simple solution. Count distinct nodes along each root-to-leaf path and return the maximum number. Hashing is an efficient solution. We traverse the tree recursively, keeping track of the number of distinct nodes on the path from the root to the current node. We repeat for the left and right subtrees, returning the maximum of two values. The implementation of the above idea is shown below. Program in C++ 
// C++ program to find count of distinct nodes
// on a path with maximum distinct nodes.
#include <bits/stdc++.h>
using namespace std;

// A node of binary tree
struct Node {
	int data;
	struct Node *left, *right;
};

// A utility function to create a new Binary
// Tree node
Node* newNode(int data)
{
	Node* temp = new Node;
	temp->data = data;
	temp->left = temp->right = NULL;
	return temp;
}

int largestUinquePathUtil(Node* node, unordered_map<int, int> m)
{
	if (!node)
		return m.size();

	// put this node into hash
	m[node->data]++;

	int max_path = max(largestUinquePathUtil(node->left, m),
					largestUinquePathUtil(node->right, m));

	// remove current node from path "hash"
	m[node->data]--;

	// if we reached a condition where all duplicate value
	// of current node is deleted
	if (m[node->data] == 0)
		m.erase(node->data);

	return max_path;
}

// A utility function to find long unique value path
int largestUinquePath(Node* node)
{
	if (!node)
		return 0;

	// hash that store all node value
	unordered_map<int, int> hash;

	// return max length unique value path
	return largestUinquePathUtil(node, hash);
}

// Driver program to test above functions
int main()
{
	// Create binary tree shown in above figure
	Node* root = newNode(1);
	root->left = newNode(2);
	root->right = newNode(3);
	root->left->left = newNode(4);
	root->left->right = newNode(5);
	root->right->left = newNode(6);
	root->right->right = newNode(7);
	root->right->left->right = newNode(8);
	root->right->right->right = newNode(9);

	cout << largestUinquePath(root) << endl;

	return 0;
}
 Output 4
 Time Complexity : O (n) Next Topic# ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/maximum-number-of-distinct-nodes-in-a-root-to-leaf-path Maximum number of distinct nodes in a root-to-leaf path - javatpoint ? SCROLL TO TOP Home Data Structure C C++ C# Java SQL HTML CSS JavaScript Ajax Android Cloud Design Pattern Quiz Projects Interview Q Comment Forum DS Tutorial DS Tutorial DS Introduction DS Algorithm Asymptotic Analysis DS Pointer DS Structure DS Array DS Array 2D Array DS Linked List Linked List Types of Linked List Singly Linked List Doubly Linked List Circular Linked List Circular Doubly List Skip list in DS DS Stack DS Stack Array Implementation Linked List Implementation DS Queue DS Queue Types of Queues Array Representation Linked List Representation Circular Queue Deque Priority Queue DS Tree DS Tree Binary Tree Binary Search Tree AVL Tree B Tree B+ Tree DS Graph DS Graph Graph Implementation BFS Algorithm DFS Algorithm Spanning Tree DS Searching Linear Search Binary Search DS Sorting Bubble Sort Bucket Sort Comb Sort Counting Sort Heap Sort Insertion Sort Merge Sort Quick Sort Radix Sort Selection Sort Shell Sort Bitonic Sort Cocktail Sort Cycle Sort Tim Sort Differences Linear vs non-linear Array vs linked list Stack vs queue Linear vs Circular Queue Linear Search vs Binary Search Singly Linked List vs Doubly Linked List Binary vs Binary Search Tree Tree vs Graph Binary Search tree vs AVL tree Red Black Tree vs AVL tree B tree vs B+ tree Quick Sort vs Merge Sort BFS vs DFS Stack vs Heap Bubble sort vs. Selection sort Stack vs Array Full Binary Tree vs Complete Binary Tree Binary Tree vs B Tree Primitive vs non-primitive data structure Data types vs data structure Misc Trie Data Structure Heap Data Structure Splay Tree Fundamental of the DS Hash Table Preorder Traversal Tree Traversal Implementation of Queue using Stacks Implementation of Stack using Queue Binomial Heap Postorder Traversal Sparse Matrix Detect loop in a Linked list Inorder Traversal Convert Infix to Postfix notation Convert infix to prefix notation Conversion of Prefix to Postfix expression Conversion of Postfix to Prefix expression Remove the loop in a Linked List Implement two stacks in an array Reverse a stack using recursion Detect cycle in a directed graph Optimal Binary Search Tree Priority Queue using Linked list Balanced Binary Search Tree Boundary Traversal of Binary tree Diagonal Traversal of Binary Tree Vertical Traversal of a Binary tree Graph Algorithms Time Complexity of Sorting Algorithms Applications of Stack in Data Structure Dictionary Data Structure Structured Data and Unstructured Data List Data Structure Types of Tree in Data Structure Abstract data type in data structure Disjoint set data structure Dynamic Data Structure Hash Function in Data Structure Complete Binary Tree Threaded Binary Tree Diameter of Binary Tree Height of Binary Tree Inorder Tree Traversal without Stack Enumeration of Binary Trees Maximum Width of a Binary Tree Types of Graph in Data Structure Primitive Data Type Semi-Structured Data Advance Data Structures Sort an Array of 0's, 1's, and 2's Stock Span Problem Implementation of Deque by Circular Array Rotate Operation in Linked List Subarray with given sum Self-organizing List Unrolled Linked List Types of Sparse Matrices Application of Linked List Topological Sorting Ternary Search Tree Stock Span Problem Treap Data Structure Quicksort on Doubly Linked List Inversion count Expression tree in DS Garbage Collection in DS Merge Sort on Doubly Linked List Sort Stack using Recursion LIFO Approach in data structure Big O Notation in DS Binary Tree Traversal in DS Queue Operations in DS What is a Non-Linear Data Structure FIFO Approach in data structure What are connected graphs in data structure Which Python data structure is immutable Which data structure is used by map What is iteration in data structure What are linear search and binary search in data structure Hash Table vs STL Map Recaman's Sequence Maximum area rectangle created by selecting four sides from an array Maximum number of distinct nodes in a root-to-leaf path DS MCQ Data Structure MCQ Advanced DS MCQ next ? ? prev Maximum number of distinct nodes in a root-to-leaf path Find the maximum number of distinct nodes in all root-to-leaf paths given a Binary Tree. Examples 
Input :   1
            /    \
           2      3
          / \    / \
        4   5  6   3
               \   \
                8   9 

Output : 4 
The root to leaf path with maximum distinct
nodes is 1-3-6-8.
 Exploring all root to leaf paths is a simple solution. Count distinct nodes along each root-to-leaf path and return the maximum number. Hashing is an efficient solution. We traverse the tree recursively, keeping track of the number of distinct nodes on the path from the root to the current node. We repeat for the left and right subtrees, returning the maximum of two values. The implementation of the above idea is shown below. Program in C++ 
// C++ program to find count of distinct nodes
// on a path with maximum distinct nodes.
#include <bits/stdc++.h>
using namespace std;

// A node of binary tree
struct Node {
	int data;
	struct Node *left, *right;
};

// A utility function to create a new Binary
// Tree node
Node* newNode(int data)
{
	Node* temp = new Node;
	temp->data = data;
	temp->left = temp->right = NULL;
	return temp;
}

int largestUinquePathUtil(Node* node, unordered_map<int, int> m)
{
	if (!node)
		return m.size();

	// put this node into hash
	m[node->data]++;

	int max_path = max(largestUinquePathUtil(node->left, m),
					largestUinquePathUtil(node->right, m));

	// remove current node from path "hash"
	m[node->data]--;

	// if we reached a condition where all duplicate value
	// of current node is deleted
	if (m[node->data] == 0)
		m.erase(node->data);

	return max_path;
}

// A utility function to find long unique value path
int largestUinquePath(Node* node)
{
	if (!node)
		return 0;

	// hash that store all node value
	unordered_map<int, int> hash;

	// return max length unique value path
	return largestUinquePathUtil(node, hash);
}

// Driver program to test above functions
int main()
{
	// Create binary tree shown in above figure
	Node* root = newNode(1);
	root->left = newNode(2);
	root->right = newNode(3);
	root->left->left = newNode(4);
	root->left->right = newNode(5);
	root->right->left = newNode(6);
	root->right->right = newNode(7);
	root->right->left->right = newNode(8);
	root->right->right->right = newNode(9);

	cout << largestUinquePath(root) << endl;

	return 0;
}
 Output 4
 Time Complexity : O (n) Next Topic# ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/maximum-number-of-distinct-nodes-in-a-root-to-leaf-path Maximum number of distinct nodes in a root-to-leaf path - javatpoint ? SCROLL TO TOP Home Data Structure C C++ C# Java SQL HTML CSS JavaScript Ajax Android Cloud Design Pattern Quiz Projects Interview Q Comment Forum DS Tutorial DS Tutorial DS Introduction DS Algorithm Asymptotic Analysis DS Pointer DS Structure DS Array DS Array 2D Array DS Linked List Linked List Types of Linked List Singly Linked List Doubly Linked List Circular Linked List Circular Doubly List Skip list in DS DS Stack DS Stack Array Implementation Linked List Implementation DS Queue DS Queue Types of Queues Array Representation Linked List Representation Circular Queue Deque Priority Queue DS Tree DS Tree Binary Tree Binary Search Tree AVL Tree B Tree B+ Tree DS Graph DS Graph Graph Implementation BFS Algorithm DFS Algorithm Spanning Tree DS Searching Linear Search Binary Search DS Sorting Bubble Sort Bucket Sort Comb Sort Counting Sort Heap Sort Insertion Sort Merge Sort Quick Sort Radix Sort Selection Sort Shell Sort Bitonic Sort Cocktail Sort Cycle Sort Tim Sort Differences Linear vs non-linear Array vs linked list Stack vs queue Linear vs Circular Queue Linear Search vs Binary Search Singly Linked List vs Doubly Linked List Binary vs Binary Search Tree Tree vs Graph Binary Search tree vs AVL tree Red Black Tree vs AVL tree B tree vs B+ tree Quick Sort vs Merge Sort BFS vs DFS Stack vs Heap Bubble sort vs. Selection sort Stack vs Array Full Binary Tree vs Complete Binary Tree Binary Tree vs B Tree Primitive vs non-primitive data structure Data types vs data structure Misc Trie Data Structure Heap Data Structure Splay Tree Fundamental of the DS Hash Table Preorder Traversal Tree Traversal Implementation of Queue using Stacks Implementation of Stack using Queue Binomial Heap Postorder Traversal Sparse Matrix Detect loop in a Linked list Inorder Traversal Convert Infix to Postfix notation Convert infix to prefix notation Conversion of Prefix to Postfix expression Conversion of Postfix to Prefix expression Remove the loop in a Linked List Implement two stacks in an array Reverse a stack using recursion Detect cycle in a directed graph Optimal Binary Search Tree Priority Queue using Linked list Balanced Binary Search Tree Boundary Traversal of Binary tree Diagonal Traversal of Binary Tree Vertical Traversal of a Binary tree Graph Algorithms Time Complexity of Sorting Algorithms Applications of Stack in Data Structure Dictionary Data Structure Structured Data and Unstructured Data List Data Structure Types of Tree in Data Structure Abstract data type in data structure Disjoint set data structure Dynamic Data Structure Hash Function in Data Structure Complete Binary Tree Threaded Binary Tree Diameter of Binary Tree Height of Binary Tree Inorder Tree Traversal without Stack Enumeration of Binary Trees Maximum Width of a Binary Tree Types of Graph in Data Structure Primitive Data Type Semi-Structured Data Advance Data Structures Sort an Array of 0's, 1's, and 2's Stock Span Problem Implementation of Deque by Circular Array Rotate Operation in Linked List Subarray with given sum Self-organizing List Unrolled Linked List Types of Sparse Matrices Application of Linked List Topological Sorting Ternary Search Tree Stock Span Problem Treap Data Structure Quicksort on Doubly Linked List Inversion count Expression tree in DS Garbage Collection in DS Merge Sort on Doubly Linked List Sort Stack using Recursion LIFO Approach in data structure Big O Notation in DS Binary Tree Traversal in DS Queue Operations in DS What is a Non-Linear Data Structure FIFO Approach in data structure What are connected graphs in data structure Which Python data structure is immutable Which data structure is used by map What is iteration in data structure What are linear search and binary search in data structure Hash Table vs STL Map Recaman's Sequence Maximum area rectangle created by selecting four sides from an array Maximum number of distinct nodes in a root-to-leaf path DS MCQ Data Structure MCQ Advanced DS MCQ next ? ? prev Maximum number of distinct nodes in a root-to-leaf path Find the maximum number of distinct nodes in all root-to-leaf paths given a Binary Tree. Examples 
Input :   1
            /    \
           2      3
          / \    / \
        4   5  6   3
               \   \
                8   9 

Output : 4 
The root to leaf path with maximum distinct
nodes is 1-3-6-8.
 Exploring all root to leaf paths is a simple solution. Count distinct nodes along each root-to-leaf path and return the maximum number. Hashing is an efficient solution. We traverse the tree recursively, keeping track of the number of distinct nodes on the path from the root to the current node. We repeat for the left and right subtrees, returning the maximum of two values. The implementation of the above idea is shown below. Program in C++ 
// C++ program to find count of distinct nodes
// on a path with maximum distinct nodes.
#include <bits/stdc++.h>
using namespace std;

// A node of binary tree
struct Node {
	int data;
	struct Node *left, *right;
};

// A utility function to create a new Binary
// Tree node
Node* newNode(int data)
{
	Node* temp = new Node;
	temp->data = data;
	temp->left = temp->right = NULL;
	return temp;
}

int largestUinquePathUtil(Node* node, unordered_map<int, int> m)
{
	if (!node)
		return m.size();

	// put this node into hash
	m[node->data]++;

	int max_path = max(largestUinquePathUtil(node->left, m),
					largestUinquePathUtil(node->right, m));

	// remove current node from path "hash"
	m[node->data]--;

	// if we reached a condition where all duplicate value
	// of current node is deleted
	if (m[node->data] == 0)
		m.erase(node->data);

	return max_path;
}

// A utility function to find long unique value path
int largestUinquePath(Node* node)
{
	if (!node)
		return 0;

	// hash that store all node value
	unordered_map<int, int> hash;

	// return max length unique value path
	return largestUinquePathUtil(node, hash);
}

// Driver program to test above functions
int main()
{
	// Create binary tree shown in above figure
	Node* root = newNode(1);
	root->left = newNode(2);
	root->right = newNode(3);
	root->left->left = newNode(4);
	root->left->right = newNode(5);
	root->right->left = newNode(6);
	root->right->right = newNode(7);
	root->right->left->right = newNode(8);
	root->right->right->right = newNode(9);

	cout << largestUinquePath(root) << endl;

	return 0;
}
 Output 4
 Time Complexity : O (n) Next Topic# ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/maximum-number-of-distinct-nodes-in-a-root-to-leaf-path Maximum number of distinct nodes in a root-to-leaf path - javatpoint ? SCROLL TO TOP Home Data Structure C C++ C# Java SQL HTML CSS JavaScript Ajax Android Cloud Design Pattern Quiz Projects Interview Q Comment Forum DS Tutorial DS Tutorial DS Introduction DS Algorithm Asymptotic Analysis DS Pointer DS Structure DS Array DS Array 2D Array DS Linked List Linked List Types of Linked List Singly Linked List Doubly Linked List Circular Linked List Circular Doubly List Skip list in DS DS Stack DS Stack Array Implementation Linked List Implementation DS Queue DS Queue Types of Queues Array Representation Linked List Representation Circular Queue Deque Priority Queue DS Tree DS Tree Binary Tree Binary Search Tree AVL Tree B Tree B+ Tree DS Graph DS Graph Graph Implementation BFS Algorithm DFS Algorithm Spanning Tree DS Searching Linear Search Binary Search DS Sorting Bubble Sort Bucket Sort Comb Sort Counting Sort Heap Sort Insertion Sort Merge Sort Quick Sort Radix Sort Selection Sort Shell Sort Bitonic Sort Cocktail Sort Cycle Sort Tim Sort Differences Linear vs non-linear Array vs linked list Stack vs queue Linear vs Circular Queue Linear Search vs Binary Search Singly Linked List vs Doubly Linked List Binary vs Binary Search Tree Tree vs Graph Binary Search tree vs AVL tree Red Black Tree vs AVL tree B tree vs B+ tree Quick Sort vs Merge Sort BFS vs DFS Stack vs Heap Bubble sort vs. Selection sort Stack vs Array Full Binary Tree vs Complete Binary Tree Binary Tree vs B Tree Primitive vs non-primitive data structure Data types vs data structure Misc Trie Data Structure Heap Data Structure Splay Tree Fundamental of the DS Hash Table Preorder Traversal Tree Traversal Implementation of Queue using Stacks Implementation of Stack using Queue Binomial Heap Postorder Traversal Sparse Matrix Detect loop in a Linked list Inorder Traversal Convert Infix to Postfix notation Convert infix to prefix notation Conversion of Prefix to Postfix expression Conversion of Postfix to Prefix expression Remove the loop in a Linked List Implement two stacks in an array Reverse a stack using recursion Detect cycle in a directed graph Optimal Binary Search Tree Priority Queue using Linked list Balanced Binary Search Tree Boundary Traversal of Binary tree Diagonal Traversal of Binary Tree Vertical Traversal of a Binary tree Graph Algorithms Time Complexity of Sorting Algorithms Applications of Stack in Data Structure Dictionary Data Structure Structured Data and Unstructured Data List Data Structure Types of Tree in Data Structure Abstract data type in data structure Disjoint set data structure Dynamic Data Structure Hash Function in Data Structure Complete Binary Tree Threaded Binary Tree Diameter of Binary Tree Height of Binary Tree Inorder Tree Traversal without Stack Enumeration of Binary Trees Maximum Width of a Binary Tree Types of Graph in Data Structure Primitive Data Type Semi-Structured Data Advance Data Structures Sort an Array of 0's, 1's, and 2's Stock Span Problem Implementation of Deque by Circular Array Rotate Operation in Linked List Subarray with given sum Self-organizing List Unrolled Linked List Types of Sparse Matrices Application of Linked List Topological Sorting Ternary Search Tree Stock Span Problem Treap Data Structure Quicksort on Doubly Linked List Inversion count Expression tree in DS Garbage Collection in DS Merge Sort on Doubly Linked List Sort Stack using Recursion LIFO Approach in data structure Big O Notation in DS Binary Tree Traversal in DS Queue Operations in DS What is a Non-Linear Data Structure FIFO Approach in data structure What are connected graphs in data structure Which Python data structure is immutable Which data structure is used by map What is iteration in data structure What are linear search and binary search in data structure Hash Table vs STL Map Recaman's Sequence Maximum area rectangle created by selecting four sides from an array Maximum number of distinct nodes in a root-to-leaf path DS MCQ Data Structure MCQ Advanced DS MCQ next ? ? prev Maximum number of distinct nodes in a root-to-leaf path Find the maximum number of distinct nodes in all root-to-leaf paths given a Binary Tree. Examples 
Input :   1
            /    \
           2      3
          / \    / \
        4   5  6   3
               \   \
                8   9 

Output : 4 
The root to leaf path with maximum distinct
nodes is 1-3-6-8.
 Exploring all root to leaf paths is a simple solution. Count distinct nodes along each root-to-leaf path and return the maximum number. Hashing is an efficient solution. We traverse the tree recursively, keeping track of the number of distinct nodes on the path from the root to the current node. We repeat for the left and right subtrees, returning the maximum of two values. The implementation of the above idea is shown below. Program in C++ 
// C++ program to find count of distinct nodes
// on a path with maximum distinct nodes.
#include <bits/stdc++.h>
using namespace std;

// A node of binary tree
struct Node {
	int data;
	struct Node *left, *right;
};

// A utility function to create a new Binary
// Tree node
Node* newNode(int data)
{
	Node* temp = new Node;
	temp->data = data;
	temp->left = temp->right = NULL;
	return temp;
}

int largestUinquePathUtil(Node* node, unordered_map<int, int> m)
{
	if (!node)
		return m.size();

	// put this node into hash
	m[node->data]++;

	int max_path = max(largestUinquePathUtil(node->left, m),
					largestUinquePathUtil(node->right, m));

	// remove current node from path "hash"
	m[node->data]--;

	// if we reached a condition where all duplicate value
	// of current node is deleted
	if (m[node->data] == 0)
		m.erase(node->data);

	return max_path;
}

// A utility function to find long unique value path
int largestUinquePath(Node* node)
{
	if (!node)
		return 0;

	// hash that store all node value
	unordered_map<int, int> hash;

	// return max length unique value path
	return largestUinquePathUtil(node, hash);
}

// Driver program to test above functions
int main()
{
	// Create binary tree shown in above figure
	Node* root = newNode(1);
	root->left = newNode(2);
	root->right = newNode(3);
	root->left->left = newNode(4);
	root->left->right = newNode(5);
	root->right->left = newNode(6);
	root->right->right = newNode(7);
	root->right->left->right = newNode(8);
	root->right->right->right = newNode(9);

	cout << largestUinquePath(root) << endl;

	return 0;
}
 Output 4
 Time Complexity : O (n) Next Topic# ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/maximum-number-of-distinct-nodes-in-a-root-to-leaf-path Maximum number of distinct nodes in a root-to-leaf path - javatpoint ? SCROLL TO TOP Home Data Structure C C++ C# Java SQL HTML CSS JavaScript Ajax Android Cloud Design Pattern Quiz Projects Interview Q Comment Forum DS Tutorial DS Tutorial DS Introduction DS Algorithm Asymptotic Analysis DS Pointer DS Structure DS Array DS Array 2D Array DS Linked List Linked List Types of Linked List Singly Linked List Doubly Linked List Circular Linked List Circular Doubly List Skip list in DS DS Stack DS Stack Array Implementation Linked List Implementation DS Queue DS Queue Types of Queues Array Representation Linked List Representation Circular Queue Deque Priority Queue DS Tree DS Tree Binary Tree Binary Search Tree AVL Tree B Tree B+ Tree DS Graph DS Graph Graph Implementation BFS Algorithm DFS Algorithm Spanning Tree DS Searching Linear Search Binary Search DS Sorting Bubble Sort Bucket Sort Comb Sort Counting Sort Heap Sort Insertion Sort Merge Sort Quick Sort Radix Sort Selection Sort Shell Sort Bitonic Sort Cocktail Sort Cycle Sort Tim Sort Differences Linear vs non-linear Array vs linked list Stack vs queue Linear vs Circular Queue Linear Search vs Binary Search Singly Linked List vs Doubly Linked List Binary vs Binary Search Tree Tree vs Graph Binary Search tree vs AVL tree Red Black Tree vs AVL tree B tree vs B+ tree Quick Sort vs Merge Sort BFS vs DFS Stack vs Heap Bubble sort vs. Selection sort Stack vs Array Full Binary Tree vs Complete Binary Tree Binary Tree vs B Tree Primitive vs non-primitive data structure Data types vs data structure Misc Trie Data Structure Heap Data Structure Splay Tree Fundamental of the DS Hash Table Preorder Traversal Tree Traversal Implementation of Queue using Stacks Implementation of Stack using Queue Binomial Heap Postorder Traversal Sparse Matrix Detect loop in a Linked list Inorder Traversal Convert Infix to Postfix notation Convert infix to prefix notation Conversion of Prefix to Postfix expression Conversion of Postfix to Prefix expression Remove the loop in a Linked List Implement two stacks in an array Reverse a stack using recursion Detect cycle in a directed graph Optimal Binary Search Tree Priority Queue using Linked list Balanced Binary Search Tree Boundary Traversal of Binary tree Diagonal Traversal of Binary Tree Vertical Traversal of a Binary tree Graph Algorithms Time Complexity of Sorting Algorithms Applications of Stack in Data Structure Dictionary Data Structure Structured Data and Unstructured Data List Data Structure Types of Tree in Data Structure Abstract data type in data structure Disjoint set data structure Dynamic Data Structure Hash Function in Data Structure Complete Binary Tree Threaded Binary Tree Diameter of Binary Tree Height of Binary Tree Inorder Tree Traversal without Stack Enumeration of Binary Trees Maximum Width of a Binary Tree Types of Graph in Data Structure Primitive Data Type Semi-Structured Data Advance Data Structures Sort an Array of 0's, 1's, and 2's Stock Span Problem Implementation of Deque by Circular Array Rotate Operation in Linked List Subarray with given sum Self-organizing List Unrolled Linked List Types of Sparse Matrices Application of Linked List Topological Sorting Ternary Search Tree Stock Span Problem Treap Data Structure Quicksort on Doubly Linked List Inversion count Expression tree in DS Garbage Collection in DS Merge Sort on Doubly Linked List Sort Stack using Recursion LIFO Approach in data structure Big O Notation in DS Binary Tree Traversal in DS Queue Operations in DS What is a Non-Linear Data Structure FIFO Approach in data structure What are connected graphs in data structure Which Python data structure is immutable Which data structure is used by map What is iteration in data structure What are linear search and binary search in data structure Hash Table vs STL Map Recaman's Sequence Maximum area rectangle created by selecting four sides from an array Maximum number of distinct nodes in a root-to-leaf path DS MCQ Data Structure MCQ Advanced DS MCQ next ? ? prev Maximum number of distinct nodes in a root-to-leaf path Find the maximum number of distinct nodes in all root-to-leaf paths given a Binary Tree. Examples 
Input :   1
            /    \
           2      3
          / \    / \
        4   5  6   3
               \   \
                8   9 

Output : 4 
The root to leaf path with maximum distinct
nodes is 1-3-6-8.
 Exploring all root to leaf paths is a simple solution. Count distinct nodes along each root-to-leaf path and return the maximum number. Hashing is an efficient solution. We traverse the tree recursively, keeping track of the number of distinct nodes on the path from the root to the current node. We repeat for the left and right subtrees, returning the maximum of two values. The implementation of the above idea is shown below. Program in C++ 
// C++ program to find count of distinct nodes
// on a path with maximum distinct nodes.
#include <bits/stdc++.h>
using namespace std;

// A node of binary tree
struct Node {
	int data;
	struct Node *left, *right;
};

// A utility function to create a new Binary
// Tree node
Node* newNode(int data)
{
	Node* temp = new Node;
	temp->data = data;
	temp->left = temp->right = NULL;
	return temp;
}

int largestUinquePathUtil(Node* node, unordered_map<int, int> m)
{
	if (!node)
		return m.size();

	// put this node into hash
	m[node->data]++;

	int max_path = max(largestUinquePathUtil(node->left, m),
					largestUinquePathUtil(node->right, m));

	// remove current node from path "hash"
	m[node->data]--;

	// if we reached a condition where all duplicate value
	// of current node is deleted
	if (m[node->data] == 0)
		m.erase(node->data);

	return max_path;
}

// A utility function to find long unique value path
int largestUinquePath(Node* node)
{
	if (!node)
		return 0;

	// hash that store all node value
	unordered_map<int, int> hash;

	// return max length unique value path
	return largestUinquePathUtil(node, hash);
}

// Driver program to test above functions
int main()
{
	// Create binary tree shown in above figure
	Node* root = newNode(1);
	root->left = newNode(2);
	root->right = newNode(3);
	root->left->left = newNode(4);
	root->left->right = newNode(5);
	root->right->left = newNode(6);
	root->right->right = newNode(7);
	root->right->left->right = newNode(8);
	root->right->right->right = newNode(9);

	cout << largestUinquePath(root) << endl;

	return 0;
}
 Output 4
 Time Complexity : O (n) Next Topic# ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/maximum-number-of-distinct-nodes-in-a-root-to-leaf-path Maximum number of distinct nodes in a root-to-leaf path - javatpoint ? SCROLL TO TOP Home Data Structure C C++ C# Java SQL HTML CSS JavaScript Ajax Android Cloud Design Pattern Quiz Projects Interview Q Comment Forum DS Tutorial DS Tutorial DS Introduction DS Algorithm Asymptotic Analysis DS Pointer DS Structure DS Array DS Array 2D Array DS Linked List Linked List Types of Linked List Singly Linked List Doubly Linked List Circular Linked List Circular Doubly List Skip list in DS DS Stack DS Stack Array Implementation Linked List Implementation DS Queue DS Queue Types of Queues Array Representation Linked List Representation Circular Queue Deque Priority Queue DS Tree DS Tree Binary Tree Binary Search Tree AVL Tree B Tree B+ Tree DS Graph DS Graph Graph Implementation BFS Algorithm DFS Algorithm Spanning Tree DS Searching Linear Search Binary Search DS Sorting Bubble Sort Bucket Sort Comb Sort Counting Sort Heap Sort Insertion Sort Merge Sort Quick Sort Radix Sort Selection Sort Shell Sort Bitonic Sort Cocktail Sort Cycle Sort Tim Sort Differences Linear vs non-linear Array vs linked list Stack vs queue Linear vs Circular Queue Linear Search vs Binary Search Singly Linked List vs Doubly Linked List Binary vs Binary Search Tree Tree vs Graph Binary Search tree vs AVL tree Red Black Tree vs AVL tree B tree vs B+ tree Quick Sort vs Merge Sort BFS vs DFS Stack vs Heap Bubble sort vs. Selection sort Stack vs Array Full Binary Tree vs Complete Binary Tree Binary Tree vs B Tree Primitive vs non-primitive data structure Data types vs data structure Misc Trie Data Structure Heap Data Structure Splay Tree Fundamental of the DS Hash Table Preorder Traversal Tree Traversal Implementation of Queue using Stacks Implementation of Stack using Queue Binomial Heap Postorder Traversal Sparse Matrix Detect loop in a Linked list Inorder Traversal Convert Infix to Postfix notation Convert infix to prefix notation Conversion of Prefix to Postfix expression Conversion of Postfix to Prefix expression Remove the loop in a Linked List Implement two stacks in an array Reverse a stack using recursion Detect cycle in a directed graph Optimal Binary Search Tree Priority Queue using Linked list Balanced Binary Search Tree Boundary Traversal of Binary tree Diagonal Traversal of Binary Tree Vertical Traversal of a Binary tree Graph Algorithms Time Complexity of Sorting Algorithms Applications of Stack in Data Structure Dictionary Data Structure Structured Data and Unstructured Data List Data Structure Types of Tree in Data Structure Abstract data type in data structure Disjoint set data structure Dynamic Data Structure Hash Function in Data Structure Complete Binary Tree Threaded Binary Tree Diameter of Binary Tree Height of Binary Tree Inorder Tree Traversal without Stack Enumeration of Binary Trees Maximum Width of a Binary Tree Types of Graph in Data Structure Primitive Data Type Semi-Structured Data Advance Data Structures Sort an Array of 0's, 1's, and 2's Stock Span Problem Implementation of Deque by Circular Array Rotate Operation in Linked List Subarray with given sum Self-organizing List Unrolled Linked List Types of Sparse Matrices Application of Linked List Topological Sorting Ternary Search Tree Stock Span Problem Treap Data Structure Quicksort on Doubly Linked List Inversion count Expression tree in DS Garbage Collection in DS Merge Sort on Doubly Linked List Sort Stack using Recursion LIFO Approach in data structure Big O Notation in DS Binary Tree Traversal in DS Queue Operations in DS What is a Non-Linear Data Structure FIFO Approach in data structure What are connected graphs in data structure Which Python data structure is immutable Which data structure is used by map What is iteration in data structure What are linear search and binary search in data structure Hash Table vs STL Map Recaman's Sequence Maximum area rectangle created by selecting four sides from an array Maximum number of distinct nodes in a root-to-leaf path DS MCQ Data Structure MCQ Advanced DS MCQ next ? ? prev Maximum number of distinct nodes in a root-to-leaf path Find the maximum number of distinct nodes in all root-to-leaf paths given a Binary Tree. Examples 
Input :   1
            /    \
           2      3
          / \    / \
        4   5  6   3
               \   \
                8   9 

Output : 4 
The root to leaf path with maximum distinct
nodes is 1-3-6-8.
 Exploring all root to leaf paths is a simple solution. Count distinct nodes along each root-to-leaf path and return the maximum number. Hashing is an efficient solution. We traverse the tree recursively, keeping track of the number of distinct nodes on the path from the root to the current node. We repeat for the left and right subtrees, returning the maximum of two values. The implementation of the above idea is shown below. Program in C++ 
// C++ program to find count of distinct nodes
// on a path with maximum distinct nodes.
#include <bits/stdc++.h>
using namespace std;

// A node of binary tree
struct Node {
	int data;
	struct Node *left, *right;
};

// A utility function to create a new Binary
// Tree node
Node* newNode(int data)
{
	Node* temp = new Node;
	temp->data = data;
	temp->left = temp->right = NULL;
	return temp;
}

int largestUinquePathUtil(Node* node, unordered_map<int, int> m)
{
	if (!node)
		return m.size();

	// put this node into hash
	m[node->data]++;

	int max_path = max(largestUinquePathUtil(node->left, m),
					largestUinquePathUtil(node->right, m));

	// remove current node from path "hash"
	m[node->data]--;

	// if we reached a condition where all duplicate value
	// of current node is deleted
	if (m[node->data] == 0)
		m.erase(node->data);

	return max_path;
}

// A utility function to find long unique value path
int largestUinquePath(Node* node)
{
	if (!node)
		return 0;

	// hash that store all node value
	unordered_map<int, int> hash;

	// return max length unique value path
	return largestUinquePathUtil(node, hash);
}

// Driver program to test above functions
int main()
{
	// Create binary tree shown in above figure
	Node* root = newNode(1);
	root->left = newNode(2);
	root->right = newNode(3);
	root->left->left = newNode(4);
	root->left->right = newNode(5);
	root->right->left = newNode(6);
	root->right->right = newNode(7);
	root->right->left->right = newNode(8);
	root->right->right->right = newNode(9);

	cout << largestUinquePath(root) << endl;

	return 0;
}
 Output 4
 Time Complexity : O (n) Next Topic# ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/maximum-number-of-distinct-nodes-in-a-root-to-leaf-path Maximum number of distinct nodes in a root-to-leaf path - javatpoint ? SCROLL TO TOP Home Data Structure C C++ C# Java SQL HTML CSS JavaScript Ajax Android Cloud Design Pattern Quiz Projects Interview Q Comment Forum DS Tutorial DS Tutorial DS Introduction DS Algorithm Asymptotic Analysis DS Pointer DS Structure DS Array DS Array 2D Array DS Linked List Linked List Types of Linked List Singly Linked List Doubly Linked List Circular Linked List Circular Doubly List Skip list in DS DS Stack DS Stack Array Implementation Linked List Implementation DS Queue DS Queue Types of Queues Array Representation Linked List Representation Circular Queue Deque Priority Queue DS Tree DS Tree Binary Tree Binary Search Tree AVL Tree B Tree B+ Tree DS Graph DS Graph Graph Implementation BFS Algorithm DFS Algorithm Spanning Tree DS Searching Linear Search Binary Search DS Sorting Bubble Sort Bucket Sort Comb Sort Counting Sort Heap Sort Insertion Sort Merge Sort Quick Sort Radix Sort Selection Sort Shell Sort Bitonic Sort Cocktail Sort Cycle Sort Tim Sort Differences Linear vs non-linear Array vs linked list Stack vs queue Linear vs Circular Queue Linear Search vs Binary Search Singly Linked List vs Doubly Linked List Binary vs Binary Search Tree Tree vs Graph Binary Search tree vs AVL tree Red Black Tree vs AVL tree B tree vs B+ tree Quick Sort vs Merge Sort BFS vs DFS Stack vs Heap Bubble sort vs. Selection sort Stack vs Array Full Binary Tree vs Complete Binary Tree Binary Tree vs B Tree Primitive vs non-primitive data structure Data types vs data structure Misc Trie Data Structure Heap Data Structure Splay Tree Fundamental of the DS Hash Table Preorder Traversal Tree Traversal Implementation of Queue using Stacks Implementation of Stack using Queue Binomial Heap Postorder Traversal Sparse Matrix Detect loop in a Linked list Inorder Traversal Convert Infix to Postfix notation Convert infix to prefix notation Conversion of Prefix to Postfix expression Conversion of Postfix to Prefix expression Remove the loop in a Linked List Implement two stacks in an array Reverse a stack using recursion Detect cycle in a directed graph Optimal Binary Search Tree Priority Queue using Linked list Balanced Binary Search Tree Boundary Traversal of Binary tree Diagonal Traversal of Binary Tree Vertical Traversal of a Binary tree Graph Algorithms Time Complexity of Sorting Algorithms Applications of Stack in Data Structure Dictionary Data Structure Structured Data and Unstructured Data List Data Structure Types of Tree in Data Structure Abstract data type in data structure Disjoint set data structure Dynamic Data Structure Hash Function in Data Structure Complete Binary Tree Threaded Binary Tree Diameter of Binary Tree Height of Binary Tree Inorder Tree Traversal without Stack Enumeration of Binary Trees Maximum Width of a Binary Tree Types of Graph in Data Structure Primitive Data Type Semi-Structured Data Advance Data Structures Sort an Array of 0's, 1's, and 2's Stock Span Problem Implementation of Deque by Circular Array Rotate Operation in Linked List Subarray with given sum Self-organizing List Unrolled Linked List Types of Sparse Matrices Application of Linked List Topological Sorting Ternary Search Tree Stock Span Problem Treap Data Structure Quicksort on Doubly Linked List Inversion count Expression tree in DS Garbage Collection in DS Merge Sort on Doubly Linked List Sort Stack using Recursion LIFO Approach in data structure Big O Notation in DS Binary Tree Traversal in DS Queue Operations in DS What is a Non-Linear Data Structure FIFO Approach in data structure What are connected graphs in data structure Which Python data structure is immutable Which data structure is used by map What is iteration in data structure What are linear search and binary search in data structure Hash Table vs STL Map Recaman's Sequence Maximum area rectangle created by selecting four sides from an array Maximum number of distinct nodes in a root-to-leaf path DS MCQ Data Structure MCQ Advanced DS MCQ next ? ? prev Maximum number of distinct nodes in a root-to-leaf path Find the maximum number of distinct nodes in all root-to-leaf paths given a Binary Tree. Examples 
Input :   1
            /    \
           2      3
          / \    / \
        4   5  6   3
               \   \
                8   9 

Output : 4 
The root to leaf path with maximum distinct
nodes is 1-3-6-8.
 Exploring all root to leaf paths is a simple solution. Count distinct nodes along each root-to-leaf path and return the maximum number. Hashing is an efficient solution. We traverse the tree recursively, keeping track of the number of distinct nodes on the path from the root to the current node. We repeat for the left and right subtrees, returning the maximum of two values. The implementation of the above idea is shown below. Program in C++ 
// C++ program to find count of distinct nodes
// on a path with maximum distinct nodes.
#include <bits/stdc++.h>
using namespace std;

// A node of binary tree
struct Node {
	int data;
	struct Node *left, *right;
};

// A utility function to create a new Binary
// Tree node
Node* newNode(int data)
{
	Node* temp = new Node;
	temp->data = data;
	temp->left = temp->right = NULL;
	return temp;
}

int largestUinquePathUtil(Node* node, unordered_map<int, int> m)
{
	if (!node)
		return m.size();

	// put this node into hash
	m[node->data]++;

	int max_path = max(largestUinquePathUtil(node->left, m),
					largestUinquePathUtil(node->right, m));

	// remove current node from path "hash"
	m[node->data]--;

	// if we reached a condition where all duplicate value
	// of current node is deleted
	if (m[node->data] == 0)
		m.erase(node->data);

	return max_path;
}

// A utility function to find long unique value path
int largestUinquePath(Node* node)
{
	if (!node)
		return 0;

	// hash that store all node value
	unordered_map<int, int> hash;

	// return max length unique value path
	return largestUinquePathUtil(node, hash);
}

// Driver program to test above functions
int main()
{
	// Create binary tree shown in above figure
	Node* root = newNode(1);
	root->left = newNode(2);
	root->right = newNode(3);
	root->left->left = newNode(4);
	root->left->right = newNode(5);
	root->right->left = newNode(6);
	root->right->right = newNode(7);
	root->right->left->right = newNode(8);
	root->right->right->right = newNode(9);

	cout << largestUinquePath(root) << endl;

	return 0;
}
 Output 4
 Time Complexity : O (n) Next Topic# ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/maximum-number-of-distinct-nodes-in-a-root-to-leaf-path Maximum number of distinct nodes in a root-to-leaf path - javatpoint ? SCROLL TO TOP Home Data Structure C C++ C# Java SQL HTML CSS JavaScript Ajax Android Cloud Design Pattern Quiz Projects Interview Q Comment Forum DS Tutorial DS Tutorial DS Introduction DS Algorithm Asymptotic Analysis DS Pointer DS Structure DS Array DS Array 2D Array DS Linked List Linked List Types of Linked List Singly Linked List Doubly Linked List Circular Linked List Circular Doubly List Skip list in DS DS Stack DS Stack Array Implementation Linked List Implementation DS Queue DS Queue Types of Queues Array Representation Linked List Representation Circular Queue Deque Priority Queue DS Tree DS Tree Binary Tree Binary Search Tree AVL Tree B Tree B+ Tree DS Graph DS Graph Graph Implementation BFS Algorithm DFS Algorithm Spanning Tree DS Searching Linear Search Binary Search DS Sorting Bubble Sort Bucket Sort Comb Sort Counting Sort Heap Sort Insertion Sort Merge Sort Quick Sort Radix Sort Selection Sort Shell Sort Bitonic Sort Cocktail Sort Cycle Sort Tim Sort Differences Linear vs non-linear Array vs linked list Stack vs queue Linear vs Circular Queue Linear Search vs Binary Search Singly Linked List vs Doubly Linked List Binary vs Binary Search Tree Tree vs Graph Binary Search tree vs AVL tree Red Black Tree vs AVL tree B tree vs B+ tree Quick Sort vs Merge Sort BFS vs DFS Stack vs Heap Bubble sort vs. Selection sort Stack vs Array Full Binary Tree vs Complete Binary Tree Binary Tree vs B Tree Primitive vs non-primitive data structure Data types vs data structure Misc Trie Data Structure Heap Data Structure Splay Tree Fundamental of the DS Hash Table Preorder Traversal Tree Traversal Implementation of Queue using Stacks Implementation of Stack using Queue Binomial Heap Postorder Traversal Sparse Matrix Detect loop in a Linked list Inorder Traversal Convert Infix to Postfix notation Convert infix to prefix notation Conversion of Prefix to Postfix expression Conversion of Postfix to Prefix expression Remove the loop in a Linked List Implement two stacks in an array Reverse a stack using recursion Detect cycle in a directed graph Optimal Binary Search Tree Priority Queue using Linked list Balanced Binary Search Tree Boundary Traversal of Binary tree Diagonal Traversal of Binary Tree Vertical Traversal of a Binary tree Graph Algorithms Time Complexity of Sorting Algorithms Applications of Stack in Data Structure Dictionary Data Structure Structured Data and Unstructured Data List Data Structure Types of Tree in Data Structure Abstract data type in data structure Disjoint set data structure Dynamic Data Structure Hash Function in Data Structure Complete Binary Tree Threaded Binary Tree Diameter of Binary Tree Height of Binary Tree Inorder Tree Traversal without Stack Enumeration of Binary Trees Maximum Width of a Binary Tree Types of Graph in Data Structure Primitive Data Type Semi-Structured Data Advance Data Structures Sort an Array of 0's, 1's, and 2's Stock Span Problem Implementation of Deque by Circular Array Rotate Operation in Linked List Subarray with given sum Self-organizing List Unrolled Linked List Types of Sparse Matrices Application of Linked List Topological Sorting Ternary Search Tree Stock Span Problem Treap Data Structure Quicksort on Doubly Linked List Inversion count Expression tree in DS Garbage Collection in DS Merge Sort on Doubly Linked List Sort Stack using Recursion LIFO Approach in data structure Big O Notation in DS Binary Tree Traversal in DS Queue Operations in DS What is a Non-Linear Data Structure FIFO Approach in data structure What are connected graphs in data structure Which Python data structure is immutable Which data structure is used by map What is iteration in data structure What are linear search and binary search in data structure Hash Table vs STL Map Recaman's Sequence Maximum area rectangle created by selecting four sides from an array Maximum number of distinct nodes in a root-to-leaf path DS MCQ Data Structure MCQ Advanced DS MCQ next ? ? prev Maximum number of distinct nodes in a root-to-leaf path Find the maximum number of distinct nodes in all root-to-leaf paths given a Binary Tree. Examples 
Input :   1
            /    \
           2      3
          / \    / \
        4   5  6   3
               \   \
                8   9 

Output : 4 
The root to leaf path with maximum distinct
nodes is 1-3-6-8.
 Exploring all root to leaf paths is a simple solution. Count distinct nodes along each root-to-leaf path and return the maximum number. Hashing is an efficient solution. We traverse the tree recursively, keeping track of the number of distinct nodes on the path from the root to the current node. We repeat for the left and right subtrees, returning the maximum of two values. The implementation of the above idea is shown below. Program in C++ 
// C++ program to find count of distinct nodes
// on a path with maximum distinct nodes.
#include <bits/stdc++.h>
using namespace std;

// A node of binary tree
struct Node {
	int data;
	struct Node *left, *right;
};

// A utility function to create a new Binary
// Tree node
Node* newNode(int data)
{
	Node* temp = new Node;
	temp->data = data;
	temp->left = temp->right = NULL;
	return temp;
}

int largestUinquePathUtil(Node* node, unordered_map<int, int> m)
{
	if (!node)
		return m.size();

	// put this node into hash
	m[node->data]++;

	int max_path = max(largestUinquePathUtil(node->left, m),
					largestUinquePathUtil(node->right, m));

	// remove current node from path "hash"
	m[node->data]--;

	// if we reached a condition where all duplicate value
	// of current node is deleted
	if (m[node->data] == 0)
		m.erase(node->data);

	return max_path;
}

// A utility function to find long unique value path
int largestUinquePath(Node* node)
{
	if (!node)
		return 0;

	// hash that store all node value
	unordered_map<int, int> hash;

	// return max length unique value path
	return largestUinquePathUtil(node, hash);
}

// Driver program to test above functions
int main()
{
	// Create binary tree shown in above figure
	Node* root = newNode(1);
	root->left = newNode(2);
	root->right = newNode(3);
	root->left->left = newNode(4);
	root->left->right = newNode(5);
	root->right->left = newNode(6);
	root->right->right = newNode(7);
	root->right->left->right = newNode(8);
	root->right->right->right = newNode(9);

	cout << largestUinquePath(root) << endl;

	return 0;
}
 Output 4
 Time Complexity : O (n) Next Topic# ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/maximum-number-of-distinct-nodes-in-a-root-to-leaf-path Maximum number of distinct nodes in a root-to-leaf path - javatpoint ? SCROLL TO TOP Home Data Structure C C++ C# Java SQL HTML CSS JavaScript Ajax Android Cloud Design Pattern Quiz Projects Interview Q Comment Forum DS Tutorial DS Tutorial DS Introduction DS Algorithm Asymptotic Analysis DS Pointer DS Structure DS Array DS Array 2D Array DS Linked List Linked List Types of Linked List Singly Linked List Doubly Linked List Circular Linked List Circular Doubly List Skip list in DS DS Stack DS Stack Array Implementation Linked List Implementation DS Queue DS Queue Types of Queues Array Representation Linked List Representation Circular Queue Deque Priority Queue DS Tree DS Tree Binary Tree Binary Search Tree AVL Tree B Tree B+ Tree DS Graph DS Graph Graph Implementation BFS Algorithm DFS Algorithm Spanning Tree DS Searching Linear Search Binary Search DS Sorting Bubble Sort Bucket Sort Comb Sort Counting Sort Heap Sort Insertion Sort Merge Sort Quick Sort Radix Sort Selection Sort Shell Sort Bitonic Sort Cocktail Sort Cycle Sort Tim Sort Differences Linear vs non-linear Array vs linked list Stack vs queue Linear vs Circular Queue Linear Search vs Binary Search Singly Linked List vs Doubly Linked List Binary vs Binary Search Tree Tree vs Graph Binary Search tree vs AVL tree Red Black Tree vs AVL tree B tree vs B+ tree Quick Sort vs Merge Sort BFS vs DFS Stack vs Heap Bubble sort vs. Selection sort Stack vs Array Full Binary Tree vs Complete Binary Tree Binary Tree vs B Tree Primitive vs non-primitive data structure Data types vs data structure Misc Trie Data Structure Heap Data Structure Splay Tree Fundamental of the DS Hash Table Preorder Traversal Tree Traversal Implementation of Queue using Stacks Implementation of Stack using Queue Binomial Heap Postorder Traversal Sparse Matrix Detect loop in a Linked list Inorder Traversal Convert Infix to Postfix notation Convert infix to prefix notation Conversion of Prefix to Postfix expression Conversion of Postfix to Prefix expression Remove the loop in a Linked List Implement two stacks in an array Reverse a stack using recursion Detect cycle in a directed graph Optimal Binary Search Tree Priority Queue using Linked list Balanced Binary Search Tree Boundary Traversal of Binary tree Diagonal Traversal of Binary Tree Vertical Traversal of a Binary tree Graph Algorithms Time Complexity of Sorting Algorithms Applications of Stack in Data Structure Dictionary Data Structure Structured Data and Unstructured Data List Data Structure Types of Tree in Data Structure Abstract data type in data structure Disjoint set data structure Dynamic Data Structure Hash Function in Data Structure Complete Binary Tree Threaded Binary Tree Diameter of Binary Tree Height of Binary Tree Inorder Tree Traversal without Stack Enumeration of Binary Trees Maximum Width of a Binary Tree Types of Graph in Data Structure Primitive Data Type Semi-Structured Data Advance Data Structures Sort an Array of 0's, 1's, and 2's Stock Span Problem Implementation of Deque by Circular Array Rotate Operation in Linked List Subarray with given sum Self-organizing List Unrolled Linked List Types of Sparse Matrices Application of Linked List Topological Sorting Ternary Search Tree Stock Span Problem Treap Data Structure Quicksort on Doubly Linked List Inversion count Expression tree in DS Garbage Collection in DS Merge Sort on Doubly Linked List Sort Stack using Recursion LIFO Approach in data structure Big O Notation in DS Binary Tree Traversal in DS Queue Operations in DS What is a Non-Linear Data Structure FIFO Approach in data structure What are connected graphs in data structure Which Python data structure is immutable Which data structure is used by map What is iteration in data structure What are linear search and binary search in data structure Hash Table vs STL Map Recaman's Sequence Maximum area rectangle created by selecting four sides from an array Maximum number of distinct nodes in a root-to-leaf path DS MCQ Data Structure MCQ Advanced DS MCQ next ? ? prev Maximum number of distinct nodes in a root-to-leaf path Find the maximum number of distinct nodes in all root-to-leaf paths given a Binary Tree. Examples 
Input :   1
            /    \
           2      3
          / \    / \
        4   5  6   3
               \   \
                8   9 

Output : 4 
The root to leaf path with maximum distinct
nodes is 1-3-6-8.
 Exploring all root to leaf paths is a simple solution. Count distinct nodes along each root-to-leaf path and return the maximum number. Hashing is an efficient solution. We traverse the tree recursively, keeping track of the number of distinct nodes on the path from the root to the current node. We repeat for the left and right subtrees, returning the maximum of two values. The implementation of the above idea is shown below. Program in C++ 
// C++ program to find count of distinct nodes
// on a path with maximum distinct nodes.
#include <bits/stdc++.h>
using namespace std;

// A node of binary tree
struct Node {
	int data;
	struct Node *left, *right;
};

// A utility function to create a new Binary
// Tree node
Node* newNode(int data)
{
	Node* temp = new Node;
	temp->data = data;
	temp->left = temp->right = NULL;
	return temp;
}

int largestUinquePathUtil(Node* node, unordered_map<int, int> m)
{
	if (!node)
		return m.size();

	// put this node into hash
	m[node->data]++;

	int max_path = max(largestUinquePathUtil(node->left, m),
					largestUinquePathUtil(node->right, m));

	// remove current node from path "hash"
	m[node->data]--;

	// if we reached a condition where all duplicate value
	// of current node is deleted
	if (m[node->data] == 0)
		m.erase(node->data);

	return max_path;
}

// A utility function to find long unique value path
int largestUinquePath(Node* node)
{
	if (!node)
		return 0;

	// hash that store all node value
	unordered_map<int, int> hash;

	// return max length unique value path
	return largestUinquePathUtil(node, hash);
}

// Driver program to test above functions
int main()
{
	// Create binary tree shown in above figure
	Node* root = newNode(1);
	root->left = newNode(2);
	root->right = newNode(3);
	root->left->left = newNode(4);
	root->left->right = newNode(5);
	root->right->left = newNode(6);
	root->right->right = newNode(7);
	root->right->left->right = newNode(8);
	root->right->right->right = newNode(9);

	cout << largestUinquePath(root) << endl;

	return 0;
}
 Output 4
 Time Complexity : O (n) Next Topic# ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/maximum-number-of-distinct-nodes-in-a-root-to-leaf-path Maximum number of distinct nodes in a root-to-leaf path - javatpoint ? SCROLL TO TOP Home Data Structure C C++ C# Java SQL HTML CSS JavaScript Ajax Android Cloud Design Pattern Quiz Projects Interview Q Comment Forum DS Tutorial DS Tutorial DS Introduction DS Algorithm Asymptotic Analysis DS Pointer DS Structure DS Array DS Array 2D Array DS Linked List Linked List Types of Linked List Singly Linked List Doubly Linked List Circular Linked List Circular Doubly List Skip list in DS DS Stack DS Stack Array Implementation Linked List Implementation DS Queue DS Queue Types of Queues Array Representation Linked List Representation Circular Queue Deque Priority Queue DS Tree DS Tree Binary Tree Binary Search Tree AVL Tree B Tree B+ Tree DS Graph DS Graph Graph Implementation BFS Algorithm DFS Algorithm Spanning Tree DS Searching Linear Search Binary Search DS Sorting Bubble Sort Bucket Sort Comb Sort Counting Sort Heap Sort Insertion Sort Merge Sort Quick Sort Radix Sort Selection Sort Shell Sort Bitonic Sort Cocktail Sort Cycle Sort Tim Sort Differences Linear vs non-linear Array vs linked list Stack vs queue Linear vs Circular Queue Linear Search vs Binary Search Singly Linked List vs Doubly Linked List Binary vs Binary Search Tree Tree vs Graph Binary Search tree vs AVL tree Red Black Tree vs AVL tree B tree vs B+ tree Quick Sort vs Merge Sort BFS vs DFS Stack vs Heap Bubble sort vs. Selection sort Stack vs Array Full Binary Tree vs Complete Binary Tree Binary Tree vs B Tree Primitive vs non-primitive data structure Data types vs data structure Misc Trie Data Structure Heap Data Structure Splay Tree Fundamental of the DS Hash Table Preorder Traversal Tree Traversal Implementation of Queue using Stacks Implementation of Stack using Queue Binomial Heap Postorder Traversal Sparse Matrix Detect loop in a Linked list Inorder Traversal Convert Infix to Postfix notation Convert infix to prefix notation Conversion of Prefix to Postfix expression Conversion of Postfix to Prefix expression Remove the loop in a Linked List Implement two stacks in an array Reverse a stack using recursion Detect cycle in a directed graph Optimal Binary Search Tree Priority Queue using Linked list Balanced Binary Search Tree Boundary Traversal of Binary tree Diagonal Traversal of Binary Tree Vertical Traversal of a Binary tree Graph Algorithms Time Complexity of Sorting Algorithms Applications of Stack in Data Structure Dictionary Data Structure Structured Data and Unstructured Data List Data Structure Types of Tree in Data Structure Abstract data type in data structure Disjoint set data structure Dynamic Data Structure Hash Function in Data Structure Complete Binary Tree Threaded Binary Tree Diameter of Binary Tree Height of Binary Tree Inorder Tree Traversal without Stack Enumeration of Binary Trees Maximum Width of a Binary Tree Types of Graph in Data Structure Primitive Data Type Semi-Structured Data Advance Data Structures Sort an Array of 0's, 1's, and 2's Stock Span Problem Implementation of Deque by Circular Array Rotate Operation in Linked List Subarray with given sum Self-organizing List Unrolled Linked List Types of Sparse Matrices Application of Linked List Topological Sorting Ternary Search Tree Stock Span Problem Treap Data Structure Quicksort on Doubly Linked List Inversion count Expression tree in DS Garbage Collection in DS Merge Sort on Doubly Linked List Sort Stack using Recursion LIFO Approach in data structure Big O Notation in DS Binary Tree Traversal in DS Queue Operations in DS What is a Non-Linear Data Structure FIFO Approach in data structure What are connected graphs in data structure Which Python data structure is immutable Which data structure is used by map What is iteration in data structure What are linear search and binary search in data structure Hash Table vs STL Map Recaman's Sequence Maximum area rectangle created by selecting four sides from an array Maximum number of distinct nodes in a root-to-leaf path DS MCQ Data Structure MCQ Advanced DS MCQ next ? ? prev Maximum number of distinct nodes in a root-to-leaf path Find the maximum number of distinct nodes in all root-to-leaf paths given a Binary Tree. Examples 
Input :   1
            /    \
           2      3
          / \    / \
        4   5  6   3
               \   \
                8   9 

Output : 4 
The root to leaf path with maximum distinct
nodes is 1-3-6-8.
 Exploring all root to leaf paths is a simple solution. Count distinct nodes along each root-to-leaf path and return the maximum number. Hashing is an efficient solution. We traverse the tree recursively, keeping track of the number of distinct nodes on the path from the root to the current node. We repeat for the left and right subtrees, returning the maximum of two values. The implementation of the above idea is shown below. Program in C++ 
// C++ program to find count of distinct nodes
// on a path with maximum distinct nodes.
#include <bits/stdc++.h>
using namespace std;

// A node of binary tree
struct Node {
	int data;
	struct Node *left, *right;
};

// A utility function to create a new Binary
// Tree node
Node* newNode(int data)
{
	Node* temp = new Node;
	temp->data = data;
	temp->left = temp->right = NULL;
	return temp;
}

int largestUinquePathUtil(Node* node, unordered_map<int, int> m)
{
	if (!node)
		return m.size();

	// put this node into hash
	m[node->data]++;

	int max_path = max(largestUinquePathUtil(node->left, m),
					largestUinquePathUtil(node->right, m));

	// remove current node from path "hash"
	m[node->data]--;

	// if we reached a condition where all duplicate value
	// of current node is deleted
	if (m[node->data] == 0)
		m.erase(node->data);

	return max_path;
}

// A utility function to find long unique value path
int largestUinquePath(Node* node)
{
	if (!node)
		return 0;

	// hash that store all node value
	unordered_map<int, int> hash;

	// return max length unique value path
	return largestUinquePathUtil(node, hash);
}

// Driver program to test above functions
int main()
{
	// Create binary tree shown in above figure
	Node* root = newNode(1);
	root->left = newNode(2);
	root->right = newNode(3);
	root->left->left = newNode(4);
	root->left->right = newNode(5);
	root->right->left = newNode(6);
	root->right->right = newNode(7);
	root->right->left->right = newNode(8);
	root->right->right->right = newNode(9);

	cout << largestUinquePath(root) << endl;

	return 0;
}
 Output 4
 Time Complexity : O (n) Next Topic# ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/maximum-number-of-distinct-nodes-in-a-root-to-leaf-path Maximum number of distinct nodes in a root-to-leaf path - javatpoint ? SCROLL TO TOP Home Data Structure C C++ C# Java SQL HTML CSS JavaScript Ajax Android Cloud Design Pattern Quiz Projects Interview Q Comment Forum DS Tutorial DS Tutorial DS Introduction DS Algorithm Asymptotic Analysis DS Pointer DS Structure DS Array DS Array 2D Array DS Linked List Linked List Types of Linked List Singly Linked List Doubly Linked List Circular Linked List Circular Doubly List Skip list in DS DS Stack DS Stack Array Implementation Linked List Implementation DS Queue DS Queue Types of Queues Array Representation Linked List Representation Circular Queue Deque Priority Queue DS Tree DS Tree Binary Tree Binary Search Tree AVL Tree B Tree B+ Tree DS Graph DS Graph Graph Implementation BFS Algorithm DFS Algorithm Spanning Tree DS Searching Linear Search Binary Search DS Sorting Bubble Sort Bucket Sort Comb Sort Counting Sort Heap Sort Insertion Sort Merge Sort Quick Sort Radix Sort Selection Sort Shell Sort Bitonic Sort Cocktail Sort Cycle Sort Tim Sort Differences Linear vs non-linear Array vs linked list Stack vs queue Linear vs Circular Queue Linear Search vs Binary Search Singly Linked List vs Doubly Linked List Binary vs Binary Search Tree Tree vs Graph Binary Search tree vs AVL tree Red Black Tree vs AVL tree B tree vs B+ tree Quick Sort vs Merge Sort BFS vs DFS Stack vs Heap Bubble sort vs. Selection sort Stack vs Array Full Binary Tree vs Complete Binary Tree Binary Tree vs B Tree Primitive vs non-primitive data structure Data types vs data structure Misc Trie Data Structure Heap Data Structure Splay Tree Fundamental of the DS Hash Table Preorder Traversal Tree Traversal Implementation of Queue using Stacks Implementation of Stack using Queue Binomial Heap Postorder Traversal Sparse Matrix Detect loop in a Linked list Inorder Traversal Convert Infix to Postfix notation Convert infix to prefix notation Conversion of Prefix to Postfix expression Conversion of Postfix to Prefix expression Remove the loop in a Linked List Implement two stacks in an array Reverse a stack using recursion Detect cycle in a directed graph Optimal Binary Search Tree Priority Queue using Linked list Balanced Binary Search Tree Boundary Traversal of Binary tree Diagonal Traversal of Binary Tree Vertical Traversal of a Binary tree Graph Algorithms Time Complexity of Sorting Algorithms Applications of Stack in Data Structure Dictionary Data Structure Structured Data and Unstructured Data List Data Structure Types of Tree in Data Structure Abstract data type in data structure Disjoint set data structure Dynamic Data Structure Hash Function in Data Structure Complete Binary Tree Threaded Binary Tree Diameter of Binary Tree Height of Binary Tree Inorder Tree Traversal without Stack Enumeration of Binary Trees Maximum Width of a Binary Tree Types of Graph in Data Structure Primitive Data Type Semi-Structured Data Advance Data Structures Sort an Array of 0's, 1's, and 2's Stock Span Problem Implementation of Deque by Circular Array Rotate Operation in Linked List Subarray with given sum Self-organizing List Unrolled Linked List Types of Sparse Matrices Application of Linked List Topological Sorting Ternary Search Tree Stock Span Problem Treap Data Structure Quicksort on Doubly Linked List Inversion count Expression tree in DS Garbage Collection in DS Merge Sort on Doubly Linked List Sort Stack using Recursion LIFO Approach in data structure Big O Notation in DS Binary Tree Traversal in DS Queue Operations in DS What is a Non-Linear Data Structure FIFO Approach in data structure What are connected graphs in data structure Which Python data structure is immutable Which data structure is used by map What is iteration in data structure What are linear search and binary search in data structure Hash Table vs STL Map Recaman's Sequence Maximum area rectangle created by selecting four sides from an array Maximum number of distinct nodes in a root-to-leaf path DS MCQ Data Structure MCQ Advanced DS MCQ next ? ? prev Maximum number of distinct nodes in a root-to-leaf path Find the maximum number of distinct nodes in all root-to-leaf paths given a Binary Tree. Examples 
Input :   1
            /    \
           2      3
          / \    / \
        4   5  6   3
               \   \
                8   9 

Output : 4 
The root to leaf path with maximum distinct
nodes is 1-3-6-8.
 Exploring all root to leaf paths is a simple solution. Count distinct nodes along each root-to-leaf path and return the maximum number. Hashing is an efficient solution. We traverse the tree recursively, keeping track of the number of distinct nodes on the path from the root to the current node. We repeat for the left and right subtrees, returning the maximum of two values. The implementation of the above idea is shown below. Program in C++ 
// C++ program to find count of distinct nodes
// on a path with maximum distinct nodes.
#include <bits/stdc++.h>
using namespace std;

// A node of binary tree
struct Node {
	int data;
	struct Node *left, *right;
};

// A utility function to create a new Binary
// Tree node
Node* newNode(int data)
{
	Node* temp = new Node;
	temp->data = data;
	temp->left = temp->right = NULL;
	return temp;
}

int largestUinquePathUtil(Node* node, unordered_map<int, int> m)
{
	if (!node)
		return m.size();

	// put this node into hash
	m[node->data]++;

	int max_path = max(largestUinquePathUtil(node->left, m),
					largestUinquePathUtil(node->right, m));

	// remove current node from path "hash"
	m[node->data]--;

	// if we reached a condition where all duplicate value
	// of current node is deleted
	if (m[node->data] == 0)
		m.erase(node->data);

	return max_path;
}

// A utility function to find long unique value path
int largestUinquePath(Node* node)
{
	if (!node)
		return 0;

	// hash that store all node value
	unordered_map<int, int> hash;

	// return max length unique value path
	return largestUinquePathUtil(node, hash);
}

// Driver program to test above functions
int main()
{
	// Create binary tree shown in above figure
	Node* root = newNode(1);
	root->left = newNode(2);
	root->right = newNode(3);
	root->left->left = newNode(4);
	root->left->right = newNode(5);
	root->right->left = newNode(6);
	root->right->right = newNode(7);
	root->right->left->right = newNode(8);
	root->right->right->right = newNode(9);

	cout << largestUinquePath(root) << endl;

	return 0;
}
 Output 4
 Time Complexity : O (n) Next Topic# ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/maximum-number-of-distinct-nodes-in-a-root-to-leaf-path Maximum number of distinct nodes in a root-to-leaf path - javatpoint ? SCROLL TO TOP Home Data Structure C C++ C# Java SQL HTML CSS JavaScript Ajax Android Cloud Design Pattern Quiz Projects Interview Q Comment Forum DS Tutorial DS Tutorial DS Introduction DS Algorithm Asymptotic Analysis DS Pointer DS Structure DS Array DS Array 2D Array DS Linked List Linked List Types of Linked List Singly Linked List Doubly Linked List Circular Linked List Circular Doubly List Skip list in DS DS Stack DS Stack Array Implementation Linked List Implementation DS Queue DS Queue Types of Queues Array Representation Linked List Representation Circular Queue Deque Priority Queue DS Tree DS Tree Binary Tree Binary Search Tree AVL Tree B Tree B+ Tree DS Graph DS Graph Graph Implementation BFS Algorithm DFS Algorithm Spanning Tree DS Searching Linear Search Binary Search DS Sorting Bubble Sort Bucket Sort Comb Sort Counting Sort Heap Sort Insertion Sort Merge Sort Quick Sort Radix Sort Selection Sort Shell Sort Bitonic Sort Cocktail Sort Cycle Sort Tim Sort Differences Linear vs non-linear Array vs linked list Stack vs queue Linear vs Circular Queue Linear Search vs Binary Search Singly Linked List vs Doubly Linked List Binary vs Binary Search Tree Tree vs Graph Binary Search tree vs AVL tree Red Black Tree vs AVL tree B tree vs B+ tree Quick Sort vs Merge Sort BFS vs DFS Stack vs Heap Bubble sort vs. Selection sort Stack vs Array Full Binary Tree vs Complete Binary Tree Binary Tree vs B Tree Primitive vs non-primitive data structure Data types vs data structure Misc Trie Data Structure Heap Data Structure Splay Tree Fundamental of the DS Hash Table Preorder Traversal Tree Traversal Implementation of Queue using Stacks Implementation of Stack using Queue Binomial Heap Postorder Traversal Sparse Matrix Detect loop in a Linked list Inorder Traversal Convert Infix to Postfix notation Convert infix to prefix notation Conversion of Prefix to Postfix expression Conversion of Postfix to Prefix expression Remove the loop in a Linked List Implement two stacks in an array Reverse a stack using recursion Detect cycle in a directed graph Optimal Binary Search Tree Priority Queue using Linked list Balanced Binary Search Tree Boundary Traversal of Binary tree Diagonal Traversal of Binary Tree Vertical Traversal of a Binary tree Graph Algorithms Time Complexity of Sorting Algorithms Applications of Stack in Data Structure Dictionary Data Structure Structured Data and Unstructured Data List Data Structure Types of Tree in Data Structure Abstract data type in data structure Disjoint set data structure Dynamic Data Structure Hash Function in Data Structure Complete Binary Tree Threaded Binary Tree Diameter of Binary Tree Height of Binary Tree Inorder Tree Traversal without Stack Enumeration of Binary Trees Maximum Width of a Binary Tree Types of Graph in Data Structure Primitive Data Type Semi-Structured Data Advance Data Structures Sort an Array of 0's, 1's, and 2's Stock Span Problem Implementation of Deque by Circular Array Rotate Operation in Linked List Subarray with given sum Self-organizing List Unrolled Linked List Types of Sparse Matrices Application of Linked List Topological Sorting Ternary Search Tree Stock Span Problem Treap Data Structure Quicksort on Doubly Linked List Inversion count Expression tree in DS Garbage Collection in DS Merge Sort on Doubly Linked List Sort Stack using Recursion LIFO Approach in data structure Big O Notation in DS Binary Tree Traversal in DS Queue Operations in DS What is a Non-Linear Data Structure FIFO Approach in data structure What are connected graphs in data structure Which Python data structure is immutable Which data structure is used by map What is iteration in data structure What are linear search and binary search in data structure Hash Table vs STL Map Recaman's Sequence Maximum area rectangle created by selecting four sides from an array Maximum number of distinct nodes in a root-to-leaf path DS MCQ Data Structure MCQ Advanced DS MCQ next ? ? prev Maximum number of distinct nodes in a root-to-leaf path Find the maximum number of distinct nodes in all root-to-leaf paths given a Binary Tree. Examples 
Input :   1
            /    \
           2      3
          / \    / \
        4   5  6   3
               \   \
                8   9 

Output : 4 
The root to leaf path with maximum distinct
nodes is 1-3-6-8.
 Exploring all root to leaf paths is a simple solution. Count distinct nodes along each root-to-leaf path and return the maximum number. Hashing is an efficient solution. We traverse the tree recursively, keeping track of the number of distinct nodes on the path from the root to the current node. We repeat for the left and right subtrees, returning the maximum of two values. The implementation of the above idea is shown below. Program in C++ 
// C++ program to find count of distinct nodes
// on a path with maximum distinct nodes.
#include <bits/stdc++.h>
using namespace std;

// A node of binary tree
struct Node {
	int data;
	struct Node *left, *right;
};

// A utility function to create a new Binary
// Tree node
Node* newNode(int data)
{
	Node* temp = new Node;
	temp->data = data;
	temp->left = temp->right = NULL;
	return temp;
}

int largestUinquePathUtil(Node* node, unordered_map<int, int> m)
{
	if (!node)
		return m.size();

	// put this node into hash
	m[node->data]++;

	int max_path = max(largestUinquePathUtil(node->left, m),
					largestUinquePathUtil(node->right, m));

	// remove current node from path "hash"
	m[node->data]--;

	// if we reached a condition where all duplicate value
	// of current node is deleted
	if (m[node->data] == 0)
		m.erase(node->data);

	return max_path;
}

// A utility function to find long unique value path
int largestUinquePath(Node* node)
{
	if (!node)
		return 0;

	// hash that store all node value
	unordered_map<int, int> hash;

	// return max length unique value path
	return largestUinquePathUtil(node, hash);
}

// Driver program to test above functions
int main()
{
	// Create binary tree shown in above figure
	Node* root = newNode(1);
	root->left = newNode(2);
	root->right = newNode(3);
	root->left->left = newNode(4);
	root->left->right = newNode(5);
	root->right->left = newNode(6);
	root->right->right = newNode(7);
	root->right->left->right = newNode(8);
	root->right->right->right = newNode(9);

	cout << largestUinquePath(root) << endl;

	return 0;
}
 Output 4
 Time Complexity : O (n) Next Topic# ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/maximum-number-of-distinct-nodes-in-a-root-to-leaf-path Maximum number of distinct nodes in a root-to-leaf path - javatpoint ? SCROLL TO TOP Home Data Structure C C++ C# Java SQL HTML CSS JavaScript Ajax Android Cloud Design Pattern Quiz Projects Interview Q Comment Forum DS Tutorial DS Tutorial DS Introduction DS Algorithm Asymptotic Analysis DS Pointer DS Structure DS Array DS Array 2D Array DS Linked List Linked List Types of Linked List Singly Linked List Doubly Linked List Circular Linked List Circular Doubly List Skip list in DS DS Stack DS Stack Array Implementation Linked List Implementation DS Queue DS Queue Types of Queues Array Representation Linked List Representation Circular Queue Deque Priority Queue DS Tree DS Tree Binary Tree Binary Search Tree AVL Tree B Tree B+ Tree DS Graph DS Graph Graph Implementation BFS Algorithm DFS Algorithm Spanning Tree DS Searching Linear Search Binary Search DS Sorting Bubble Sort Bucket Sort Comb Sort Counting Sort Heap Sort Insertion Sort Merge Sort Quick Sort Radix Sort Selection Sort Shell Sort Bitonic Sort Cocktail Sort Cycle Sort Tim Sort Differences Linear vs non-linear Array vs linked list Stack vs queue Linear vs Circular Queue Linear Search vs Binary Search Singly Linked List vs Doubly Linked List Binary vs Binary Search Tree Tree vs Graph Binary Search tree vs AVL tree Red Black Tree vs AVL tree B tree vs B+ tree Quick Sort vs Merge Sort BFS vs DFS Stack vs Heap Bubble sort vs. Selection sort Stack vs Array Full Binary Tree vs Complete Binary Tree Binary Tree vs B Tree Primitive vs non-primitive data structure Data types vs data structure Misc Trie Data Structure Heap Data Structure Splay Tree Fundamental of the DS Hash Table Preorder Traversal Tree Traversal Implementation of Queue using Stacks Implementation of Stack using Queue Binomial Heap Postorder Traversal Sparse Matrix Detect loop in a Linked list Inorder Traversal Convert Infix to Postfix notation Convert infix to prefix notation Conversion of Prefix to Postfix expression Conversion of Postfix to Prefix expression Remove the loop in a Linked List Implement two stacks in an array Reverse a stack using recursion Detect cycle in a directed graph Optimal Binary Search Tree Priority Queue using Linked list Balanced Binary Search Tree Boundary Traversal of Binary tree Diagonal Traversal of Binary Tree Vertical Traversal of a Binary tree Graph Algorithms Time Complexity of Sorting Algorithms Applications of Stack in Data Structure Dictionary Data Structure Structured Data and Unstructured Data List Data Structure Types of Tree in Data Structure Abstract data type in data structure Disjoint set data structure Dynamic Data Structure Hash Function in Data Structure Complete Binary Tree Threaded Binary Tree Diameter of Binary Tree Height of Binary Tree Inorder Tree Traversal without Stack Enumeration of Binary Trees Maximum Width of a Binary Tree Types of Graph in Data Structure Primitive Data Type Semi-Structured Data Advance Data Structures Sort an Array of 0's, 1's, and 2's Stock Span Problem Implementation of Deque by Circular Array Rotate Operation in Linked List Subarray with given sum Self-organizing List Unrolled Linked List Types of Sparse Matrices Application of Linked List Topological Sorting Ternary Search Tree Stock Span Problem Treap Data Structure Quicksort on Doubly Linked List Inversion count Expression tree in DS Garbage Collection in DS Merge Sort on Doubly Linked List Sort Stack using Recursion LIFO Approach in data structure Big O Notation in DS Binary Tree Traversal in DS Queue Operations in DS What is a Non-Linear Data Structure FIFO Approach in data structure What are connected graphs in data structure Which Python data structure is immutable Which data structure is used by map What is iteration in data structure What are linear search and binary search in data structure Hash Table vs STL Map Recaman's Sequence Maximum area rectangle created by selecting four sides from an array Maximum number of distinct nodes in a root-to-leaf path DS MCQ Data Structure MCQ Advanced DS MCQ next ? ? prev Maximum number of distinct nodes in a root-to-leaf path Find the maximum number of distinct nodes in all root-to-leaf paths given a Binary Tree. Examples 
Input :   1
            /    \
           2      3
          / \    / \
        4   5  6   3
               \   \
                8   9 

Output : 4 
The root to leaf path with maximum distinct
nodes is 1-3-6-8.
 Exploring all root to leaf paths is a simple solution. Count distinct nodes along each root-to-leaf path and return the maximum number. Hashing is an efficient solution. We traverse the tree recursively, keeping track of the number of distinct nodes on the path from the root to the current node. We repeat for the left and right subtrees, returning the maximum of two values. The implementation of the above idea is shown below. Program in C++ 
// C++ program to find count of distinct nodes
// on a path with maximum distinct nodes.
#include <bits/stdc++.h>
using namespace std;

// A node of binary tree
struct Node {
	int data;
	struct Node *left, *right;
};

// A utility function to create a new Binary
// Tree node
Node* newNode(int data)
{
	Node* temp = new Node;
	temp->data = data;
	temp->left = temp->right = NULL;
	return temp;
}

int largestUinquePathUtil(Node* node, unordered_map<int, int> m)
{
	if (!node)
		return m.size();

	// put this node into hash
	m[node->data]++;

	int max_path = max(largestUinquePathUtil(node->left, m),
					largestUinquePathUtil(node->right, m));

	// remove current node from path "hash"
	m[node->data]--;

	// if we reached a condition where all duplicate value
	// of current node is deleted
	if (m[node->data] == 0)
		m.erase(node->data);

	return max_path;
}

// A utility function to find long unique value path
int largestUinquePath(Node* node)
{
	if (!node)
		return 0;

	// hash that store all node value
	unordered_map<int, int> hash;

	// return max length unique value path
	return largestUinquePathUtil(node, hash);
}

// Driver program to test above functions
int main()
{
	// Create binary tree shown in above figure
	Node* root = newNode(1);
	root->left = newNode(2);
	root->right = newNode(3);
	root->left->left = newNode(4);
	root->left->right = newNode(5);
	root->right->left = newNode(6);
	root->right->right = newNode(7);
	root->right->left->right = newNode(8);
	root->right->right->right = newNode(9);

	cout << largestUinquePath(root) << endl;

	return 0;
}
 Output 4
 Time Complexity : O (n) Next Topic# ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/maximum-number-of-distinct-nodes-in-a-root-to-leaf-path Maximum number of distinct nodes in a root-to-leaf path - javatpoint ? SCROLL TO TOP Home Data Structure C C++ C# Java SQL HTML CSS JavaScript Ajax Android Cloud Design Pattern Quiz Projects Interview Q Comment Forum DS Tutorial DS Tutorial DS Introduction DS Algorithm Asymptotic Analysis DS Pointer DS Structure DS Array DS Array 2D Array DS Linked List Linked List Types of Linked List Singly Linked List Doubly Linked List Circular Linked List Circular Doubly List Skip list in DS DS Stack DS Stack Array Implementation Linked List Implementation DS Queue DS Queue Types of Queues Array Representation Linked List Representation Circular Queue Deque Priority Queue DS Tree DS Tree Binary Tree Binary Search Tree AVL Tree B Tree B+ Tree DS Graph DS Graph Graph Implementation BFS Algorithm DFS Algorithm Spanning Tree DS Searching Linear Search Binary Search DS Sorting Bubble Sort Bucket Sort Comb Sort Counting Sort Heap Sort Insertion Sort Merge Sort Quick Sort Radix Sort Selection Sort Shell Sort Bitonic Sort Cocktail Sort Cycle Sort Tim Sort Differences Linear vs non-linear Array vs linked list Stack vs queue Linear vs Circular Queue Linear Search vs Binary Search Singly Linked List vs Doubly Linked List Binary vs Binary Search Tree Tree vs Graph Binary Search tree vs AVL tree Red Black Tree vs AVL tree B tree vs B+ tree Quick Sort vs Merge Sort BFS vs DFS Stack vs Heap Bubble sort vs. Selection sort Stack vs Array Full Binary Tree vs Complete Binary Tree Binary Tree vs B Tree Primitive vs non-primitive data structure Data types vs data structure Misc Trie Data Structure Heap Data Structure Splay Tree Fundamental of the DS Hash Table Preorder Traversal Tree Traversal Implementation of Queue using Stacks Implementation of Stack using Queue Binomial Heap Postorder Traversal Sparse Matrix Detect loop in a Linked list Inorder Traversal Convert Infix to Postfix notation Convert infix to prefix notation Conversion of Prefix to Postfix expression Conversion of Postfix to Prefix expression Remove the loop in a Linked List Implement two stacks in an array Reverse a stack using recursion Detect cycle in a directed graph Optimal Binary Search Tree Priority Queue using Linked list Balanced Binary Search Tree Boundary Traversal of Binary tree Diagonal Traversal of Binary Tree Vertical Traversal of a Binary tree Graph Algorithms Time Complexity of Sorting Algorithms Applications of Stack in Data Structure Dictionary Data Structure Structured Data and Unstructured Data List Data Structure Types of Tree in Data Structure Abstract data type in data structure Disjoint set data structure Dynamic Data Structure Hash Function in Data Structure Complete Binary Tree Threaded Binary Tree Diameter of Binary Tree Height of Binary Tree Inorder Tree Traversal without Stack Enumeration of Binary Trees Maximum Width of a Binary Tree Types of Graph in Data Structure Primitive Data Type Semi-Structured Data Advance Data Structures Sort an Array of 0's, 1's, and 2's Stock Span Problem Implementation of Deque by Circular Array Rotate Operation in Linked List Subarray with given sum Self-organizing List Unrolled Linked List Types of Sparse Matrices Application of Linked List Topological Sorting Ternary Search Tree Stock Span Problem Treap Data Structure Quicksort on Doubly Linked List Inversion count Expression tree in DS Garbage Collection in DS Merge Sort on Doubly Linked List Sort Stack using Recursion LIFO Approach in data structure Big O Notation in DS Binary Tree Traversal in DS Queue Operations in DS What is a Non-Linear Data Structure FIFO Approach in data structure What are connected graphs in data structure Which Python data structure is immutable Which data structure is used by map What is iteration in data structure What are linear search and binary search in data structure Hash Table vs STL Map Recaman's Sequence Maximum area rectangle created by selecting four sides from an array Maximum number of distinct nodes in a root-to-leaf path DS MCQ Data Structure MCQ Advanced DS MCQ next ? ? prev Maximum number of distinct nodes in a root-to-leaf path Find the maximum number of distinct nodes in all root-to-leaf paths given a Binary Tree. Examples 
Input :   1
            /    \
           2      3
          / \    / \
        4   5  6   3
               \   \
                8   9 

Output : 4 
The root to leaf path with maximum distinct
nodes is 1-3-6-8.
 Exploring all root to leaf paths is a simple solution. Count distinct nodes along each root-to-leaf path and return the maximum number. Hashing is an efficient solution. We traverse the tree recursively, keeping track of the number of distinct nodes on the path from the root to the current node. We repeat for the left and right subtrees, returning the maximum of two values. The implementation of the above idea is shown below. Program in C++ 
// C++ program to find count of distinct nodes
// on a path with maximum distinct nodes.
#include <bits/stdc++.h>
using namespace std;

// A node of binary tree
struct Node {
	int data;
	struct Node *left, *right;
};

// A utility function to create a new Binary
// Tree node
Node* newNode(int data)
{
	Node* temp = new Node;
	temp->data = data;
	temp->left = temp->right = NULL;
	return temp;
}

int largestUinquePathUtil(Node* node, unordered_map<int, int> m)
{
	if (!node)
		return m.size();

	// put this node into hash
	m[node->data]++;

	int max_path = max(largestUinquePathUtil(node->left, m),
					largestUinquePathUtil(node->right, m));

	// remove current node from path "hash"
	m[node->data]--;

	// if we reached a condition where all duplicate value
	// of current node is deleted
	if (m[node->data] == 0)
		m.erase(node->data);

	return max_path;
}

// A utility function to find long unique value path
int largestUinquePath(Node* node)
{
	if (!node)
		return 0;

	// hash that store all node value
	unordered_map<int, int> hash;

	// return max length unique value path
	return largestUinquePathUtil(node, hash);
}

// Driver program to test above functions
int main()
{
	// Create binary tree shown in above figure
	Node* root = newNode(1);
	root->left = newNode(2);
	root->right = newNode(3);
	root->left->left = newNode(4);
	root->left->right = newNode(5);
	root->right->left = newNode(6);
	root->right->right = newNode(7);
	root->right->left->right = newNode(8);
	root->right->right->right = newNode(9);

	cout << largestUinquePath(root) << endl;

	return 0;
}
 Output 4
 Time Complexity : O (n) Next Topic# ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/maximum-number-of-distinct-nodes-in-a-root-to-leaf-path Maximum number of distinct nodes in a root-to-leaf path - javatpoint ? SCROLL TO TOP Home Data Structure C C++ C# Java SQL HTML CSS JavaScript Ajax Android Cloud Design Pattern Quiz Projects Interview Q Comment Forum DS Tutorial DS Tutorial DS Introduction DS Algorithm Asymptotic Analysis DS Pointer DS Structure DS Array DS Array 2D Array DS Linked List Linked List Types of Linked List Singly Linked List Doubly Linked List Circular Linked List Circular Doubly List Skip list in DS DS Stack DS Stack Array Implementation Linked List Implementation DS Queue DS Queue Types of Queues Array Representation Linked List Representation Circular Queue Deque Priority Queue DS Tree DS Tree Binary Tree Binary Search Tree AVL Tree B Tree B+ Tree DS Graph DS Graph Graph Implementation BFS Algorithm DFS Algorithm Spanning Tree DS Searching Linear Search Binary Search DS Sorting Bubble Sort Bucket Sort Comb Sort Counting Sort Heap Sort Insertion Sort Merge Sort Quick Sort Radix Sort Selection Sort Shell Sort Bitonic Sort Cocktail Sort Cycle Sort Tim Sort Differences Linear vs non-linear Array vs linked list Stack vs queue Linear vs Circular Queue Linear Search vs Binary Search Singly Linked List vs Doubly Linked List Binary vs Binary Search Tree Tree vs Graph Binary Search tree vs AVL tree Red Black Tree vs AVL tree B tree vs B+ tree Quick Sort vs Merge Sort BFS vs DFS Stack vs Heap Bubble sort vs. Selection sort Stack vs Array Full Binary Tree vs Complete Binary Tree Binary Tree vs B Tree Primitive vs non-primitive data structure Data types vs data structure Misc Trie Data Structure Heap Data Structure Splay Tree Fundamental of the DS Hash Table Preorder Traversal Tree Traversal Implementation of Queue using Stacks Implementation of Stack using Queue Binomial Heap Postorder Traversal Sparse Matrix Detect loop in a Linked list Inorder Traversal Convert Infix to Postfix notation Convert infix to prefix notation Conversion of Prefix to Postfix expression Conversion of Postfix to Prefix expression Remove the loop in a Linked List Implement two stacks in an array Reverse a stack using recursion Detect cycle in a directed graph Optimal Binary Search Tree Priority Queue using Linked list Balanced Binary Search Tree Boundary Traversal of Binary tree Diagonal Traversal of Binary Tree Vertical Traversal of a Binary tree Graph Algorithms Time Complexity of Sorting Algorithms Applications of Stack in Data Structure Dictionary Data Structure Structured Data and Unstructured Data List Data Structure Types of Tree in Data Structure Abstract data type in data structure Disjoint set data structure Dynamic Data Structure Hash Function in Data Structure Complete Binary Tree Threaded Binary Tree Diameter of Binary Tree Height of Binary Tree Inorder Tree Traversal without Stack Enumeration of Binary Trees Maximum Width of a Binary Tree Types of Graph in Data Structure Primitive Data Type Semi-Structured Data Advance Data Structures Sort an Array of 0's, 1's, and 2's Stock Span Problem Implementation of Deque by Circular Array Rotate Operation in Linked List Subarray with given sum Self-organizing List Unrolled Linked List Types of Sparse Matrices Application of Linked List Topological Sorting Ternary Search Tree Stock Span Problem Treap Data Structure Quicksort on Doubly Linked List Inversion count Expression tree in DS Garbage Collection in DS Merge Sort on Doubly Linked List Sort Stack using Recursion LIFO Approach in data structure Big O Notation in DS Binary Tree Traversal in DS Queue Operations in DS What is a Non-Linear Data Structure FIFO Approach in data structure What are connected graphs in data structure Which Python data structure is immutable Which data structure is used by map What is iteration in data structure What are linear search and binary search in data structure Hash Table vs STL Map Recaman's Sequence Maximum area rectangle created by selecting four sides from an array Maximum number of distinct nodes in a root-to-leaf path DS MCQ Data Structure MCQ Advanced DS MCQ next ? ? prev Maximum number of distinct nodes in a root-to-leaf path Find the maximum number of distinct nodes in all root-to-leaf paths given a Binary Tree. Examples 
Input :   1
            /    \
           2      3
          / \    / \
        4   5  6   3
               \   \
                8   9 

Output : 4 
The root to leaf path with maximum distinct
nodes is 1-3-6-8.
 Exploring all root to leaf paths is a simple solution. Count distinct nodes along each root-to-leaf path and return the maximum number. Hashing is an efficient solution. We traverse the tree recursively, keeping track of the number of distinct nodes on the path from the root to the current node. We repeat for the left and right subtrees, returning the maximum of two values. The implementation of the above idea is shown below. Program in C++ 
// C++ program to find count of distinct nodes
// on a path with maximum distinct nodes.
#include <bits/stdc++.h>
using namespace std;

// A node of binary tree
struct Node {
	int data;
	struct Node *left, *right;
};

// A utility function to create a new Binary
// Tree node
Node* newNode(int data)
{
	Node* temp = new Node;
	temp->data = data;
	temp->left = temp->right = NULL;
	return temp;
}

int largestUinquePathUtil(Node* node, unordered_map<int, int> m)
{
	if (!node)
		return m.size();

	// put this node into hash
	m[node->data]++;

	int max_path = max(largestUinquePathUtil(node->left, m),
					largestUinquePathUtil(node->right, m));

	// remove current node from path "hash"
	m[node->data]--;

	// if we reached a condition where all duplicate value
	// of current node is deleted
	if (m[node->data] == 0)
		m.erase(node->data);

	return max_path;
}

// A utility function to find long unique value path
int largestUinquePath(Node* node)
{
	if (!node)
		return 0;

	// hash that store all node value
	unordered_map<int, int> hash;

	// return max length unique value path
	return largestUinquePathUtil(node, hash);
}

// Driver program to test above functions
int main()
{
	// Create binary tree shown in above figure
	Node* root = newNode(1);
	root->left = newNode(2);
	root->right = newNode(3);
	root->left->left = newNode(4);
	root->left->right = newNode(5);
	root->right->left = newNode(6);
	root->right->right = newNode(7);
	root->right->left->right = newNode(8);
	root->right->right->right = newNode(9);

	cout << largestUinquePath(root) << endl;

	return 0;
}
 Output 4
 Time Complexity : O (n) Next Topic# ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/maximum-number-of-distinct-nodes-in-a-root-to-leaf-path Maximum number of distinct nodes in a root-to-leaf path - javatpoint ? SCROLL TO TOP Home Data Structure C C++ C# Java SQL HTML CSS JavaScript Ajax Android Cloud Design Pattern Quiz Projects Interview Q Comment Forum DS Tutorial DS Tutorial DS Introduction DS Algorithm Asymptotic Analysis DS Pointer DS Structure DS Array DS Array 2D Array DS Linked List Linked List Types of Linked List Singly Linked List Doubly Linked List Circular Linked List Circular Doubly List Skip list in DS DS Stack DS Stack Array Implementation Linked List Implementation DS Queue DS Queue Types of Queues Array Representation Linked List Representation Circular Queue Deque Priority Queue DS Tree DS Tree Binary Tree Binary Search Tree AVL Tree B Tree B+ Tree DS Graph DS Graph Graph Implementation BFS Algorithm DFS Algorithm Spanning Tree DS Searching Linear Search Binary Search DS Sorting Bubble Sort Bucket Sort Comb Sort Counting Sort Heap Sort Insertion Sort Merge Sort Quick Sort Radix Sort Selection Sort Shell Sort Bitonic Sort Cocktail Sort Cycle Sort Tim Sort Differences Linear vs non-linear Array vs linked list Stack vs queue Linear vs Circular Queue Linear Search vs Binary Search Singly Linked List vs Doubly Linked List Binary vs Binary Search Tree Tree vs Graph Binary Search tree vs AVL tree Red Black Tree vs AVL tree B tree vs B+ tree Quick Sort vs Merge Sort BFS vs DFS Stack vs Heap Bubble sort vs. Selection sort Stack vs Array Full Binary Tree vs Complete Binary Tree Binary Tree vs B Tree Primitive vs non-primitive data structure Data types vs data structure Misc Trie Data Structure Heap Data Structure Splay Tree Fundamental of the DS Hash Table Preorder Traversal Tree Traversal Implementation of Queue using Stacks Implementation of Stack using Queue Binomial Heap Postorder Traversal Sparse Matrix Detect loop in a Linked list Inorder Traversal Convert Infix to Postfix notation Convert infix to prefix notation Conversion of Prefix to Postfix expression Conversion of Postfix to Prefix expression Remove the loop in a Linked List Implement two stacks in an array Reverse a stack using recursion Detect cycle in a directed graph Optimal Binary Search Tree Priority Queue using Linked list Balanced Binary Search Tree Boundary Traversal of Binary tree Diagonal Traversal of Binary Tree Vertical Traversal of a Binary tree Graph Algorithms Time Complexity of Sorting Algorithms Applications of Stack in Data Structure Dictionary Data Structure Structured Data and Unstructured Data List Data Structure Types of Tree in Data Structure Abstract data type in data structure Disjoint set data structure Dynamic Data Structure Hash Function in Data Structure Complete Binary Tree Threaded Binary Tree Diameter of Binary Tree Height of Binary Tree Inorder Tree Traversal without Stack Enumeration of Binary Trees Maximum Width of a Binary Tree Types of Graph in Data Structure Primitive Data Type Semi-Structured Data Advance Data Structures Sort an Array of 0's, 1's, and 2's Stock Span Problem Implementation of Deque by Circular Array Rotate Operation in Linked List Subarray with given sum Self-organizing List Unrolled Linked List Types of Sparse Matrices Application of Linked List Topological Sorting Ternary Search Tree Stock Span Problem Treap Data Structure Quicksort on Doubly Linked List Inversion count Expression tree in DS Garbage Collection in DS Merge Sort on Doubly Linked List Sort Stack using Recursion LIFO Approach in data structure Big O Notation in DS Binary Tree Traversal in DS Queue Operations in DS What is a Non-Linear Data Structure FIFO Approach in data structure What are connected graphs in data structure Which Python data structure is immutable Which data structure is used by map What is iteration in data structure What are linear search and binary search in data structure Hash Table vs STL Map Recaman's Sequence Maximum area rectangle created by selecting four sides from an array Maximum number of distinct nodes in a root-to-leaf path DS MCQ Data Structure MCQ Advanced DS MCQ next ? ? prev Maximum number of distinct nodes in a root-to-leaf path Find the maximum number of distinct nodes in all root-to-leaf paths given a Binary Tree. Examples 
Input :   1
            /    \
           2      3
          / \    / \
        4   5  6   3
               \   \
                8   9 

Output : 4 
The root to leaf path with maximum distinct
nodes is 1-3-6-8.
 Exploring all root to leaf paths is a simple solution. Count distinct nodes along each root-to-leaf path and return the maximum number. Hashing is an efficient solution. We traverse the tree recursively, keeping track of the number of distinct nodes on the path from the root to the current node. We repeat for the left and right subtrees, returning the maximum of two values. The implementation of the above idea is shown below. Program in C++ 
// C++ program to find count of distinct nodes
// on a path with maximum distinct nodes.
#include <bits/stdc++.h>
using namespace std;

// A node of binary tree
struct Node {
	int data;
	struct Node *left, *right;
};

// A utility function to create a new Binary
// Tree node
Node* newNode(int data)
{
	Node* temp = new Node;
	temp->data = data;
	temp->left = temp->right = NULL;
	return temp;
}

int largestUinquePathUtil(Node* node, unordered_map<int, int> m)
{
	if (!node)
		return m.size();

	// put this node into hash
	m[node->data]++;

	int max_path = max(largestUinquePathUtil(node->left, m),
					largestUinquePathUtil(node->right, m));

	// remove current node from path "hash"
	m[node->data]--;

	// if we reached a condition where all duplicate value
	// of current node is deleted
	if (m[node->data] == 0)
		m.erase(node->data);

	return max_path;
}

// A utility function to find long unique value path
int largestUinquePath(Node* node)
{
	if (!node)
		return 0;

	// hash that store all node value
	unordered_map<int, int> hash;

	// return max length unique value path
	return largestUinquePathUtil(node, hash);
}

// Driver program to test above functions
int main()
{
	// Create binary tree shown in above figure
	Node* root = newNode(1);
	root->left = newNode(2);
	root->right = newNode(3);
	root->left->left = newNode(4);
	root->left->right = newNode(5);
	root->right->left = newNode(6);
	root->right->right = newNode(7);
	root->right->left->right = newNode(8);
	root->right->right->right = newNode(9);

	cout << largestUinquePath(root) << endl;

	return 0;
}
 Output 4
 Time Complexity : O (n) Next Topic# ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/maximum-number-of-distinct-nodes-in-a-root-to-leaf-path Maximum number of distinct nodes in a root-to-leaf path - javatpoint ? SCROLL TO TOP Home Data Structure C C++ C# Java SQL HTML CSS JavaScript Ajax Android Cloud Design Pattern Quiz Projects Interview Q Comment Forum DS Tutorial DS Tutorial DS Introduction DS Algorithm Asymptotic Analysis DS Pointer DS Structure DS Array DS Array 2D Array DS Linked List Linked List Types of Linked List Singly Linked List Doubly Linked List Circular Linked List Circular Doubly List Skip list in DS DS Stack DS Stack Array Implementation Linked List Implementation DS Queue DS Queue Types of Queues Array Representation Linked List Representation Circular Queue Deque Priority Queue DS Tree DS Tree Binary Tree Binary Search Tree AVL Tree B Tree B+ Tree DS Graph DS Graph Graph Implementation BFS Algorithm DFS Algorithm Spanning Tree DS Searching Linear Search Binary Search DS Sorting Bubble Sort Bucket Sort Comb Sort Counting Sort Heap Sort Insertion Sort Merge Sort Quick Sort Radix Sort Selection Sort Shell Sort Bitonic Sort Cocktail Sort Cycle Sort Tim Sort Differences Linear vs non-linear Array vs linked list Stack vs queue Linear vs Circular Queue Linear Search vs Binary Search Singly Linked List vs Doubly Linked List Binary vs Binary Search Tree Tree vs Graph Binary Search tree vs AVL tree Red Black Tree vs AVL tree B tree vs B+ tree Quick Sort vs Merge Sort BFS vs DFS Stack vs Heap Bubble sort vs. Selection sort Stack vs Array Full Binary Tree vs Complete Binary Tree Binary Tree vs B Tree Primitive vs non-primitive data structure Data types vs data structure Misc Trie Data Structure Heap Data Structure Splay Tree Fundamental of the DS Hash Table Preorder Traversal Tree Traversal Implementation of Queue using Stacks Implementation of Stack using Queue Binomial Heap Postorder Traversal Sparse Matrix Detect loop in a Linked list Inorder Traversal Convert Infix to Postfix notation Convert infix to prefix notation Conversion of Prefix to Postfix expression Conversion of Postfix to Prefix expression Remove the loop in a Linked List Implement two stacks in an array Reverse a stack using recursion Detect cycle in a directed graph Optimal Binary Search Tree Priority Queue using Linked list Balanced Binary Search Tree Boundary Traversal of Binary tree Diagonal Traversal of Binary Tree Vertical Traversal of a Binary tree Graph Algorithms Time Complexity of Sorting Algorithms Applications of Stack in Data Structure Dictionary Data Structure Structured Data and Unstructured Data List Data Structure Types of Tree in Data Structure Abstract data type in data structure Disjoint set data structure Dynamic Data Structure Hash Function in Data Structure Complete Binary Tree Threaded Binary Tree Diameter of Binary Tree Height of Binary Tree Inorder Tree Traversal without Stack Enumeration of Binary Trees Maximum Width of a Binary Tree Types of Graph in Data Structure Primitive Data Type Semi-Structured Data Advance Data Structures Sort an Array of 0's, 1's, and 2's Stock Span Problem Implementation of Deque by Circular Array Rotate Operation in Linked List Subarray with given sum Self-organizing List Unrolled Linked List Types of Sparse Matrices Application of Linked List Topological Sorting Ternary Search Tree Stock Span Problem Treap Data Structure Quicksort on Doubly Linked List Inversion count Expression tree in DS Garbage Collection in DS Merge Sort on Doubly Linked List Sort Stack using Recursion LIFO Approach in data structure Big O Notation in DS Binary Tree Traversal in DS Queue Operations in DS What is a Non-Linear Data Structure FIFO Approach in data structure What are connected graphs in data structure Which Python data structure is immutable Which data structure is used by map What is iteration in data structure What are linear search and binary search in data structure Hash Table vs STL Map Recaman's Sequence Maximum area rectangle created by selecting four sides from an array Maximum number of distinct nodes in a root-to-leaf path DS MCQ Data Structure MCQ Advanced DS MCQ next ? ? prev Maximum number of distinct nodes in a root-to-leaf path Find the maximum number of distinct nodes in all root-to-leaf paths given a Binary Tree. Examples 
Input :   1
            /    \
           2      3
          / \    / \
        4   5  6   3
               \   \
                8   9 

Output : 4 
The root to leaf path with maximum distinct
nodes is 1-3-6-8.
 Exploring all root to leaf paths is a simple solution. Count distinct nodes along each root-to-leaf path and return the maximum number. Hashing is an efficient solution. We traverse the tree recursively, keeping track of the number of distinct nodes on the path from the root to the current node. We repeat for the left and right subtrees, returning the maximum of two values. The implementation of the above idea is shown below. Program in C++ 
// C++ program to find count of distinct nodes
// on a path with maximum distinct nodes.
#include <bits/stdc++.h>
using namespace std;

// A node of binary tree
struct Node {
	int data;
	struct Node *left, *right;
};

// A utility function to create a new Binary
// Tree node
Node* newNode(int data)
{
	Node* temp = new Node;
	temp->data = data;
	temp->left = temp->right = NULL;
	return temp;
}

int largestUinquePathUtil(Node* node, unordered_map<int, int> m)
{
	if (!node)
		return m.size();

	// put this node into hash
	m[node->data]++;

	int max_path = max(largestUinquePathUtil(node->left, m),
					largestUinquePathUtil(node->right, m));

	// remove current node from path "hash"
	m[node->data]--;

	// if we reached a condition where all duplicate value
	// of current node is deleted
	if (m[node->data] == 0)
		m.erase(node->data);

	return max_path;
}

// A utility function to find long unique value path
int largestUinquePath(Node* node)
{
	if (!node)
		return 0;

	// hash that store all node value
	unordered_map<int, int> hash;

	// return max length unique value path
	return largestUinquePathUtil(node, hash);
}

// Driver program to test above functions
int main()
{
	// Create binary tree shown in above figure
	Node* root = newNode(1);
	root->left = newNode(2);
	root->right = newNode(3);
	root->left->left = newNode(4);
	root->left->right = newNode(5);
	root->right->left = newNode(6);
	root->right->right = newNode(7);
	root->right->left->right = newNode(8);
	root->right->right->right = newNode(9);

	cout << largestUinquePath(root) << endl;

	return 0;
}
 Output 4
 Time Complexity : O (n) Next Topic# ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/maximum-number-of-distinct-nodes-in-a-root-to-leaf-path Maximum number of distinct nodes in a root-to-leaf path - javatpoint ? SCROLL TO TOP Home Data Structure C C++ C# Java SQL HTML CSS JavaScript Ajax Android Cloud Design Pattern Quiz Projects Interview Q Comment Forum DS Tutorial DS Tutorial DS Introduction DS Algorithm Asymptotic Analysis DS Pointer DS Structure DS Array DS Array 2D Array DS Linked List Linked List Types of Linked List Singly Linked List Doubly Linked List Circular Linked List Circular Doubly List Skip list in DS DS Stack DS Stack Array Implementation Linked List Implementation DS Queue DS Queue Types of Queues Array Representation Linked List Representation Circular Queue Deque Priority Queue DS Tree DS Tree Binary Tree Binary Search Tree AVL Tree B Tree B+ Tree DS Graph DS Graph Graph Implementation BFS Algorithm DFS Algorithm Spanning Tree DS Searching Linear Search Binary Search DS Sorting Bubble Sort Bucket Sort Comb Sort Counting Sort Heap Sort Insertion Sort Merge Sort Quick Sort Radix Sort Selection Sort Shell Sort Bitonic Sort Cocktail Sort Cycle Sort Tim Sort Differences Linear vs non-linear Array vs linked list Stack vs queue Linear vs Circular Queue Linear Search vs Binary Search Singly Linked List vs Doubly Linked List Binary vs Binary Search Tree Tree vs Graph Binary Search tree vs AVL tree Red Black Tree vs AVL tree B tree vs B+ tree Quick Sort vs Merge Sort BFS vs DFS Stack vs Heap Bubble sort vs. Selection sort Stack vs Array Full Binary Tree vs Complete Binary Tree Binary Tree vs B Tree Primitive vs non-primitive data structure Data types vs data structure Misc Trie Data Structure Heap Data Structure Splay Tree Fundamental of the DS Hash Table Preorder Traversal Tree Traversal Implementation of Queue using Stacks Implementation of Stack using Queue Binomial Heap Postorder Traversal Sparse Matrix Detect loop in a Linked list Inorder Traversal Convert Infix to Postfix notation Convert infix to prefix notation Conversion of Prefix to Postfix expression Conversion of Postfix to Prefix expression Remove the loop in a Linked List Implement two stacks in an array Reverse a stack using recursion Detect cycle in a directed graph Optimal Binary Search Tree Priority Queue using Linked list Balanced Binary Search Tree Boundary Traversal of Binary tree Diagonal Traversal of Binary Tree Vertical Traversal of a Binary tree Graph Algorithms Time Complexity of Sorting Algorithms Applications of Stack in Data Structure Dictionary Data Structure Structured Data and Unstructured Data List Data Structure Types of Tree in Data Structure Abstract data type in data structure Disjoint set data structure Dynamic Data Structure Hash Function in Data Structure Complete Binary Tree Threaded Binary Tree Diameter of Binary Tree Height of Binary Tree Inorder Tree Traversal without Stack Enumeration of Binary Trees Maximum Width of a Binary Tree Types of Graph in Data Structure Primitive Data Type Semi-Structured Data Advance Data Structures Sort an Array of 0's, 1's, and 2's Stock Span Problem Implementation of Deque by Circular Array Rotate Operation in Linked List Subarray with given sum Self-organizing List Unrolled Linked List Types of Sparse Matrices Application of Linked List Topological Sorting Ternary Search Tree Stock Span Problem Treap Data Structure Quicksort on Doubly Linked List Inversion count Expression tree in DS Garbage Collection in DS Merge Sort on Doubly Linked List Sort Stack using Recursion LIFO Approach in data structure Big O Notation in DS Binary Tree Traversal in DS Queue Operations in DS What is a Non-Linear Data Structure FIFO Approach in data structure What are connected graphs in data structure Which Python data structure is immutable Which data structure is used by map What is iteration in data structure What are linear search and binary search in data structure Hash Table vs STL Map Recaman's Sequence Maximum area rectangle created by selecting four sides from an array Maximum number of distinct nodes in a root-to-leaf path DS MCQ Data Structure MCQ Advanced DS MCQ next ? ? prev Maximum number of distinct nodes in a root-to-leaf path Find the maximum number of distinct nodes in all root-to-leaf paths given a Binary Tree. Examples 
Input :   1
            /    \
           2      3
          / \    / \
        4   5  6   3
               \   \
                8   9 

Output : 4 
The root to leaf path with maximum distinct
nodes is 1-3-6-8.
 Exploring all root to leaf paths is a simple solution. Count distinct nodes along each root-to-leaf path and return the maximum number. Hashing is an efficient solution. We traverse the tree recursively, keeping track of the number of distinct nodes on the path from the root to the current node. We repeat for the left and right subtrees, returning the maximum of two values. The implementation of the above idea is shown below. Program in C++ 
// C++ program to find count of distinct nodes
// on a path with maximum distinct nodes.
#include <bits/stdc++.h>
using namespace std;

// A node of binary tree
struct Node {
	int data;
	struct Node *left, *right;
};

// A utility function to create a new Binary
// Tree node
Node* newNode(int data)
{
	Node* temp = new Node;
	temp->data = data;
	temp->left = temp->right = NULL;
	return temp;
}

int largestUinquePathUtil(Node* node, unordered_map<int, int> m)
{
	if (!node)
		return m.size();

	// put this node into hash
	m[node->data]++;

	int max_path = max(largestUinquePathUtil(node->left, m),
					largestUinquePathUtil(node->right, m));

	// remove current node from path "hash"
	m[node->data]--;

	// if we reached a condition where all duplicate value
	// of current node is deleted
	if (m[node->data] == 0)
		m.erase(node->data);

	return max_path;
}

// A utility function to find long unique value path
int largestUinquePath(Node* node)
{
	if (!node)
		return 0;

	// hash that store all node value
	unordered_map<int, int> hash;

	// return max length unique value path
	return largestUinquePathUtil(node, hash);
}

// Driver program to test above functions
int main()
{
	// Create binary tree shown in above figure
	Node* root = newNode(1);
	root->left = newNode(2);
	root->right = newNode(3);
	root->left->left = newNode(4);
	root->left->right = newNode(5);
	root->right->left = newNode(6);
	root->right->right = newNode(7);
	root->right->left->right = newNode(8);
	root->right->right->right = newNode(9);

	cout << largestUinquePath(root) << endl;

	return 0;
}
 Output 4
 Time Complexity : O (n) Next Topic# ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/maximum-number-of-distinct-nodes-in-a-root-to-leaf-path Maximum number of distinct nodes in a root-to-leaf path - javatpoint ? SCROLL TO TOP Home Data Structure C C++ C# Java SQL HTML CSS JavaScript Ajax Android Cloud Design Pattern Quiz Projects Interview Q Comment Forum DS Tutorial DS Tutorial DS Introduction DS Algorithm Asymptotic Analysis DS Pointer DS Structure DS Array DS Array 2D Array DS Linked List Linked List Types of Linked List Singly Linked List Doubly Linked List Circular Linked List Circular Doubly List Skip list in DS DS Stack DS Stack Array Implementation Linked List Implementation DS Queue DS Queue Types of Queues Array Representation Linked List Representation Circular Queue Deque Priority Queue DS Tree DS Tree Binary Tree Binary Search Tree AVL Tree B Tree B+ Tree DS Graph DS Graph Graph Implementation BFS Algorithm DFS Algorithm Spanning Tree DS Searching Linear Search Binary Search DS Sorting Bubble Sort Bucket Sort Comb Sort Counting Sort Heap Sort Insertion Sort Merge Sort Quick Sort Radix Sort Selection Sort Shell Sort Bitonic Sort Cocktail Sort Cycle Sort Tim Sort Differences Linear vs non-linear Array vs linked list Stack vs queue Linear vs Circular Queue Linear Search vs Binary Search Singly Linked List vs Doubly Linked List Binary vs Binary Search Tree Tree vs Graph Binary Search tree vs AVL tree Red Black Tree vs AVL tree B tree vs B+ tree Quick Sort vs Merge Sort BFS vs DFS Stack vs Heap Bubble sort vs. Selection sort Stack vs Array Full Binary Tree vs Complete Binary Tree Binary Tree vs B Tree Primitive vs non-primitive data structure Data types vs data structure Misc Trie Data Structure Heap Data Structure Splay Tree Fundamental of the DS Hash Table Preorder Traversal Tree Traversal Implementation of Queue using Stacks Implementation of Stack using Queue Binomial Heap Postorder Traversal Sparse Matrix Detect loop in a Linked list Inorder Traversal Convert Infix to Postfix notation Convert infix to prefix notation Conversion of Prefix to Postfix expression Conversion of Postfix to Prefix expression Remove the loop in a Linked List Implement two stacks in an array Reverse a stack using recursion Detect cycle in a directed graph Optimal Binary Search Tree Priority Queue using Linked list Balanced Binary Search Tree Boundary Traversal of Binary tree Diagonal Traversal of Binary Tree Vertical Traversal of a Binary tree Graph Algorithms Time Complexity of Sorting Algorithms Applications of Stack in Data Structure Dictionary Data Structure Structured Data and Unstructured Data List Data Structure Types of Tree in Data Structure Abstract data type in data structure Disjoint set data structure Dynamic Data Structure Hash Function in Data Structure Complete Binary Tree Threaded Binary Tree Diameter of Binary Tree Height of Binary Tree Inorder Tree Traversal without Stack Enumeration of Binary Trees Maximum Width of a Binary Tree Types of Graph in Data Structure Primitive Data Type Semi-Structured Data Advance Data Structures Sort an Array of 0's, 1's, and 2's Stock Span Problem Implementation of Deque by Circular Array Rotate Operation in Linked List Subarray with given sum Self-organizing List Unrolled Linked List Types of Sparse Matrices Application of Linked List Topological Sorting Ternary Search Tree Stock Span Problem Treap Data Structure Quicksort on Doubly Linked List Inversion count Expression tree in DS Garbage Collection in DS Merge Sort on Doubly Linked List Sort Stack using Recursion LIFO Approach in data structure Big O Notation in DS Binary Tree Traversal in DS Queue Operations in DS What is a Non-Linear Data Structure FIFO Approach in data structure What are connected graphs in data structure Which Python data structure is immutable Which data structure is used by map What is iteration in data structure What are linear search and binary search in data structure Hash Table vs STL Map Recaman's Sequence Maximum area rectangle created by selecting four sides from an array Maximum number of distinct nodes in a root-to-leaf path DS MCQ Data Structure MCQ Advanced DS MCQ next ? ? prev Maximum number of distinct nodes in a root-to-leaf path Find the maximum number of distinct nodes in all root-to-leaf paths given a Binary Tree. Examples 
Input :   1
            /    \
           2      3
          / \    / \
        4   5  6   3
               \   \
                8   9 

Output : 4 
The root to leaf path with maximum distinct
nodes is 1-3-6-8.
 Exploring all root to leaf paths is a simple solution. Count distinct nodes along each root-to-leaf path and return the maximum number. Hashing is an efficient solution. We traverse the tree recursively, keeping track of the number of distinct nodes on the path from the root to the current node. We repeat for the left and right subtrees, returning the maximum of two values. The implementation of the above idea is shown below. Program in C++ 
// C++ program to find count of distinct nodes
// on a path with maximum distinct nodes.
#include <bits/stdc++.h>
using namespace std;

// A node of binary tree
struct Node {
	int data;
	struct Node *left, *right;
};

// A utility function to create a new Binary
// Tree node
Node* newNode(int data)
{
	Node* temp = new Node;
	temp->data = data;
	temp->left = temp->right = NULL;
	return temp;
}

int largestUinquePathUtil(Node* node, unordered_map<int, int> m)
{
	if (!node)
		return m.size();

	// put this node into hash
	m[node->data]++;

	int max_path = max(largestUinquePathUtil(node->left, m),
					largestUinquePathUtil(node->right, m));

	// remove current node from path "hash"
	m[node->data]--;

	// if we reached a condition where all duplicate value
	// of current node is deleted
	if (m[node->data] == 0)
		m.erase(node->data);

	return max_path;
}

// A utility function to find long unique value path
int largestUinquePath(Node* node)
{
	if (!node)
		return 0;

	// hash that store all node value
	unordered_map<int, int> hash;

	// return max length unique value path
	return largestUinquePathUtil(node, hash);
}

// Driver program to test above functions
int main()
{
	// Create binary tree shown in above figure
	Node* root = newNode(1);
	root->left = newNode(2);
	root->right = newNode(3);
	root->left->left = newNode(4);
	root->left->right = newNode(5);
	root->right->left = newNode(6);
	root->right->right = newNode(7);
	root->right->left->right = newNode(8);
	root->right->right->right = newNode(9);

	cout << largestUinquePath(root) << endl;

	return 0;
}
 Output 4
 Time Complexity : O (n) Next Topic# ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/maximum-number-of-distinct-nodes-in-a-root-to-leaf-path Maximum number of distinct nodes in a root-to-leaf path - javatpoint ? SCROLL TO TOP Home Data Structure C C++ C# Java SQL HTML CSS JavaScript Ajax Android Cloud Design Pattern Quiz Projects Interview Q Comment Forum DS Tutorial DS Tutorial DS Introduction DS Algorithm Asymptotic Analysis DS Pointer DS Structure DS Array DS Array 2D Array DS Linked List Linked List Types of Linked List Singly Linked List Doubly Linked List Circular Linked List Circular Doubly List Skip list in DS DS Stack DS Stack Array Implementation Linked List Implementation DS Queue DS Queue Types of Queues Array Representation Linked List Representation Circular Queue Deque Priority Queue DS Tree DS Tree Binary Tree Binary Search Tree AVL Tree B Tree B+ Tree DS Graph DS Graph Graph Implementation BFS Algorithm DFS Algorithm Spanning Tree DS Searching Linear Search Binary Search DS Sorting Bubble Sort Bucket Sort Comb Sort Counting Sort Heap Sort Insertion Sort Merge Sort Quick Sort Radix Sort Selection Sort Shell Sort Bitonic Sort Cocktail Sort Cycle Sort Tim Sort Differences Linear vs non-linear Array vs linked list Stack vs queue Linear vs Circular Queue Linear Search vs Binary Search Singly Linked List vs Doubly Linked List Binary vs Binary Search Tree Tree vs Graph Binary Search tree vs AVL tree Red Black Tree vs AVL tree B tree vs B+ tree Quick Sort vs Merge Sort BFS vs DFS Stack vs Heap Bubble sort vs. Selection sort Stack vs Array Full Binary Tree vs Complete Binary Tree Binary Tree vs B Tree Primitive vs non-primitive data structure Data types vs data structure Misc Trie Data Structure Heap Data Structure Splay Tree Fundamental of the DS Hash Table Preorder Traversal Tree Traversal Implementation of Queue using Stacks Implementation of Stack using Queue Binomial Heap Postorder Traversal Sparse Matrix Detect loop in a Linked list Inorder Traversal Convert Infix to Postfix notation Convert infix to prefix notation Conversion of Prefix to Postfix expression Conversion of Postfix to Prefix expression Remove the loop in a Linked List Implement two stacks in an array Reverse a stack using recursion Detect cycle in a directed graph Optimal Binary Search Tree Priority Queue using Linked list Balanced Binary Search Tree Boundary Traversal of Binary tree Diagonal Traversal of Binary Tree Vertical Traversal of a Binary tree Graph Algorithms Time Complexity of Sorting Algorithms Applications of Stack in Data Structure Dictionary Data Structure Structured Data and Unstructured Data List Data Structure Types of Tree in Data Structure Abstract data type in data structure Disjoint set data structure Dynamic Data Structure Hash Function in Data Structure Complete Binary Tree Threaded Binary Tree Diameter of Binary Tree Height of Binary Tree Inorder Tree Traversal without Stack Enumeration of Binary Trees Maximum Width of a Binary Tree Types of Graph in Data Structure Primitive Data Type Semi-Structured Data Advance Data Structures Sort an Array of 0's, 1's, and 2's Stock Span Problem Implementation of Deque by Circular Array Rotate Operation in Linked List Subarray with given sum Self-organizing List Unrolled Linked List Types of Sparse Matrices Application of Linked List Topological Sorting Ternary Search Tree Stock Span Problem Treap Data Structure Quicksort on Doubly Linked List Inversion count Expression tree in DS Garbage Collection in DS Merge Sort on Doubly Linked List Sort Stack using Recursion LIFO Approach in data structure Big O Notation in DS Binary Tree Traversal in DS Queue Operations in DS What is a Non-Linear Data Structure FIFO Approach in data structure What are connected graphs in data structure Which Python data structure is immutable Which data structure is used by map What is iteration in data structure What are linear search and binary search in data structure Hash Table vs STL Map Recaman's Sequence Maximum area rectangle created by selecting four sides from an array Maximum number of distinct nodes in a root-to-leaf path DS MCQ Data Structure MCQ Advanced DS MCQ next ? ? prev Maximum number of distinct nodes in a root-to-leaf path Find the maximum number of distinct nodes in all root-to-leaf paths given a Binary Tree. Examples 
Input :   1
            /    \
           2      3
          / \    / \
        4   5  6   3
               \   \
                8   9 

Output : 4 
The root to leaf path with maximum distinct
nodes is 1-3-6-8.
 Exploring all root to leaf paths is a simple solution. Count distinct nodes along each root-to-leaf path and return the maximum number. Hashing is an efficient solution. We traverse the tree recursively, keeping track of the number of distinct nodes on the path from the root to the current node. We repeat for the left and right subtrees, returning the maximum of two values. The implementation of the above idea is shown below. Program in C++ 
// C++ program to find count of distinct nodes
// on a path with maximum distinct nodes.
#include <bits/stdc++.h>
using namespace std;

// A node of binary tree
struct Node {
	int data;
	struct Node *left, *right;
};

// A utility function to create a new Binary
// Tree node
Node* newNode(int data)
{
	Node* temp = new Node;
	temp->data = data;
	temp->left = temp->right = NULL;
	return temp;
}

int largestUinquePathUtil(Node* node, unordered_map<int, int> m)
{
	if (!node)
		return m.size();

	// put this node into hash
	m[node->data]++;

	int max_path = max(largestUinquePathUtil(node->left, m),
					largestUinquePathUtil(node->right, m));

	// remove current node from path "hash"
	m[node->data]--;

	// if we reached a condition where all duplicate value
	// of current node is deleted
	if (m[node->data] == 0)
		m.erase(node->data);

	return max_path;
}

// A utility function to find long unique value path
int largestUinquePath(Node* node)
{
	if (!node)
		return 0;

	// hash that store all node value
	unordered_map<int, int> hash;

	// return max length unique value path
	return largestUinquePathUtil(node, hash);
}

// Driver program to test above functions
int main()
{
	// Create binary tree shown in above figure
	Node* root = newNode(1);
	root->left = newNode(2);
	root->right = newNode(3);
	root->left->left = newNode(4);
	root->left->right = newNode(5);
	root->right->left = newNode(6);
	root->right->right = newNode(7);
	root->right->left->right = newNode(8);
	root->right->right->right = newNode(9);

	cout << largestUinquePath(root) << endl;

	return 0;
}
 Output 4
 Time Complexity : O (n) Next Topic# ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/maximum-number-of-distinct-nodes-in-a-root-to-leaf-path Maximum number of distinct nodes in a root-to-leaf path - javatpoint ? SCROLL TO TOP Home Data Structure C C++ C# Java SQL HTML CSS JavaScript Ajax Android Cloud Design Pattern Quiz Projects Interview Q Comment Forum DS Tutorial DS Tutorial DS Introduction DS Algorithm Asymptotic Analysis DS Pointer DS Structure DS Array DS Array 2D Array DS Linked List Linked List Types of Linked List Singly Linked List Doubly Linked List Circular Linked List Circular Doubly List Skip list in DS DS Stack DS Stack Array Implementation Linked List Implementation DS Queue DS Queue Types of Queues Array Representation Linked List Representation Circular Queue Deque Priority Queue DS Tree DS Tree Binary Tree Binary Search Tree AVL Tree B Tree B+ Tree DS Graph DS Graph Graph Implementation BFS Algorithm DFS Algorithm Spanning Tree DS Searching Linear Search Binary Search DS Sorting Bubble Sort Bucket Sort Comb Sort Counting Sort Heap Sort Insertion Sort Merge Sort Quick Sort Radix Sort Selection Sort Shell Sort Bitonic Sort Cocktail Sort Cycle Sort Tim Sort Differences Linear vs non-linear Array vs linked list Stack vs queue Linear vs Circular Queue Linear Search vs Binary Search Singly Linked List vs Doubly Linked List Binary vs Binary Search Tree Tree vs Graph Binary Search tree vs AVL tree Red Black Tree vs AVL tree B tree vs B+ tree Quick Sort vs Merge Sort BFS vs DFS Stack vs Heap Bubble sort vs. Selection sort Stack vs Array Full Binary Tree vs Complete Binary Tree Binary Tree vs B Tree Primitive vs non-primitive data structure Data types vs data structure Misc Trie Data Structure Heap Data Structure Splay Tree Fundamental of the DS Hash Table Preorder Traversal Tree Traversal Implementation of Queue using Stacks Implementation of Stack using Queue Binomial Heap Postorder Traversal Sparse Matrix Detect loop in a Linked list Inorder Traversal Convert Infix to Postfix notation Convert infix to prefix notation Conversion of Prefix to Postfix expression Conversion of Postfix to Prefix expression Remove the loop in a Linked List Implement two stacks in an array Reverse a stack using recursion Detect cycle in a directed graph Optimal Binary Search Tree Priority Queue using Linked list Balanced Binary Search Tree Boundary Traversal of Binary tree Diagonal Traversal of Binary Tree Vertical Traversal of a Binary tree Graph Algorithms Time Complexity of Sorting Algorithms Applications of Stack in Data Structure Dictionary Data Structure Structured Data and Unstructured Data List Data Structure Types of Tree in Data Structure Abstract data type in data structure Disjoint set data structure Dynamic Data Structure Hash Function in Data Structure Complete Binary Tree Threaded Binary Tree Diameter of Binary Tree Height of Binary Tree Inorder Tree Traversal without Stack Enumeration of Binary Trees Maximum Width of a Binary Tree Types of Graph in Data Structure Primitive Data Type Semi-Structured Data Advance Data Structures Sort an Array of 0's, 1's, and 2's Stock Span Problem Implementation of Deque by Circular Array Rotate Operation in Linked List Subarray with given sum Self-organizing List Unrolled Linked List Types of Sparse Matrices Application of Linked List Topological Sorting Ternary Search Tree Stock Span Problem Treap Data Structure Quicksort on Doubly Linked List Inversion count Expression tree in DS Garbage Collection in DS Merge Sort on Doubly Linked List Sort Stack using Recursion LIFO Approach in data structure Big O Notation in DS Binary Tree Traversal in DS Queue Operations in DS What is a Non-Linear Data Structure FIFO Approach in data structure What are connected graphs in data structure Which Python data structure is immutable Which data structure is used by map What is iteration in data structure What are linear search and binary search in data structure Hash Table vs STL Map Recaman's Sequence Maximum area rectangle created by selecting four sides from an array Maximum number of distinct nodes in a root-to-leaf path DS MCQ Data Structure MCQ Advanced DS MCQ next ? ? prev Maximum number of distinct nodes in a root-to-leaf path Find the maximum number of distinct nodes in all root-to-leaf paths given a Binary Tree. Examples 
Input :   1
            /    \
           2      3
          / \    / \
        4   5  6   3
               \   \
                8   9 

Output : 4 
The root to leaf path with maximum distinct
nodes is 1-3-6-8.
 Exploring all root to leaf paths is a simple solution. Count distinct nodes along each root-to-leaf path and return the maximum number. Hashing is an efficient solution. We traverse the tree recursively, keeping track of the number of distinct nodes on the path from the root to the current node. We repeat for the left and right subtrees, returning the maximum of two values. The implementation of the above idea is shown below. Program in C++ 
// C++ program to find count of distinct nodes
// on a path with maximum distinct nodes.
#include <bits/stdc++.h>
using namespace std;

// A node of binary tree
struct Node {
	int data;
	struct Node *left, *right;
};

// A utility function to create a new Binary
// Tree node
Node* newNode(int data)
{
	Node* temp = new Node;
	temp->data = data;
	temp->left = temp->right = NULL;
	return temp;
}

int largestUinquePathUtil(Node* node, unordered_map<int, int> m)
{
	if (!node)
		return m.size();

	// put this node into hash
	m[node->data]++;

	int max_path = max(largestUinquePathUtil(node->left, m),
					largestUinquePathUtil(node->right, m));

	// remove current node from path "hash"
	m[node->data]--;

	// if we reached a condition where all duplicate value
	// of current node is deleted
	if (m[node->data] == 0)
		m.erase(node->data);

	return max_path;
}

// A utility function to find long unique value path
int largestUinquePath(Node* node)
{
	if (!node)
		return 0;

	// hash that store all node value
	unordered_map<int, int> hash;

	// return max length unique value path
	return largestUinquePathUtil(node, hash);
}

// Driver program to test above functions
int main()
{
	// Create binary tree shown in above figure
	Node* root = newNode(1);
	root->left = newNode(2);
	root->right = newNode(3);
	root->left->left = newNode(4);
	root->left->right = newNode(5);
	root->right->left = newNode(6);
	root->right->right = newNode(7);
	root->right->left->right = newNode(8);
	root->right->right->right = newNode(9);

	cout << largestUinquePath(root) << endl;

	return 0;
}
 Output 4
 Time Complexity : O (n) Next Topic# ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/maximum-number-of-distinct-nodes-in-a-root-to-leaf-path Maximum number of distinct nodes in a root-to-leaf path - javatpoint ? SCROLL TO TOP Home Data Structure C C++ C# Java SQL HTML CSS JavaScript Ajax Android Cloud Design Pattern Quiz Projects Interview Q Comment Forum DS Tutorial DS Tutorial DS Introduction DS Algorithm Asymptotic Analysis DS Pointer DS Structure DS Array DS Array 2D Array DS Linked List Linked List Types of Linked List Singly Linked List Doubly Linked List Circular Linked List Circular Doubly List Skip list in DS DS Stack DS Stack Array Implementation Linked List Implementation DS Queue DS Queue Types of Queues Array Representation Linked List Representation Circular Queue Deque Priority Queue DS Tree DS Tree Binary Tree Binary Search Tree AVL Tree B Tree B+ Tree DS Graph DS Graph Graph Implementation BFS Algorithm DFS Algorithm Spanning Tree DS Searching Linear Search Binary Search DS Sorting Bubble Sort Bucket Sort Comb Sort Counting Sort Heap Sort Insertion Sort Merge Sort Quick Sort Radix Sort Selection Sort Shell Sort Bitonic Sort Cocktail Sort Cycle Sort Tim Sort Differences Linear vs non-linear Array vs linked list Stack vs queue Linear vs Circular Queue Linear Search vs Binary Search Singly Linked List vs Doubly Linked List Binary vs Binary Search Tree Tree vs Graph Binary Search tree vs AVL tree Red Black Tree vs AVL tree B tree vs B+ tree Quick Sort vs Merge Sort BFS vs DFS Stack vs Heap Bubble sort vs. Selection sort Stack vs Array Full Binary Tree vs Complete Binary Tree Binary Tree vs B Tree Primitive vs non-primitive data structure Data types vs data structure Misc Trie Data Structure Heap Data Structure Splay Tree Fundamental of the DS Hash Table Preorder Traversal Tree Traversal Implementation of Queue using Stacks Implementation of Stack using Queue Binomial Heap Postorder Traversal Sparse Matrix Detect loop in a Linked list Inorder Traversal Convert Infix to Postfix notation Convert infix to prefix notation Conversion of Prefix to Postfix expression Conversion of Postfix to Prefix expression Remove the loop in a Linked List Implement two stacks in an array Reverse a stack using recursion Detect cycle in a directed graph Optimal Binary Search Tree Priority Queue using Linked list Balanced Binary Search Tree Boundary Traversal of Binary tree Diagonal Traversal of Binary Tree Vertical Traversal of a Binary tree Graph Algorithms Time Complexity of Sorting Algorithms Applications of Stack in Data Structure Dictionary Data Structure Structured Data and Unstructured Data List Data Structure Types of Tree in Data Structure Abstract data type in data structure Disjoint set data structure Dynamic Data Structure Hash Function in Data Structure Complete Binary Tree Threaded Binary Tree Diameter of Binary Tree Height of Binary Tree Inorder Tree Traversal without Stack Enumeration of Binary Trees Maximum Width of a Binary Tree Types of Graph in Data Structure Primitive Data Type Semi-Structured Data Advance Data Structures Sort an Array of 0's, 1's, and 2's Stock Span Problem Implementation of Deque by Circular Array Rotate Operation in Linked List Subarray with given sum Self-organizing List Unrolled Linked List Types of Sparse Matrices Application of Linked List Topological Sorting Ternary Search Tree Stock Span Problem Treap Data Structure Quicksort on Doubly Linked List Inversion count Expression tree in DS Garbage Collection in DS Merge Sort on Doubly Linked List Sort Stack using Recursion LIFO Approach in data structure Big O Notation in DS Binary Tree Traversal in DS Queue Operations in DS What is a Non-Linear Data Structure FIFO Approach in data structure What are connected graphs in data structure Which Python data structure is immutable Which data structure is used by map What is iteration in data structure What are linear search and binary search in data structure Hash Table vs STL Map Recaman's Sequence Maximum area rectangle created by selecting four sides from an array Maximum number of distinct nodes in a root-to-leaf path DS MCQ Data Structure MCQ Advanced DS MCQ next ? ? prev Maximum number of distinct nodes in a root-to-leaf path Find the maximum number of distinct nodes in all root-to-leaf paths given a Binary Tree. Examples 
Input :   1
            /    \
           2      3
          / \    / \
        4   5  6   3
               \   \
                8   9 

Output : 4 
The root to leaf path with maximum distinct
nodes is 1-3-6-8.
 Exploring all root to leaf paths is a simple solution. Count distinct nodes along each root-to-leaf path and return the maximum number. Hashing is an efficient solution. We traverse the tree recursively, keeping track of the number of distinct nodes on the path from the root to the current node. We repeat for the left and right subtrees, returning the maximum of two values. The implementation of the above idea is shown below. Program in C++ 
// C++ program to find count of distinct nodes
// on a path with maximum distinct nodes.
#include <bits/stdc++.h>
using namespace std;

// A node of binary tree
struct Node {
	int data;
	struct Node *left, *right;
};

// A utility function to create a new Binary
// Tree node
Node* newNode(int data)
{
	Node* temp = new Node;
	temp->data = data;
	temp->left = temp->right = NULL;
	return temp;
}

int largestUinquePathUtil(Node* node, unordered_map<int, int> m)
{
	if (!node)
		return m.size();

	// put this node into hash
	m[node->data]++;

	int max_path = max(largestUinquePathUtil(node->left, m),
					largestUinquePathUtil(node->right, m));

	// remove current node from path "hash"
	m[node->data]--;

	// if we reached a condition where all duplicate value
	// of current node is deleted
	if (m[node->data] == 0)
		m.erase(node->data);

	return max_path;
}

// A utility function to find long unique value path
int largestUinquePath(Node* node)
{
	if (!node)
		return 0;

	// hash that store all node value
	unordered_map<int, int> hash;

	// return max length unique value path
	return largestUinquePathUtil(node, hash);
}

// Driver program to test above functions
int main()
{
	// Create binary tree shown in above figure
	Node* root = newNode(1);
	root->left = newNode(2);
	root->right = newNode(3);
	root->left->left = newNode(4);
	root->left->right = newNode(5);
	root->right->left = newNode(6);
	root->right->right = newNode(7);
	root->right->left->right = newNode(8);
	root->right->right->right = newNode(9);

	cout << largestUinquePath(root) << endl;

	return 0;
}
 Output 4
 Time Complexity : O (n) Next Topic# ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.