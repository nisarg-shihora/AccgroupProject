https://www.javatpoint.com/missing-number-in-an-arithmetic-progression-in-java Missing Number in An Arithmetic Progression in Java - javatpoint ? SCROLL TO TOP Home Coding Problems Java Programs OOPs String Exception Multithreading Collections Coding Problems Candy Distribution Problem in Java Find Rectangle in a Matrix with Corner as 1 in Java Minimum Number of Taps to Open to Water a Garden in Java Seven Segment Display Problem in Java Split Array Largest Sum in Java Find Original Array from a Double Array in Java Minimum Lights to Activate Problem in Java Rotate List in Java Count of Range Sum Problem in Java Create A Tree of Coprime in Java Convert Integer to Roman Numerals in Java Check if n and its Double Exist or not in Java Array of Doubled Pair Problem in Java Tag Content Extractor Problem in Java Convert Roman to Integer in Java Minimum Number of Flips to Convert Binary Matrix into Zero Matrix in Java XOR of Array Elements Except Itself in Java Check If the Given Array is Mirror Inverse in Java How to Create a Mirror Image of A 2D Array in Java Add Numbers Represented by Linked Lists in Java Majority Element In an Array in Java Block Swap Algorithm or Array Rotation in Java Minimum Difference Among Group Size Two in Java Missing Number in An Arithmetic Progression in Java Peak Index of Mountain Array Problem in Java next ? ? prev Missing Number in An Arithmetic Progression in Java It is very interesting problem frequently asked in interviews of top IT companies like Google, Amazon, TCS, Accenture, etc. By solving the problem, one wants to check the logical ability, critical thinking, and problem-solving skill of the interviewee. So, in this section, we are going to find missing number in an arithmetic progression in Java with different approaches and logic. Also, we will create Java programs for the same. Problem Statement An array is given. The array contains some numbers that represent an arithmetic progression. In the arithmetic progression, one number is missing. The task is to find that missing number. Example 1: Input: int arr[] = {3, 5, 7, 9, 11, 15, 17, 19} Output: 13 Explanation: If we put the number 13 after number 11 in the input array, the arithmetic progression is complete. Hence, the answer is 13 Example 2: Input: int arr[] = {1, 7, 13, 19, 31, 37, 43} Output: 25 Explanation: If we put the number 25 after the number 19 in the input array, the arithmetic progression is complete. Hence, the answer is 25. Example 3: Input: int arr[] = {25, 18, 4, -3, -10, -17, -24} Output: 11 Explanation: If we put the number 11 after the number 18 in the input array, the arithmetic progression is complete. Hence, the answer is 11. Solution to the Problem Using Arithmetic Progression Formula The sum of the numbers in an arithmetic progression whose first term is a1 and the last term is an, and the total term is n is: Sn = (n x (a1 + an) ) / 2. Thus, we can compute the sum of the input array. It is because we know the first, last, and size of the input array. If we take the reference of example 1, we get: S9 = (9 x (3 + 19)) / 2 = (9 x 22) / 2 = 198 / 2 = 99 (9 is the size of the input array including the missing element) Now, iterate over the array and find the sum of the elements present. We get Sum of elements: 3 + 5 + 7 + 9 + 11 + 15 + 17 + 19 = 86 Now, subtract S8 with the sum of elements of the input array. We get 99 - 86 = 13, which is the missing element of the arithmetic progression. The following program implements the same concept. FileName: MissingElementAP.java 
public class MissingElementAP 
{
public int findMissingEle(int inputArr[], int size)
{
    // for storing the sum of the elements
    // present in the array
    int sumOfEle = 0;
    // for storing the sum using the AP sum formula
    int APSum = 0;
    // sum of the elements of the array, including the missing element
    // using the sum of the elements of an Arithmetic Progression Formula
    // size + 1 because we have to include the missing element in the input array
    APSum = ((size + 1) * (inputArr[0] + inputArr[size - 1])) / 2;
    // loop for computing the sum of elements
    // present in the input array
    for(int i = 0; i < size; i++)
    {
        sumOfEle = sumOfEle + inputArr[i];
    }
    // finding the missing element
    int missingEle = APSum - sumOfEle;
    // returning the missing element
    return missingEle;
}
// main method
public static void main(String[] argvs) 
{
// creating an object of the class MissingElementAP
MissingElementAP obj = new MissingElementAP();
// input 1
int apArr[] = {3, 5, 7, 9, 11, 15, 17, 19};
int size = apArr.length;
int ans = obj.findMissingEle(apArr, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
    System.out.print(apArr[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
System.out.println( "\n" );
// input 2
int apArr1[] = {1, 7, 13, 19, 31, 37, 43};
size = apArr1.length;
ans = obj.findMissingEle(apArr1, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
    System.out.print(apArr1[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
System.out.println( "\n" );
// input 3
int apArr2[] = {25, 18, 4, -3, -10, -17, -24};
size = apArr2.length;
ans = obj.findMissingEle(apArr2, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
    System.out.print(apArr2[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
}
}
<p><strong>Output:</strong></p>
<div class="codeblock3"><pre>
For the input array: 
3 5 7 9 11 15 17 19 
The missing element is: 13


For the input array: 
1 7 13 19 31 37 43 
The missing element is: 25


For the input array: 
25 18 4 -3 -10 -17 -24 
The missing element is: 11
</pre></div>
<p><strong>Complexity Analysis:</strong> Since the program is using a for-loop for computing the sum of elements, the time complexity of the program is O(n), where n is the total number of elements present in the array. The space complexity of the program is constant, i.e., O(1).</p>
<h3 class="h3">Using Binary Search</h3>
<p>Observe the examples mentioned above. One can see that elements of the input array are either in increasing order or in decreasing order. Whenever such a kind of pattern is observed, one can use binary search.</p>
<p>Go to the middle element and compute the difference between the middle and next to the middle element. If it is not equal to the common difference of the arithmetic progression, then the missing element lies between mid and mid + 1. If the middle element is equal to the (s / 2)th term of the arithmetic progression series, then the missing element is in the right half of the input array; otherwise in the left half. The following program illustrates the same.</p>
<p><strong>FileName:</strong> MissingElementAP1.java</p>
<div class="codeblock"><textarea name="code" class="java">
public class MissingElementAP1
{
// the following method implements the binary 
// search with the help of recursion to find the 
// missing element in the arithmetic progression
public int findMissingUtility(int arr[], int l, int h, int difference)
{
// There has to be atleast two elements
// for computing the missing element
if (h <= l)
{
return Integer.MAX_VALUE;
}
// Finding the middle element index
int m = l + (h - l) / 2;
// The element just after the middle element is missing.
// The arr[mid+1] must exist, because we return when
// (l == hi) and take the floor of (h - l) / 2
if (arr[m + 1] - arr[m] != difference)
{
return (arr[m] + difference);
}
// The element just before mid is missing
if (m > 0 && arr[m] - arr[m - 1] != difference)
{
return (arr[m - 1] + difference);
}
// If the elements till the mid follow
// AP, then apply recursion on the right half
if (arr[m] == arr[0] + m * difference)
{
return findMissingUtility(arr, m + 1, h, difference);
}
// Else applying recursion on the left half
return findMissingUtility(arr, l, m - 1, difference);
}
// The method uses the method findMissingUtility()
// for finding the element that is missing in AP.
// The method only the considers that the 
// common difference of the arithmetic progression is
// an integer.
public int findMissing(int arr[], int n)
{
// Since only one element is missing
// we can use the last and first element
// for computing the common difference of the
// arithemtic progression
int commonDiff = (arr[n - 1] - arr[0]) / n;
// Applying Binary search for the missing
// number using the above calculated diff
return findMissingUtility(arr, 0, n - 1, commonDiff);
}
// main method
public static void main(String[] argvs) 
{
// creating an object of the class MissingElementAP1
MissingElementAP1 obj = new MissingElementAP1();
// input 1
int apArr[] = {3, 5, 7, 9, 11, 15, 17, 19};
int size = apArr.length;
int ans = obj.findMissing(apArr, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
System.out.print(apArr[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
System.out.println( "\n" );
// input 2
int apArr1[] = {1, 7, 13, 19, 31, 37, 43};
size = apArr1.length;
ans = obj.findMissing(apArr1, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
System.out.print(apArr1[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
System.out.println( "\n" );
// input 3
int apArr2[] = {25, 18, 4, -3, -10, -17, -24};
size = apArr2.length;
ans = obj.findMissing(apArr2, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
System.out.print(apArr2[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
}
}
 Output: For the input array: 
3 5 7 9 11 15 17 19 
The missing element is: 13


For the input array: 
1 7 13 19 31 37 43 
The missing element is: 25


For the input array: 
25 18 4 -3 -10 -17 -24 
The missing element is: 11
 Complexity Analysis: Since the program is using the binary search, the time complexity of the program is O(n), where n is the total number of elements present in the input array. The program is not using any auxiliary space. Therefore, the space complexity of the program is constant, i.e., O(1). Next TopicPeak Index of Mountain Array Problem in Java ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/missing-number-in-an-arithmetic-progression-in-java Missing Number in An Arithmetic Progression in Java - javatpoint ? SCROLL TO TOP Home Coding Problems Java Programs OOPs String Exception Multithreading Collections Coding Problems Candy Distribution Problem in Java Find Rectangle in a Matrix with Corner as 1 in Java Minimum Number of Taps to Open to Water a Garden in Java Seven Segment Display Problem in Java Split Array Largest Sum in Java Find Original Array from a Double Array in Java Minimum Lights to Activate Problem in Java Rotate List in Java Count of Range Sum Problem in Java Create A Tree of Coprime in Java Convert Integer to Roman Numerals in Java Check if n and its Double Exist or not in Java Array of Doubled Pair Problem in Java Tag Content Extractor Problem in Java Convert Roman to Integer in Java Minimum Number of Flips to Convert Binary Matrix into Zero Matrix in Java XOR of Array Elements Except Itself in Java Check If the Given Array is Mirror Inverse in Java How to Create a Mirror Image of A 2D Array in Java Add Numbers Represented by Linked Lists in Java Majority Element In an Array in Java Block Swap Algorithm or Array Rotation in Java Minimum Difference Among Group Size Two in Java Missing Number in An Arithmetic Progression in Java Peak Index of Mountain Array Problem in Java next ? ? prev Missing Number in An Arithmetic Progression in Java It is very interesting problem frequently asked in interviews of top IT companies like Google, Amazon, TCS, Accenture, etc. By solving the problem, one wants to check the logical ability, critical thinking, and problem-solving skill of the interviewee. So, in this section, we are going to find missing number in an arithmetic progression in Java with different approaches and logic. Also, we will create Java programs for the same. Problem Statement An array is given. The array contains some numbers that represent an arithmetic progression. In the arithmetic progression, one number is missing. The task is to find that missing number. Example 1: Input: int arr[] = {3, 5, 7, 9, 11, 15, 17, 19} Output: 13 Explanation: If we put the number 13 after number 11 in the input array, the arithmetic progression is complete. Hence, the answer is 13 Example 2: Input: int arr[] = {1, 7, 13, 19, 31, 37, 43} Output: 25 Explanation: If we put the number 25 after the number 19 in the input array, the arithmetic progression is complete. Hence, the answer is 25. Example 3: Input: int arr[] = {25, 18, 4, -3, -10, -17, -24} Output: 11 Explanation: If we put the number 11 after the number 18 in the input array, the arithmetic progression is complete. Hence, the answer is 11. Solution to the Problem Using Arithmetic Progression Formula The sum of the numbers in an arithmetic progression whose first term is a1 and the last term is an, and the total term is n is: Sn = (n x (a1 + an) ) / 2. Thus, we can compute the sum of the input array. It is because we know the first, last, and size of the input array. If we take the reference of example 1, we get: S9 = (9 x (3 + 19)) / 2 = (9 x 22) / 2 = 198 / 2 = 99 (9 is the size of the input array including the missing element) Now, iterate over the array and find the sum of the elements present. We get Sum of elements: 3 + 5 + 7 + 9 + 11 + 15 + 17 + 19 = 86 Now, subtract S8 with the sum of elements of the input array. We get 99 - 86 = 13, which is the missing element of the arithmetic progression. The following program implements the same concept. FileName: MissingElementAP.java 
public class MissingElementAP 
{
public int findMissingEle(int inputArr[], int size)
{
    // for storing the sum of the elements
    // present in the array
    int sumOfEle = 0;
    // for storing the sum using the AP sum formula
    int APSum = 0;
    // sum of the elements of the array, including the missing element
    // using the sum of the elements of an Arithmetic Progression Formula
    // size + 1 because we have to include the missing element in the input array
    APSum = ((size + 1) * (inputArr[0] + inputArr[size - 1])) / 2;
    // loop for computing the sum of elements
    // present in the input array
    for(int i = 0; i < size; i++)
    {
        sumOfEle = sumOfEle + inputArr[i];
    }
    // finding the missing element
    int missingEle = APSum - sumOfEle;
    // returning the missing element
    return missingEle;
}
// main method
public static void main(String[] argvs) 
{
// creating an object of the class MissingElementAP
MissingElementAP obj = new MissingElementAP();
// input 1
int apArr[] = {3, 5, 7, 9, 11, 15, 17, 19};
int size = apArr.length;
int ans = obj.findMissingEle(apArr, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
    System.out.print(apArr[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
System.out.println( "\n" );
// input 2
int apArr1[] = {1, 7, 13, 19, 31, 37, 43};
size = apArr1.length;
ans = obj.findMissingEle(apArr1, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
    System.out.print(apArr1[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
System.out.println( "\n" );
// input 3
int apArr2[] = {25, 18, 4, -3, -10, -17, -24};
size = apArr2.length;
ans = obj.findMissingEle(apArr2, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
    System.out.print(apArr2[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
}
}
<p><strong>Output:</strong></p>
<div class="codeblock3"><pre>
For the input array: 
3 5 7 9 11 15 17 19 
The missing element is: 13


For the input array: 
1 7 13 19 31 37 43 
The missing element is: 25


For the input array: 
25 18 4 -3 -10 -17 -24 
The missing element is: 11
</pre></div>
<p><strong>Complexity Analysis:</strong> Since the program is using a for-loop for computing the sum of elements, the time complexity of the program is O(n), where n is the total number of elements present in the array. The space complexity of the program is constant, i.e., O(1).</p>
<h3 class="h3">Using Binary Search</h3>
<p>Observe the examples mentioned above. One can see that elements of the input array are either in increasing order or in decreasing order. Whenever such a kind of pattern is observed, one can use binary search.</p>
<p>Go to the middle element and compute the difference between the middle and next to the middle element. If it is not equal to the common difference of the arithmetic progression, then the missing element lies between mid and mid + 1. If the middle element is equal to the (s / 2)th term of the arithmetic progression series, then the missing element is in the right half of the input array; otherwise in the left half. The following program illustrates the same.</p>
<p><strong>FileName:</strong> MissingElementAP1.java</p>
<div class="codeblock"><textarea name="code" class="java">
public class MissingElementAP1
{
// the following method implements the binary 
// search with the help of recursion to find the 
// missing element in the arithmetic progression
public int findMissingUtility(int arr[], int l, int h, int difference)
{
// There has to be atleast two elements
// for computing the missing element
if (h <= l)
{
return Integer.MAX_VALUE;
}
// Finding the middle element index
int m = l + (h - l) / 2;
// The element just after the middle element is missing.
// The arr[mid+1] must exist, because we return when
// (l == hi) and take the floor of (h - l) / 2
if (arr[m + 1] - arr[m] != difference)
{
return (arr[m] + difference);
}
// The element just before mid is missing
if (m > 0 && arr[m] - arr[m - 1] != difference)
{
return (arr[m - 1] + difference);
}
// If the elements till the mid follow
// AP, then apply recursion on the right half
if (arr[m] == arr[0] + m * difference)
{
return findMissingUtility(arr, m + 1, h, difference);
}
// Else applying recursion on the left half
return findMissingUtility(arr, l, m - 1, difference);
}
// The method uses the method findMissingUtility()
// for finding the element that is missing in AP.
// The method only the considers that the 
// common difference of the arithmetic progression is
// an integer.
public int findMissing(int arr[], int n)
{
// Since only one element is missing
// we can use the last and first element
// for computing the common difference of the
// arithemtic progression
int commonDiff = (arr[n - 1] - arr[0]) / n;
// Applying Binary search for the missing
// number using the above calculated diff
return findMissingUtility(arr, 0, n - 1, commonDiff);
}
// main method
public static void main(String[] argvs) 
{
// creating an object of the class MissingElementAP1
MissingElementAP1 obj = new MissingElementAP1();
// input 1
int apArr[] = {3, 5, 7, 9, 11, 15, 17, 19};
int size = apArr.length;
int ans = obj.findMissing(apArr, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
System.out.print(apArr[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
System.out.println( "\n" );
// input 2
int apArr1[] = {1, 7, 13, 19, 31, 37, 43};
size = apArr1.length;
ans = obj.findMissing(apArr1, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
System.out.print(apArr1[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
System.out.println( "\n" );
// input 3
int apArr2[] = {25, 18, 4, -3, -10, -17, -24};
size = apArr2.length;
ans = obj.findMissing(apArr2, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
System.out.print(apArr2[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
}
}
 Output: For the input array: 
3 5 7 9 11 15 17 19 
The missing element is: 13


For the input array: 
1 7 13 19 31 37 43 
The missing element is: 25


For the input array: 
25 18 4 -3 -10 -17 -24 
The missing element is: 11
 Complexity Analysis: Since the program is using the binary search, the time complexity of the program is O(n), where n is the total number of elements present in the input array. The program is not using any auxiliary space. Therefore, the space complexity of the program is constant, i.e., O(1). Next TopicPeak Index of Mountain Array Problem in Java ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/missing-number-in-an-arithmetic-progression-in-java Missing Number in An Arithmetic Progression in Java - javatpoint ? SCROLL TO TOP Home Coding Problems Java Programs OOPs String Exception Multithreading Collections Coding Problems Candy Distribution Problem in Java Find Rectangle in a Matrix with Corner as 1 in Java Minimum Number of Taps to Open to Water a Garden in Java Seven Segment Display Problem in Java Split Array Largest Sum in Java Find Original Array from a Double Array in Java Minimum Lights to Activate Problem in Java Rotate List in Java Count of Range Sum Problem in Java Create A Tree of Coprime in Java Convert Integer to Roman Numerals in Java Check if n and its Double Exist or not in Java Array of Doubled Pair Problem in Java Tag Content Extractor Problem in Java Convert Roman to Integer in Java Minimum Number of Flips to Convert Binary Matrix into Zero Matrix in Java XOR of Array Elements Except Itself in Java Check If the Given Array is Mirror Inverse in Java How to Create a Mirror Image of A 2D Array in Java Add Numbers Represented by Linked Lists in Java Majority Element In an Array in Java Block Swap Algorithm or Array Rotation in Java Minimum Difference Among Group Size Two in Java Missing Number in An Arithmetic Progression in Java Peak Index of Mountain Array Problem in Java next ? ? prev Missing Number in An Arithmetic Progression in Java It is very interesting problem frequently asked in interviews of top IT companies like Google, Amazon, TCS, Accenture, etc. By solving the problem, one wants to check the logical ability, critical thinking, and problem-solving skill of the interviewee. So, in this section, we are going to find missing number in an arithmetic progression in Java with different approaches and logic. Also, we will create Java programs for the same. Problem Statement An array is given. The array contains some numbers that represent an arithmetic progression. In the arithmetic progression, one number is missing. The task is to find that missing number. Example 1: Input: int arr[] = {3, 5, 7, 9, 11, 15, 17, 19} Output: 13 Explanation: If we put the number 13 after number 11 in the input array, the arithmetic progression is complete. Hence, the answer is 13 Example 2: Input: int arr[] = {1, 7, 13, 19, 31, 37, 43} Output: 25 Explanation: If we put the number 25 after the number 19 in the input array, the arithmetic progression is complete. Hence, the answer is 25. Example 3: Input: int arr[] = {25, 18, 4, -3, -10, -17, -24} Output: 11 Explanation: If we put the number 11 after the number 18 in the input array, the arithmetic progression is complete. Hence, the answer is 11. Solution to the Problem Using Arithmetic Progression Formula The sum of the numbers in an arithmetic progression whose first term is a1 and the last term is an, and the total term is n is: Sn = (n x (a1 + an) ) / 2. Thus, we can compute the sum of the input array. It is because we know the first, last, and size of the input array. If we take the reference of example 1, we get: S9 = (9 x (3 + 19)) / 2 = (9 x 22) / 2 = 198 / 2 = 99 (9 is the size of the input array including the missing element) Now, iterate over the array and find the sum of the elements present. We get Sum of elements: 3 + 5 + 7 + 9 + 11 + 15 + 17 + 19 = 86 Now, subtract S8 with the sum of elements of the input array. We get 99 - 86 = 13, which is the missing element of the arithmetic progression. The following program implements the same concept. FileName: MissingElementAP.java 
public class MissingElementAP 
{
public int findMissingEle(int inputArr[], int size)
{
    // for storing the sum of the elements
    // present in the array
    int sumOfEle = 0;
    // for storing the sum using the AP sum formula
    int APSum = 0;
    // sum of the elements of the array, including the missing element
    // using the sum of the elements of an Arithmetic Progression Formula
    // size + 1 because we have to include the missing element in the input array
    APSum = ((size + 1) * (inputArr[0] + inputArr[size - 1])) / 2;
    // loop for computing the sum of elements
    // present in the input array
    for(int i = 0; i < size; i++)
    {
        sumOfEle = sumOfEle + inputArr[i];
    }
    // finding the missing element
    int missingEle = APSum - sumOfEle;
    // returning the missing element
    return missingEle;
}
// main method
public static void main(String[] argvs) 
{
// creating an object of the class MissingElementAP
MissingElementAP obj = new MissingElementAP();
// input 1
int apArr[] = {3, 5, 7, 9, 11, 15, 17, 19};
int size = apArr.length;
int ans = obj.findMissingEle(apArr, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
    System.out.print(apArr[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
System.out.println( "\n" );
// input 2
int apArr1[] = {1, 7, 13, 19, 31, 37, 43};
size = apArr1.length;
ans = obj.findMissingEle(apArr1, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
    System.out.print(apArr1[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
System.out.println( "\n" );
// input 3
int apArr2[] = {25, 18, 4, -3, -10, -17, -24};
size = apArr2.length;
ans = obj.findMissingEle(apArr2, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
    System.out.print(apArr2[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
}
}
<p><strong>Output:</strong></p>
<div class="codeblock3"><pre>
For the input array: 
3 5 7 9 11 15 17 19 
The missing element is: 13


For the input array: 
1 7 13 19 31 37 43 
The missing element is: 25


For the input array: 
25 18 4 -3 -10 -17 -24 
The missing element is: 11
</pre></div>
<p><strong>Complexity Analysis:</strong> Since the program is using a for-loop for computing the sum of elements, the time complexity of the program is O(n), where n is the total number of elements present in the array. The space complexity of the program is constant, i.e., O(1).</p>
<h3 class="h3">Using Binary Search</h3>
<p>Observe the examples mentioned above. One can see that elements of the input array are either in increasing order or in decreasing order. Whenever such a kind of pattern is observed, one can use binary search.</p>
<p>Go to the middle element and compute the difference between the middle and next to the middle element. If it is not equal to the common difference of the arithmetic progression, then the missing element lies between mid and mid + 1. If the middle element is equal to the (s / 2)th term of the arithmetic progression series, then the missing element is in the right half of the input array; otherwise in the left half. The following program illustrates the same.</p>
<p><strong>FileName:</strong> MissingElementAP1.java</p>
<div class="codeblock"><textarea name="code" class="java">
public class MissingElementAP1
{
// the following method implements the binary 
// search with the help of recursion to find the 
// missing element in the arithmetic progression
public int findMissingUtility(int arr[], int l, int h, int difference)
{
// There has to be atleast two elements
// for computing the missing element
if (h <= l)
{
return Integer.MAX_VALUE;
}
// Finding the middle element index
int m = l + (h - l) / 2;
// The element just after the middle element is missing.
// The arr[mid+1] must exist, because we return when
// (l == hi) and take the floor of (h - l) / 2
if (arr[m + 1] - arr[m] != difference)
{
return (arr[m] + difference);
}
// The element just before mid is missing
if (m > 0 && arr[m] - arr[m - 1] != difference)
{
return (arr[m - 1] + difference);
}
// If the elements till the mid follow
// AP, then apply recursion on the right half
if (arr[m] == arr[0] + m * difference)
{
return findMissingUtility(arr, m + 1, h, difference);
}
// Else applying recursion on the left half
return findMissingUtility(arr, l, m - 1, difference);
}
// The method uses the method findMissingUtility()
// for finding the element that is missing in AP.
// The method only the considers that the 
// common difference of the arithmetic progression is
// an integer.
public int findMissing(int arr[], int n)
{
// Since only one element is missing
// we can use the last and first element
// for computing the common difference of the
// arithemtic progression
int commonDiff = (arr[n - 1] - arr[0]) / n;
// Applying Binary search for the missing
// number using the above calculated diff
return findMissingUtility(arr, 0, n - 1, commonDiff);
}
// main method
public static void main(String[] argvs) 
{
// creating an object of the class MissingElementAP1
MissingElementAP1 obj = new MissingElementAP1();
// input 1
int apArr[] = {3, 5, 7, 9, 11, 15, 17, 19};
int size = apArr.length;
int ans = obj.findMissing(apArr, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
System.out.print(apArr[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
System.out.println( "\n" );
// input 2
int apArr1[] = {1, 7, 13, 19, 31, 37, 43};
size = apArr1.length;
ans = obj.findMissing(apArr1, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
System.out.print(apArr1[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
System.out.println( "\n" );
// input 3
int apArr2[] = {25, 18, 4, -3, -10, -17, -24};
size = apArr2.length;
ans = obj.findMissing(apArr2, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
System.out.print(apArr2[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
}
}
 Output: For the input array: 
3 5 7 9 11 15 17 19 
The missing element is: 13


For the input array: 
1 7 13 19 31 37 43 
The missing element is: 25


For the input array: 
25 18 4 -3 -10 -17 -24 
The missing element is: 11
 Complexity Analysis: Since the program is using the binary search, the time complexity of the program is O(n), where n is the total number of elements present in the input array. The program is not using any auxiliary space. Therefore, the space complexity of the program is constant, i.e., O(1). Next TopicPeak Index of Mountain Array Problem in Java ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/missing-number-in-an-arithmetic-progression-in-java Missing Number in An Arithmetic Progression in Java - javatpoint ? SCROLL TO TOP Home Coding Problems Java Programs OOPs String Exception Multithreading Collections Coding Problems Candy Distribution Problem in Java Find Rectangle in a Matrix with Corner as 1 in Java Minimum Number of Taps to Open to Water a Garden in Java Seven Segment Display Problem in Java Split Array Largest Sum in Java Find Original Array from a Double Array in Java Minimum Lights to Activate Problem in Java Rotate List in Java Count of Range Sum Problem in Java Create A Tree of Coprime in Java Convert Integer to Roman Numerals in Java Check if n and its Double Exist or not in Java Array of Doubled Pair Problem in Java Tag Content Extractor Problem in Java Convert Roman to Integer in Java Minimum Number of Flips to Convert Binary Matrix into Zero Matrix in Java XOR of Array Elements Except Itself in Java Check If the Given Array is Mirror Inverse in Java How to Create a Mirror Image of A 2D Array in Java Add Numbers Represented by Linked Lists in Java Majority Element In an Array in Java Block Swap Algorithm or Array Rotation in Java Minimum Difference Among Group Size Two in Java Missing Number in An Arithmetic Progression in Java Peak Index of Mountain Array Problem in Java next ? ? prev Missing Number in An Arithmetic Progression in Java It is very interesting problem frequently asked in interviews of top IT companies like Google, Amazon, TCS, Accenture, etc. By solving the problem, one wants to check the logical ability, critical thinking, and problem-solving skill of the interviewee. So, in this section, we are going to find missing number in an arithmetic progression in Java with different approaches and logic. Also, we will create Java programs for the same. Problem Statement An array is given. The array contains some numbers that represent an arithmetic progression. In the arithmetic progression, one number is missing. The task is to find that missing number. Example 1: Input: int arr[] = {3, 5, 7, 9, 11, 15, 17, 19} Output: 13 Explanation: If we put the number 13 after number 11 in the input array, the arithmetic progression is complete. Hence, the answer is 13 Example 2: Input: int arr[] = {1, 7, 13, 19, 31, 37, 43} Output: 25 Explanation: If we put the number 25 after the number 19 in the input array, the arithmetic progression is complete. Hence, the answer is 25. Example 3: Input: int arr[] = {25, 18, 4, -3, -10, -17, -24} Output: 11 Explanation: If we put the number 11 after the number 18 in the input array, the arithmetic progression is complete. Hence, the answer is 11. Solution to the Problem Using Arithmetic Progression Formula The sum of the numbers in an arithmetic progression whose first term is a1 and the last term is an, and the total term is n is: Sn = (n x (a1 + an) ) / 2. Thus, we can compute the sum of the input array. It is because we know the first, last, and size of the input array. If we take the reference of example 1, we get: S9 = (9 x (3 + 19)) / 2 = (9 x 22) / 2 = 198 / 2 = 99 (9 is the size of the input array including the missing element) Now, iterate over the array and find the sum of the elements present. We get Sum of elements: 3 + 5 + 7 + 9 + 11 + 15 + 17 + 19 = 86 Now, subtract S8 with the sum of elements of the input array. We get 99 - 86 = 13, which is the missing element of the arithmetic progression. The following program implements the same concept. FileName: MissingElementAP.java 
public class MissingElementAP 
{
public int findMissingEle(int inputArr[], int size)
{
    // for storing the sum of the elements
    // present in the array
    int sumOfEle = 0;
    // for storing the sum using the AP sum formula
    int APSum = 0;
    // sum of the elements of the array, including the missing element
    // using the sum of the elements of an Arithmetic Progression Formula
    // size + 1 because we have to include the missing element in the input array
    APSum = ((size + 1) * (inputArr[0] + inputArr[size - 1])) / 2;
    // loop for computing the sum of elements
    // present in the input array
    for(int i = 0; i < size; i++)
    {
        sumOfEle = sumOfEle + inputArr[i];
    }
    // finding the missing element
    int missingEle = APSum - sumOfEle;
    // returning the missing element
    return missingEle;
}
// main method
public static void main(String[] argvs) 
{
// creating an object of the class MissingElementAP
MissingElementAP obj = new MissingElementAP();
// input 1
int apArr[] = {3, 5, 7, 9, 11, 15, 17, 19};
int size = apArr.length;
int ans = obj.findMissingEle(apArr, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
    System.out.print(apArr[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
System.out.println( "\n" );
// input 2
int apArr1[] = {1, 7, 13, 19, 31, 37, 43};
size = apArr1.length;
ans = obj.findMissingEle(apArr1, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
    System.out.print(apArr1[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
System.out.println( "\n" );
// input 3
int apArr2[] = {25, 18, 4, -3, -10, -17, -24};
size = apArr2.length;
ans = obj.findMissingEle(apArr2, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
    System.out.print(apArr2[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
}
}
<p><strong>Output:</strong></p>
<div class="codeblock3"><pre>
For the input array: 
3 5 7 9 11 15 17 19 
The missing element is: 13


For the input array: 
1 7 13 19 31 37 43 
The missing element is: 25


For the input array: 
25 18 4 -3 -10 -17 -24 
The missing element is: 11
</pre></div>
<p><strong>Complexity Analysis:</strong> Since the program is using a for-loop for computing the sum of elements, the time complexity of the program is O(n), where n is the total number of elements present in the array. The space complexity of the program is constant, i.e., O(1).</p>
<h3 class="h3">Using Binary Search</h3>
<p>Observe the examples mentioned above. One can see that elements of the input array are either in increasing order or in decreasing order. Whenever such a kind of pattern is observed, one can use binary search.</p>
<p>Go to the middle element and compute the difference between the middle and next to the middle element. If it is not equal to the common difference of the arithmetic progression, then the missing element lies between mid and mid + 1. If the middle element is equal to the (s / 2)th term of the arithmetic progression series, then the missing element is in the right half of the input array; otherwise in the left half. The following program illustrates the same.</p>
<p><strong>FileName:</strong> MissingElementAP1.java</p>
<div class="codeblock"><textarea name="code" class="java">
public class MissingElementAP1
{
// the following method implements the binary 
// search with the help of recursion to find the 
// missing element in the arithmetic progression
public int findMissingUtility(int arr[], int l, int h, int difference)
{
// There has to be atleast two elements
// for computing the missing element
if (h <= l)
{
return Integer.MAX_VALUE;
}
// Finding the middle element index
int m = l + (h - l) / 2;
// The element just after the middle element is missing.
// The arr[mid+1] must exist, because we return when
// (l == hi) and take the floor of (h - l) / 2
if (arr[m + 1] - arr[m] != difference)
{
return (arr[m] + difference);
}
// The element just before mid is missing
if (m > 0 && arr[m] - arr[m - 1] != difference)
{
return (arr[m - 1] + difference);
}
// If the elements till the mid follow
// AP, then apply recursion on the right half
if (arr[m] == arr[0] + m * difference)
{
return findMissingUtility(arr, m + 1, h, difference);
}
// Else applying recursion on the left half
return findMissingUtility(arr, l, m - 1, difference);
}
// The method uses the method findMissingUtility()
// for finding the element that is missing in AP.
// The method only the considers that the 
// common difference of the arithmetic progression is
// an integer.
public int findMissing(int arr[], int n)
{
// Since only one element is missing
// we can use the last and first element
// for computing the common difference of the
// arithemtic progression
int commonDiff = (arr[n - 1] - arr[0]) / n;
// Applying Binary search for the missing
// number using the above calculated diff
return findMissingUtility(arr, 0, n - 1, commonDiff);
}
// main method
public static void main(String[] argvs) 
{
// creating an object of the class MissingElementAP1
MissingElementAP1 obj = new MissingElementAP1();
// input 1
int apArr[] = {3, 5, 7, 9, 11, 15, 17, 19};
int size = apArr.length;
int ans = obj.findMissing(apArr, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
System.out.print(apArr[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
System.out.println( "\n" );
// input 2
int apArr1[] = {1, 7, 13, 19, 31, 37, 43};
size = apArr1.length;
ans = obj.findMissing(apArr1, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
System.out.print(apArr1[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
System.out.println( "\n" );
// input 3
int apArr2[] = {25, 18, 4, -3, -10, -17, -24};
size = apArr2.length;
ans = obj.findMissing(apArr2, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
System.out.print(apArr2[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
}
}
 Output: For the input array: 
3 5 7 9 11 15 17 19 
The missing element is: 13


For the input array: 
1 7 13 19 31 37 43 
The missing element is: 25


For the input array: 
25 18 4 -3 -10 -17 -24 
The missing element is: 11
 Complexity Analysis: Since the program is using the binary search, the time complexity of the program is O(n), where n is the total number of elements present in the input array. The program is not using any auxiliary space. Therefore, the space complexity of the program is constant, i.e., O(1). Next TopicPeak Index of Mountain Array Problem in Java ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/missing-number-in-an-arithmetic-progression-in-java Missing Number in An Arithmetic Progression in Java - javatpoint ? SCROLL TO TOP Home Coding Problems Java Programs OOPs String Exception Multithreading Collections Coding Problems Candy Distribution Problem in Java Find Rectangle in a Matrix with Corner as 1 in Java Minimum Number of Taps to Open to Water a Garden in Java Seven Segment Display Problem in Java Split Array Largest Sum in Java Find Original Array from a Double Array in Java Minimum Lights to Activate Problem in Java Rotate List in Java Count of Range Sum Problem in Java Create A Tree of Coprime in Java Convert Integer to Roman Numerals in Java Check if n and its Double Exist or not in Java Array of Doubled Pair Problem in Java Tag Content Extractor Problem in Java Convert Roman to Integer in Java Minimum Number of Flips to Convert Binary Matrix into Zero Matrix in Java XOR of Array Elements Except Itself in Java Check If the Given Array is Mirror Inverse in Java How to Create a Mirror Image of A 2D Array in Java Add Numbers Represented by Linked Lists in Java Majority Element In an Array in Java Block Swap Algorithm or Array Rotation in Java Minimum Difference Among Group Size Two in Java Missing Number in An Arithmetic Progression in Java Peak Index of Mountain Array Problem in Java next ? ? prev Missing Number in An Arithmetic Progression in Java It is very interesting problem frequently asked in interviews of top IT companies like Google, Amazon, TCS, Accenture, etc. By solving the problem, one wants to check the logical ability, critical thinking, and problem-solving skill of the interviewee. So, in this section, we are going to find missing number in an arithmetic progression in Java with different approaches and logic. Also, we will create Java programs for the same. Problem Statement An array is given. The array contains some numbers that represent an arithmetic progression. In the arithmetic progression, one number is missing. The task is to find that missing number. Example 1: Input: int arr[] = {3, 5, 7, 9, 11, 15, 17, 19} Output: 13 Explanation: If we put the number 13 after number 11 in the input array, the arithmetic progression is complete. Hence, the answer is 13 Example 2: Input: int arr[] = {1, 7, 13, 19, 31, 37, 43} Output: 25 Explanation: If we put the number 25 after the number 19 in the input array, the arithmetic progression is complete. Hence, the answer is 25. Example 3: Input: int arr[] = {25, 18, 4, -3, -10, -17, -24} Output: 11 Explanation: If we put the number 11 after the number 18 in the input array, the arithmetic progression is complete. Hence, the answer is 11. Solution to the Problem Using Arithmetic Progression Formula The sum of the numbers in an arithmetic progression whose first term is a1 and the last term is an, and the total term is n is: Sn = (n x (a1 + an) ) / 2. Thus, we can compute the sum of the input array. It is because we know the first, last, and size of the input array. If we take the reference of example 1, we get: S9 = (9 x (3 + 19)) / 2 = (9 x 22) / 2 = 198 / 2 = 99 (9 is the size of the input array including the missing element) Now, iterate over the array and find the sum of the elements present. We get Sum of elements: 3 + 5 + 7 + 9 + 11 + 15 + 17 + 19 = 86 Now, subtract S8 with the sum of elements of the input array. We get 99 - 86 = 13, which is the missing element of the arithmetic progression. The following program implements the same concept. FileName: MissingElementAP.java 
public class MissingElementAP 
{
public int findMissingEle(int inputArr[], int size)
{
    // for storing the sum of the elements
    // present in the array
    int sumOfEle = 0;
    // for storing the sum using the AP sum formula
    int APSum = 0;
    // sum of the elements of the array, including the missing element
    // using the sum of the elements of an Arithmetic Progression Formula
    // size + 1 because we have to include the missing element in the input array
    APSum = ((size + 1) * (inputArr[0] + inputArr[size - 1])) / 2;
    // loop for computing the sum of elements
    // present in the input array
    for(int i = 0; i < size; i++)
    {
        sumOfEle = sumOfEle + inputArr[i];
    }
    // finding the missing element
    int missingEle = APSum - sumOfEle;
    // returning the missing element
    return missingEle;
}
// main method
public static void main(String[] argvs) 
{
// creating an object of the class MissingElementAP
MissingElementAP obj = new MissingElementAP();
// input 1
int apArr[] = {3, 5, 7, 9, 11, 15, 17, 19};
int size = apArr.length;
int ans = obj.findMissingEle(apArr, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
    System.out.print(apArr[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
System.out.println( "\n" );
// input 2
int apArr1[] = {1, 7, 13, 19, 31, 37, 43};
size = apArr1.length;
ans = obj.findMissingEle(apArr1, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
    System.out.print(apArr1[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
System.out.println( "\n" );
// input 3
int apArr2[] = {25, 18, 4, -3, -10, -17, -24};
size = apArr2.length;
ans = obj.findMissingEle(apArr2, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
    System.out.print(apArr2[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
}
}
<p><strong>Output:</strong></p>
<div class="codeblock3"><pre>
For the input array: 
3 5 7 9 11 15 17 19 
The missing element is: 13


For the input array: 
1 7 13 19 31 37 43 
The missing element is: 25


For the input array: 
25 18 4 -3 -10 -17 -24 
The missing element is: 11
</pre></div>
<p><strong>Complexity Analysis:</strong> Since the program is using a for-loop for computing the sum of elements, the time complexity of the program is O(n), where n is the total number of elements present in the array. The space complexity of the program is constant, i.e., O(1).</p>
<h3 class="h3">Using Binary Search</h3>
<p>Observe the examples mentioned above. One can see that elements of the input array are either in increasing order or in decreasing order. Whenever such a kind of pattern is observed, one can use binary search.</p>
<p>Go to the middle element and compute the difference between the middle and next to the middle element. If it is not equal to the common difference of the arithmetic progression, then the missing element lies between mid and mid + 1. If the middle element is equal to the (s / 2)th term of the arithmetic progression series, then the missing element is in the right half of the input array; otherwise in the left half. The following program illustrates the same.</p>
<p><strong>FileName:</strong> MissingElementAP1.java</p>
<div class="codeblock"><textarea name="code" class="java">
public class MissingElementAP1
{
// the following method implements the binary 
// search with the help of recursion to find the 
// missing element in the arithmetic progression
public int findMissingUtility(int arr[], int l, int h, int difference)
{
// There has to be atleast two elements
// for computing the missing element
if (h <= l)
{
return Integer.MAX_VALUE;
}
// Finding the middle element index
int m = l + (h - l) / 2;
// The element just after the middle element is missing.
// The arr[mid+1] must exist, because we return when
// (l == hi) and take the floor of (h - l) / 2
if (arr[m + 1] - arr[m] != difference)
{
return (arr[m] + difference);
}
// The element just before mid is missing
if (m > 0 && arr[m] - arr[m - 1] != difference)
{
return (arr[m - 1] + difference);
}
// If the elements till the mid follow
// AP, then apply recursion on the right half
if (arr[m] == arr[0] + m * difference)
{
return findMissingUtility(arr, m + 1, h, difference);
}
// Else applying recursion on the left half
return findMissingUtility(arr, l, m - 1, difference);
}
// The method uses the method findMissingUtility()
// for finding the element that is missing in AP.
// The method only the considers that the 
// common difference of the arithmetic progression is
// an integer.
public int findMissing(int arr[], int n)
{
// Since only one element is missing
// we can use the last and first element
// for computing the common difference of the
// arithemtic progression
int commonDiff = (arr[n - 1] - arr[0]) / n;
// Applying Binary search for the missing
// number using the above calculated diff
return findMissingUtility(arr, 0, n - 1, commonDiff);
}
// main method
public static void main(String[] argvs) 
{
// creating an object of the class MissingElementAP1
MissingElementAP1 obj = new MissingElementAP1();
// input 1
int apArr[] = {3, 5, 7, 9, 11, 15, 17, 19};
int size = apArr.length;
int ans = obj.findMissing(apArr, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
System.out.print(apArr[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
System.out.println( "\n" );
// input 2
int apArr1[] = {1, 7, 13, 19, 31, 37, 43};
size = apArr1.length;
ans = obj.findMissing(apArr1, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
System.out.print(apArr1[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
System.out.println( "\n" );
// input 3
int apArr2[] = {25, 18, 4, -3, -10, -17, -24};
size = apArr2.length;
ans = obj.findMissing(apArr2, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
System.out.print(apArr2[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
}
}
 Output: For the input array: 
3 5 7 9 11 15 17 19 
The missing element is: 13


For the input array: 
1 7 13 19 31 37 43 
The missing element is: 25


For the input array: 
25 18 4 -3 -10 -17 -24 
The missing element is: 11
 Complexity Analysis: Since the program is using the binary search, the time complexity of the program is O(n), where n is the total number of elements present in the input array. The program is not using any auxiliary space. Therefore, the space complexity of the program is constant, i.e., O(1). Next TopicPeak Index of Mountain Array Problem in Java ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/missing-number-in-an-arithmetic-progression-in-java Missing Number in An Arithmetic Progression in Java - javatpoint ? SCROLL TO TOP Home Coding Problems Java Programs OOPs String Exception Multithreading Collections Coding Problems Candy Distribution Problem in Java Find Rectangle in a Matrix with Corner as 1 in Java Minimum Number of Taps to Open to Water a Garden in Java Seven Segment Display Problem in Java Split Array Largest Sum in Java Find Original Array from a Double Array in Java Minimum Lights to Activate Problem in Java Rotate List in Java Count of Range Sum Problem in Java Create A Tree of Coprime in Java Convert Integer to Roman Numerals in Java Check if n and its Double Exist or not in Java Array of Doubled Pair Problem in Java Tag Content Extractor Problem in Java Convert Roman to Integer in Java Minimum Number of Flips to Convert Binary Matrix into Zero Matrix in Java XOR of Array Elements Except Itself in Java Check If the Given Array is Mirror Inverse in Java How to Create a Mirror Image of A 2D Array in Java Add Numbers Represented by Linked Lists in Java Majority Element In an Array in Java Block Swap Algorithm or Array Rotation in Java Minimum Difference Among Group Size Two in Java Missing Number in An Arithmetic Progression in Java Peak Index of Mountain Array Problem in Java next ? ? prev Missing Number in An Arithmetic Progression in Java It is very interesting problem frequently asked in interviews of top IT companies like Google, Amazon, TCS, Accenture, etc. By solving the problem, one wants to check the logical ability, critical thinking, and problem-solving skill of the interviewee. So, in this section, we are going to find missing number in an arithmetic progression in Java with different approaches and logic. Also, we will create Java programs for the same. Problem Statement An array is given. The array contains some numbers that represent an arithmetic progression. In the arithmetic progression, one number is missing. The task is to find that missing number. Example 1: Input: int arr[] = {3, 5, 7, 9, 11, 15, 17, 19} Output: 13 Explanation: If we put the number 13 after number 11 in the input array, the arithmetic progression is complete. Hence, the answer is 13 Example 2: Input: int arr[] = {1, 7, 13, 19, 31, 37, 43} Output: 25 Explanation: If we put the number 25 after the number 19 in the input array, the arithmetic progression is complete. Hence, the answer is 25. Example 3: Input: int arr[] = {25, 18, 4, -3, -10, -17, -24} Output: 11 Explanation: If we put the number 11 after the number 18 in the input array, the arithmetic progression is complete. Hence, the answer is 11. Solution to the Problem Using Arithmetic Progression Formula The sum of the numbers in an arithmetic progression whose first term is a1 and the last term is an, and the total term is n is: Sn = (n x (a1 + an) ) / 2. Thus, we can compute the sum of the input array. It is because we know the first, last, and size of the input array. If we take the reference of example 1, we get: S9 = (9 x (3 + 19)) / 2 = (9 x 22) / 2 = 198 / 2 = 99 (9 is the size of the input array including the missing element) Now, iterate over the array and find the sum of the elements present. We get Sum of elements: 3 + 5 + 7 + 9 + 11 + 15 + 17 + 19 = 86 Now, subtract S8 with the sum of elements of the input array. We get 99 - 86 = 13, which is the missing element of the arithmetic progression. The following program implements the same concept. FileName: MissingElementAP.java 
public class MissingElementAP 
{
public int findMissingEle(int inputArr[], int size)
{
    // for storing the sum of the elements
    // present in the array
    int sumOfEle = 0;
    // for storing the sum using the AP sum formula
    int APSum = 0;
    // sum of the elements of the array, including the missing element
    // using the sum of the elements of an Arithmetic Progression Formula
    // size + 1 because we have to include the missing element in the input array
    APSum = ((size + 1) * (inputArr[0] + inputArr[size - 1])) / 2;
    // loop for computing the sum of elements
    // present in the input array
    for(int i = 0; i < size; i++)
    {
        sumOfEle = sumOfEle + inputArr[i];
    }
    // finding the missing element
    int missingEle = APSum - sumOfEle;
    // returning the missing element
    return missingEle;
}
// main method
public static void main(String[] argvs) 
{
// creating an object of the class MissingElementAP
MissingElementAP obj = new MissingElementAP();
// input 1
int apArr[] = {3, 5, 7, 9, 11, 15, 17, 19};
int size = apArr.length;
int ans = obj.findMissingEle(apArr, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
    System.out.print(apArr[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
System.out.println( "\n" );
// input 2
int apArr1[] = {1, 7, 13, 19, 31, 37, 43};
size = apArr1.length;
ans = obj.findMissingEle(apArr1, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
    System.out.print(apArr1[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
System.out.println( "\n" );
// input 3
int apArr2[] = {25, 18, 4, -3, -10, -17, -24};
size = apArr2.length;
ans = obj.findMissingEle(apArr2, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
    System.out.print(apArr2[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
}
}
<p><strong>Output:</strong></p>
<div class="codeblock3"><pre>
For the input array: 
3 5 7 9 11 15 17 19 
The missing element is: 13


For the input array: 
1 7 13 19 31 37 43 
The missing element is: 25


For the input array: 
25 18 4 -3 -10 -17 -24 
The missing element is: 11
</pre></div>
<p><strong>Complexity Analysis:</strong> Since the program is using a for-loop for computing the sum of elements, the time complexity of the program is O(n), where n is the total number of elements present in the array. The space complexity of the program is constant, i.e., O(1).</p>
<h3 class="h3">Using Binary Search</h3>
<p>Observe the examples mentioned above. One can see that elements of the input array are either in increasing order or in decreasing order. Whenever such a kind of pattern is observed, one can use binary search.</p>
<p>Go to the middle element and compute the difference between the middle and next to the middle element. If it is not equal to the common difference of the arithmetic progression, then the missing element lies between mid and mid + 1. If the middle element is equal to the (s / 2)th term of the arithmetic progression series, then the missing element is in the right half of the input array; otherwise in the left half. The following program illustrates the same.</p>
<p><strong>FileName:</strong> MissingElementAP1.java</p>
<div class="codeblock"><textarea name="code" class="java">
public class MissingElementAP1
{
// the following method implements the binary 
// search with the help of recursion to find the 
// missing element in the arithmetic progression
public int findMissingUtility(int arr[], int l, int h, int difference)
{
// There has to be atleast two elements
// for computing the missing element
if (h <= l)
{
return Integer.MAX_VALUE;
}
// Finding the middle element index
int m = l + (h - l) / 2;
// The element just after the middle element is missing.
// The arr[mid+1] must exist, because we return when
// (l == hi) and take the floor of (h - l) / 2
if (arr[m + 1] - arr[m] != difference)
{
return (arr[m] + difference);
}
// The element just before mid is missing
if (m > 0 && arr[m] - arr[m - 1] != difference)
{
return (arr[m - 1] + difference);
}
// If the elements till the mid follow
// AP, then apply recursion on the right half
if (arr[m] == arr[0] + m * difference)
{
return findMissingUtility(arr, m + 1, h, difference);
}
// Else applying recursion on the left half
return findMissingUtility(arr, l, m - 1, difference);
}
// The method uses the method findMissingUtility()
// for finding the element that is missing in AP.
// The method only the considers that the 
// common difference of the arithmetic progression is
// an integer.
public int findMissing(int arr[], int n)
{
// Since only one element is missing
// we can use the last and first element
// for computing the common difference of the
// arithemtic progression
int commonDiff = (arr[n - 1] - arr[0]) / n;
// Applying Binary search for the missing
// number using the above calculated diff
return findMissingUtility(arr, 0, n - 1, commonDiff);
}
// main method
public static void main(String[] argvs) 
{
// creating an object of the class MissingElementAP1
MissingElementAP1 obj = new MissingElementAP1();
// input 1
int apArr[] = {3, 5, 7, 9, 11, 15, 17, 19};
int size = apArr.length;
int ans = obj.findMissing(apArr, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
System.out.print(apArr[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
System.out.println( "\n" );
// input 2
int apArr1[] = {1, 7, 13, 19, 31, 37, 43};
size = apArr1.length;
ans = obj.findMissing(apArr1, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
System.out.print(apArr1[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
System.out.println( "\n" );
// input 3
int apArr2[] = {25, 18, 4, -3, -10, -17, -24};
size = apArr2.length;
ans = obj.findMissing(apArr2, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
System.out.print(apArr2[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
}
}
 Output: For the input array: 
3 5 7 9 11 15 17 19 
The missing element is: 13


For the input array: 
1 7 13 19 31 37 43 
The missing element is: 25


For the input array: 
25 18 4 -3 -10 -17 -24 
The missing element is: 11
 Complexity Analysis: Since the program is using the binary search, the time complexity of the program is O(n), where n is the total number of elements present in the input array. The program is not using any auxiliary space. Therefore, the space complexity of the program is constant, i.e., O(1). Next TopicPeak Index of Mountain Array Problem in Java ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/missing-number-in-an-arithmetic-progression-in-java Missing Number in An Arithmetic Progression in Java - javatpoint ? SCROLL TO TOP Home Coding Problems Java Programs OOPs String Exception Multithreading Collections Coding Problems Candy Distribution Problem in Java Find Rectangle in a Matrix with Corner as 1 in Java Minimum Number of Taps to Open to Water a Garden in Java Seven Segment Display Problem in Java Split Array Largest Sum in Java Find Original Array from a Double Array in Java Minimum Lights to Activate Problem in Java Rotate List in Java Count of Range Sum Problem in Java Create A Tree of Coprime in Java Convert Integer to Roman Numerals in Java Check if n and its Double Exist or not in Java Array of Doubled Pair Problem in Java Tag Content Extractor Problem in Java Convert Roman to Integer in Java Minimum Number of Flips to Convert Binary Matrix into Zero Matrix in Java XOR of Array Elements Except Itself in Java Check If the Given Array is Mirror Inverse in Java How to Create a Mirror Image of A 2D Array in Java Add Numbers Represented by Linked Lists in Java Majority Element In an Array in Java Block Swap Algorithm or Array Rotation in Java Minimum Difference Among Group Size Two in Java Missing Number in An Arithmetic Progression in Java Peak Index of Mountain Array Problem in Java next ? ? prev Missing Number in An Arithmetic Progression in Java It is very interesting problem frequently asked in interviews of top IT companies like Google, Amazon, TCS, Accenture, etc. By solving the problem, one wants to check the logical ability, critical thinking, and problem-solving skill of the interviewee. So, in this section, we are going to find missing number in an arithmetic progression in Java with different approaches and logic. Also, we will create Java programs for the same. Problem Statement An array is given. The array contains some numbers that represent an arithmetic progression. In the arithmetic progression, one number is missing. The task is to find that missing number. Example 1: Input: int arr[] = {3, 5, 7, 9, 11, 15, 17, 19} Output: 13 Explanation: If we put the number 13 after number 11 in the input array, the arithmetic progression is complete. Hence, the answer is 13 Example 2: Input: int arr[] = {1, 7, 13, 19, 31, 37, 43} Output: 25 Explanation: If we put the number 25 after the number 19 in the input array, the arithmetic progression is complete. Hence, the answer is 25. Example 3: Input: int arr[] = {25, 18, 4, -3, -10, -17, -24} Output: 11 Explanation: If we put the number 11 after the number 18 in the input array, the arithmetic progression is complete. Hence, the answer is 11. Solution to the Problem Using Arithmetic Progression Formula The sum of the numbers in an arithmetic progression whose first term is a1 and the last term is an, and the total term is n is: Sn = (n x (a1 + an) ) / 2. Thus, we can compute the sum of the input array. It is because we know the first, last, and size of the input array. If we take the reference of example 1, we get: S9 = (9 x (3 + 19)) / 2 = (9 x 22) / 2 = 198 / 2 = 99 (9 is the size of the input array including the missing element) Now, iterate over the array and find the sum of the elements present. We get Sum of elements: 3 + 5 + 7 + 9 + 11 + 15 + 17 + 19 = 86 Now, subtract S8 with the sum of elements of the input array. We get 99 - 86 = 13, which is the missing element of the arithmetic progression. The following program implements the same concept. FileName: MissingElementAP.java 
public class MissingElementAP 
{
public int findMissingEle(int inputArr[], int size)
{
    // for storing the sum of the elements
    // present in the array
    int sumOfEle = 0;
    // for storing the sum using the AP sum formula
    int APSum = 0;
    // sum of the elements of the array, including the missing element
    // using the sum of the elements of an Arithmetic Progression Formula
    // size + 1 because we have to include the missing element in the input array
    APSum = ((size + 1) * (inputArr[0] + inputArr[size - 1])) / 2;
    // loop for computing the sum of elements
    // present in the input array
    for(int i = 0; i < size; i++)
    {
        sumOfEle = sumOfEle + inputArr[i];
    }
    // finding the missing element
    int missingEle = APSum - sumOfEle;
    // returning the missing element
    return missingEle;
}
// main method
public static void main(String[] argvs) 
{
// creating an object of the class MissingElementAP
MissingElementAP obj = new MissingElementAP();
// input 1
int apArr[] = {3, 5, 7, 9, 11, 15, 17, 19};
int size = apArr.length;
int ans = obj.findMissingEle(apArr, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
    System.out.print(apArr[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
System.out.println( "\n" );
// input 2
int apArr1[] = {1, 7, 13, 19, 31, 37, 43};
size = apArr1.length;
ans = obj.findMissingEle(apArr1, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
    System.out.print(apArr1[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
System.out.println( "\n" );
// input 3
int apArr2[] = {25, 18, 4, -3, -10, -17, -24};
size = apArr2.length;
ans = obj.findMissingEle(apArr2, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
    System.out.print(apArr2[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
}
}
<p><strong>Output:</strong></p>
<div class="codeblock3"><pre>
For the input array: 
3 5 7 9 11 15 17 19 
The missing element is: 13


For the input array: 
1 7 13 19 31 37 43 
The missing element is: 25


For the input array: 
25 18 4 -3 -10 -17 -24 
The missing element is: 11
</pre></div>
<p><strong>Complexity Analysis:</strong> Since the program is using a for-loop for computing the sum of elements, the time complexity of the program is O(n), where n is the total number of elements present in the array. The space complexity of the program is constant, i.e., O(1).</p>
<h3 class="h3">Using Binary Search</h3>
<p>Observe the examples mentioned above. One can see that elements of the input array are either in increasing order or in decreasing order. Whenever such a kind of pattern is observed, one can use binary search.</p>
<p>Go to the middle element and compute the difference between the middle and next to the middle element. If it is not equal to the common difference of the arithmetic progression, then the missing element lies between mid and mid + 1. If the middle element is equal to the (s / 2)th term of the arithmetic progression series, then the missing element is in the right half of the input array; otherwise in the left half. The following program illustrates the same.</p>
<p><strong>FileName:</strong> MissingElementAP1.java</p>
<div class="codeblock"><textarea name="code" class="java">
public class MissingElementAP1
{
// the following method implements the binary 
// search with the help of recursion to find the 
// missing element in the arithmetic progression
public int findMissingUtility(int arr[], int l, int h, int difference)
{
// There has to be atleast two elements
// for computing the missing element
if (h <= l)
{
return Integer.MAX_VALUE;
}
// Finding the middle element index
int m = l + (h - l) / 2;
// The element just after the middle element is missing.
// The arr[mid+1] must exist, because we return when
// (l == hi) and take the floor of (h - l) / 2
if (arr[m + 1] - arr[m] != difference)
{
return (arr[m] + difference);
}
// The element just before mid is missing
if (m > 0 && arr[m] - arr[m - 1] != difference)
{
return (arr[m - 1] + difference);
}
// If the elements till the mid follow
// AP, then apply recursion on the right half
if (arr[m] == arr[0] + m * difference)
{
return findMissingUtility(arr, m + 1, h, difference);
}
// Else applying recursion on the left half
return findMissingUtility(arr, l, m - 1, difference);
}
// The method uses the method findMissingUtility()
// for finding the element that is missing in AP.
// The method only the considers that the 
// common difference of the arithmetic progression is
// an integer.
public int findMissing(int arr[], int n)
{
// Since only one element is missing
// we can use the last and first element
// for computing the common difference of the
// arithemtic progression
int commonDiff = (arr[n - 1] - arr[0]) / n;
// Applying Binary search for the missing
// number using the above calculated diff
return findMissingUtility(arr, 0, n - 1, commonDiff);
}
// main method
public static void main(String[] argvs) 
{
// creating an object of the class MissingElementAP1
MissingElementAP1 obj = new MissingElementAP1();
// input 1
int apArr[] = {3, 5, 7, 9, 11, 15, 17, 19};
int size = apArr.length;
int ans = obj.findMissing(apArr, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
System.out.print(apArr[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
System.out.println( "\n" );
// input 2
int apArr1[] = {1, 7, 13, 19, 31, 37, 43};
size = apArr1.length;
ans = obj.findMissing(apArr1, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
System.out.print(apArr1[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
System.out.println( "\n" );
// input 3
int apArr2[] = {25, 18, 4, -3, -10, -17, -24};
size = apArr2.length;
ans = obj.findMissing(apArr2, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
System.out.print(apArr2[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
}
}
 Output: For the input array: 
3 5 7 9 11 15 17 19 
The missing element is: 13


For the input array: 
1 7 13 19 31 37 43 
The missing element is: 25


For the input array: 
25 18 4 -3 -10 -17 -24 
The missing element is: 11
 Complexity Analysis: Since the program is using the binary search, the time complexity of the program is O(n), where n is the total number of elements present in the input array. The program is not using any auxiliary space. Therefore, the space complexity of the program is constant, i.e., O(1). Next TopicPeak Index of Mountain Array Problem in Java ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/missing-number-in-an-arithmetic-progression-in-java Missing Number in An Arithmetic Progression in Java - javatpoint ? SCROLL TO TOP Home Coding Problems Java Programs OOPs String Exception Multithreading Collections Coding Problems Candy Distribution Problem in Java Find Rectangle in a Matrix with Corner as 1 in Java Minimum Number of Taps to Open to Water a Garden in Java Seven Segment Display Problem in Java Split Array Largest Sum in Java Find Original Array from a Double Array in Java Minimum Lights to Activate Problem in Java Rotate List in Java Count of Range Sum Problem in Java Create A Tree of Coprime in Java Convert Integer to Roman Numerals in Java Check if n and its Double Exist or not in Java Array of Doubled Pair Problem in Java Tag Content Extractor Problem in Java Convert Roman to Integer in Java Minimum Number of Flips to Convert Binary Matrix into Zero Matrix in Java XOR of Array Elements Except Itself in Java Check If the Given Array is Mirror Inverse in Java How to Create a Mirror Image of A 2D Array in Java Add Numbers Represented by Linked Lists in Java Majority Element In an Array in Java Block Swap Algorithm or Array Rotation in Java Minimum Difference Among Group Size Two in Java Missing Number in An Arithmetic Progression in Java Peak Index of Mountain Array Problem in Java next ? ? prev Missing Number in An Arithmetic Progression in Java It is very interesting problem frequently asked in interviews of top IT companies like Google, Amazon, TCS, Accenture, etc. By solving the problem, one wants to check the logical ability, critical thinking, and problem-solving skill of the interviewee. So, in this section, we are going to find missing number in an arithmetic progression in Java with different approaches and logic. Also, we will create Java programs for the same. Problem Statement An array is given. The array contains some numbers that represent an arithmetic progression. In the arithmetic progression, one number is missing. The task is to find that missing number. Example 1: Input: int arr[] = {3, 5, 7, 9, 11, 15, 17, 19} Output: 13 Explanation: If we put the number 13 after number 11 in the input array, the arithmetic progression is complete. Hence, the answer is 13 Example 2: Input: int arr[] = {1, 7, 13, 19, 31, 37, 43} Output: 25 Explanation: If we put the number 25 after the number 19 in the input array, the arithmetic progression is complete. Hence, the answer is 25. Example 3: Input: int arr[] = {25, 18, 4, -3, -10, -17, -24} Output: 11 Explanation: If we put the number 11 after the number 18 in the input array, the arithmetic progression is complete. Hence, the answer is 11. Solution to the Problem Using Arithmetic Progression Formula The sum of the numbers in an arithmetic progression whose first term is a1 and the last term is an, and the total term is n is: Sn = (n x (a1 + an) ) / 2. Thus, we can compute the sum of the input array. It is because we know the first, last, and size of the input array. If we take the reference of example 1, we get: S9 = (9 x (3 + 19)) / 2 = (9 x 22) / 2 = 198 / 2 = 99 (9 is the size of the input array including the missing element) Now, iterate over the array and find the sum of the elements present. We get Sum of elements: 3 + 5 + 7 + 9 + 11 + 15 + 17 + 19 = 86 Now, subtract S8 with the sum of elements of the input array. We get 99 - 86 = 13, which is the missing element of the arithmetic progression. The following program implements the same concept. FileName: MissingElementAP.java 
public class MissingElementAP 
{
public int findMissingEle(int inputArr[], int size)
{
    // for storing the sum of the elements
    // present in the array
    int sumOfEle = 0;
    // for storing the sum using the AP sum formula
    int APSum = 0;
    // sum of the elements of the array, including the missing element
    // using the sum of the elements of an Arithmetic Progression Formula
    // size + 1 because we have to include the missing element in the input array
    APSum = ((size + 1) * (inputArr[0] + inputArr[size - 1])) / 2;
    // loop for computing the sum of elements
    // present in the input array
    for(int i = 0; i < size; i++)
    {
        sumOfEle = sumOfEle + inputArr[i];
    }
    // finding the missing element
    int missingEle = APSum - sumOfEle;
    // returning the missing element
    return missingEle;
}
// main method
public static void main(String[] argvs) 
{
// creating an object of the class MissingElementAP
MissingElementAP obj = new MissingElementAP();
// input 1
int apArr[] = {3, 5, 7, 9, 11, 15, 17, 19};
int size = apArr.length;
int ans = obj.findMissingEle(apArr, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
    System.out.print(apArr[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
System.out.println( "\n" );
// input 2
int apArr1[] = {1, 7, 13, 19, 31, 37, 43};
size = apArr1.length;
ans = obj.findMissingEle(apArr1, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
    System.out.print(apArr1[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
System.out.println( "\n" );
// input 3
int apArr2[] = {25, 18, 4, -3, -10, -17, -24};
size = apArr2.length;
ans = obj.findMissingEle(apArr2, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
    System.out.print(apArr2[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
}
}
<p><strong>Output:</strong></p>
<div class="codeblock3"><pre>
For the input array: 
3 5 7 9 11 15 17 19 
The missing element is: 13


For the input array: 
1 7 13 19 31 37 43 
The missing element is: 25


For the input array: 
25 18 4 -3 -10 -17 -24 
The missing element is: 11
</pre></div>
<p><strong>Complexity Analysis:</strong> Since the program is using a for-loop for computing the sum of elements, the time complexity of the program is O(n), where n is the total number of elements present in the array. The space complexity of the program is constant, i.e., O(1).</p>
<h3 class="h3">Using Binary Search</h3>
<p>Observe the examples mentioned above. One can see that elements of the input array are either in increasing order or in decreasing order. Whenever such a kind of pattern is observed, one can use binary search.</p>
<p>Go to the middle element and compute the difference between the middle and next to the middle element. If it is not equal to the common difference of the arithmetic progression, then the missing element lies between mid and mid + 1. If the middle element is equal to the (s / 2)th term of the arithmetic progression series, then the missing element is in the right half of the input array; otherwise in the left half. The following program illustrates the same.</p>
<p><strong>FileName:</strong> MissingElementAP1.java</p>
<div class="codeblock"><textarea name="code" class="java">
public class MissingElementAP1
{
// the following method implements the binary 
// search with the help of recursion to find the 
// missing element in the arithmetic progression
public int findMissingUtility(int arr[], int l, int h, int difference)
{
// There has to be atleast two elements
// for computing the missing element
if (h <= l)
{
return Integer.MAX_VALUE;
}
// Finding the middle element index
int m = l + (h - l) / 2;
// The element just after the middle element is missing.
// The arr[mid+1] must exist, because we return when
// (l == hi) and take the floor of (h - l) / 2
if (arr[m + 1] - arr[m] != difference)
{
return (arr[m] + difference);
}
// The element just before mid is missing
if (m > 0 && arr[m] - arr[m - 1] != difference)
{
return (arr[m - 1] + difference);
}
// If the elements till the mid follow
// AP, then apply recursion on the right half
if (arr[m] == arr[0] + m * difference)
{
return findMissingUtility(arr, m + 1, h, difference);
}
// Else applying recursion on the left half
return findMissingUtility(arr, l, m - 1, difference);
}
// The method uses the method findMissingUtility()
// for finding the element that is missing in AP.
// The method only the considers that the 
// common difference of the arithmetic progression is
// an integer.
public int findMissing(int arr[], int n)
{
// Since only one element is missing
// we can use the last and first element
// for computing the common difference of the
// arithemtic progression
int commonDiff = (arr[n - 1] - arr[0]) / n;
// Applying Binary search for the missing
// number using the above calculated diff
return findMissingUtility(arr, 0, n - 1, commonDiff);
}
// main method
public static void main(String[] argvs) 
{
// creating an object of the class MissingElementAP1
MissingElementAP1 obj = new MissingElementAP1();
// input 1
int apArr[] = {3, 5, 7, 9, 11, 15, 17, 19};
int size = apArr.length;
int ans = obj.findMissing(apArr, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
System.out.print(apArr[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
System.out.println( "\n" );
// input 2
int apArr1[] = {1, 7, 13, 19, 31, 37, 43};
size = apArr1.length;
ans = obj.findMissing(apArr1, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
System.out.print(apArr1[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
System.out.println( "\n" );
// input 3
int apArr2[] = {25, 18, 4, -3, -10, -17, -24};
size = apArr2.length;
ans = obj.findMissing(apArr2, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
System.out.print(apArr2[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
}
}
 Output: For the input array: 
3 5 7 9 11 15 17 19 
The missing element is: 13


For the input array: 
1 7 13 19 31 37 43 
The missing element is: 25


For the input array: 
25 18 4 -3 -10 -17 -24 
The missing element is: 11
 Complexity Analysis: Since the program is using the binary search, the time complexity of the program is O(n), where n is the total number of elements present in the input array. The program is not using any auxiliary space. Therefore, the space complexity of the program is constant, i.e., O(1). Next TopicPeak Index of Mountain Array Problem in Java ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/missing-number-in-an-arithmetic-progression-in-java Missing Number in An Arithmetic Progression in Java - javatpoint ? SCROLL TO TOP Home Coding Problems Java Programs OOPs String Exception Multithreading Collections Coding Problems Candy Distribution Problem in Java Find Rectangle in a Matrix with Corner as 1 in Java Minimum Number of Taps to Open to Water a Garden in Java Seven Segment Display Problem in Java Split Array Largest Sum in Java Find Original Array from a Double Array in Java Minimum Lights to Activate Problem in Java Rotate List in Java Count of Range Sum Problem in Java Create A Tree of Coprime in Java Convert Integer to Roman Numerals in Java Check if n and its Double Exist or not in Java Array of Doubled Pair Problem in Java Tag Content Extractor Problem in Java Convert Roman to Integer in Java Minimum Number of Flips to Convert Binary Matrix into Zero Matrix in Java XOR of Array Elements Except Itself in Java Check If the Given Array is Mirror Inverse in Java How to Create a Mirror Image of A 2D Array in Java Add Numbers Represented by Linked Lists in Java Majority Element In an Array in Java Block Swap Algorithm or Array Rotation in Java Minimum Difference Among Group Size Two in Java Missing Number in An Arithmetic Progression in Java Peak Index of Mountain Array Problem in Java next ? ? prev Missing Number in An Arithmetic Progression in Java It is very interesting problem frequently asked in interviews of top IT companies like Google, Amazon, TCS, Accenture, etc. By solving the problem, one wants to check the logical ability, critical thinking, and problem-solving skill of the interviewee. So, in this section, we are going to find missing number in an arithmetic progression in Java with different approaches and logic. Also, we will create Java programs for the same. Problem Statement An array is given. The array contains some numbers that represent an arithmetic progression. In the arithmetic progression, one number is missing. The task is to find that missing number. Example 1: Input: int arr[] = {3, 5, 7, 9, 11, 15, 17, 19} Output: 13 Explanation: If we put the number 13 after number 11 in the input array, the arithmetic progression is complete. Hence, the answer is 13 Example 2: Input: int arr[] = {1, 7, 13, 19, 31, 37, 43} Output: 25 Explanation: If we put the number 25 after the number 19 in the input array, the arithmetic progression is complete. Hence, the answer is 25. Example 3: Input: int arr[] = {25, 18, 4, -3, -10, -17, -24} Output: 11 Explanation: If we put the number 11 after the number 18 in the input array, the arithmetic progression is complete. Hence, the answer is 11. Solution to the Problem Using Arithmetic Progression Formula The sum of the numbers in an arithmetic progression whose first term is a1 and the last term is an, and the total term is n is: Sn = (n x (a1 + an) ) / 2. Thus, we can compute the sum of the input array. It is because we know the first, last, and size of the input array. If we take the reference of example 1, we get: S9 = (9 x (3 + 19)) / 2 = (9 x 22) / 2 = 198 / 2 = 99 (9 is the size of the input array including the missing element) Now, iterate over the array and find the sum of the elements present. We get Sum of elements: 3 + 5 + 7 + 9 + 11 + 15 + 17 + 19 = 86 Now, subtract S8 with the sum of elements of the input array. We get 99 - 86 = 13, which is the missing element of the arithmetic progression. The following program implements the same concept. FileName: MissingElementAP.java 
public class MissingElementAP 
{
public int findMissingEle(int inputArr[], int size)
{
    // for storing the sum of the elements
    // present in the array
    int sumOfEle = 0;
    // for storing the sum using the AP sum formula
    int APSum = 0;
    // sum of the elements of the array, including the missing element
    // using the sum of the elements of an Arithmetic Progression Formula
    // size + 1 because we have to include the missing element in the input array
    APSum = ((size + 1) * (inputArr[0] + inputArr[size - 1])) / 2;
    // loop for computing the sum of elements
    // present in the input array
    for(int i = 0; i < size; i++)
    {
        sumOfEle = sumOfEle + inputArr[i];
    }
    // finding the missing element
    int missingEle = APSum - sumOfEle;
    // returning the missing element
    return missingEle;
}
// main method
public static void main(String[] argvs) 
{
// creating an object of the class MissingElementAP
MissingElementAP obj = new MissingElementAP();
// input 1
int apArr[] = {3, 5, 7, 9, 11, 15, 17, 19};
int size = apArr.length;
int ans = obj.findMissingEle(apArr, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
    System.out.print(apArr[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
System.out.println( "\n" );
// input 2
int apArr1[] = {1, 7, 13, 19, 31, 37, 43};
size = apArr1.length;
ans = obj.findMissingEle(apArr1, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
    System.out.print(apArr1[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
System.out.println( "\n" );
// input 3
int apArr2[] = {25, 18, 4, -3, -10, -17, -24};
size = apArr2.length;
ans = obj.findMissingEle(apArr2, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
    System.out.print(apArr2[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
}
}
<p><strong>Output:</strong></p>
<div class="codeblock3"><pre>
For the input array: 
3 5 7 9 11 15 17 19 
The missing element is: 13


For the input array: 
1 7 13 19 31 37 43 
The missing element is: 25


For the input array: 
25 18 4 -3 -10 -17 -24 
The missing element is: 11
</pre></div>
<p><strong>Complexity Analysis:</strong> Since the program is using a for-loop for computing the sum of elements, the time complexity of the program is O(n), where n is the total number of elements present in the array. The space complexity of the program is constant, i.e., O(1).</p>
<h3 class="h3">Using Binary Search</h3>
<p>Observe the examples mentioned above. One can see that elements of the input array are either in increasing order or in decreasing order. Whenever such a kind of pattern is observed, one can use binary search.</p>
<p>Go to the middle element and compute the difference between the middle and next to the middle element. If it is not equal to the common difference of the arithmetic progression, then the missing element lies between mid and mid + 1. If the middle element is equal to the (s / 2)th term of the arithmetic progression series, then the missing element is in the right half of the input array; otherwise in the left half. The following program illustrates the same.</p>
<p><strong>FileName:</strong> MissingElementAP1.java</p>
<div class="codeblock"><textarea name="code" class="java">
public class MissingElementAP1
{
// the following method implements the binary 
// search with the help of recursion to find the 
// missing element in the arithmetic progression
public int findMissingUtility(int arr[], int l, int h, int difference)
{
// There has to be atleast two elements
// for computing the missing element
if (h <= l)
{
return Integer.MAX_VALUE;
}
// Finding the middle element index
int m = l + (h - l) / 2;
// The element just after the middle element is missing.
// The arr[mid+1] must exist, because we return when
// (l == hi) and take the floor of (h - l) / 2
if (arr[m + 1] - arr[m] != difference)
{
return (arr[m] + difference);
}
// The element just before mid is missing
if (m > 0 && arr[m] - arr[m - 1] != difference)
{
return (arr[m - 1] + difference);
}
// If the elements till the mid follow
// AP, then apply recursion on the right half
if (arr[m] == arr[0] + m * difference)
{
return findMissingUtility(arr, m + 1, h, difference);
}
// Else applying recursion on the left half
return findMissingUtility(arr, l, m - 1, difference);
}
// The method uses the method findMissingUtility()
// for finding the element that is missing in AP.
// The method only the considers that the 
// common difference of the arithmetic progression is
// an integer.
public int findMissing(int arr[], int n)
{
// Since only one element is missing
// we can use the last and first element
// for computing the common difference of the
// arithemtic progression
int commonDiff = (arr[n - 1] - arr[0]) / n;
// Applying Binary search for the missing
// number using the above calculated diff
return findMissingUtility(arr, 0, n - 1, commonDiff);
}
// main method
public static void main(String[] argvs) 
{
// creating an object of the class MissingElementAP1
MissingElementAP1 obj = new MissingElementAP1();
// input 1
int apArr[] = {3, 5, 7, 9, 11, 15, 17, 19};
int size = apArr.length;
int ans = obj.findMissing(apArr, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
System.out.print(apArr[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
System.out.println( "\n" );
// input 2
int apArr1[] = {1, 7, 13, 19, 31, 37, 43};
size = apArr1.length;
ans = obj.findMissing(apArr1, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
System.out.print(apArr1[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
System.out.println( "\n" );
// input 3
int apArr2[] = {25, 18, 4, -3, -10, -17, -24};
size = apArr2.length;
ans = obj.findMissing(apArr2, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
System.out.print(apArr2[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
}
}
 Output: For the input array: 
3 5 7 9 11 15 17 19 
The missing element is: 13


For the input array: 
1 7 13 19 31 37 43 
The missing element is: 25


For the input array: 
25 18 4 -3 -10 -17 -24 
The missing element is: 11
 Complexity Analysis: Since the program is using the binary search, the time complexity of the program is O(n), where n is the total number of elements present in the input array. The program is not using any auxiliary space. Therefore, the space complexity of the program is constant, i.e., O(1). Next TopicPeak Index of Mountain Array Problem in Java ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/missing-number-in-an-arithmetic-progression-in-java Missing Number in An Arithmetic Progression in Java - javatpoint ? SCROLL TO TOP Home Coding Problems Java Programs OOPs String Exception Multithreading Collections Coding Problems Candy Distribution Problem in Java Find Rectangle in a Matrix with Corner as 1 in Java Minimum Number of Taps to Open to Water a Garden in Java Seven Segment Display Problem in Java Split Array Largest Sum in Java Find Original Array from a Double Array in Java Minimum Lights to Activate Problem in Java Rotate List in Java Count of Range Sum Problem in Java Create A Tree of Coprime in Java Convert Integer to Roman Numerals in Java Check if n and its Double Exist or not in Java Array of Doubled Pair Problem in Java Tag Content Extractor Problem in Java Convert Roman to Integer in Java Minimum Number of Flips to Convert Binary Matrix into Zero Matrix in Java XOR of Array Elements Except Itself in Java Check If the Given Array is Mirror Inverse in Java How to Create a Mirror Image of A 2D Array in Java Add Numbers Represented by Linked Lists in Java Majority Element In an Array in Java Block Swap Algorithm or Array Rotation in Java Minimum Difference Among Group Size Two in Java Missing Number in An Arithmetic Progression in Java Peak Index of Mountain Array Problem in Java next ? ? prev Missing Number in An Arithmetic Progression in Java It is very interesting problem frequently asked in interviews of top IT companies like Google, Amazon, TCS, Accenture, etc. By solving the problem, one wants to check the logical ability, critical thinking, and problem-solving skill of the interviewee. So, in this section, we are going to find missing number in an arithmetic progression in Java with different approaches and logic. Also, we will create Java programs for the same. Problem Statement An array is given. The array contains some numbers that represent an arithmetic progression. In the arithmetic progression, one number is missing. The task is to find that missing number. Example 1: Input: int arr[] = {3, 5, 7, 9, 11, 15, 17, 19} Output: 13 Explanation: If we put the number 13 after number 11 in the input array, the arithmetic progression is complete. Hence, the answer is 13 Example 2: Input: int arr[] = {1, 7, 13, 19, 31, 37, 43} Output: 25 Explanation: If we put the number 25 after the number 19 in the input array, the arithmetic progression is complete. Hence, the answer is 25. Example 3: Input: int arr[] = {25, 18, 4, -3, -10, -17, -24} Output: 11 Explanation: If we put the number 11 after the number 18 in the input array, the arithmetic progression is complete. Hence, the answer is 11. Solution to the Problem Using Arithmetic Progression Formula The sum of the numbers in an arithmetic progression whose first term is a1 and the last term is an, and the total term is n is: Sn = (n x (a1 + an) ) / 2. Thus, we can compute the sum of the input array. It is because we know the first, last, and size of the input array. If we take the reference of example 1, we get: S9 = (9 x (3 + 19)) / 2 = (9 x 22) / 2 = 198 / 2 = 99 (9 is the size of the input array including the missing element) Now, iterate over the array and find the sum of the elements present. We get Sum of elements: 3 + 5 + 7 + 9 + 11 + 15 + 17 + 19 = 86 Now, subtract S8 with the sum of elements of the input array. We get 99 - 86 = 13, which is the missing element of the arithmetic progression. The following program implements the same concept. FileName: MissingElementAP.java 
public class MissingElementAP 
{
public int findMissingEle(int inputArr[], int size)
{
    // for storing the sum of the elements
    // present in the array
    int sumOfEle = 0;
    // for storing the sum using the AP sum formula
    int APSum = 0;
    // sum of the elements of the array, including the missing element
    // using the sum of the elements of an Arithmetic Progression Formula
    // size + 1 because we have to include the missing element in the input array
    APSum = ((size + 1) * (inputArr[0] + inputArr[size - 1])) / 2;
    // loop for computing the sum of elements
    // present in the input array
    for(int i = 0; i < size; i++)
    {
        sumOfEle = sumOfEle + inputArr[i];
    }
    // finding the missing element
    int missingEle = APSum - sumOfEle;
    // returning the missing element
    return missingEle;
}
// main method
public static void main(String[] argvs) 
{
// creating an object of the class MissingElementAP
MissingElementAP obj = new MissingElementAP();
// input 1
int apArr[] = {3, 5, 7, 9, 11, 15, 17, 19};
int size = apArr.length;
int ans = obj.findMissingEle(apArr, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
    System.out.print(apArr[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
System.out.println( "\n" );
// input 2
int apArr1[] = {1, 7, 13, 19, 31, 37, 43};
size = apArr1.length;
ans = obj.findMissingEle(apArr1, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
    System.out.print(apArr1[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
System.out.println( "\n" );
// input 3
int apArr2[] = {25, 18, 4, -3, -10, -17, -24};
size = apArr2.length;
ans = obj.findMissingEle(apArr2, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
    System.out.print(apArr2[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
}
}
<p><strong>Output:</strong></p>
<div class="codeblock3"><pre>
For the input array: 
3 5 7 9 11 15 17 19 
The missing element is: 13


For the input array: 
1 7 13 19 31 37 43 
The missing element is: 25


For the input array: 
25 18 4 -3 -10 -17 -24 
The missing element is: 11
</pre></div>
<p><strong>Complexity Analysis:</strong> Since the program is using a for-loop for computing the sum of elements, the time complexity of the program is O(n), where n is the total number of elements present in the array. The space complexity of the program is constant, i.e., O(1).</p>
<h3 class="h3">Using Binary Search</h3>
<p>Observe the examples mentioned above. One can see that elements of the input array are either in increasing order or in decreasing order. Whenever such a kind of pattern is observed, one can use binary search.</p>
<p>Go to the middle element and compute the difference between the middle and next to the middle element. If it is not equal to the common difference of the arithmetic progression, then the missing element lies between mid and mid + 1. If the middle element is equal to the (s / 2)th term of the arithmetic progression series, then the missing element is in the right half of the input array; otherwise in the left half. The following program illustrates the same.</p>
<p><strong>FileName:</strong> MissingElementAP1.java</p>
<div class="codeblock"><textarea name="code" class="java">
public class MissingElementAP1
{
// the following method implements the binary 
// search with the help of recursion to find the 
// missing element in the arithmetic progression
public int findMissingUtility(int arr[], int l, int h, int difference)
{
// There has to be atleast two elements
// for computing the missing element
if (h <= l)
{
return Integer.MAX_VALUE;
}
// Finding the middle element index
int m = l + (h - l) / 2;
// The element just after the middle element is missing.
// The arr[mid+1] must exist, because we return when
// (l == hi) and take the floor of (h - l) / 2
if (arr[m + 1] - arr[m] != difference)
{
return (arr[m] + difference);
}
// The element just before mid is missing
if (m > 0 && arr[m] - arr[m - 1] != difference)
{
return (arr[m - 1] + difference);
}
// If the elements till the mid follow
// AP, then apply recursion on the right half
if (arr[m] == arr[0] + m * difference)
{
return findMissingUtility(arr, m + 1, h, difference);
}
// Else applying recursion on the left half
return findMissingUtility(arr, l, m - 1, difference);
}
// The method uses the method findMissingUtility()
// for finding the element that is missing in AP.
// The method only the considers that the 
// common difference of the arithmetic progression is
// an integer.
public int findMissing(int arr[], int n)
{
// Since only one element is missing
// we can use the last and first element
// for computing the common difference of the
// arithemtic progression
int commonDiff = (arr[n - 1] - arr[0]) / n;
// Applying Binary search for the missing
// number using the above calculated diff
return findMissingUtility(arr, 0, n - 1, commonDiff);
}
// main method
public static void main(String[] argvs) 
{
// creating an object of the class MissingElementAP1
MissingElementAP1 obj = new MissingElementAP1();
// input 1
int apArr[] = {3, 5, 7, 9, 11, 15, 17, 19};
int size = apArr.length;
int ans = obj.findMissing(apArr, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
System.out.print(apArr[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
System.out.println( "\n" );
// input 2
int apArr1[] = {1, 7, 13, 19, 31, 37, 43};
size = apArr1.length;
ans = obj.findMissing(apArr1, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
System.out.print(apArr1[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
System.out.println( "\n" );
// input 3
int apArr2[] = {25, 18, 4, -3, -10, -17, -24};
size = apArr2.length;
ans = obj.findMissing(apArr2, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
System.out.print(apArr2[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
}
}
 Output: For the input array: 
3 5 7 9 11 15 17 19 
The missing element is: 13


For the input array: 
1 7 13 19 31 37 43 
The missing element is: 25


For the input array: 
25 18 4 -3 -10 -17 -24 
The missing element is: 11
 Complexity Analysis: Since the program is using the binary search, the time complexity of the program is O(n), where n is the total number of elements present in the input array. The program is not using any auxiliary space. Therefore, the space complexity of the program is constant, i.e., O(1). Next TopicPeak Index of Mountain Array Problem in Java ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/missing-number-in-an-arithmetic-progression-in-java Missing Number in An Arithmetic Progression in Java - javatpoint ? SCROLL TO TOP Home Coding Problems Java Programs OOPs String Exception Multithreading Collections Coding Problems Candy Distribution Problem in Java Find Rectangle in a Matrix with Corner as 1 in Java Minimum Number of Taps to Open to Water a Garden in Java Seven Segment Display Problem in Java Split Array Largest Sum in Java Find Original Array from a Double Array in Java Minimum Lights to Activate Problem in Java Rotate List in Java Count of Range Sum Problem in Java Create A Tree of Coprime in Java Convert Integer to Roman Numerals in Java Check if n and its Double Exist or not in Java Array of Doubled Pair Problem in Java Tag Content Extractor Problem in Java Convert Roman to Integer in Java Minimum Number of Flips to Convert Binary Matrix into Zero Matrix in Java XOR of Array Elements Except Itself in Java Check If the Given Array is Mirror Inverse in Java How to Create a Mirror Image of A 2D Array in Java Add Numbers Represented by Linked Lists in Java Majority Element In an Array in Java Block Swap Algorithm or Array Rotation in Java Minimum Difference Among Group Size Two in Java Missing Number in An Arithmetic Progression in Java Peak Index of Mountain Array Problem in Java next ? ? prev Missing Number in An Arithmetic Progression in Java It is very interesting problem frequently asked in interviews of top IT companies like Google, Amazon, TCS, Accenture, etc. By solving the problem, one wants to check the logical ability, critical thinking, and problem-solving skill of the interviewee. So, in this section, we are going to find missing number in an arithmetic progression in Java with different approaches and logic. Also, we will create Java programs for the same. Problem Statement An array is given. The array contains some numbers that represent an arithmetic progression. In the arithmetic progression, one number is missing. The task is to find that missing number. Example 1: Input: int arr[] = {3, 5, 7, 9, 11, 15, 17, 19} Output: 13 Explanation: If we put the number 13 after number 11 in the input array, the arithmetic progression is complete. Hence, the answer is 13 Example 2: Input: int arr[] = {1, 7, 13, 19, 31, 37, 43} Output: 25 Explanation: If we put the number 25 after the number 19 in the input array, the arithmetic progression is complete. Hence, the answer is 25. Example 3: Input: int arr[] = {25, 18, 4, -3, -10, -17, -24} Output: 11 Explanation: If we put the number 11 after the number 18 in the input array, the arithmetic progression is complete. Hence, the answer is 11. Solution to the Problem Using Arithmetic Progression Formula The sum of the numbers in an arithmetic progression whose first term is a1 and the last term is an, and the total term is n is: Sn = (n x (a1 + an) ) / 2. Thus, we can compute the sum of the input array. It is because we know the first, last, and size of the input array. If we take the reference of example 1, we get: S9 = (9 x (3 + 19)) / 2 = (9 x 22) / 2 = 198 / 2 = 99 (9 is the size of the input array including the missing element) Now, iterate over the array and find the sum of the elements present. We get Sum of elements: 3 + 5 + 7 + 9 + 11 + 15 + 17 + 19 = 86 Now, subtract S8 with the sum of elements of the input array. We get 99 - 86 = 13, which is the missing element of the arithmetic progression. The following program implements the same concept. FileName: MissingElementAP.java 
public class MissingElementAP 
{
public int findMissingEle(int inputArr[], int size)
{
    // for storing the sum of the elements
    // present in the array
    int sumOfEle = 0;
    // for storing the sum using the AP sum formula
    int APSum = 0;
    // sum of the elements of the array, including the missing element
    // using the sum of the elements of an Arithmetic Progression Formula
    // size + 1 because we have to include the missing element in the input array
    APSum = ((size + 1) * (inputArr[0] + inputArr[size - 1])) / 2;
    // loop for computing the sum of elements
    // present in the input array
    for(int i = 0; i < size; i++)
    {
        sumOfEle = sumOfEle + inputArr[i];
    }
    // finding the missing element
    int missingEle = APSum - sumOfEle;
    // returning the missing element
    return missingEle;
}
// main method
public static void main(String[] argvs) 
{
// creating an object of the class MissingElementAP
MissingElementAP obj = new MissingElementAP();
// input 1
int apArr[] = {3, 5, 7, 9, 11, 15, 17, 19};
int size = apArr.length;
int ans = obj.findMissingEle(apArr, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
    System.out.print(apArr[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
System.out.println( "\n" );
// input 2
int apArr1[] = {1, 7, 13, 19, 31, 37, 43};
size = apArr1.length;
ans = obj.findMissingEle(apArr1, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
    System.out.print(apArr1[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
System.out.println( "\n" );
// input 3
int apArr2[] = {25, 18, 4, -3, -10, -17, -24};
size = apArr2.length;
ans = obj.findMissingEle(apArr2, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
    System.out.print(apArr2[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
}
}
<p><strong>Output:</strong></p>
<div class="codeblock3"><pre>
For the input array: 
3 5 7 9 11 15 17 19 
The missing element is: 13


For the input array: 
1 7 13 19 31 37 43 
The missing element is: 25


For the input array: 
25 18 4 -3 -10 -17 -24 
The missing element is: 11
</pre></div>
<p><strong>Complexity Analysis:</strong> Since the program is using a for-loop for computing the sum of elements, the time complexity of the program is O(n), where n is the total number of elements present in the array. The space complexity of the program is constant, i.e., O(1).</p>
<h3 class="h3">Using Binary Search</h3>
<p>Observe the examples mentioned above. One can see that elements of the input array are either in increasing order or in decreasing order. Whenever such a kind of pattern is observed, one can use binary search.</p>
<p>Go to the middle element and compute the difference between the middle and next to the middle element. If it is not equal to the common difference of the arithmetic progression, then the missing element lies between mid and mid + 1. If the middle element is equal to the (s / 2)th term of the arithmetic progression series, then the missing element is in the right half of the input array; otherwise in the left half. The following program illustrates the same.</p>
<p><strong>FileName:</strong> MissingElementAP1.java</p>
<div class="codeblock"><textarea name="code" class="java">
public class MissingElementAP1
{
// the following method implements the binary 
// search with the help of recursion to find the 
// missing element in the arithmetic progression
public int findMissingUtility(int arr[], int l, int h, int difference)
{
// There has to be atleast two elements
// for computing the missing element
if (h <= l)
{
return Integer.MAX_VALUE;
}
// Finding the middle element index
int m = l + (h - l) / 2;
// The element just after the middle element is missing.
// The arr[mid+1] must exist, because we return when
// (l == hi) and take the floor of (h - l) / 2
if (arr[m + 1] - arr[m] != difference)
{
return (arr[m] + difference);
}
// The element just before mid is missing
if (m > 0 && arr[m] - arr[m - 1] != difference)
{
return (arr[m - 1] + difference);
}
// If the elements till the mid follow
// AP, then apply recursion on the right half
if (arr[m] == arr[0] + m * difference)
{
return findMissingUtility(arr, m + 1, h, difference);
}
// Else applying recursion on the left half
return findMissingUtility(arr, l, m - 1, difference);
}
// The method uses the method findMissingUtility()
// for finding the element that is missing in AP.
// The method only the considers that the 
// common difference of the arithmetic progression is
// an integer.
public int findMissing(int arr[], int n)
{
// Since only one element is missing
// we can use the last and first element
// for computing the common difference of the
// arithemtic progression
int commonDiff = (arr[n - 1] - arr[0]) / n;
// Applying Binary search for the missing
// number using the above calculated diff
return findMissingUtility(arr, 0, n - 1, commonDiff);
}
// main method
public static void main(String[] argvs) 
{
// creating an object of the class MissingElementAP1
MissingElementAP1 obj = new MissingElementAP1();
// input 1
int apArr[] = {3, 5, 7, 9, 11, 15, 17, 19};
int size = apArr.length;
int ans = obj.findMissing(apArr, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
System.out.print(apArr[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
System.out.println( "\n" );
// input 2
int apArr1[] = {1, 7, 13, 19, 31, 37, 43};
size = apArr1.length;
ans = obj.findMissing(apArr1, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
System.out.print(apArr1[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
System.out.println( "\n" );
// input 3
int apArr2[] = {25, 18, 4, -3, -10, -17, -24};
size = apArr2.length;
ans = obj.findMissing(apArr2, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
System.out.print(apArr2[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
}
}
 Output: For the input array: 
3 5 7 9 11 15 17 19 
The missing element is: 13


For the input array: 
1 7 13 19 31 37 43 
The missing element is: 25


For the input array: 
25 18 4 -3 -10 -17 -24 
The missing element is: 11
 Complexity Analysis: Since the program is using the binary search, the time complexity of the program is O(n), where n is the total number of elements present in the input array. The program is not using any auxiliary space. Therefore, the space complexity of the program is constant, i.e., O(1). Next TopicPeak Index of Mountain Array Problem in Java ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/missing-number-in-an-arithmetic-progression-in-java Missing Number in An Arithmetic Progression in Java - javatpoint ? SCROLL TO TOP Home Coding Problems Java Programs OOPs String Exception Multithreading Collections Coding Problems Candy Distribution Problem in Java Find Rectangle in a Matrix with Corner as 1 in Java Minimum Number of Taps to Open to Water a Garden in Java Seven Segment Display Problem in Java Split Array Largest Sum in Java Find Original Array from a Double Array in Java Minimum Lights to Activate Problem in Java Rotate List in Java Count of Range Sum Problem in Java Create A Tree of Coprime in Java Convert Integer to Roman Numerals in Java Check if n and its Double Exist or not in Java Array of Doubled Pair Problem in Java Tag Content Extractor Problem in Java Convert Roman to Integer in Java Minimum Number of Flips to Convert Binary Matrix into Zero Matrix in Java XOR of Array Elements Except Itself in Java Check If the Given Array is Mirror Inverse in Java How to Create a Mirror Image of A 2D Array in Java Add Numbers Represented by Linked Lists in Java Majority Element In an Array in Java Block Swap Algorithm or Array Rotation in Java Minimum Difference Among Group Size Two in Java Missing Number in An Arithmetic Progression in Java Peak Index of Mountain Array Problem in Java next ? ? prev Missing Number in An Arithmetic Progression in Java It is very interesting problem frequently asked in interviews of top IT companies like Google, Amazon, TCS, Accenture, etc. By solving the problem, one wants to check the logical ability, critical thinking, and problem-solving skill of the interviewee. So, in this section, we are going to find missing number in an arithmetic progression in Java with different approaches and logic. Also, we will create Java programs for the same. Problem Statement An array is given. The array contains some numbers that represent an arithmetic progression. In the arithmetic progression, one number is missing. The task is to find that missing number. Example 1: Input: int arr[] = {3, 5, 7, 9, 11, 15, 17, 19} Output: 13 Explanation: If we put the number 13 after number 11 in the input array, the arithmetic progression is complete. Hence, the answer is 13 Example 2: Input: int arr[] = {1, 7, 13, 19, 31, 37, 43} Output: 25 Explanation: If we put the number 25 after the number 19 in the input array, the arithmetic progression is complete. Hence, the answer is 25. Example 3: Input: int arr[] = {25, 18, 4, -3, -10, -17, -24} Output: 11 Explanation: If we put the number 11 after the number 18 in the input array, the arithmetic progression is complete. Hence, the answer is 11. Solution to the Problem Using Arithmetic Progression Formula The sum of the numbers in an arithmetic progression whose first term is a1 and the last term is an, and the total term is n is: Sn = (n x (a1 + an) ) / 2. Thus, we can compute the sum of the input array. It is because we know the first, last, and size of the input array. If we take the reference of example 1, we get: S9 = (9 x (3 + 19)) / 2 = (9 x 22) / 2 = 198 / 2 = 99 (9 is the size of the input array including the missing element) Now, iterate over the array and find the sum of the elements present. We get Sum of elements: 3 + 5 + 7 + 9 + 11 + 15 + 17 + 19 = 86 Now, subtract S8 with the sum of elements of the input array. We get 99 - 86 = 13, which is the missing element of the arithmetic progression. The following program implements the same concept. FileName: MissingElementAP.java 
public class MissingElementAP 
{
public int findMissingEle(int inputArr[], int size)
{
    // for storing the sum of the elements
    // present in the array
    int sumOfEle = 0;
    // for storing the sum using the AP sum formula
    int APSum = 0;
    // sum of the elements of the array, including the missing element
    // using the sum of the elements of an Arithmetic Progression Formula
    // size + 1 because we have to include the missing element in the input array
    APSum = ((size + 1) * (inputArr[0] + inputArr[size - 1])) / 2;
    // loop for computing the sum of elements
    // present in the input array
    for(int i = 0; i < size; i++)
    {
        sumOfEle = sumOfEle + inputArr[i];
    }
    // finding the missing element
    int missingEle = APSum - sumOfEle;
    // returning the missing element
    return missingEle;
}
// main method
public static void main(String[] argvs) 
{
// creating an object of the class MissingElementAP
MissingElementAP obj = new MissingElementAP();
// input 1
int apArr[] = {3, 5, 7, 9, 11, 15, 17, 19};
int size = apArr.length;
int ans = obj.findMissingEle(apArr, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
    System.out.print(apArr[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
System.out.println( "\n" );
// input 2
int apArr1[] = {1, 7, 13, 19, 31, 37, 43};
size = apArr1.length;
ans = obj.findMissingEle(apArr1, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
    System.out.print(apArr1[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
System.out.println( "\n" );
// input 3
int apArr2[] = {25, 18, 4, -3, -10, -17, -24};
size = apArr2.length;
ans = obj.findMissingEle(apArr2, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
    System.out.print(apArr2[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
}
}
<p><strong>Output:</strong></p>
<div class="codeblock3"><pre>
For the input array: 
3 5 7 9 11 15 17 19 
The missing element is: 13


For the input array: 
1 7 13 19 31 37 43 
The missing element is: 25


For the input array: 
25 18 4 -3 -10 -17 -24 
The missing element is: 11
</pre></div>
<p><strong>Complexity Analysis:</strong> Since the program is using a for-loop for computing the sum of elements, the time complexity of the program is O(n), where n is the total number of elements present in the array. The space complexity of the program is constant, i.e., O(1).</p>
<h3 class="h3">Using Binary Search</h3>
<p>Observe the examples mentioned above. One can see that elements of the input array are either in increasing order or in decreasing order. Whenever such a kind of pattern is observed, one can use binary search.</p>
<p>Go to the middle element and compute the difference between the middle and next to the middle element. If it is not equal to the common difference of the arithmetic progression, then the missing element lies between mid and mid + 1. If the middle element is equal to the (s / 2)th term of the arithmetic progression series, then the missing element is in the right half of the input array; otherwise in the left half. The following program illustrates the same.</p>
<p><strong>FileName:</strong> MissingElementAP1.java</p>
<div class="codeblock"><textarea name="code" class="java">
public class MissingElementAP1
{
// the following method implements the binary 
// search with the help of recursion to find the 
// missing element in the arithmetic progression
public int findMissingUtility(int arr[], int l, int h, int difference)
{
// There has to be atleast two elements
// for computing the missing element
if (h <= l)
{
return Integer.MAX_VALUE;
}
// Finding the middle element index
int m = l + (h - l) / 2;
// The element just after the middle element is missing.
// The arr[mid+1] must exist, because we return when
// (l == hi) and take the floor of (h - l) / 2
if (arr[m + 1] - arr[m] != difference)
{
return (arr[m] + difference);
}
// The element just before mid is missing
if (m > 0 && arr[m] - arr[m - 1] != difference)
{
return (arr[m - 1] + difference);
}
// If the elements till the mid follow
// AP, then apply recursion on the right half
if (arr[m] == arr[0] + m * difference)
{
return findMissingUtility(arr, m + 1, h, difference);
}
// Else applying recursion on the left half
return findMissingUtility(arr, l, m - 1, difference);
}
// The method uses the method findMissingUtility()
// for finding the element that is missing in AP.
// The method only the considers that the 
// common difference of the arithmetic progression is
// an integer.
public int findMissing(int arr[], int n)
{
// Since only one element is missing
// we can use the last and first element
// for computing the common difference of the
// arithemtic progression
int commonDiff = (arr[n - 1] - arr[0]) / n;
// Applying Binary search for the missing
// number using the above calculated diff
return findMissingUtility(arr, 0, n - 1, commonDiff);
}
// main method
public static void main(String[] argvs) 
{
// creating an object of the class MissingElementAP1
MissingElementAP1 obj = new MissingElementAP1();
// input 1
int apArr[] = {3, 5, 7, 9, 11, 15, 17, 19};
int size = apArr.length;
int ans = obj.findMissing(apArr, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
System.out.print(apArr[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
System.out.println( "\n" );
// input 2
int apArr1[] = {1, 7, 13, 19, 31, 37, 43};
size = apArr1.length;
ans = obj.findMissing(apArr1, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
System.out.print(apArr1[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
System.out.println( "\n" );
// input 3
int apArr2[] = {25, 18, 4, -3, -10, -17, -24};
size = apArr2.length;
ans = obj.findMissing(apArr2, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
System.out.print(apArr2[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
}
}
 Output: For the input array: 
3 5 7 9 11 15 17 19 
The missing element is: 13


For the input array: 
1 7 13 19 31 37 43 
The missing element is: 25


For the input array: 
25 18 4 -3 -10 -17 -24 
The missing element is: 11
 Complexity Analysis: Since the program is using the binary search, the time complexity of the program is O(n), where n is the total number of elements present in the input array. The program is not using any auxiliary space. Therefore, the space complexity of the program is constant, i.e., O(1). Next TopicPeak Index of Mountain Array Problem in Java ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/missing-number-in-an-arithmetic-progression-in-java Missing Number in An Arithmetic Progression in Java - javatpoint ? SCROLL TO TOP Home Coding Problems Java Programs OOPs String Exception Multithreading Collections Coding Problems Candy Distribution Problem in Java Find Rectangle in a Matrix with Corner as 1 in Java Minimum Number of Taps to Open to Water a Garden in Java Seven Segment Display Problem in Java Split Array Largest Sum in Java Find Original Array from a Double Array in Java Minimum Lights to Activate Problem in Java Rotate List in Java Count of Range Sum Problem in Java Create A Tree of Coprime in Java Convert Integer to Roman Numerals in Java Check if n and its Double Exist or not in Java Array of Doubled Pair Problem in Java Tag Content Extractor Problem in Java Convert Roman to Integer in Java Minimum Number of Flips to Convert Binary Matrix into Zero Matrix in Java XOR of Array Elements Except Itself in Java Check If the Given Array is Mirror Inverse in Java How to Create a Mirror Image of A 2D Array in Java Add Numbers Represented by Linked Lists in Java Majority Element In an Array in Java Block Swap Algorithm or Array Rotation in Java Minimum Difference Among Group Size Two in Java Missing Number in An Arithmetic Progression in Java Peak Index of Mountain Array Problem in Java next ? ? prev Missing Number in An Arithmetic Progression in Java It is very interesting problem frequently asked in interviews of top IT companies like Google, Amazon, TCS, Accenture, etc. By solving the problem, one wants to check the logical ability, critical thinking, and problem-solving skill of the interviewee. So, in this section, we are going to find missing number in an arithmetic progression in Java with different approaches and logic. Also, we will create Java programs for the same. Problem Statement An array is given. The array contains some numbers that represent an arithmetic progression. In the arithmetic progression, one number is missing. The task is to find that missing number. Example 1: Input: int arr[] = {3, 5, 7, 9, 11, 15, 17, 19} Output: 13 Explanation: If we put the number 13 after number 11 in the input array, the arithmetic progression is complete. Hence, the answer is 13 Example 2: Input: int arr[] = {1, 7, 13, 19, 31, 37, 43} Output: 25 Explanation: If we put the number 25 after the number 19 in the input array, the arithmetic progression is complete. Hence, the answer is 25. Example 3: Input: int arr[] = {25, 18, 4, -3, -10, -17, -24} Output: 11 Explanation: If we put the number 11 after the number 18 in the input array, the arithmetic progression is complete. Hence, the answer is 11. Solution to the Problem Using Arithmetic Progression Formula The sum of the numbers in an arithmetic progression whose first term is a1 and the last term is an, and the total term is n is: Sn = (n x (a1 + an) ) / 2. Thus, we can compute the sum of the input array. It is because we know the first, last, and size of the input array. If we take the reference of example 1, we get: S9 = (9 x (3 + 19)) / 2 = (9 x 22) / 2 = 198 / 2 = 99 (9 is the size of the input array including the missing element) Now, iterate over the array and find the sum of the elements present. We get Sum of elements: 3 + 5 + 7 + 9 + 11 + 15 + 17 + 19 = 86 Now, subtract S8 with the sum of elements of the input array. We get 99 - 86 = 13, which is the missing element of the arithmetic progression. The following program implements the same concept. FileName: MissingElementAP.java 
public class MissingElementAP 
{
public int findMissingEle(int inputArr[], int size)
{
    // for storing the sum of the elements
    // present in the array
    int sumOfEle = 0;
    // for storing the sum using the AP sum formula
    int APSum = 0;
    // sum of the elements of the array, including the missing element
    // using the sum of the elements of an Arithmetic Progression Formula
    // size + 1 because we have to include the missing element in the input array
    APSum = ((size + 1) * (inputArr[0] + inputArr[size - 1])) / 2;
    // loop for computing the sum of elements
    // present in the input array
    for(int i = 0; i < size; i++)
    {
        sumOfEle = sumOfEle + inputArr[i];
    }
    // finding the missing element
    int missingEle = APSum - sumOfEle;
    // returning the missing element
    return missingEle;
}
// main method
public static void main(String[] argvs) 
{
// creating an object of the class MissingElementAP
MissingElementAP obj = new MissingElementAP();
// input 1
int apArr[] = {3, 5, 7, 9, 11, 15, 17, 19};
int size = apArr.length;
int ans = obj.findMissingEle(apArr, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
    System.out.print(apArr[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
System.out.println( "\n" );
// input 2
int apArr1[] = {1, 7, 13, 19, 31, 37, 43};
size = apArr1.length;
ans = obj.findMissingEle(apArr1, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
    System.out.print(apArr1[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
System.out.println( "\n" );
// input 3
int apArr2[] = {25, 18, 4, -3, -10, -17, -24};
size = apArr2.length;
ans = obj.findMissingEle(apArr2, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
    System.out.print(apArr2[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
}
}
<p><strong>Output:</strong></p>
<div class="codeblock3"><pre>
For the input array: 
3 5 7 9 11 15 17 19 
The missing element is: 13


For the input array: 
1 7 13 19 31 37 43 
The missing element is: 25


For the input array: 
25 18 4 -3 -10 -17 -24 
The missing element is: 11
</pre></div>
<p><strong>Complexity Analysis:</strong> Since the program is using a for-loop for computing the sum of elements, the time complexity of the program is O(n), where n is the total number of elements present in the array. The space complexity of the program is constant, i.e., O(1).</p>
<h3 class="h3">Using Binary Search</h3>
<p>Observe the examples mentioned above. One can see that elements of the input array are either in increasing order or in decreasing order. Whenever such a kind of pattern is observed, one can use binary search.</p>
<p>Go to the middle element and compute the difference between the middle and next to the middle element. If it is not equal to the common difference of the arithmetic progression, then the missing element lies between mid and mid + 1. If the middle element is equal to the (s / 2)th term of the arithmetic progression series, then the missing element is in the right half of the input array; otherwise in the left half. The following program illustrates the same.</p>
<p><strong>FileName:</strong> MissingElementAP1.java</p>
<div class="codeblock"><textarea name="code" class="java">
public class MissingElementAP1
{
// the following method implements the binary 
// search with the help of recursion to find the 
// missing element in the arithmetic progression
public int findMissingUtility(int arr[], int l, int h, int difference)
{
// There has to be atleast two elements
// for computing the missing element
if (h <= l)
{
return Integer.MAX_VALUE;
}
// Finding the middle element index
int m = l + (h - l) / 2;
// The element just after the middle element is missing.
// The arr[mid+1] must exist, because we return when
// (l == hi) and take the floor of (h - l) / 2
if (arr[m + 1] - arr[m] != difference)
{
return (arr[m] + difference);
}
// The element just before mid is missing
if (m > 0 && arr[m] - arr[m - 1] != difference)
{
return (arr[m - 1] + difference);
}
// If the elements till the mid follow
// AP, then apply recursion on the right half
if (arr[m] == arr[0] + m * difference)
{
return findMissingUtility(arr, m + 1, h, difference);
}
// Else applying recursion on the left half
return findMissingUtility(arr, l, m - 1, difference);
}
// The method uses the method findMissingUtility()
// for finding the element that is missing in AP.
// The method only the considers that the 
// common difference of the arithmetic progression is
// an integer.
public int findMissing(int arr[], int n)
{
// Since only one element is missing
// we can use the last and first element
// for computing the common difference of the
// arithemtic progression
int commonDiff = (arr[n - 1] - arr[0]) / n;
// Applying Binary search for the missing
// number using the above calculated diff
return findMissingUtility(arr, 0, n - 1, commonDiff);
}
// main method
public static void main(String[] argvs) 
{
// creating an object of the class MissingElementAP1
MissingElementAP1 obj = new MissingElementAP1();
// input 1
int apArr[] = {3, 5, 7, 9, 11, 15, 17, 19};
int size = apArr.length;
int ans = obj.findMissing(apArr, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
System.out.print(apArr[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
System.out.println( "\n" );
// input 2
int apArr1[] = {1, 7, 13, 19, 31, 37, 43};
size = apArr1.length;
ans = obj.findMissing(apArr1, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
System.out.print(apArr1[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
System.out.println( "\n" );
// input 3
int apArr2[] = {25, 18, 4, -3, -10, -17, -24};
size = apArr2.length;
ans = obj.findMissing(apArr2, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
System.out.print(apArr2[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
}
}
 Output: For the input array: 
3 5 7 9 11 15 17 19 
The missing element is: 13


For the input array: 
1 7 13 19 31 37 43 
The missing element is: 25


For the input array: 
25 18 4 -3 -10 -17 -24 
The missing element is: 11
 Complexity Analysis: Since the program is using the binary search, the time complexity of the program is O(n), where n is the total number of elements present in the input array. The program is not using any auxiliary space. Therefore, the space complexity of the program is constant, i.e., O(1). Next TopicPeak Index of Mountain Array Problem in Java ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/missing-number-in-an-arithmetic-progression-in-java Missing Number in An Arithmetic Progression in Java - javatpoint ? SCROLL TO TOP Home Coding Problems Java Programs OOPs String Exception Multithreading Collections Coding Problems Candy Distribution Problem in Java Find Rectangle in a Matrix with Corner as 1 in Java Minimum Number of Taps to Open to Water a Garden in Java Seven Segment Display Problem in Java Split Array Largest Sum in Java Find Original Array from a Double Array in Java Minimum Lights to Activate Problem in Java Rotate List in Java Count of Range Sum Problem in Java Create A Tree of Coprime in Java Convert Integer to Roman Numerals in Java Check if n and its Double Exist or not in Java Array of Doubled Pair Problem in Java Tag Content Extractor Problem in Java Convert Roman to Integer in Java Minimum Number of Flips to Convert Binary Matrix into Zero Matrix in Java XOR of Array Elements Except Itself in Java Check If the Given Array is Mirror Inverse in Java How to Create a Mirror Image of A 2D Array in Java Add Numbers Represented by Linked Lists in Java Majority Element In an Array in Java Block Swap Algorithm or Array Rotation in Java Minimum Difference Among Group Size Two in Java Missing Number in An Arithmetic Progression in Java Peak Index of Mountain Array Problem in Java next ? ? prev Missing Number in An Arithmetic Progression in Java It is very interesting problem frequently asked in interviews of top IT companies like Google, Amazon, TCS, Accenture, etc. By solving the problem, one wants to check the logical ability, critical thinking, and problem-solving skill of the interviewee. So, in this section, we are going to find missing number in an arithmetic progression in Java with different approaches and logic. Also, we will create Java programs for the same. Problem Statement An array is given. The array contains some numbers that represent an arithmetic progression. In the arithmetic progression, one number is missing. The task is to find that missing number. Example 1: Input: int arr[] = {3, 5, 7, 9, 11, 15, 17, 19} Output: 13 Explanation: If we put the number 13 after number 11 in the input array, the arithmetic progression is complete. Hence, the answer is 13 Example 2: Input: int arr[] = {1, 7, 13, 19, 31, 37, 43} Output: 25 Explanation: If we put the number 25 after the number 19 in the input array, the arithmetic progression is complete. Hence, the answer is 25. Example 3: Input: int arr[] = {25, 18, 4, -3, -10, -17, -24} Output: 11 Explanation: If we put the number 11 after the number 18 in the input array, the arithmetic progression is complete. Hence, the answer is 11. Solution to the Problem Using Arithmetic Progression Formula The sum of the numbers in an arithmetic progression whose first term is a1 and the last term is an, and the total term is n is: Sn = (n x (a1 + an) ) / 2. Thus, we can compute the sum of the input array. It is because we know the first, last, and size of the input array. If we take the reference of example 1, we get: S9 = (9 x (3 + 19)) / 2 = (9 x 22) / 2 = 198 / 2 = 99 (9 is the size of the input array including the missing element) Now, iterate over the array and find the sum of the elements present. We get Sum of elements: 3 + 5 + 7 + 9 + 11 + 15 + 17 + 19 = 86 Now, subtract S8 with the sum of elements of the input array. We get 99 - 86 = 13, which is the missing element of the arithmetic progression. The following program implements the same concept. FileName: MissingElementAP.java 
public class MissingElementAP 
{
public int findMissingEle(int inputArr[], int size)
{
    // for storing the sum of the elements
    // present in the array
    int sumOfEle = 0;
    // for storing the sum using the AP sum formula
    int APSum = 0;
    // sum of the elements of the array, including the missing element
    // using the sum of the elements of an Arithmetic Progression Formula
    // size + 1 because we have to include the missing element in the input array
    APSum = ((size + 1) * (inputArr[0] + inputArr[size - 1])) / 2;
    // loop for computing the sum of elements
    // present in the input array
    for(int i = 0; i < size; i++)
    {
        sumOfEle = sumOfEle + inputArr[i];
    }
    // finding the missing element
    int missingEle = APSum - sumOfEle;
    // returning the missing element
    return missingEle;
}
// main method
public static void main(String[] argvs) 
{
// creating an object of the class MissingElementAP
MissingElementAP obj = new MissingElementAP();
// input 1
int apArr[] = {3, 5, 7, 9, 11, 15, 17, 19};
int size = apArr.length;
int ans = obj.findMissingEle(apArr, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
    System.out.print(apArr[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
System.out.println( "\n" );
// input 2
int apArr1[] = {1, 7, 13, 19, 31, 37, 43};
size = apArr1.length;
ans = obj.findMissingEle(apArr1, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
    System.out.print(apArr1[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
System.out.println( "\n" );
// input 3
int apArr2[] = {25, 18, 4, -3, -10, -17, -24};
size = apArr2.length;
ans = obj.findMissingEle(apArr2, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
    System.out.print(apArr2[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
}
}
<p><strong>Output:</strong></p>
<div class="codeblock3"><pre>
For the input array: 
3 5 7 9 11 15 17 19 
The missing element is: 13


For the input array: 
1 7 13 19 31 37 43 
The missing element is: 25


For the input array: 
25 18 4 -3 -10 -17 -24 
The missing element is: 11
</pre></div>
<p><strong>Complexity Analysis:</strong> Since the program is using a for-loop for computing the sum of elements, the time complexity of the program is O(n), where n is the total number of elements present in the array. The space complexity of the program is constant, i.e., O(1).</p>
<h3 class="h3">Using Binary Search</h3>
<p>Observe the examples mentioned above. One can see that elements of the input array are either in increasing order or in decreasing order. Whenever such a kind of pattern is observed, one can use binary search.</p>
<p>Go to the middle element and compute the difference between the middle and next to the middle element. If it is not equal to the common difference of the arithmetic progression, then the missing element lies between mid and mid + 1. If the middle element is equal to the (s / 2)th term of the arithmetic progression series, then the missing element is in the right half of the input array; otherwise in the left half. The following program illustrates the same.</p>
<p><strong>FileName:</strong> MissingElementAP1.java</p>
<div class="codeblock"><textarea name="code" class="java">
public class MissingElementAP1
{
// the following method implements the binary 
// search with the help of recursion to find the 
// missing element in the arithmetic progression
public int findMissingUtility(int arr[], int l, int h, int difference)
{
// There has to be atleast two elements
// for computing the missing element
if (h <= l)
{
return Integer.MAX_VALUE;
}
// Finding the middle element index
int m = l + (h - l) / 2;
// The element just after the middle element is missing.
// The arr[mid+1] must exist, because we return when
// (l == hi) and take the floor of (h - l) / 2
if (arr[m + 1] - arr[m] != difference)
{
return (arr[m] + difference);
}
// The element just before mid is missing
if (m > 0 && arr[m] - arr[m - 1] != difference)
{
return (arr[m - 1] + difference);
}
// If the elements till the mid follow
// AP, then apply recursion on the right half
if (arr[m] == arr[0] + m * difference)
{
return findMissingUtility(arr, m + 1, h, difference);
}
// Else applying recursion on the left half
return findMissingUtility(arr, l, m - 1, difference);
}
// The method uses the method findMissingUtility()
// for finding the element that is missing in AP.
// The method only the considers that the 
// common difference of the arithmetic progression is
// an integer.
public int findMissing(int arr[], int n)
{
// Since only one element is missing
// we can use the last and first element
// for computing the common difference of the
// arithemtic progression
int commonDiff = (arr[n - 1] - arr[0]) / n;
// Applying Binary search for the missing
// number using the above calculated diff
return findMissingUtility(arr, 0, n - 1, commonDiff);
}
// main method
public static void main(String[] argvs) 
{
// creating an object of the class MissingElementAP1
MissingElementAP1 obj = new MissingElementAP1();
// input 1
int apArr[] = {3, 5, 7, 9, 11, 15, 17, 19};
int size = apArr.length;
int ans = obj.findMissing(apArr, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
System.out.print(apArr[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
System.out.println( "\n" );
// input 2
int apArr1[] = {1, 7, 13, 19, 31, 37, 43};
size = apArr1.length;
ans = obj.findMissing(apArr1, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
System.out.print(apArr1[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
System.out.println( "\n" );
// input 3
int apArr2[] = {25, 18, 4, -3, -10, -17, -24};
size = apArr2.length;
ans = obj.findMissing(apArr2, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
System.out.print(apArr2[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
}
}
 Output: For the input array: 
3 5 7 9 11 15 17 19 
The missing element is: 13


For the input array: 
1 7 13 19 31 37 43 
The missing element is: 25


For the input array: 
25 18 4 -3 -10 -17 -24 
The missing element is: 11
 Complexity Analysis: Since the program is using the binary search, the time complexity of the program is O(n), where n is the total number of elements present in the input array. The program is not using any auxiliary space. Therefore, the space complexity of the program is constant, i.e., O(1). Next TopicPeak Index of Mountain Array Problem in Java ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/missing-number-in-an-arithmetic-progression-in-java Missing Number in An Arithmetic Progression in Java - javatpoint ? SCROLL TO TOP Home Coding Problems Java Programs OOPs String Exception Multithreading Collections Coding Problems Candy Distribution Problem in Java Find Rectangle in a Matrix with Corner as 1 in Java Minimum Number of Taps to Open to Water a Garden in Java Seven Segment Display Problem in Java Split Array Largest Sum in Java Find Original Array from a Double Array in Java Minimum Lights to Activate Problem in Java Rotate List in Java Count of Range Sum Problem in Java Create A Tree of Coprime in Java Convert Integer to Roman Numerals in Java Check if n and its Double Exist or not in Java Array of Doubled Pair Problem in Java Tag Content Extractor Problem in Java Convert Roman to Integer in Java Minimum Number of Flips to Convert Binary Matrix into Zero Matrix in Java XOR of Array Elements Except Itself in Java Check If the Given Array is Mirror Inverse in Java How to Create a Mirror Image of A 2D Array in Java Add Numbers Represented by Linked Lists in Java Majority Element In an Array in Java Block Swap Algorithm or Array Rotation in Java Minimum Difference Among Group Size Two in Java Missing Number in An Arithmetic Progression in Java Peak Index of Mountain Array Problem in Java next ? ? prev Missing Number in An Arithmetic Progression in Java It is very interesting problem frequently asked in interviews of top IT companies like Google, Amazon, TCS, Accenture, etc. By solving the problem, one wants to check the logical ability, critical thinking, and problem-solving skill of the interviewee. So, in this section, we are going to find missing number in an arithmetic progression in Java with different approaches and logic. Also, we will create Java programs for the same. Problem Statement An array is given. The array contains some numbers that represent an arithmetic progression. In the arithmetic progression, one number is missing. The task is to find that missing number. Example 1: Input: int arr[] = {3, 5, 7, 9, 11, 15, 17, 19} Output: 13 Explanation: If we put the number 13 after number 11 in the input array, the arithmetic progression is complete. Hence, the answer is 13 Example 2: Input: int arr[] = {1, 7, 13, 19, 31, 37, 43} Output: 25 Explanation: If we put the number 25 after the number 19 in the input array, the arithmetic progression is complete. Hence, the answer is 25. Example 3: Input: int arr[] = {25, 18, 4, -3, -10, -17, -24} Output: 11 Explanation: If we put the number 11 after the number 18 in the input array, the arithmetic progression is complete. Hence, the answer is 11. Solution to the Problem Using Arithmetic Progression Formula The sum of the numbers in an arithmetic progression whose first term is a1 and the last term is an, and the total term is n is: Sn = (n x (a1 + an) ) / 2. Thus, we can compute the sum of the input array. It is because we know the first, last, and size of the input array. If we take the reference of example 1, we get: S9 = (9 x (3 + 19)) / 2 = (9 x 22) / 2 = 198 / 2 = 99 (9 is the size of the input array including the missing element) Now, iterate over the array and find the sum of the elements present. We get Sum of elements: 3 + 5 + 7 + 9 + 11 + 15 + 17 + 19 = 86 Now, subtract S8 with the sum of elements of the input array. We get 99 - 86 = 13, which is the missing element of the arithmetic progression. The following program implements the same concept. FileName: MissingElementAP.java 
public class MissingElementAP 
{
public int findMissingEle(int inputArr[], int size)
{
    // for storing the sum of the elements
    // present in the array
    int sumOfEle = 0;
    // for storing the sum using the AP sum formula
    int APSum = 0;
    // sum of the elements of the array, including the missing element
    // using the sum of the elements of an Arithmetic Progression Formula
    // size + 1 because we have to include the missing element in the input array
    APSum = ((size + 1) * (inputArr[0] + inputArr[size - 1])) / 2;
    // loop for computing the sum of elements
    // present in the input array
    for(int i = 0; i < size; i++)
    {
        sumOfEle = sumOfEle + inputArr[i];
    }
    // finding the missing element
    int missingEle = APSum - sumOfEle;
    // returning the missing element
    return missingEle;
}
// main method
public static void main(String[] argvs) 
{
// creating an object of the class MissingElementAP
MissingElementAP obj = new MissingElementAP();
// input 1
int apArr[] = {3, 5, 7, 9, 11, 15, 17, 19};
int size = apArr.length;
int ans = obj.findMissingEle(apArr, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
    System.out.print(apArr[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
System.out.println( "\n" );
// input 2
int apArr1[] = {1, 7, 13, 19, 31, 37, 43};
size = apArr1.length;
ans = obj.findMissingEle(apArr1, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
    System.out.print(apArr1[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
System.out.println( "\n" );
// input 3
int apArr2[] = {25, 18, 4, -3, -10, -17, -24};
size = apArr2.length;
ans = obj.findMissingEle(apArr2, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
    System.out.print(apArr2[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
}
}
<p><strong>Output:</strong></p>
<div class="codeblock3"><pre>
For the input array: 
3 5 7 9 11 15 17 19 
The missing element is: 13


For the input array: 
1 7 13 19 31 37 43 
The missing element is: 25


For the input array: 
25 18 4 -3 -10 -17 -24 
The missing element is: 11
</pre></div>
<p><strong>Complexity Analysis:</strong> Since the program is using a for-loop for computing the sum of elements, the time complexity of the program is O(n), where n is the total number of elements present in the array. The space complexity of the program is constant, i.e., O(1).</p>
<h3 class="h3">Using Binary Search</h3>
<p>Observe the examples mentioned above. One can see that elements of the input array are either in increasing order or in decreasing order. Whenever such a kind of pattern is observed, one can use binary search.</p>
<p>Go to the middle element and compute the difference between the middle and next to the middle element. If it is not equal to the common difference of the arithmetic progression, then the missing element lies between mid and mid + 1. If the middle element is equal to the (s / 2)th term of the arithmetic progression series, then the missing element is in the right half of the input array; otherwise in the left half. The following program illustrates the same.</p>
<p><strong>FileName:</strong> MissingElementAP1.java</p>
<div class="codeblock"><textarea name="code" class="java">
public class MissingElementAP1
{
// the following method implements the binary 
// search with the help of recursion to find the 
// missing element in the arithmetic progression
public int findMissingUtility(int arr[], int l, int h, int difference)
{
// There has to be atleast two elements
// for computing the missing element
if (h <= l)
{
return Integer.MAX_VALUE;
}
// Finding the middle element index
int m = l + (h - l) / 2;
// The element just after the middle element is missing.
// The arr[mid+1] must exist, because we return when
// (l == hi) and take the floor of (h - l) / 2
if (arr[m + 1] - arr[m] != difference)
{
return (arr[m] + difference);
}
// The element just before mid is missing
if (m > 0 && arr[m] - arr[m - 1] != difference)
{
return (arr[m - 1] + difference);
}
// If the elements till the mid follow
// AP, then apply recursion on the right half
if (arr[m] == arr[0] + m * difference)
{
return findMissingUtility(arr, m + 1, h, difference);
}
// Else applying recursion on the left half
return findMissingUtility(arr, l, m - 1, difference);
}
// The method uses the method findMissingUtility()
// for finding the element that is missing in AP.
// The method only the considers that the 
// common difference of the arithmetic progression is
// an integer.
public int findMissing(int arr[], int n)
{
// Since only one element is missing
// we can use the last and first element
// for computing the common difference of the
// arithemtic progression
int commonDiff = (arr[n - 1] - arr[0]) / n;
// Applying Binary search for the missing
// number using the above calculated diff
return findMissingUtility(arr, 0, n - 1, commonDiff);
}
// main method
public static void main(String[] argvs) 
{
// creating an object of the class MissingElementAP1
MissingElementAP1 obj = new MissingElementAP1();
// input 1
int apArr[] = {3, 5, 7, 9, 11, 15, 17, 19};
int size = apArr.length;
int ans = obj.findMissing(apArr, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
System.out.print(apArr[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
System.out.println( "\n" );
// input 2
int apArr1[] = {1, 7, 13, 19, 31, 37, 43};
size = apArr1.length;
ans = obj.findMissing(apArr1, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
System.out.print(apArr1[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
System.out.println( "\n" );
// input 3
int apArr2[] = {25, 18, 4, -3, -10, -17, -24};
size = apArr2.length;
ans = obj.findMissing(apArr2, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
System.out.print(apArr2[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
}
}
 Output: For the input array: 
3 5 7 9 11 15 17 19 
The missing element is: 13


For the input array: 
1 7 13 19 31 37 43 
The missing element is: 25


For the input array: 
25 18 4 -3 -10 -17 -24 
The missing element is: 11
 Complexity Analysis: Since the program is using the binary search, the time complexity of the program is O(n), where n is the total number of elements present in the input array. The program is not using any auxiliary space. Therefore, the space complexity of the program is constant, i.e., O(1). Next TopicPeak Index of Mountain Array Problem in Java ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/missing-number-in-an-arithmetic-progression-in-java Missing Number in An Arithmetic Progression in Java - javatpoint ? SCROLL TO TOP Home Coding Problems Java Programs OOPs String Exception Multithreading Collections Coding Problems Candy Distribution Problem in Java Find Rectangle in a Matrix with Corner as 1 in Java Minimum Number of Taps to Open to Water a Garden in Java Seven Segment Display Problem in Java Split Array Largest Sum in Java Find Original Array from a Double Array in Java Minimum Lights to Activate Problem in Java Rotate List in Java Count of Range Sum Problem in Java Create A Tree of Coprime in Java Convert Integer to Roman Numerals in Java Check if n and its Double Exist or not in Java Array of Doubled Pair Problem in Java Tag Content Extractor Problem in Java Convert Roman to Integer in Java Minimum Number of Flips to Convert Binary Matrix into Zero Matrix in Java XOR of Array Elements Except Itself in Java Check If the Given Array is Mirror Inverse in Java How to Create a Mirror Image of A 2D Array in Java Add Numbers Represented by Linked Lists in Java Majority Element In an Array in Java Block Swap Algorithm or Array Rotation in Java Minimum Difference Among Group Size Two in Java Missing Number in An Arithmetic Progression in Java Peak Index of Mountain Array Problem in Java next ? ? prev Missing Number in An Arithmetic Progression in Java It is very interesting problem frequently asked in interviews of top IT companies like Google, Amazon, TCS, Accenture, etc. By solving the problem, one wants to check the logical ability, critical thinking, and problem-solving skill of the interviewee. So, in this section, we are going to find missing number in an arithmetic progression in Java with different approaches and logic. Also, we will create Java programs for the same. Problem Statement An array is given. The array contains some numbers that represent an arithmetic progression. In the arithmetic progression, one number is missing. The task is to find that missing number. Example 1: Input: int arr[] = {3, 5, 7, 9, 11, 15, 17, 19} Output: 13 Explanation: If we put the number 13 after number 11 in the input array, the arithmetic progression is complete. Hence, the answer is 13 Example 2: Input: int arr[] = {1, 7, 13, 19, 31, 37, 43} Output: 25 Explanation: If we put the number 25 after the number 19 in the input array, the arithmetic progression is complete. Hence, the answer is 25. Example 3: Input: int arr[] = {25, 18, 4, -3, -10, -17, -24} Output: 11 Explanation: If we put the number 11 after the number 18 in the input array, the arithmetic progression is complete. Hence, the answer is 11. Solution to the Problem Using Arithmetic Progression Formula The sum of the numbers in an arithmetic progression whose first term is a1 and the last term is an, and the total term is n is: Sn = (n x (a1 + an) ) / 2. Thus, we can compute the sum of the input array. It is because we know the first, last, and size of the input array. If we take the reference of example 1, we get: S9 = (9 x (3 + 19)) / 2 = (9 x 22) / 2 = 198 / 2 = 99 (9 is the size of the input array including the missing element) Now, iterate over the array and find the sum of the elements present. We get Sum of elements: 3 + 5 + 7 + 9 + 11 + 15 + 17 + 19 = 86 Now, subtract S8 with the sum of elements of the input array. We get 99 - 86 = 13, which is the missing element of the arithmetic progression. The following program implements the same concept. FileName: MissingElementAP.java 
public class MissingElementAP 
{
public int findMissingEle(int inputArr[], int size)
{
    // for storing the sum of the elements
    // present in the array
    int sumOfEle = 0;
    // for storing the sum using the AP sum formula
    int APSum = 0;
    // sum of the elements of the array, including the missing element
    // using the sum of the elements of an Arithmetic Progression Formula
    // size + 1 because we have to include the missing element in the input array
    APSum = ((size + 1) * (inputArr[0] + inputArr[size - 1])) / 2;
    // loop for computing the sum of elements
    // present in the input array
    for(int i = 0; i < size; i++)
    {
        sumOfEle = sumOfEle + inputArr[i];
    }
    // finding the missing element
    int missingEle = APSum - sumOfEle;
    // returning the missing element
    return missingEle;
}
// main method
public static void main(String[] argvs) 
{
// creating an object of the class MissingElementAP
MissingElementAP obj = new MissingElementAP();
// input 1
int apArr[] = {3, 5, 7, 9, 11, 15, 17, 19};
int size = apArr.length;
int ans = obj.findMissingEle(apArr, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
    System.out.print(apArr[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
System.out.println( "\n" );
// input 2
int apArr1[] = {1, 7, 13, 19, 31, 37, 43};
size = apArr1.length;
ans = obj.findMissingEle(apArr1, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
    System.out.print(apArr1[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
System.out.println( "\n" );
// input 3
int apArr2[] = {25, 18, 4, -3, -10, -17, -24};
size = apArr2.length;
ans = obj.findMissingEle(apArr2, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
    System.out.print(apArr2[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
}
}
<p><strong>Output:</strong></p>
<div class="codeblock3"><pre>
For the input array: 
3 5 7 9 11 15 17 19 
The missing element is: 13


For the input array: 
1 7 13 19 31 37 43 
The missing element is: 25


For the input array: 
25 18 4 -3 -10 -17 -24 
The missing element is: 11
</pre></div>
<p><strong>Complexity Analysis:</strong> Since the program is using a for-loop for computing the sum of elements, the time complexity of the program is O(n), where n is the total number of elements present in the array. The space complexity of the program is constant, i.e., O(1).</p>
<h3 class="h3">Using Binary Search</h3>
<p>Observe the examples mentioned above. One can see that elements of the input array are either in increasing order or in decreasing order. Whenever such a kind of pattern is observed, one can use binary search.</p>
<p>Go to the middle element and compute the difference between the middle and next to the middle element. If it is not equal to the common difference of the arithmetic progression, then the missing element lies between mid and mid + 1. If the middle element is equal to the (s / 2)th term of the arithmetic progression series, then the missing element is in the right half of the input array; otherwise in the left half. The following program illustrates the same.</p>
<p><strong>FileName:</strong> MissingElementAP1.java</p>
<div class="codeblock"><textarea name="code" class="java">
public class MissingElementAP1
{
// the following method implements the binary 
// search with the help of recursion to find the 
// missing element in the arithmetic progression
public int findMissingUtility(int arr[], int l, int h, int difference)
{
// There has to be atleast two elements
// for computing the missing element
if (h <= l)
{
return Integer.MAX_VALUE;
}
// Finding the middle element index
int m = l + (h - l) / 2;
// The element just after the middle element is missing.
// The arr[mid+1] must exist, because we return when
// (l == hi) and take the floor of (h - l) / 2
if (arr[m + 1] - arr[m] != difference)
{
return (arr[m] + difference);
}
// The element just before mid is missing
if (m > 0 && arr[m] - arr[m - 1] != difference)
{
return (arr[m - 1] + difference);
}
// If the elements till the mid follow
// AP, then apply recursion on the right half
if (arr[m] == arr[0] + m * difference)
{
return findMissingUtility(arr, m + 1, h, difference);
}
// Else applying recursion on the left half
return findMissingUtility(arr, l, m - 1, difference);
}
// The method uses the method findMissingUtility()
// for finding the element that is missing in AP.
// The method only the considers that the 
// common difference of the arithmetic progression is
// an integer.
public int findMissing(int arr[], int n)
{
// Since only one element is missing
// we can use the last and first element
// for computing the common difference of the
// arithemtic progression
int commonDiff = (arr[n - 1] - arr[0]) / n;
// Applying Binary search for the missing
// number using the above calculated diff
return findMissingUtility(arr, 0, n - 1, commonDiff);
}
// main method
public static void main(String[] argvs) 
{
// creating an object of the class MissingElementAP1
MissingElementAP1 obj = new MissingElementAP1();
// input 1
int apArr[] = {3, 5, 7, 9, 11, 15, 17, 19};
int size = apArr.length;
int ans = obj.findMissing(apArr, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
System.out.print(apArr[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
System.out.println( "\n" );
// input 2
int apArr1[] = {1, 7, 13, 19, 31, 37, 43};
size = apArr1.length;
ans = obj.findMissing(apArr1, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
System.out.print(apArr1[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
System.out.println( "\n" );
// input 3
int apArr2[] = {25, 18, 4, -3, -10, -17, -24};
size = apArr2.length;
ans = obj.findMissing(apArr2, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
System.out.print(apArr2[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
}
}
 Output: For the input array: 
3 5 7 9 11 15 17 19 
The missing element is: 13


For the input array: 
1 7 13 19 31 37 43 
The missing element is: 25


For the input array: 
25 18 4 -3 -10 -17 -24 
The missing element is: 11
 Complexity Analysis: Since the program is using the binary search, the time complexity of the program is O(n), where n is the total number of elements present in the input array. The program is not using any auxiliary space. Therefore, the space complexity of the program is constant, i.e., O(1). Next TopicPeak Index of Mountain Array Problem in Java ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/missing-number-in-an-arithmetic-progression-in-java Missing Number in An Arithmetic Progression in Java - javatpoint ? SCROLL TO TOP Home Coding Problems Java Programs OOPs String Exception Multithreading Collections Coding Problems Candy Distribution Problem in Java Find Rectangle in a Matrix with Corner as 1 in Java Minimum Number of Taps to Open to Water a Garden in Java Seven Segment Display Problem in Java Split Array Largest Sum in Java Find Original Array from a Double Array in Java Minimum Lights to Activate Problem in Java Rotate List in Java Count of Range Sum Problem in Java Create A Tree of Coprime in Java Convert Integer to Roman Numerals in Java Check if n and its Double Exist or not in Java Array of Doubled Pair Problem in Java Tag Content Extractor Problem in Java Convert Roman to Integer in Java Minimum Number of Flips to Convert Binary Matrix into Zero Matrix in Java XOR of Array Elements Except Itself in Java Check If the Given Array is Mirror Inverse in Java How to Create a Mirror Image of A 2D Array in Java Add Numbers Represented by Linked Lists in Java Majority Element In an Array in Java Block Swap Algorithm or Array Rotation in Java Minimum Difference Among Group Size Two in Java Missing Number in An Arithmetic Progression in Java Peak Index of Mountain Array Problem in Java next ? ? prev Missing Number in An Arithmetic Progression in Java It is very interesting problem frequently asked in interviews of top IT companies like Google, Amazon, TCS, Accenture, etc. By solving the problem, one wants to check the logical ability, critical thinking, and problem-solving skill of the interviewee. So, in this section, we are going to find missing number in an arithmetic progression in Java with different approaches and logic. Also, we will create Java programs for the same. Problem Statement An array is given. The array contains some numbers that represent an arithmetic progression. In the arithmetic progression, one number is missing. The task is to find that missing number. Example 1: Input: int arr[] = {3, 5, 7, 9, 11, 15, 17, 19} Output: 13 Explanation: If we put the number 13 after number 11 in the input array, the arithmetic progression is complete. Hence, the answer is 13 Example 2: Input: int arr[] = {1, 7, 13, 19, 31, 37, 43} Output: 25 Explanation: If we put the number 25 after the number 19 in the input array, the arithmetic progression is complete. Hence, the answer is 25. Example 3: Input: int arr[] = {25, 18, 4, -3, -10, -17, -24} Output: 11 Explanation: If we put the number 11 after the number 18 in the input array, the arithmetic progression is complete. Hence, the answer is 11. Solution to the Problem Using Arithmetic Progression Formula The sum of the numbers in an arithmetic progression whose first term is a1 and the last term is an, and the total term is n is: Sn = (n x (a1 + an) ) / 2. Thus, we can compute the sum of the input array. It is because we know the first, last, and size of the input array. If we take the reference of example 1, we get: S9 = (9 x (3 + 19)) / 2 = (9 x 22) / 2 = 198 / 2 = 99 (9 is the size of the input array including the missing element) Now, iterate over the array and find the sum of the elements present. We get Sum of elements: 3 + 5 + 7 + 9 + 11 + 15 + 17 + 19 = 86 Now, subtract S8 with the sum of elements of the input array. We get 99 - 86 = 13, which is the missing element of the arithmetic progression. The following program implements the same concept. FileName: MissingElementAP.java 
public class MissingElementAP 
{
public int findMissingEle(int inputArr[], int size)
{
    // for storing the sum of the elements
    // present in the array
    int sumOfEle = 0;
    // for storing the sum using the AP sum formula
    int APSum = 0;
    // sum of the elements of the array, including the missing element
    // using the sum of the elements of an Arithmetic Progression Formula
    // size + 1 because we have to include the missing element in the input array
    APSum = ((size + 1) * (inputArr[0] + inputArr[size - 1])) / 2;
    // loop for computing the sum of elements
    // present in the input array
    for(int i = 0; i < size; i++)
    {
        sumOfEle = sumOfEle + inputArr[i];
    }
    // finding the missing element
    int missingEle = APSum - sumOfEle;
    // returning the missing element
    return missingEle;
}
// main method
public static void main(String[] argvs) 
{
// creating an object of the class MissingElementAP
MissingElementAP obj = new MissingElementAP();
// input 1
int apArr[] = {3, 5, 7, 9, 11, 15, 17, 19};
int size = apArr.length;
int ans = obj.findMissingEle(apArr, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
    System.out.print(apArr[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
System.out.println( "\n" );
// input 2
int apArr1[] = {1, 7, 13, 19, 31, 37, 43};
size = apArr1.length;
ans = obj.findMissingEle(apArr1, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
    System.out.print(apArr1[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
System.out.println( "\n" );
// input 3
int apArr2[] = {25, 18, 4, -3, -10, -17, -24};
size = apArr2.length;
ans = obj.findMissingEle(apArr2, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
    System.out.print(apArr2[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
}
}
<p><strong>Output:</strong></p>
<div class="codeblock3"><pre>
For the input array: 
3 5 7 9 11 15 17 19 
The missing element is: 13


For the input array: 
1 7 13 19 31 37 43 
The missing element is: 25


For the input array: 
25 18 4 -3 -10 -17 -24 
The missing element is: 11
</pre></div>
<p><strong>Complexity Analysis:</strong> Since the program is using a for-loop for computing the sum of elements, the time complexity of the program is O(n), where n is the total number of elements present in the array. The space complexity of the program is constant, i.e., O(1).</p>
<h3 class="h3">Using Binary Search</h3>
<p>Observe the examples mentioned above. One can see that elements of the input array are either in increasing order or in decreasing order. Whenever such a kind of pattern is observed, one can use binary search.</p>
<p>Go to the middle element and compute the difference between the middle and next to the middle element. If it is not equal to the common difference of the arithmetic progression, then the missing element lies between mid and mid + 1. If the middle element is equal to the (s / 2)th term of the arithmetic progression series, then the missing element is in the right half of the input array; otherwise in the left half. The following program illustrates the same.</p>
<p><strong>FileName:</strong> MissingElementAP1.java</p>
<div class="codeblock"><textarea name="code" class="java">
public class MissingElementAP1
{
// the following method implements the binary 
// search with the help of recursion to find the 
// missing element in the arithmetic progression
public int findMissingUtility(int arr[], int l, int h, int difference)
{
// There has to be atleast two elements
// for computing the missing element
if (h <= l)
{
return Integer.MAX_VALUE;
}
// Finding the middle element index
int m = l + (h - l) / 2;
// The element just after the middle element is missing.
// The arr[mid+1] must exist, because we return when
// (l == hi) and take the floor of (h - l) / 2
if (arr[m + 1] - arr[m] != difference)
{
return (arr[m] + difference);
}
// The element just before mid is missing
if (m > 0 && arr[m] - arr[m - 1] != difference)
{
return (arr[m - 1] + difference);
}
// If the elements till the mid follow
// AP, then apply recursion on the right half
if (arr[m] == arr[0] + m * difference)
{
return findMissingUtility(arr, m + 1, h, difference);
}
// Else applying recursion on the left half
return findMissingUtility(arr, l, m - 1, difference);
}
// The method uses the method findMissingUtility()
// for finding the element that is missing in AP.
// The method only the considers that the 
// common difference of the arithmetic progression is
// an integer.
public int findMissing(int arr[], int n)
{
// Since only one element is missing
// we can use the last and first element
// for computing the common difference of the
// arithemtic progression
int commonDiff = (arr[n - 1] - arr[0]) / n;
// Applying Binary search for the missing
// number using the above calculated diff
return findMissingUtility(arr, 0, n - 1, commonDiff);
}
// main method
public static void main(String[] argvs) 
{
// creating an object of the class MissingElementAP1
MissingElementAP1 obj = new MissingElementAP1();
// input 1
int apArr[] = {3, 5, 7, 9, 11, 15, 17, 19};
int size = apArr.length;
int ans = obj.findMissing(apArr, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
System.out.print(apArr[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
System.out.println( "\n" );
// input 2
int apArr1[] = {1, 7, 13, 19, 31, 37, 43};
size = apArr1.length;
ans = obj.findMissing(apArr1, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
System.out.print(apArr1[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
System.out.println( "\n" );
// input 3
int apArr2[] = {25, 18, 4, -3, -10, -17, -24};
size = apArr2.length;
ans = obj.findMissing(apArr2, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
System.out.print(apArr2[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
}
}
 Output: For the input array: 
3 5 7 9 11 15 17 19 
The missing element is: 13


For the input array: 
1 7 13 19 31 37 43 
The missing element is: 25


For the input array: 
25 18 4 -3 -10 -17 -24 
The missing element is: 11
 Complexity Analysis: Since the program is using the binary search, the time complexity of the program is O(n), where n is the total number of elements present in the input array. The program is not using any auxiliary space. Therefore, the space complexity of the program is constant, i.e., O(1). Next TopicPeak Index of Mountain Array Problem in Java ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/missing-number-in-an-arithmetic-progression-in-java Missing Number in An Arithmetic Progression in Java - javatpoint ? SCROLL TO TOP Home Coding Problems Java Programs OOPs String Exception Multithreading Collections Coding Problems Candy Distribution Problem in Java Find Rectangle in a Matrix with Corner as 1 in Java Minimum Number of Taps to Open to Water a Garden in Java Seven Segment Display Problem in Java Split Array Largest Sum in Java Find Original Array from a Double Array in Java Minimum Lights to Activate Problem in Java Rotate List in Java Count of Range Sum Problem in Java Create A Tree of Coprime in Java Convert Integer to Roman Numerals in Java Check if n and its Double Exist or not in Java Array of Doubled Pair Problem in Java Tag Content Extractor Problem in Java Convert Roman to Integer in Java Minimum Number of Flips to Convert Binary Matrix into Zero Matrix in Java XOR of Array Elements Except Itself in Java Check If the Given Array is Mirror Inverse in Java How to Create a Mirror Image of A 2D Array in Java Add Numbers Represented by Linked Lists in Java Majority Element In an Array in Java Block Swap Algorithm or Array Rotation in Java Minimum Difference Among Group Size Two in Java Missing Number in An Arithmetic Progression in Java Peak Index of Mountain Array Problem in Java next ? ? prev Missing Number in An Arithmetic Progression in Java It is very interesting problem frequently asked in interviews of top IT companies like Google, Amazon, TCS, Accenture, etc. By solving the problem, one wants to check the logical ability, critical thinking, and problem-solving skill of the interviewee. So, in this section, we are going to find missing number in an arithmetic progression in Java with different approaches and logic. Also, we will create Java programs for the same. Problem Statement An array is given. The array contains some numbers that represent an arithmetic progression. In the arithmetic progression, one number is missing. The task is to find that missing number. Example 1: Input: int arr[] = {3, 5, 7, 9, 11, 15, 17, 19} Output: 13 Explanation: If we put the number 13 after number 11 in the input array, the arithmetic progression is complete. Hence, the answer is 13 Example 2: Input: int arr[] = {1, 7, 13, 19, 31, 37, 43} Output: 25 Explanation: If we put the number 25 after the number 19 in the input array, the arithmetic progression is complete. Hence, the answer is 25. Example 3: Input: int arr[] = {25, 18, 4, -3, -10, -17, -24} Output: 11 Explanation: If we put the number 11 after the number 18 in the input array, the arithmetic progression is complete. Hence, the answer is 11. Solution to the Problem Using Arithmetic Progression Formula The sum of the numbers in an arithmetic progression whose first term is a1 and the last term is an, and the total term is n is: Sn = (n x (a1 + an) ) / 2. Thus, we can compute the sum of the input array. It is because we know the first, last, and size of the input array. If we take the reference of example 1, we get: S9 = (9 x (3 + 19)) / 2 = (9 x 22) / 2 = 198 / 2 = 99 (9 is the size of the input array including the missing element) Now, iterate over the array and find the sum of the elements present. We get Sum of elements: 3 + 5 + 7 + 9 + 11 + 15 + 17 + 19 = 86 Now, subtract S8 with the sum of elements of the input array. We get 99 - 86 = 13, which is the missing element of the arithmetic progression. The following program implements the same concept. FileName: MissingElementAP.java 
public class MissingElementAP 
{
public int findMissingEle(int inputArr[], int size)
{
    // for storing the sum of the elements
    // present in the array
    int sumOfEle = 0;
    // for storing the sum using the AP sum formula
    int APSum = 0;
    // sum of the elements of the array, including the missing element
    // using the sum of the elements of an Arithmetic Progression Formula
    // size + 1 because we have to include the missing element in the input array
    APSum = ((size + 1) * (inputArr[0] + inputArr[size - 1])) / 2;
    // loop for computing the sum of elements
    // present in the input array
    for(int i = 0; i < size; i++)
    {
        sumOfEle = sumOfEle + inputArr[i];
    }
    // finding the missing element
    int missingEle = APSum - sumOfEle;
    // returning the missing element
    return missingEle;
}
// main method
public static void main(String[] argvs) 
{
// creating an object of the class MissingElementAP
MissingElementAP obj = new MissingElementAP();
// input 1
int apArr[] = {3, 5, 7, 9, 11, 15, 17, 19};
int size = apArr.length;
int ans = obj.findMissingEle(apArr, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
    System.out.print(apArr[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
System.out.println( "\n" );
// input 2
int apArr1[] = {1, 7, 13, 19, 31, 37, 43};
size = apArr1.length;
ans = obj.findMissingEle(apArr1, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
    System.out.print(apArr1[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
System.out.println( "\n" );
// input 3
int apArr2[] = {25, 18, 4, -3, -10, -17, -24};
size = apArr2.length;
ans = obj.findMissingEle(apArr2, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
    System.out.print(apArr2[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
}
}
<p><strong>Output:</strong></p>
<div class="codeblock3"><pre>
For the input array: 
3 5 7 9 11 15 17 19 
The missing element is: 13


For the input array: 
1 7 13 19 31 37 43 
The missing element is: 25


For the input array: 
25 18 4 -3 -10 -17 -24 
The missing element is: 11
</pre></div>
<p><strong>Complexity Analysis:</strong> Since the program is using a for-loop for computing the sum of elements, the time complexity of the program is O(n), where n is the total number of elements present in the array. The space complexity of the program is constant, i.e., O(1).</p>
<h3 class="h3">Using Binary Search</h3>
<p>Observe the examples mentioned above. One can see that elements of the input array are either in increasing order or in decreasing order. Whenever such a kind of pattern is observed, one can use binary search.</p>
<p>Go to the middle element and compute the difference between the middle and next to the middle element. If it is not equal to the common difference of the arithmetic progression, then the missing element lies between mid and mid + 1. If the middle element is equal to the (s / 2)th term of the arithmetic progression series, then the missing element is in the right half of the input array; otherwise in the left half. The following program illustrates the same.</p>
<p><strong>FileName:</strong> MissingElementAP1.java</p>
<div class="codeblock"><textarea name="code" class="java">
public class MissingElementAP1
{
// the following method implements the binary 
// search with the help of recursion to find the 
// missing element in the arithmetic progression
public int findMissingUtility(int arr[], int l, int h, int difference)
{
// There has to be atleast two elements
// for computing the missing element
if (h <= l)
{
return Integer.MAX_VALUE;
}
// Finding the middle element index
int m = l + (h - l) / 2;
// The element just after the middle element is missing.
// The arr[mid+1] must exist, because we return when
// (l == hi) and take the floor of (h - l) / 2
if (arr[m + 1] - arr[m] != difference)
{
return (arr[m] + difference);
}
// The element just before mid is missing
if (m > 0 && arr[m] - arr[m - 1] != difference)
{
return (arr[m - 1] + difference);
}
// If the elements till the mid follow
// AP, then apply recursion on the right half
if (arr[m] == arr[0] + m * difference)
{
return findMissingUtility(arr, m + 1, h, difference);
}
// Else applying recursion on the left half
return findMissingUtility(arr, l, m - 1, difference);
}
// The method uses the method findMissingUtility()
// for finding the element that is missing in AP.
// The method only the considers that the 
// common difference of the arithmetic progression is
// an integer.
public int findMissing(int arr[], int n)
{
// Since only one element is missing
// we can use the last and first element
// for computing the common difference of the
// arithemtic progression
int commonDiff = (arr[n - 1] - arr[0]) / n;
// Applying Binary search for the missing
// number using the above calculated diff
return findMissingUtility(arr, 0, n - 1, commonDiff);
}
// main method
public static void main(String[] argvs) 
{
// creating an object of the class MissingElementAP1
MissingElementAP1 obj = new MissingElementAP1();
// input 1
int apArr[] = {3, 5, 7, 9, 11, 15, 17, 19};
int size = apArr.length;
int ans = obj.findMissing(apArr, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
System.out.print(apArr[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
System.out.println( "\n" );
// input 2
int apArr1[] = {1, 7, 13, 19, 31, 37, 43};
size = apArr1.length;
ans = obj.findMissing(apArr1, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
System.out.print(apArr1[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
System.out.println( "\n" );
// input 3
int apArr2[] = {25, 18, 4, -3, -10, -17, -24};
size = apArr2.length;
ans = obj.findMissing(apArr2, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
System.out.print(apArr2[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
}
}
 Output: For the input array: 
3 5 7 9 11 15 17 19 
The missing element is: 13


For the input array: 
1 7 13 19 31 37 43 
The missing element is: 25


For the input array: 
25 18 4 -3 -10 -17 -24 
The missing element is: 11
 Complexity Analysis: Since the program is using the binary search, the time complexity of the program is O(n), where n is the total number of elements present in the input array. The program is not using any auxiliary space. Therefore, the space complexity of the program is constant, i.e., O(1). Next TopicPeak Index of Mountain Array Problem in Java ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/missing-number-in-an-arithmetic-progression-in-java Missing Number in An Arithmetic Progression in Java - javatpoint ? SCROLL TO TOP Home Coding Problems Java Programs OOPs String Exception Multithreading Collections Coding Problems Candy Distribution Problem in Java Find Rectangle in a Matrix with Corner as 1 in Java Minimum Number of Taps to Open to Water a Garden in Java Seven Segment Display Problem in Java Split Array Largest Sum in Java Find Original Array from a Double Array in Java Minimum Lights to Activate Problem in Java Rotate List in Java Count of Range Sum Problem in Java Create A Tree of Coprime in Java Convert Integer to Roman Numerals in Java Check if n and its Double Exist or not in Java Array of Doubled Pair Problem in Java Tag Content Extractor Problem in Java Convert Roman to Integer in Java Minimum Number of Flips to Convert Binary Matrix into Zero Matrix in Java XOR of Array Elements Except Itself in Java Check If the Given Array is Mirror Inverse in Java How to Create a Mirror Image of A 2D Array in Java Add Numbers Represented by Linked Lists in Java Majority Element In an Array in Java Block Swap Algorithm or Array Rotation in Java Minimum Difference Among Group Size Two in Java Missing Number in An Arithmetic Progression in Java Peak Index of Mountain Array Problem in Java next ? ? prev Missing Number in An Arithmetic Progression in Java It is very interesting problem frequently asked in interviews of top IT companies like Google, Amazon, TCS, Accenture, etc. By solving the problem, one wants to check the logical ability, critical thinking, and problem-solving skill of the interviewee. So, in this section, we are going to find missing number in an arithmetic progression in Java with different approaches and logic. Also, we will create Java programs for the same. Problem Statement An array is given. The array contains some numbers that represent an arithmetic progression. In the arithmetic progression, one number is missing. The task is to find that missing number. Example 1: Input: int arr[] = {3, 5, 7, 9, 11, 15, 17, 19} Output: 13 Explanation: If we put the number 13 after number 11 in the input array, the arithmetic progression is complete. Hence, the answer is 13 Example 2: Input: int arr[] = {1, 7, 13, 19, 31, 37, 43} Output: 25 Explanation: If we put the number 25 after the number 19 in the input array, the arithmetic progression is complete. Hence, the answer is 25. Example 3: Input: int arr[] = {25, 18, 4, -3, -10, -17, -24} Output: 11 Explanation: If we put the number 11 after the number 18 in the input array, the arithmetic progression is complete. Hence, the answer is 11. Solution to the Problem Using Arithmetic Progression Formula The sum of the numbers in an arithmetic progression whose first term is a1 and the last term is an, and the total term is n is: Sn = (n x (a1 + an) ) / 2. Thus, we can compute the sum of the input array. It is because we know the first, last, and size of the input array. If we take the reference of example 1, we get: S9 = (9 x (3 + 19)) / 2 = (9 x 22) / 2 = 198 / 2 = 99 (9 is the size of the input array including the missing element) Now, iterate over the array and find the sum of the elements present. We get Sum of elements: 3 + 5 + 7 + 9 + 11 + 15 + 17 + 19 = 86 Now, subtract S8 with the sum of elements of the input array. We get 99 - 86 = 13, which is the missing element of the arithmetic progression. The following program implements the same concept. FileName: MissingElementAP.java 
public class MissingElementAP 
{
public int findMissingEle(int inputArr[], int size)
{
    // for storing the sum of the elements
    // present in the array
    int sumOfEle = 0;
    // for storing the sum using the AP sum formula
    int APSum = 0;
    // sum of the elements of the array, including the missing element
    // using the sum of the elements of an Arithmetic Progression Formula
    // size + 1 because we have to include the missing element in the input array
    APSum = ((size + 1) * (inputArr[0] + inputArr[size - 1])) / 2;
    // loop for computing the sum of elements
    // present in the input array
    for(int i = 0; i < size; i++)
    {
        sumOfEle = sumOfEle + inputArr[i];
    }
    // finding the missing element
    int missingEle = APSum - sumOfEle;
    // returning the missing element
    return missingEle;
}
// main method
public static void main(String[] argvs) 
{
// creating an object of the class MissingElementAP
MissingElementAP obj = new MissingElementAP();
// input 1
int apArr[] = {3, 5, 7, 9, 11, 15, 17, 19};
int size = apArr.length;
int ans = obj.findMissingEle(apArr, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
    System.out.print(apArr[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
System.out.println( "\n" );
// input 2
int apArr1[] = {1, 7, 13, 19, 31, 37, 43};
size = apArr1.length;
ans = obj.findMissingEle(apArr1, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
    System.out.print(apArr1[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
System.out.println( "\n" );
// input 3
int apArr2[] = {25, 18, 4, -3, -10, -17, -24};
size = apArr2.length;
ans = obj.findMissingEle(apArr2, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
    System.out.print(apArr2[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
}
}
<p><strong>Output:</strong></p>
<div class="codeblock3"><pre>
For the input array: 
3 5 7 9 11 15 17 19 
The missing element is: 13


For the input array: 
1 7 13 19 31 37 43 
The missing element is: 25


For the input array: 
25 18 4 -3 -10 -17 -24 
The missing element is: 11
</pre></div>
<p><strong>Complexity Analysis:</strong> Since the program is using a for-loop for computing the sum of elements, the time complexity of the program is O(n), where n is the total number of elements present in the array. The space complexity of the program is constant, i.e., O(1).</p>
<h3 class="h3">Using Binary Search</h3>
<p>Observe the examples mentioned above. One can see that elements of the input array are either in increasing order or in decreasing order. Whenever such a kind of pattern is observed, one can use binary search.</p>
<p>Go to the middle element and compute the difference between the middle and next to the middle element. If it is not equal to the common difference of the arithmetic progression, then the missing element lies between mid and mid + 1. If the middle element is equal to the (s / 2)th term of the arithmetic progression series, then the missing element is in the right half of the input array; otherwise in the left half. The following program illustrates the same.</p>
<p><strong>FileName:</strong> MissingElementAP1.java</p>
<div class="codeblock"><textarea name="code" class="java">
public class MissingElementAP1
{
// the following method implements the binary 
// search with the help of recursion to find the 
// missing element in the arithmetic progression
public int findMissingUtility(int arr[], int l, int h, int difference)
{
// There has to be atleast two elements
// for computing the missing element
if (h <= l)
{
return Integer.MAX_VALUE;
}
// Finding the middle element index
int m = l + (h - l) / 2;
// The element just after the middle element is missing.
// The arr[mid+1] must exist, because we return when
// (l == hi) and take the floor of (h - l) / 2
if (arr[m + 1] - arr[m] != difference)
{
return (arr[m] + difference);
}
// The element just before mid is missing
if (m > 0 && arr[m] - arr[m - 1] != difference)
{
return (arr[m - 1] + difference);
}
// If the elements till the mid follow
// AP, then apply recursion on the right half
if (arr[m] == arr[0] + m * difference)
{
return findMissingUtility(arr, m + 1, h, difference);
}
// Else applying recursion on the left half
return findMissingUtility(arr, l, m - 1, difference);
}
// The method uses the method findMissingUtility()
// for finding the element that is missing in AP.
// The method only the considers that the 
// common difference of the arithmetic progression is
// an integer.
public int findMissing(int arr[], int n)
{
// Since only one element is missing
// we can use the last and first element
// for computing the common difference of the
// arithemtic progression
int commonDiff = (arr[n - 1] - arr[0]) / n;
// Applying Binary search for the missing
// number using the above calculated diff
return findMissingUtility(arr, 0, n - 1, commonDiff);
}
// main method
public static void main(String[] argvs) 
{
// creating an object of the class MissingElementAP1
MissingElementAP1 obj = new MissingElementAP1();
// input 1
int apArr[] = {3, 5, 7, 9, 11, 15, 17, 19};
int size = apArr.length;
int ans = obj.findMissing(apArr, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
System.out.print(apArr[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
System.out.println( "\n" );
// input 2
int apArr1[] = {1, 7, 13, 19, 31, 37, 43};
size = apArr1.length;
ans = obj.findMissing(apArr1, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
System.out.print(apArr1[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
System.out.println( "\n" );
// input 3
int apArr2[] = {25, 18, 4, -3, -10, -17, -24};
size = apArr2.length;
ans = obj.findMissing(apArr2, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
System.out.print(apArr2[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
}
}
 Output: For the input array: 
3 5 7 9 11 15 17 19 
The missing element is: 13


For the input array: 
1 7 13 19 31 37 43 
The missing element is: 25


For the input array: 
25 18 4 -3 -10 -17 -24 
The missing element is: 11
 Complexity Analysis: Since the program is using the binary search, the time complexity of the program is O(n), where n is the total number of elements present in the input array. The program is not using any auxiliary space. Therefore, the space complexity of the program is constant, i.e., O(1). Next TopicPeak Index of Mountain Array Problem in Java ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/missing-number-in-an-arithmetic-progression-in-java Missing Number in An Arithmetic Progression in Java - javatpoint ? SCROLL TO TOP Home Coding Problems Java Programs OOPs String Exception Multithreading Collections Coding Problems Candy Distribution Problem in Java Find Rectangle in a Matrix with Corner as 1 in Java Minimum Number of Taps to Open to Water a Garden in Java Seven Segment Display Problem in Java Split Array Largest Sum in Java Find Original Array from a Double Array in Java Minimum Lights to Activate Problem in Java Rotate List in Java Count of Range Sum Problem in Java Create A Tree of Coprime in Java Convert Integer to Roman Numerals in Java Check if n and its Double Exist or not in Java Array of Doubled Pair Problem in Java Tag Content Extractor Problem in Java Convert Roman to Integer in Java Minimum Number of Flips to Convert Binary Matrix into Zero Matrix in Java XOR of Array Elements Except Itself in Java Check If the Given Array is Mirror Inverse in Java How to Create a Mirror Image of A 2D Array in Java Add Numbers Represented by Linked Lists in Java Majority Element In an Array in Java Block Swap Algorithm or Array Rotation in Java Minimum Difference Among Group Size Two in Java Missing Number in An Arithmetic Progression in Java Peak Index of Mountain Array Problem in Java next ? ? prev Missing Number in An Arithmetic Progression in Java It is very interesting problem frequently asked in interviews of top IT companies like Google, Amazon, TCS, Accenture, etc. By solving the problem, one wants to check the logical ability, critical thinking, and problem-solving skill of the interviewee. So, in this section, we are going to find missing number in an arithmetic progression in Java with different approaches and logic. Also, we will create Java programs for the same. Problem Statement An array is given. The array contains some numbers that represent an arithmetic progression. In the arithmetic progression, one number is missing. The task is to find that missing number. Example 1: Input: int arr[] = {3, 5, 7, 9, 11, 15, 17, 19} Output: 13 Explanation: If we put the number 13 after number 11 in the input array, the arithmetic progression is complete. Hence, the answer is 13 Example 2: Input: int arr[] = {1, 7, 13, 19, 31, 37, 43} Output: 25 Explanation: If we put the number 25 after the number 19 in the input array, the arithmetic progression is complete. Hence, the answer is 25. Example 3: Input: int arr[] = {25, 18, 4, -3, -10, -17, -24} Output: 11 Explanation: If we put the number 11 after the number 18 in the input array, the arithmetic progression is complete. Hence, the answer is 11. Solution to the Problem Using Arithmetic Progression Formula The sum of the numbers in an arithmetic progression whose first term is a1 and the last term is an, and the total term is n is: Sn = (n x (a1 + an) ) / 2. Thus, we can compute the sum of the input array. It is because we know the first, last, and size of the input array. If we take the reference of example 1, we get: S9 = (9 x (3 + 19)) / 2 = (9 x 22) / 2 = 198 / 2 = 99 (9 is the size of the input array including the missing element) Now, iterate over the array and find the sum of the elements present. We get Sum of elements: 3 + 5 + 7 + 9 + 11 + 15 + 17 + 19 = 86 Now, subtract S8 with the sum of elements of the input array. We get 99 - 86 = 13, which is the missing element of the arithmetic progression. The following program implements the same concept. FileName: MissingElementAP.java 
public class MissingElementAP 
{
public int findMissingEle(int inputArr[], int size)
{
    // for storing the sum of the elements
    // present in the array
    int sumOfEle = 0;
    // for storing the sum using the AP sum formula
    int APSum = 0;
    // sum of the elements of the array, including the missing element
    // using the sum of the elements of an Arithmetic Progression Formula
    // size + 1 because we have to include the missing element in the input array
    APSum = ((size + 1) * (inputArr[0] + inputArr[size - 1])) / 2;
    // loop for computing the sum of elements
    // present in the input array
    for(int i = 0; i < size; i++)
    {
        sumOfEle = sumOfEle + inputArr[i];
    }
    // finding the missing element
    int missingEle = APSum - sumOfEle;
    // returning the missing element
    return missingEle;
}
// main method
public static void main(String[] argvs) 
{
// creating an object of the class MissingElementAP
MissingElementAP obj = new MissingElementAP();
// input 1
int apArr[] = {3, 5, 7, 9, 11, 15, 17, 19};
int size = apArr.length;
int ans = obj.findMissingEle(apArr, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
    System.out.print(apArr[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
System.out.println( "\n" );
// input 2
int apArr1[] = {1, 7, 13, 19, 31, 37, 43};
size = apArr1.length;
ans = obj.findMissingEle(apArr1, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
    System.out.print(apArr1[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
System.out.println( "\n" );
// input 3
int apArr2[] = {25, 18, 4, -3, -10, -17, -24};
size = apArr2.length;
ans = obj.findMissingEle(apArr2, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
    System.out.print(apArr2[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
}
}
<p><strong>Output:</strong></p>
<div class="codeblock3"><pre>
For the input array: 
3 5 7 9 11 15 17 19 
The missing element is: 13


For the input array: 
1 7 13 19 31 37 43 
The missing element is: 25


For the input array: 
25 18 4 -3 -10 -17 -24 
The missing element is: 11
</pre></div>
<p><strong>Complexity Analysis:</strong> Since the program is using a for-loop for computing the sum of elements, the time complexity of the program is O(n), where n is the total number of elements present in the array. The space complexity of the program is constant, i.e., O(1).</p>
<h3 class="h3">Using Binary Search</h3>
<p>Observe the examples mentioned above. One can see that elements of the input array are either in increasing order or in decreasing order. Whenever such a kind of pattern is observed, one can use binary search.</p>
<p>Go to the middle element and compute the difference between the middle and next to the middle element. If it is not equal to the common difference of the arithmetic progression, then the missing element lies between mid and mid + 1. If the middle element is equal to the (s / 2)th term of the arithmetic progression series, then the missing element is in the right half of the input array; otherwise in the left half. The following program illustrates the same.</p>
<p><strong>FileName:</strong> MissingElementAP1.java</p>
<div class="codeblock"><textarea name="code" class="java">
public class MissingElementAP1
{
// the following method implements the binary 
// search with the help of recursion to find the 
// missing element in the arithmetic progression
public int findMissingUtility(int arr[], int l, int h, int difference)
{
// There has to be atleast two elements
// for computing the missing element
if (h <= l)
{
return Integer.MAX_VALUE;
}
// Finding the middle element index
int m = l + (h - l) / 2;
// The element just after the middle element is missing.
// The arr[mid+1] must exist, because we return when
// (l == hi) and take the floor of (h - l) / 2
if (arr[m + 1] - arr[m] != difference)
{
return (arr[m] + difference);
}
// The element just before mid is missing
if (m > 0 && arr[m] - arr[m - 1] != difference)
{
return (arr[m - 1] + difference);
}
// If the elements till the mid follow
// AP, then apply recursion on the right half
if (arr[m] == arr[0] + m * difference)
{
return findMissingUtility(arr, m + 1, h, difference);
}
// Else applying recursion on the left half
return findMissingUtility(arr, l, m - 1, difference);
}
// The method uses the method findMissingUtility()
// for finding the element that is missing in AP.
// The method only the considers that the 
// common difference of the arithmetic progression is
// an integer.
public int findMissing(int arr[], int n)
{
// Since only one element is missing
// we can use the last and first element
// for computing the common difference of the
// arithemtic progression
int commonDiff = (arr[n - 1] - arr[0]) / n;
// Applying Binary search for the missing
// number using the above calculated diff
return findMissingUtility(arr, 0, n - 1, commonDiff);
}
// main method
public static void main(String[] argvs) 
{
// creating an object of the class MissingElementAP1
MissingElementAP1 obj = new MissingElementAP1();
// input 1
int apArr[] = {3, 5, 7, 9, 11, 15, 17, 19};
int size = apArr.length;
int ans = obj.findMissing(apArr, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
System.out.print(apArr[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
System.out.println( "\n" );
// input 2
int apArr1[] = {1, 7, 13, 19, 31, 37, 43};
size = apArr1.length;
ans = obj.findMissing(apArr1, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
System.out.print(apArr1[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
System.out.println( "\n" );
// input 3
int apArr2[] = {25, 18, 4, -3, -10, -17, -24};
size = apArr2.length;
ans = obj.findMissing(apArr2, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
System.out.print(apArr2[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
}
}
 Output: For the input array: 
3 5 7 9 11 15 17 19 
The missing element is: 13


For the input array: 
1 7 13 19 31 37 43 
The missing element is: 25


For the input array: 
25 18 4 -3 -10 -17 -24 
The missing element is: 11
 Complexity Analysis: Since the program is using the binary search, the time complexity of the program is O(n), where n is the total number of elements present in the input array. The program is not using any auxiliary space. Therefore, the space complexity of the program is constant, i.e., O(1). Next TopicPeak Index of Mountain Array Problem in Java ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/missing-number-in-an-arithmetic-progression-in-java Missing Number in An Arithmetic Progression in Java - javatpoint ? SCROLL TO TOP Home Coding Problems Java Programs OOPs String Exception Multithreading Collections Coding Problems Candy Distribution Problem in Java Find Rectangle in a Matrix with Corner as 1 in Java Minimum Number of Taps to Open to Water a Garden in Java Seven Segment Display Problem in Java Split Array Largest Sum in Java Find Original Array from a Double Array in Java Minimum Lights to Activate Problem in Java Rotate List in Java Count of Range Sum Problem in Java Create A Tree of Coprime in Java Convert Integer to Roman Numerals in Java Check if n and its Double Exist or not in Java Array of Doubled Pair Problem in Java Tag Content Extractor Problem in Java Convert Roman to Integer in Java Minimum Number of Flips to Convert Binary Matrix into Zero Matrix in Java XOR of Array Elements Except Itself in Java Check If the Given Array is Mirror Inverse in Java How to Create a Mirror Image of A 2D Array in Java Add Numbers Represented by Linked Lists in Java Majority Element In an Array in Java Block Swap Algorithm or Array Rotation in Java Minimum Difference Among Group Size Two in Java Missing Number in An Arithmetic Progression in Java Peak Index of Mountain Array Problem in Java next ? ? prev Missing Number in An Arithmetic Progression in Java It is very interesting problem frequently asked in interviews of top IT companies like Google, Amazon, TCS, Accenture, etc. By solving the problem, one wants to check the logical ability, critical thinking, and problem-solving skill of the interviewee. So, in this section, we are going to find missing number in an arithmetic progression in Java with different approaches and logic. Also, we will create Java programs for the same. Problem Statement An array is given. The array contains some numbers that represent an arithmetic progression. In the arithmetic progression, one number is missing. The task is to find that missing number. Example 1: Input: int arr[] = {3, 5, 7, 9, 11, 15, 17, 19} Output: 13 Explanation: If we put the number 13 after number 11 in the input array, the arithmetic progression is complete. Hence, the answer is 13 Example 2: Input: int arr[] = {1, 7, 13, 19, 31, 37, 43} Output: 25 Explanation: If we put the number 25 after the number 19 in the input array, the arithmetic progression is complete. Hence, the answer is 25. Example 3: Input: int arr[] = {25, 18, 4, -3, -10, -17, -24} Output: 11 Explanation: If we put the number 11 after the number 18 in the input array, the arithmetic progression is complete. Hence, the answer is 11. Solution to the Problem Using Arithmetic Progression Formula The sum of the numbers in an arithmetic progression whose first term is a1 and the last term is an, and the total term is n is: Sn = (n x (a1 + an) ) / 2. Thus, we can compute the sum of the input array. It is because we know the first, last, and size of the input array. If we take the reference of example 1, we get: S9 = (9 x (3 + 19)) / 2 = (9 x 22) / 2 = 198 / 2 = 99 (9 is the size of the input array including the missing element) Now, iterate over the array and find the sum of the elements present. We get Sum of elements: 3 + 5 + 7 + 9 + 11 + 15 + 17 + 19 = 86 Now, subtract S8 with the sum of elements of the input array. We get 99 - 86 = 13, which is the missing element of the arithmetic progression. The following program implements the same concept. FileName: MissingElementAP.java 
public class MissingElementAP 
{
public int findMissingEle(int inputArr[], int size)
{
    // for storing the sum of the elements
    // present in the array
    int sumOfEle = 0;
    // for storing the sum using the AP sum formula
    int APSum = 0;
    // sum of the elements of the array, including the missing element
    // using the sum of the elements of an Arithmetic Progression Formula
    // size + 1 because we have to include the missing element in the input array
    APSum = ((size + 1) * (inputArr[0] + inputArr[size - 1])) / 2;
    // loop for computing the sum of elements
    // present in the input array
    for(int i = 0; i < size; i++)
    {
        sumOfEle = sumOfEle + inputArr[i];
    }
    // finding the missing element
    int missingEle = APSum - sumOfEle;
    // returning the missing element
    return missingEle;
}
// main method
public static void main(String[] argvs) 
{
// creating an object of the class MissingElementAP
MissingElementAP obj = new MissingElementAP();
// input 1
int apArr[] = {3, 5, 7, 9, 11, 15, 17, 19};
int size = apArr.length;
int ans = obj.findMissingEle(apArr, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
    System.out.print(apArr[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
System.out.println( "\n" );
// input 2
int apArr1[] = {1, 7, 13, 19, 31, 37, 43};
size = apArr1.length;
ans = obj.findMissingEle(apArr1, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
    System.out.print(apArr1[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
System.out.println( "\n" );
// input 3
int apArr2[] = {25, 18, 4, -3, -10, -17, -24};
size = apArr2.length;
ans = obj.findMissingEle(apArr2, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
    System.out.print(apArr2[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
}
}
<p><strong>Output:</strong></p>
<div class="codeblock3"><pre>
For the input array: 
3 5 7 9 11 15 17 19 
The missing element is: 13


For the input array: 
1 7 13 19 31 37 43 
The missing element is: 25


For the input array: 
25 18 4 -3 -10 -17 -24 
The missing element is: 11
</pre></div>
<p><strong>Complexity Analysis:</strong> Since the program is using a for-loop for computing the sum of elements, the time complexity of the program is O(n), where n is the total number of elements present in the array. The space complexity of the program is constant, i.e., O(1).</p>
<h3 class="h3">Using Binary Search</h3>
<p>Observe the examples mentioned above. One can see that elements of the input array are either in increasing order or in decreasing order. Whenever such a kind of pattern is observed, one can use binary search.</p>
<p>Go to the middle element and compute the difference between the middle and next to the middle element. If it is not equal to the common difference of the arithmetic progression, then the missing element lies between mid and mid + 1. If the middle element is equal to the (s / 2)th term of the arithmetic progression series, then the missing element is in the right half of the input array; otherwise in the left half. The following program illustrates the same.</p>
<p><strong>FileName:</strong> MissingElementAP1.java</p>
<div class="codeblock"><textarea name="code" class="java">
public class MissingElementAP1
{
// the following method implements the binary 
// search with the help of recursion to find the 
// missing element in the arithmetic progression
public int findMissingUtility(int arr[], int l, int h, int difference)
{
// There has to be atleast two elements
// for computing the missing element
if (h <= l)
{
return Integer.MAX_VALUE;
}
// Finding the middle element index
int m = l + (h - l) / 2;
// The element just after the middle element is missing.
// The arr[mid+1] must exist, because we return when
// (l == hi) and take the floor of (h - l) / 2
if (arr[m + 1] - arr[m] != difference)
{
return (arr[m] + difference);
}
// The element just before mid is missing
if (m > 0 && arr[m] - arr[m - 1] != difference)
{
return (arr[m - 1] + difference);
}
// If the elements till the mid follow
// AP, then apply recursion on the right half
if (arr[m] == arr[0] + m * difference)
{
return findMissingUtility(arr, m + 1, h, difference);
}
// Else applying recursion on the left half
return findMissingUtility(arr, l, m - 1, difference);
}
// The method uses the method findMissingUtility()
// for finding the element that is missing in AP.
// The method only the considers that the 
// common difference of the arithmetic progression is
// an integer.
public int findMissing(int arr[], int n)
{
// Since only one element is missing
// we can use the last and first element
// for computing the common difference of the
// arithemtic progression
int commonDiff = (arr[n - 1] - arr[0]) / n;
// Applying Binary search for the missing
// number using the above calculated diff
return findMissingUtility(arr, 0, n - 1, commonDiff);
}
// main method
public static void main(String[] argvs) 
{
// creating an object of the class MissingElementAP1
MissingElementAP1 obj = new MissingElementAP1();
// input 1
int apArr[] = {3, 5, 7, 9, 11, 15, 17, 19};
int size = apArr.length;
int ans = obj.findMissing(apArr, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
System.out.print(apArr[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
System.out.println( "\n" );
// input 2
int apArr1[] = {1, 7, 13, 19, 31, 37, 43};
size = apArr1.length;
ans = obj.findMissing(apArr1, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
System.out.print(apArr1[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
System.out.println( "\n" );
// input 3
int apArr2[] = {25, 18, 4, -3, -10, -17, -24};
size = apArr2.length;
ans = obj.findMissing(apArr2, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
System.out.print(apArr2[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
}
}
 Output: For the input array: 
3 5 7 9 11 15 17 19 
The missing element is: 13


For the input array: 
1 7 13 19 31 37 43 
The missing element is: 25


For the input array: 
25 18 4 -3 -10 -17 -24 
The missing element is: 11
 Complexity Analysis: Since the program is using the binary search, the time complexity of the program is O(n), where n is the total number of elements present in the input array. The program is not using any auxiliary space. Therefore, the space complexity of the program is constant, i.e., O(1). Next TopicPeak Index of Mountain Array Problem in Java ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/missing-number-in-an-arithmetic-progression-in-java Missing Number in An Arithmetic Progression in Java - javatpoint ? SCROLL TO TOP Home Coding Problems Java Programs OOPs String Exception Multithreading Collections Coding Problems Candy Distribution Problem in Java Find Rectangle in a Matrix with Corner as 1 in Java Minimum Number of Taps to Open to Water a Garden in Java Seven Segment Display Problem in Java Split Array Largest Sum in Java Find Original Array from a Double Array in Java Minimum Lights to Activate Problem in Java Rotate List in Java Count of Range Sum Problem in Java Create A Tree of Coprime in Java Convert Integer to Roman Numerals in Java Check if n and its Double Exist or not in Java Array of Doubled Pair Problem in Java Tag Content Extractor Problem in Java Convert Roman to Integer in Java Minimum Number of Flips to Convert Binary Matrix into Zero Matrix in Java XOR of Array Elements Except Itself in Java Check If the Given Array is Mirror Inverse in Java How to Create a Mirror Image of A 2D Array in Java Add Numbers Represented by Linked Lists in Java Majority Element In an Array in Java Block Swap Algorithm or Array Rotation in Java Minimum Difference Among Group Size Two in Java Missing Number in An Arithmetic Progression in Java Peak Index of Mountain Array Problem in Java next ? ? prev Missing Number in An Arithmetic Progression in Java It is very interesting problem frequently asked in interviews of top IT companies like Google, Amazon, TCS, Accenture, etc. By solving the problem, one wants to check the logical ability, critical thinking, and problem-solving skill of the interviewee. So, in this section, we are going to find missing number in an arithmetic progression in Java with different approaches and logic. Also, we will create Java programs for the same. Problem Statement An array is given. The array contains some numbers that represent an arithmetic progression. In the arithmetic progression, one number is missing. The task is to find that missing number. Example 1: Input: int arr[] = {3, 5, 7, 9, 11, 15, 17, 19} Output: 13 Explanation: If we put the number 13 after number 11 in the input array, the arithmetic progression is complete. Hence, the answer is 13 Example 2: Input: int arr[] = {1, 7, 13, 19, 31, 37, 43} Output: 25 Explanation: If we put the number 25 after the number 19 in the input array, the arithmetic progression is complete. Hence, the answer is 25. Example 3: Input: int arr[] = {25, 18, 4, -3, -10, -17, -24} Output: 11 Explanation: If we put the number 11 after the number 18 in the input array, the arithmetic progression is complete. Hence, the answer is 11. Solution to the Problem Using Arithmetic Progression Formula The sum of the numbers in an arithmetic progression whose first term is a1 and the last term is an, and the total term is n is: Sn = (n x (a1 + an) ) / 2. Thus, we can compute the sum of the input array. It is because we know the first, last, and size of the input array. If we take the reference of example 1, we get: S9 = (9 x (3 + 19)) / 2 = (9 x 22) / 2 = 198 / 2 = 99 (9 is the size of the input array including the missing element) Now, iterate over the array and find the sum of the elements present. We get Sum of elements: 3 + 5 + 7 + 9 + 11 + 15 + 17 + 19 = 86 Now, subtract S8 with the sum of elements of the input array. We get 99 - 86 = 13, which is the missing element of the arithmetic progression. The following program implements the same concept. FileName: MissingElementAP.java 
public class MissingElementAP 
{
public int findMissingEle(int inputArr[], int size)
{
    // for storing the sum of the elements
    // present in the array
    int sumOfEle = 0;
    // for storing the sum using the AP sum formula
    int APSum = 0;
    // sum of the elements of the array, including the missing element
    // using the sum of the elements of an Arithmetic Progression Formula
    // size + 1 because we have to include the missing element in the input array
    APSum = ((size + 1) * (inputArr[0] + inputArr[size - 1])) / 2;
    // loop for computing the sum of elements
    // present in the input array
    for(int i = 0; i < size; i++)
    {
        sumOfEle = sumOfEle + inputArr[i];
    }
    // finding the missing element
    int missingEle = APSum - sumOfEle;
    // returning the missing element
    return missingEle;
}
// main method
public static void main(String[] argvs) 
{
// creating an object of the class MissingElementAP
MissingElementAP obj = new MissingElementAP();
// input 1
int apArr[] = {3, 5, 7, 9, 11, 15, 17, 19};
int size = apArr.length;
int ans = obj.findMissingEle(apArr, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
    System.out.print(apArr[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
System.out.println( "\n" );
// input 2
int apArr1[] = {1, 7, 13, 19, 31, 37, 43};
size = apArr1.length;
ans = obj.findMissingEle(apArr1, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
    System.out.print(apArr1[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
System.out.println( "\n" );
// input 3
int apArr2[] = {25, 18, 4, -3, -10, -17, -24};
size = apArr2.length;
ans = obj.findMissingEle(apArr2, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
    System.out.print(apArr2[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
}
}
<p><strong>Output:</strong></p>
<div class="codeblock3"><pre>
For the input array: 
3 5 7 9 11 15 17 19 
The missing element is: 13


For the input array: 
1 7 13 19 31 37 43 
The missing element is: 25


For the input array: 
25 18 4 -3 -10 -17 -24 
The missing element is: 11
</pre></div>
<p><strong>Complexity Analysis:</strong> Since the program is using a for-loop for computing the sum of elements, the time complexity of the program is O(n), where n is the total number of elements present in the array. The space complexity of the program is constant, i.e., O(1).</p>
<h3 class="h3">Using Binary Search</h3>
<p>Observe the examples mentioned above. One can see that elements of the input array are either in increasing order or in decreasing order. Whenever such a kind of pattern is observed, one can use binary search.</p>
<p>Go to the middle element and compute the difference between the middle and next to the middle element. If it is not equal to the common difference of the arithmetic progression, then the missing element lies between mid and mid + 1. If the middle element is equal to the (s / 2)th term of the arithmetic progression series, then the missing element is in the right half of the input array; otherwise in the left half. The following program illustrates the same.</p>
<p><strong>FileName:</strong> MissingElementAP1.java</p>
<div class="codeblock"><textarea name="code" class="java">
public class MissingElementAP1
{
// the following method implements the binary 
// search with the help of recursion to find the 
// missing element in the arithmetic progression
public int findMissingUtility(int arr[], int l, int h, int difference)
{
// There has to be atleast two elements
// for computing the missing element
if (h <= l)
{
return Integer.MAX_VALUE;
}
// Finding the middle element index
int m = l + (h - l) / 2;
// The element just after the middle element is missing.
// The arr[mid+1] must exist, because we return when
// (l == hi) and take the floor of (h - l) / 2
if (arr[m + 1] - arr[m] != difference)
{
return (arr[m] + difference);
}
// The element just before mid is missing
if (m > 0 && arr[m] - arr[m - 1] != difference)
{
return (arr[m - 1] + difference);
}
// If the elements till the mid follow
// AP, then apply recursion on the right half
if (arr[m] == arr[0] + m * difference)
{
return findMissingUtility(arr, m + 1, h, difference);
}
// Else applying recursion on the left half
return findMissingUtility(arr, l, m - 1, difference);
}
// The method uses the method findMissingUtility()
// for finding the element that is missing in AP.
// The method only the considers that the 
// common difference of the arithmetic progression is
// an integer.
public int findMissing(int arr[], int n)
{
// Since only one element is missing
// we can use the last and first element
// for computing the common difference of the
// arithemtic progression
int commonDiff = (arr[n - 1] - arr[0]) / n;
// Applying Binary search for the missing
// number using the above calculated diff
return findMissingUtility(arr, 0, n - 1, commonDiff);
}
// main method
public static void main(String[] argvs) 
{
// creating an object of the class MissingElementAP1
MissingElementAP1 obj = new MissingElementAP1();
// input 1
int apArr[] = {3, 5, 7, 9, 11, 15, 17, 19};
int size = apArr.length;
int ans = obj.findMissing(apArr, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
System.out.print(apArr[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
System.out.println( "\n" );
// input 2
int apArr1[] = {1, 7, 13, 19, 31, 37, 43};
size = apArr1.length;
ans = obj.findMissing(apArr1, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
System.out.print(apArr1[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
System.out.println( "\n" );
// input 3
int apArr2[] = {25, 18, 4, -3, -10, -17, -24};
size = apArr2.length;
ans = obj.findMissing(apArr2, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
System.out.print(apArr2[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
}
}
 Output: For the input array: 
3 5 7 9 11 15 17 19 
The missing element is: 13


For the input array: 
1 7 13 19 31 37 43 
The missing element is: 25


For the input array: 
25 18 4 -3 -10 -17 -24 
The missing element is: 11
 Complexity Analysis: Since the program is using the binary search, the time complexity of the program is O(n), where n is the total number of elements present in the input array. The program is not using any auxiliary space. Therefore, the space complexity of the program is constant, i.e., O(1). Next TopicPeak Index of Mountain Array Problem in Java ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/missing-number-in-an-arithmetic-progression-in-java Missing Number in An Arithmetic Progression in Java - javatpoint ? SCROLL TO TOP Home Coding Problems Java Programs OOPs String Exception Multithreading Collections Coding Problems Candy Distribution Problem in Java Find Rectangle in a Matrix with Corner as 1 in Java Minimum Number of Taps to Open to Water a Garden in Java Seven Segment Display Problem in Java Split Array Largest Sum in Java Find Original Array from a Double Array in Java Minimum Lights to Activate Problem in Java Rotate List in Java Count of Range Sum Problem in Java Create A Tree of Coprime in Java Convert Integer to Roman Numerals in Java Check if n and its Double Exist or not in Java Array of Doubled Pair Problem in Java Tag Content Extractor Problem in Java Convert Roman to Integer in Java Minimum Number of Flips to Convert Binary Matrix into Zero Matrix in Java XOR of Array Elements Except Itself in Java Check If the Given Array is Mirror Inverse in Java How to Create a Mirror Image of A 2D Array in Java Add Numbers Represented by Linked Lists in Java Majority Element In an Array in Java Block Swap Algorithm or Array Rotation in Java Minimum Difference Among Group Size Two in Java Missing Number in An Arithmetic Progression in Java Peak Index of Mountain Array Problem in Java next ? ? prev Missing Number in An Arithmetic Progression in Java It is very interesting problem frequently asked in interviews of top IT companies like Google, Amazon, TCS, Accenture, etc. By solving the problem, one wants to check the logical ability, critical thinking, and problem-solving skill of the interviewee. So, in this section, we are going to find missing number in an arithmetic progression in Java with different approaches and logic. Also, we will create Java programs for the same. Problem Statement An array is given. The array contains some numbers that represent an arithmetic progression. In the arithmetic progression, one number is missing. The task is to find that missing number. Example 1: Input: int arr[] = {3, 5, 7, 9, 11, 15, 17, 19} Output: 13 Explanation: If we put the number 13 after number 11 in the input array, the arithmetic progression is complete. Hence, the answer is 13 Example 2: Input: int arr[] = {1, 7, 13, 19, 31, 37, 43} Output: 25 Explanation: If we put the number 25 after the number 19 in the input array, the arithmetic progression is complete. Hence, the answer is 25. Example 3: Input: int arr[] = {25, 18, 4, -3, -10, -17, -24} Output: 11 Explanation: If we put the number 11 after the number 18 in the input array, the arithmetic progression is complete. Hence, the answer is 11. Solution to the Problem Using Arithmetic Progression Formula The sum of the numbers in an arithmetic progression whose first term is a1 and the last term is an, and the total term is n is: Sn = (n x (a1 + an) ) / 2. Thus, we can compute the sum of the input array. It is because we know the first, last, and size of the input array. If we take the reference of example 1, we get: S9 = (9 x (3 + 19)) / 2 = (9 x 22) / 2 = 198 / 2 = 99 (9 is the size of the input array including the missing element) Now, iterate over the array and find the sum of the elements present. We get Sum of elements: 3 + 5 + 7 + 9 + 11 + 15 + 17 + 19 = 86 Now, subtract S8 with the sum of elements of the input array. We get 99 - 86 = 13, which is the missing element of the arithmetic progression. The following program implements the same concept. FileName: MissingElementAP.java 
public class MissingElementAP 
{
public int findMissingEle(int inputArr[], int size)
{
    // for storing the sum of the elements
    // present in the array
    int sumOfEle = 0;
    // for storing the sum using the AP sum formula
    int APSum = 0;
    // sum of the elements of the array, including the missing element
    // using the sum of the elements of an Arithmetic Progression Formula
    // size + 1 because we have to include the missing element in the input array
    APSum = ((size + 1) * (inputArr[0] + inputArr[size - 1])) / 2;
    // loop for computing the sum of elements
    // present in the input array
    for(int i = 0; i < size; i++)
    {
        sumOfEle = sumOfEle + inputArr[i];
    }
    // finding the missing element
    int missingEle = APSum - sumOfEle;
    // returning the missing element
    return missingEle;
}
// main method
public static void main(String[] argvs) 
{
// creating an object of the class MissingElementAP
MissingElementAP obj = new MissingElementAP();
// input 1
int apArr[] = {3, 5, 7, 9, 11, 15, 17, 19};
int size = apArr.length;
int ans = obj.findMissingEle(apArr, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
    System.out.print(apArr[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
System.out.println( "\n" );
// input 2
int apArr1[] = {1, 7, 13, 19, 31, 37, 43};
size = apArr1.length;
ans = obj.findMissingEle(apArr1, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
    System.out.print(apArr1[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
System.out.println( "\n" );
// input 3
int apArr2[] = {25, 18, 4, -3, -10, -17, -24};
size = apArr2.length;
ans = obj.findMissingEle(apArr2, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
    System.out.print(apArr2[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
}
}
<p><strong>Output:</strong></p>
<div class="codeblock3"><pre>
For the input array: 
3 5 7 9 11 15 17 19 
The missing element is: 13


For the input array: 
1 7 13 19 31 37 43 
The missing element is: 25


For the input array: 
25 18 4 -3 -10 -17 -24 
The missing element is: 11
</pre></div>
<p><strong>Complexity Analysis:</strong> Since the program is using a for-loop for computing the sum of elements, the time complexity of the program is O(n), where n is the total number of elements present in the array. The space complexity of the program is constant, i.e., O(1).</p>
<h3 class="h3">Using Binary Search</h3>
<p>Observe the examples mentioned above. One can see that elements of the input array are either in increasing order or in decreasing order. Whenever such a kind of pattern is observed, one can use binary search.</p>
<p>Go to the middle element and compute the difference between the middle and next to the middle element. If it is not equal to the common difference of the arithmetic progression, then the missing element lies between mid and mid + 1. If the middle element is equal to the (s / 2)th term of the arithmetic progression series, then the missing element is in the right half of the input array; otherwise in the left half. The following program illustrates the same.</p>
<p><strong>FileName:</strong> MissingElementAP1.java</p>
<div class="codeblock"><textarea name="code" class="java">
public class MissingElementAP1
{
// the following method implements the binary 
// search with the help of recursion to find the 
// missing element in the arithmetic progression
public int findMissingUtility(int arr[], int l, int h, int difference)
{
// There has to be atleast two elements
// for computing the missing element
if (h <= l)
{
return Integer.MAX_VALUE;
}
// Finding the middle element index
int m = l + (h - l) / 2;
// The element just after the middle element is missing.
// The arr[mid+1] must exist, because we return when
// (l == hi) and take the floor of (h - l) / 2
if (arr[m + 1] - arr[m] != difference)
{
return (arr[m] + difference);
}
// The element just before mid is missing
if (m > 0 && arr[m] - arr[m - 1] != difference)
{
return (arr[m - 1] + difference);
}
// If the elements till the mid follow
// AP, then apply recursion on the right half
if (arr[m] == arr[0] + m * difference)
{
return findMissingUtility(arr, m + 1, h, difference);
}
// Else applying recursion on the left half
return findMissingUtility(arr, l, m - 1, difference);
}
// The method uses the method findMissingUtility()
// for finding the element that is missing in AP.
// The method only the considers that the 
// common difference of the arithmetic progression is
// an integer.
public int findMissing(int arr[], int n)
{
// Since only one element is missing
// we can use the last and first element
// for computing the common difference of the
// arithemtic progression
int commonDiff = (arr[n - 1] - arr[0]) / n;
// Applying Binary search for the missing
// number using the above calculated diff
return findMissingUtility(arr, 0, n - 1, commonDiff);
}
// main method
public static void main(String[] argvs) 
{
// creating an object of the class MissingElementAP1
MissingElementAP1 obj = new MissingElementAP1();
// input 1
int apArr[] = {3, 5, 7, 9, 11, 15, 17, 19};
int size = apArr.length;
int ans = obj.findMissing(apArr, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
System.out.print(apArr[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
System.out.println( "\n" );
// input 2
int apArr1[] = {1, 7, 13, 19, 31, 37, 43};
size = apArr1.length;
ans = obj.findMissing(apArr1, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
System.out.print(apArr1[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
System.out.println( "\n" );
// input 3
int apArr2[] = {25, 18, 4, -3, -10, -17, -24};
size = apArr2.length;
ans = obj.findMissing(apArr2, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
System.out.print(apArr2[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
}
}
 Output: For the input array: 
3 5 7 9 11 15 17 19 
The missing element is: 13


For the input array: 
1 7 13 19 31 37 43 
The missing element is: 25


For the input array: 
25 18 4 -3 -10 -17 -24 
The missing element is: 11
 Complexity Analysis: Since the program is using the binary search, the time complexity of the program is O(n), where n is the total number of elements present in the input array. The program is not using any auxiliary space. Therefore, the space complexity of the program is constant, i.e., O(1). Next TopicPeak Index of Mountain Array Problem in Java ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/missing-number-in-an-arithmetic-progression-in-java Missing Number in An Arithmetic Progression in Java - javatpoint ? SCROLL TO TOP Home Coding Problems Java Programs OOPs String Exception Multithreading Collections Coding Problems Candy Distribution Problem in Java Find Rectangle in a Matrix with Corner as 1 in Java Minimum Number of Taps to Open to Water a Garden in Java Seven Segment Display Problem in Java Split Array Largest Sum in Java Find Original Array from a Double Array in Java Minimum Lights to Activate Problem in Java Rotate List in Java Count of Range Sum Problem in Java Create A Tree of Coprime in Java Convert Integer to Roman Numerals in Java Check if n and its Double Exist or not in Java Array of Doubled Pair Problem in Java Tag Content Extractor Problem in Java Convert Roman to Integer in Java Minimum Number of Flips to Convert Binary Matrix into Zero Matrix in Java XOR of Array Elements Except Itself in Java Check If the Given Array is Mirror Inverse in Java How to Create a Mirror Image of A 2D Array in Java Add Numbers Represented by Linked Lists in Java Majority Element In an Array in Java Block Swap Algorithm or Array Rotation in Java Minimum Difference Among Group Size Two in Java Missing Number in An Arithmetic Progression in Java Peak Index of Mountain Array Problem in Java next ? ? prev Missing Number in An Arithmetic Progression in Java It is very interesting problem frequently asked in interviews of top IT companies like Google, Amazon, TCS, Accenture, etc. By solving the problem, one wants to check the logical ability, critical thinking, and problem-solving skill of the interviewee. So, in this section, we are going to find missing number in an arithmetic progression in Java with different approaches and logic. Also, we will create Java programs for the same. Problem Statement An array is given. The array contains some numbers that represent an arithmetic progression. In the arithmetic progression, one number is missing. The task is to find that missing number. Example 1: Input: int arr[] = {3, 5, 7, 9, 11, 15, 17, 19} Output: 13 Explanation: If we put the number 13 after number 11 in the input array, the arithmetic progression is complete. Hence, the answer is 13 Example 2: Input: int arr[] = {1, 7, 13, 19, 31, 37, 43} Output: 25 Explanation: If we put the number 25 after the number 19 in the input array, the arithmetic progression is complete. Hence, the answer is 25. Example 3: Input: int arr[] = {25, 18, 4, -3, -10, -17, -24} Output: 11 Explanation: If we put the number 11 after the number 18 in the input array, the arithmetic progression is complete. Hence, the answer is 11. Solution to the Problem Using Arithmetic Progression Formula The sum of the numbers in an arithmetic progression whose first term is a1 and the last term is an, and the total term is n is: Sn = (n x (a1 + an) ) / 2. Thus, we can compute the sum of the input array. It is because we know the first, last, and size of the input array. If we take the reference of example 1, we get: S9 = (9 x (3 + 19)) / 2 = (9 x 22) / 2 = 198 / 2 = 99 (9 is the size of the input array including the missing element) Now, iterate over the array and find the sum of the elements present. We get Sum of elements: 3 + 5 + 7 + 9 + 11 + 15 + 17 + 19 = 86 Now, subtract S8 with the sum of elements of the input array. We get 99 - 86 = 13, which is the missing element of the arithmetic progression. The following program implements the same concept. FileName: MissingElementAP.java 
public class MissingElementAP 
{
public int findMissingEle(int inputArr[], int size)
{
    // for storing the sum of the elements
    // present in the array
    int sumOfEle = 0;
    // for storing the sum using the AP sum formula
    int APSum = 0;
    // sum of the elements of the array, including the missing element
    // using the sum of the elements of an Arithmetic Progression Formula
    // size + 1 because we have to include the missing element in the input array
    APSum = ((size + 1) * (inputArr[0] + inputArr[size - 1])) / 2;
    // loop for computing the sum of elements
    // present in the input array
    for(int i = 0; i < size; i++)
    {
        sumOfEle = sumOfEle + inputArr[i];
    }
    // finding the missing element
    int missingEle = APSum - sumOfEle;
    // returning the missing element
    return missingEle;
}
// main method
public static void main(String[] argvs) 
{
// creating an object of the class MissingElementAP
MissingElementAP obj = new MissingElementAP();
// input 1
int apArr[] = {3, 5, 7, 9, 11, 15, 17, 19};
int size = apArr.length;
int ans = obj.findMissingEle(apArr, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
    System.out.print(apArr[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
System.out.println( "\n" );
// input 2
int apArr1[] = {1, 7, 13, 19, 31, 37, 43};
size = apArr1.length;
ans = obj.findMissingEle(apArr1, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
    System.out.print(apArr1[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
System.out.println( "\n" );
// input 3
int apArr2[] = {25, 18, 4, -3, -10, -17, -24};
size = apArr2.length;
ans = obj.findMissingEle(apArr2, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
    System.out.print(apArr2[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
}
}
<p><strong>Output:</strong></p>
<div class="codeblock3"><pre>
For the input array: 
3 5 7 9 11 15 17 19 
The missing element is: 13


For the input array: 
1 7 13 19 31 37 43 
The missing element is: 25


For the input array: 
25 18 4 -3 -10 -17 -24 
The missing element is: 11
</pre></div>
<p><strong>Complexity Analysis:</strong> Since the program is using a for-loop for computing the sum of elements, the time complexity of the program is O(n), where n is the total number of elements present in the array. The space complexity of the program is constant, i.e., O(1).</p>
<h3 class="h3">Using Binary Search</h3>
<p>Observe the examples mentioned above. One can see that elements of the input array are either in increasing order or in decreasing order. Whenever such a kind of pattern is observed, one can use binary search.</p>
<p>Go to the middle element and compute the difference between the middle and next to the middle element. If it is not equal to the common difference of the arithmetic progression, then the missing element lies between mid and mid + 1. If the middle element is equal to the (s / 2)th term of the arithmetic progression series, then the missing element is in the right half of the input array; otherwise in the left half. The following program illustrates the same.</p>
<p><strong>FileName:</strong> MissingElementAP1.java</p>
<div class="codeblock"><textarea name="code" class="java">
public class MissingElementAP1
{
// the following method implements the binary 
// search with the help of recursion to find the 
// missing element in the arithmetic progression
public int findMissingUtility(int arr[], int l, int h, int difference)
{
// There has to be atleast two elements
// for computing the missing element
if (h <= l)
{
return Integer.MAX_VALUE;
}
// Finding the middle element index
int m = l + (h - l) / 2;
// The element just after the middle element is missing.
// The arr[mid+1] must exist, because we return when
// (l == hi) and take the floor of (h - l) / 2
if (arr[m + 1] - arr[m] != difference)
{
return (arr[m] + difference);
}
// The element just before mid is missing
if (m > 0 && arr[m] - arr[m - 1] != difference)
{
return (arr[m - 1] + difference);
}
// If the elements till the mid follow
// AP, then apply recursion on the right half
if (arr[m] == arr[0] + m * difference)
{
return findMissingUtility(arr, m + 1, h, difference);
}
// Else applying recursion on the left half
return findMissingUtility(arr, l, m - 1, difference);
}
// The method uses the method findMissingUtility()
// for finding the element that is missing in AP.
// The method only the considers that the 
// common difference of the arithmetic progression is
// an integer.
public int findMissing(int arr[], int n)
{
// Since only one element is missing
// we can use the last and first element
// for computing the common difference of the
// arithemtic progression
int commonDiff = (arr[n - 1] - arr[0]) / n;
// Applying Binary search for the missing
// number using the above calculated diff
return findMissingUtility(arr, 0, n - 1, commonDiff);
}
// main method
public static void main(String[] argvs) 
{
// creating an object of the class MissingElementAP1
MissingElementAP1 obj = new MissingElementAP1();
// input 1
int apArr[] = {3, 5, 7, 9, 11, 15, 17, 19};
int size = apArr.length;
int ans = obj.findMissing(apArr, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
System.out.print(apArr[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
System.out.println( "\n" );
// input 2
int apArr1[] = {1, 7, 13, 19, 31, 37, 43};
size = apArr1.length;
ans = obj.findMissing(apArr1, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
System.out.print(apArr1[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
System.out.println( "\n" );
// input 3
int apArr2[] = {25, 18, 4, -3, -10, -17, -24};
size = apArr2.length;
ans = obj.findMissing(apArr2, size);
System.out.println("For the input array: ");
for(int k = 0; k < size; k++)
{
System.out.print(apArr2[k] + " ");
}
System.out.println( );
System.out.println("The missing element is: " + ans);
}
}
 Output: For the input array: 
3 5 7 9 11 15 17 19 
The missing element is: 13


For the input array: 
1 7 13 19 31 37 43 
The missing element is: 25


For the input array: 
25 18 4 -3 -10 -17 -24 
The missing element is: 11
 Complexity Analysis: Since the program is using the binary search, the time complexity of the program is O(n), where n is the total number of elements present in the input array. The program is not using any auxiliary space. Therefore, the space complexity of the program is constant, i.e., O(1). Next TopicPeak Index of Mountain Array Problem in Java ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.