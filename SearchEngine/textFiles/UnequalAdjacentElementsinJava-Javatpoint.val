https://www.javatpoint.com/unequal-adjacent-elements-in-java Unequal Adjacent Elements in Java - Javatpoint ? SCROLL TO TOP Home Java Programs OOPs String Exception Multithreading Collections JavaFX JSP Spring Spring Boot Projects Interview Questions Java Tutorial What is Java History of Java Features of Java C++ vs Java Hello Java Program Program Internal How to set path? JDK, JRE and JVM JVM: Java Virtual Machine Java Variables Java Data Types Unicode System Operators Keywords Control Statements Java Control Statements Java If-else Java Switch Java For Loop Java While Loop Java Do While Loop Java Break Java Continue Java Comments Java Programs Java Object Class Java OOPs Concepts Naming Convention Object and Class Method Constructor static keyword this keyword Java Inheritance Inheritance(IS-A) Aggregation(HAS-A) Java Polymorphism Method Overloading Method Overriding Covariant Return Type super keyword Instance Initializer block final keyword Runtime Polymorphism Dynamic Binding instanceof operator Java Abstraction Abstract class Interface Abstract vs Interface Java Encapsulation Package Access Modifiers Encapsulation Java Array Java Array Java OOPs Misc Object class Object Cloning Math class Wrapper Class Java Recursion Call By Value strictfp keyword javadoc tool Command Line Arg Object vs Class Overloading vs Overriding Java String Java Regex Exception Handling Java Inner classes Java Multithreading Java I/O Java Networking Java AWT & Events Java Swing JavaFX Java Applet Java Reflection Java Date Java Conversion Java Collection Java JDBC Java Misc Java New Features RMI Internationalization Interview Questions Java MCQ next ? ? prev Unequal Adjacent Elements in Java An array inArr containing n numbers (positive or negative) is given. The task is to return the array after the rearrangement of elements of the integers in such a way that no two adjacent elements are equal. If there are multiple valid arrangements, then any one valid arrangement can be returned. If the input array does not contain any valid arrangement, then an appropriate message can be displayed on the console. Example 1: Input int inArr[] = {7, 7, 6, 8} Output: {7, 6, 7, 8} Explanation: There are many valid arrangements possible. Those valid arrangements are mentioned below. {7, 6, 7, 8}, {7, 6, 8, 7}, {7, 8, 7, 6}, {7, 8, 6, 7}, {8, 7, 6, 7}, {6, 7, 8, 7}. Out of which {7, 6, 7, 8} is mentioned in the output. Example 2: Input int inArr[] = {2, 4, 8, 9, 5, 7, 3, 6, 1} Output: {2, 4, 8, 9, 5, 7, 3, 6, 1} Explanation: The input array is given in such a way that there are no two elements that are of the same value. Hence, the input arrays are themselves the answer. Example 3: Input int arr[] = {3, 3, 3, 3, 3} Output: no valid arrangement is possible where adjacent elements are of different values. Explanation: All the elements are of the same value. Hence, no valid arrangement is possible. Approach: Brute Force In this approach, we compute all the arrangements of the input array. If any valid arrangement comes, we return that arrangement. If no valid arrangement is possible, display the appropriate message. For computing the valid arrangement, first, we will sort the array in ascending order. Then we will find the next permutation of the sorted array and check whether it is a valid arrangement or not. If it is a valid arrangement, then we can return that arrangement. If not, then we will find the next permutation and continue to do so until we find a valid arrangement or all the arrangements are exhausted. If the arrangements are exhausted, then we can say that no valid arrangement is there for the given input array, and the same is illustrated in the following program. FileName: UniqueAdjEle.java 
// important import statements
import java.util.Collections;
import java.util.ArrayList;
import java.util.Arrays;


public class UniqueAdjEle 
{
    // swapping the elements in the array list al
    // that are present at the index j and k
    private void swapEle(ArrayList<Integer> al, int j, int k) 
    {
        int temp = al.get(j);
        al.set(j, al.get(k));
        al.set(k, temp);
    }
    // reversing the array list from j to k
    private void reverseArrList(ArrayList<Integer> al, int j, int k) 
    {
        while (j < k) 
        {
            swapEle(al, j, k);
            j = j + 1;
            k = k - 1;
        }
    }

    private boolean nextPermutation(ArrayList<Integer> al) 
    {
        // if the list has no elements
        // or the single element, then
        // there is no need to proceed further
        if (al == null || al.size() <= 1) 
        {
            return false;
        }

        int j = al.size() - 2;

        while (j >= 0 && al.get(j).intValue() >= al.get(j + 1).intValue()) 
        {

            // Finding the first j that is breaking descending order
            j = j - 1;
        }

        if (j >= 0) 
        {
            // if the control reaching
            // here, then it means the array
            // is not entirely descending

            // Starting from the end
            int k = al.size() - 1;

            while (al.get(k).intValue() <= al.get(j).intValue()) 
            {
                // Finding the rightmost first larger id than k
                k = k - 1;
            }

            // Switching j and k
            swapEle(al, j, k);

            // Reversing in the descending sequence
            reverseArrList(al, j + 1, al.size() - 1);

            return true;
        } else 
        {
            // Reversing the whole sequence.
            reverseArrList(al, 0, al.size() - 1);
            return false;
        }
    }
    // a Boolean method that checks whether the elements of the array list al 
    // have the valid arrangement or not.
    public boolean isValidArrangement(ArrayList<Integer> al, int s)
    {
        int chk = 1;

            for (int j = 1; j < s; j++) 
            {
                if (al.get(j) == al.get(j - 1)) 
                {
                    chk = 0;
                    break;
                }
            }

            return chk == 1;
    }

    public ArrayList<Integer> rearrangeArr(ArrayList<Integer> al, int s) 
    {   
        if(isValidArrangement(al, s))
        {
            return al;
        }
        // sorting the list so we can compute the next permutation
        Collections.sort(al);
       
        // Iterating the array list and 
        // checking whether it is a valid arrangement or not
        // if yes, then we terminate the do-while loop.
        // Otherwise, we find the next permutation.
         while (nextPermutation(al))
         {
             if(isValidArrangement(al, s))
             {
                 return al;
             }
         }

        return new ArrayList<Integer>();
    }
    
    // main method
    public static void main(String argvs[])
    {
        // creating an object of the class UniqueAdjEle 
        UniqueAdjEle obj = new UniqueAdjEle();
        
        // input 1
        ArrayList<Integer> inArr = new ArrayList<Integer>
        (
            Arrays.asList(7, 7, 6, 8)
        );
        
        // computing the size of the 
        // input array
        int size = inArr.size();
        System.out.println("For the input array: ");
        for(int i = 0; i < size; i++)
        {
            System.out.print(inArr.get(i) + " ");
        }
        System.out.println();
        ArrayList<Integer> ans = obj.rearrangeArr(inArr, size);
        if(ans.size() > 0)
        {
        System.out.println("The valid arrangement is: ");
        
        for(int i = 0; i < size; i++)
        {
            System.out.print(ans.get(i) + " ");
        }
        }
        else
        {
            System.out.println("The valid arrangement is not possible. ");
        }
        
        System.out.println( "\n" );
        
        // input 2
        inArr = new ArrayList<Integer>
        (
            Arrays.asList(2, 4, 8, 9, 5, 7, 3, 6, 1)
        );
        
        // computing the size of the 
        // input array
        size = inArr.size();
        
        System.out.println("For the input array: ");
        
        for(int i = 0; i < size; i++)
        {
            System.out.print(inArr.get(i) + " ");
        }
        
        System.out.println();
        
        ans = obj.rearrangeArr(inArr, size);
        
        if(ans.size() > 0)
        {
        System.out.println("The valid arrangement is: ");
        
        for(int i = 0; i < size; i++)
        {
            System.out.print(ans.get(i) + " ");
        }
        }
        else
        {
            System.out.println("The valid arrangement is not possible. ");
        }
        
        System.out.println( "\n" );
        
        // input 3
        inArr = new ArrayList<Integer>
        (
            Arrays.asList(3, 3, 3, 3, 3)
        );
        
        // computing the size of the 
        // input array
        size = inArr.size();
        
        System.out.println("For the input array: ");
        
        for(int i = 0; i < size; i++)
        {
            System.out.print(inArr.get(i) + " ");
        }
        
        System.out.println();
        
        ans = obj.rearrangeArr(inArr, size);
        if(ans.size() > 0)
        {
        System.out.println("The valid arrangement is: ");
        
        for(int i = 0; i < size; i++)
        {
            System.out.print(ans.get(i) + " ");
        }
        }
        else
        {
            System.out.println("The valid arrangement is not possible. ");
        }
        
    }
    
    
    
}
 Output: For the input array: 
7 7 6 8 
The valid arrangement is: 
6 7 8 7 

For the input array: 
2 4 8 9 5 7 3 6 1 
The valid arrangement is: 
2 4 8 9 5 7 3 6 1 

For the input array: 
3 3 3 3 3 
The valid arrangement is not possible.
 Complexity Analysis: Since the program is computing the permutation, the time complexity of the program is O(N!), where N is the total number of elements present in the linked list. The program uses constant space; therefore, the space complexity of the program is O(1). The above program is not suitable for the larger inputs as the time complexity of the program is too high. Therefore, we must do some optimization to reduce the time complexity. Approach: Using Set It is a greedy approach where we put first that element which is occurring the most number of times in the input array. Using the set, we will put all the elements in the order of their occurrence count. The following are the steps involved in computing the answer. Step 1: Declare an empty array or list solAl. Step 2: Sort the array or list solAl. Step 3: Declare a set st that keeps the elements and their occurrence count. Step 4: Iterate over the list or array solAl: Iterate until the same element is encountered every time. Increment the element count by 1. Put the element and the occurrence count of the element in the set st. Step 5: Create a temporary variable for keeping the previous element and its occurrence count. Step 6: While the set st is not empty, do the following: Fetch the last element and get it added to the result. Delete that element from the set st. Reduce the occurrence count of the element popped by 1. If the occurrence count was non-zero of the previous elements, put it in the set. The current element should be treated as the previous element for the upcoming iteration. Step 7: Eventually, return the list or array solAl. Implementation The implementation of the above steps is mentioned below. FileName: UniqueAdjEle.java 
// important import statements
import java.util.Arrays;
import java.util.ArrayList;
import java.util.TreeSet;
import java.util.Collections;
import java.util.Comparator;

class PairComparator implements Comparator<Pair>
{

// Overriding the compare() method of the Comparator
public int compare(Pair p1, Pair p2)
{
if (p1.first < p2.first)
{
return -1;
}
else if(p1.first == p2.first)
{
return p1.second - p2.second;
}
else if (p1.first > p2.first)
{
return 1;
}

return 0;
}
}

// class Pair contains 
// two elements one is first
// other is second
class Pair 
{
int first; 
int second;
Pair(int first, int second)
{
this.first = first;
this.second = second;
}
}
public class UniqueAdjEle1 
{
// a boolean method that checks whether the elements of the array list al 
// have the valid arrangement or not.
public boolean isValidArrangement(ArrayList<Integer> al, int s)
{
int chk = 1;

for (int j = 1; j < s; j++) 
{
if (al.get(j) == al.get(j - 1)) 
{
chk = 0;
break;
}
}

return chk == 1;
}

public ArrayList<Integer> rearrangeArr(ArrayList<Integer> al, int s) 
{
if(isValidArrangement(al, s))
{
// the arrangement is valid
// hence, there is no need to proceed further
return al;
}

// Sorting the list or array al
Collections.sort(al);

// Declaring a set st that keeps the elements and their
// occurrence count.
TreeSet<Pair> st = new TreeSet<>(new PairComparator());


// Iterating over the list or array al
// Iterating until the element is the same
// Incrementing the element count by 1. 
// Inserting the element and its occurrence count in the set st
for (int j = 0; j < s; j++)
{

int k = j;
while (j < s && k < s && (al.get(j).equals(al.get(k))))
{
k = k + 1;
}
st.add(new Pair(k - j, al.get(j)));

j = k - 1;
}

int prv = -1;
int prvFreq = 0;

// Declaring an empty array or list solAl
ArrayList<Integer> solAl = new ArrayList<>();

while (st.size() != 0)
{
Pair pr = st.last();
st.remove(pr);
solAl.add(pr.second);

if (prvFreq > 0)
{
st.add(new Pair(prvFreq, prv));
}

prvFreq = pr.first - 1;
prv = pr.second;
}

// calculating the new size of the 
// rearranged array list
int newSize = solAl.size();

// if the new size after the rearrangement
// if the array list is not equal to the size s
// then, the valid rearrangement is not possible
if(newSize != s)
{
return new ArrayList<Integer>();
}

return solAl;
}


// main method
public static void main(String argvs[])
{
// creating an object of the class UniqueAdjEle1 
UniqueAdjEle1 obj = new UniqueAdjEle1();

// input 1
ArrayList<Integer> inArr = new ArrayList<Integer>
(
Arrays.asList(7, 7, 6, 8)
);

// computing the size of the 
// input array
int size = inArr.size();
System.out.println("For the input array: ");
for(int i = 0; i < size; i++)
{
System.out.print(inArr.get(i) + " ");
}
System.out.println();
ArrayList<Integer> ans = obj.rearrangeArr(inArr, size);
if(ans.size() > 0)
{
System.out.println("The valid arrangement is: ");

for(int i = 0; i < size; i++)
{
System.out.print(ans.get(i) + " ");
}
}
else
{
System.out.println("The valid arrangement is not possible. ");
}

System.out.println( "\n" );

// input 2
inArr = new ArrayList<Integer>
(
Arrays.asList(2, 4, 8, 9, 5, 7, 3, 6, 1)
);

// computing the size of the 
// input array
size = inArr.size();

System.out.println("For the input array: ");

for(int i = 0; i < size; i++)
{
System.out.print(inArr.get(i) + " ");
}

System.out.println();

ans = obj.rearrangeArr(inArr, size);

if(ans.size() > 0)
{
System.out.println("The valid arrangement is: ");

for(int i = 0; i < size; i++)
{
System.out.print(ans.get(i) + " ");
}
}
else
{
System.out.println("The valid arrangement is not possible. ");
}

System.out.println( "\n" );

// input 3
inArr = new ArrayList<Integer>
(
Arrays.asList(3, 3, 3, 3, 3)
);

// computing the size of the 
// input array
size = inArr.size();

System.out.println("For the input array: ");

for(int i = 0; i < size; i++)
{
System.out.print(inArr.get(i) + " ");
}

System.out.println();

ans = obj.rearrangeArr(inArr, size);
if(ans.size() > 0)
{
System.out.println("The valid arrangement is: ");

for(int i = 0; i < size; i++)
{
System.out.print(ans.get(i) + " ");
}
}
else
{
System.out.println("The valid arrangement is not possible. ");
}

}

}
 Output: For the input array: 
7 7 6 8 
The valid arrangement is: 
7 8 7 6 

For the input array: 
2 4 8 9 5 7 3 6 1 
The valid arrangement is: 
2 4 8 9 5 7 3 6 1 

For the input array: 
3 3 3 3 3 
The valid arrangement is not possible.
 Complexity Analysis: Since the program is using sorting, the time complexity of the program is O(N * log(N)). The program uses a set to store the elements and their occurrence count. The program is also using an auxiliary array (arr). Thus, making the space complexity of the program as (N), where N is the total number of elements present in the input array. Note: Instead of Set, a priority queue can also be used. In that case, also, the time and space complexity remain the same. Next Topic# ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/unequal-adjacent-elements-in-java Unequal Adjacent Elements in Java - Javatpoint ? SCROLL TO TOP Home Java Programs OOPs String Exception Multithreading Collections JavaFX JSP Spring Spring Boot Projects Interview Questions Java Tutorial What is Java History of Java Features of Java C++ vs Java Hello Java Program Program Internal How to set path? JDK, JRE and JVM JVM: Java Virtual Machine Java Variables Java Data Types Unicode System Operators Keywords Control Statements Java Control Statements Java If-else Java Switch Java For Loop Java While Loop Java Do While Loop Java Break Java Continue Java Comments Java Programs Java Object Class Java OOPs Concepts Naming Convention Object and Class Method Constructor static keyword this keyword Java Inheritance Inheritance(IS-A) Aggregation(HAS-A) Java Polymorphism Method Overloading Method Overriding Covariant Return Type super keyword Instance Initializer block final keyword Runtime Polymorphism Dynamic Binding instanceof operator Java Abstraction Abstract class Interface Abstract vs Interface Java Encapsulation Package Access Modifiers Encapsulation Java Array Java Array Java OOPs Misc Object class Object Cloning Math class Wrapper Class Java Recursion Call By Value strictfp keyword javadoc tool Command Line Arg Object vs Class Overloading vs Overriding Java String Java Regex Exception Handling Java Inner classes Java Multithreading Java I/O Java Networking Java AWT & Events Java Swing JavaFX Java Applet Java Reflection Java Date Java Conversion Java Collection Java JDBC Java Misc Java New Features RMI Internationalization Interview Questions Java MCQ next ? ? prev Unequal Adjacent Elements in Java An array inArr containing n numbers (positive or negative) is given. The task is to return the array after the rearrangement of elements of the integers in such a way that no two adjacent elements are equal. If there are multiple valid arrangements, then any one valid arrangement can be returned. If the input array does not contain any valid arrangement, then an appropriate message can be displayed on the console. Example 1: Input int inArr[] = {7, 7, 6, 8} Output: {7, 6, 7, 8} Explanation: There are many valid arrangements possible. Those valid arrangements are mentioned below. {7, 6, 7, 8}, {7, 6, 8, 7}, {7, 8, 7, 6}, {7, 8, 6, 7}, {8, 7, 6, 7}, {6, 7, 8, 7}. Out of which {7, 6, 7, 8} is mentioned in the output. Example 2: Input int inArr[] = {2, 4, 8, 9, 5, 7, 3, 6, 1} Output: {2, 4, 8, 9, 5, 7, 3, 6, 1} Explanation: The input array is given in such a way that there are no two elements that are of the same value. Hence, the input arrays are themselves the answer. Example 3: Input int arr[] = {3, 3, 3, 3, 3} Output: no valid arrangement is possible where adjacent elements are of different values. Explanation: All the elements are of the same value. Hence, no valid arrangement is possible. Approach: Brute Force In this approach, we compute all the arrangements of the input array. If any valid arrangement comes, we return that arrangement. If no valid arrangement is possible, display the appropriate message. For computing the valid arrangement, first, we will sort the array in ascending order. Then we will find the next permutation of the sorted array and check whether it is a valid arrangement or not. If it is a valid arrangement, then we can return that arrangement. If not, then we will find the next permutation and continue to do so until we find a valid arrangement or all the arrangements are exhausted. If the arrangements are exhausted, then we can say that no valid arrangement is there for the given input array, and the same is illustrated in the following program. FileName: UniqueAdjEle.java 
// important import statements
import java.util.Collections;
import java.util.ArrayList;
import java.util.Arrays;


public class UniqueAdjEle 
{
    // swapping the elements in the array list al
    // that are present at the index j and k
    private void swapEle(ArrayList<Integer> al, int j, int k) 
    {
        int temp = al.get(j);
        al.set(j, al.get(k));
        al.set(k, temp);
    }
    // reversing the array list from j to k
    private void reverseArrList(ArrayList<Integer> al, int j, int k) 
    {
        while (j < k) 
        {
            swapEle(al, j, k);
            j = j + 1;
            k = k - 1;
        }
    }

    private boolean nextPermutation(ArrayList<Integer> al) 
    {
        // if the list has no elements
        // or the single element, then
        // there is no need to proceed further
        if (al == null || al.size() <= 1) 
        {
            return false;
        }

        int j = al.size() - 2;

        while (j >= 0 && al.get(j).intValue() >= al.get(j + 1).intValue()) 
        {

            // Finding the first j that is breaking descending order
            j = j - 1;
        }

        if (j >= 0) 
        {
            // if the control reaching
            // here, then it means the array
            // is not entirely descending

            // Starting from the end
            int k = al.size() - 1;

            while (al.get(k).intValue() <= al.get(j).intValue()) 
            {
                // Finding the rightmost first larger id than k
                k = k - 1;
            }

            // Switching j and k
            swapEle(al, j, k);

            // Reversing in the descending sequence
            reverseArrList(al, j + 1, al.size() - 1);

            return true;
        } else 
        {
            // Reversing the whole sequence.
            reverseArrList(al, 0, al.size() - 1);
            return false;
        }
    }
    // a Boolean method that checks whether the elements of the array list al 
    // have the valid arrangement or not.
    public boolean isValidArrangement(ArrayList<Integer> al, int s)
    {
        int chk = 1;

            for (int j = 1; j < s; j++) 
            {
                if (al.get(j) == al.get(j - 1)) 
                {
                    chk = 0;
                    break;
                }
            }

            return chk == 1;
    }

    public ArrayList<Integer> rearrangeArr(ArrayList<Integer> al, int s) 
    {   
        if(isValidArrangement(al, s))
        {
            return al;
        }
        // sorting the list so we can compute the next permutation
        Collections.sort(al);
       
        // Iterating the array list and 
        // checking whether it is a valid arrangement or not
        // if yes, then we terminate the do-while loop.
        // Otherwise, we find the next permutation.
         while (nextPermutation(al))
         {
             if(isValidArrangement(al, s))
             {
                 return al;
             }
         }

        return new ArrayList<Integer>();
    }
    
    // main method
    public static void main(String argvs[])
    {
        // creating an object of the class UniqueAdjEle 
        UniqueAdjEle obj = new UniqueAdjEle();
        
        // input 1
        ArrayList<Integer> inArr = new ArrayList<Integer>
        (
            Arrays.asList(7, 7, 6, 8)
        );
        
        // computing the size of the 
        // input array
        int size = inArr.size();
        System.out.println("For the input array: ");
        for(int i = 0; i < size; i++)
        {
            System.out.print(inArr.get(i) + " ");
        }
        System.out.println();
        ArrayList<Integer> ans = obj.rearrangeArr(inArr, size);
        if(ans.size() > 0)
        {
        System.out.println("The valid arrangement is: ");
        
        for(int i = 0; i < size; i++)
        {
            System.out.print(ans.get(i) + " ");
        }
        }
        else
        {
            System.out.println("The valid arrangement is not possible. ");
        }
        
        System.out.println( "\n" );
        
        // input 2
        inArr = new ArrayList<Integer>
        (
            Arrays.asList(2, 4, 8, 9, 5, 7, 3, 6, 1)
        );
        
        // computing the size of the 
        // input array
        size = inArr.size();
        
        System.out.println("For the input array: ");
        
        for(int i = 0; i < size; i++)
        {
            System.out.print(inArr.get(i) + " ");
        }
        
        System.out.println();
        
        ans = obj.rearrangeArr(inArr, size);
        
        if(ans.size() > 0)
        {
        System.out.println("The valid arrangement is: ");
        
        for(int i = 0; i < size; i++)
        {
            System.out.print(ans.get(i) + " ");
        }
        }
        else
        {
            System.out.println("The valid arrangement is not possible. ");
        }
        
        System.out.println( "\n" );
        
        // input 3
        inArr = new ArrayList<Integer>
        (
            Arrays.asList(3, 3, 3, 3, 3)
        );
        
        // computing the size of the 
        // input array
        size = inArr.size();
        
        System.out.println("For the input array: ");
        
        for(int i = 0; i < size; i++)
        {
            System.out.print(inArr.get(i) + " ");
        }
        
        System.out.println();
        
        ans = obj.rearrangeArr(inArr, size);
        if(ans.size() > 0)
        {
        System.out.println("The valid arrangement is: ");
        
        for(int i = 0; i < size; i++)
        {
            System.out.print(ans.get(i) + " ");
        }
        }
        else
        {
            System.out.println("The valid arrangement is not possible. ");
        }
        
    }
    
    
    
}
 Output: For the input array: 
7 7 6 8 
The valid arrangement is: 
6 7 8 7 

For the input array: 
2 4 8 9 5 7 3 6 1 
The valid arrangement is: 
2 4 8 9 5 7 3 6 1 

For the input array: 
3 3 3 3 3 
The valid arrangement is not possible.
 Complexity Analysis: Since the program is computing the permutation, the time complexity of the program is O(N!), where N is the total number of elements present in the linked list. The program uses constant space; therefore, the space complexity of the program is O(1). The above program is not suitable for the larger inputs as the time complexity of the program is too high. Therefore, we must do some optimization to reduce the time complexity. Approach: Using Set It is a greedy approach where we put first that element which is occurring the most number of times in the input array. Using the set, we will put all the elements in the order of their occurrence count. The following are the steps involved in computing the answer. Step 1: Declare an empty array or list solAl. Step 2: Sort the array or list solAl. Step 3: Declare a set st that keeps the elements and their occurrence count. Step 4: Iterate over the list or array solAl: Iterate until the same element is encountered every time. Increment the element count by 1. Put the element and the occurrence count of the element in the set st. Step 5: Create a temporary variable for keeping the previous element and its occurrence count. Step 6: While the set st is not empty, do the following: Fetch the last element and get it added to the result. Delete that element from the set st. Reduce the occurrence count of the element popped by 1. If the occurrence count was non-zero of the previous elements, put it in the set. The current element should be treated as the previous element for the upcoming iteration. Step 7: Eventually, return the list or array solAl. Implementation The implementation of the above steps is mentioned below. FileName: UniqueAdjEle.java 
// important import statements
import java.util.Arrays;
import java.util.ArrayList;
import java.util.TreeSet;
import java.util.Collections;
import java.util.Comparator;

class PairComparator implements Comparator<Pair>
{

// Overriding the compare() method of the Comparator
public int compare(Pair p1, Pair p2)
{
if (p1.first < p2.first)
{
return -1;
}
else if(p1.first == p2.first)
{
return p1.second - p2.second;
}
else if (p1.first > p2.first)
{
return 1;
}

return 0;
}
}

// class Pair contains 
// two elements one is first
// other is second
class Pair 
{
int first; 
int second;
Pair(int first, int second)
{
this.first = first;
this.second = second;
}
}
public class UniqueAdjEle1 
{
// a boolean method that checks whether the elements of the array list al 
// have the valid arrangement or not.
public boolean isValidArrangement(ArrayList<Integer> al, int s)
{
int chk = 1;

for (int j = 1; j < s; j++) 
{
if (al.get(j) == al.get(j - 1)) 
{
chk = 0;
break;
}
}

return chk == 1;
}

public ArrayList<Integer> rearrangeArr(ArrayList<Integer> al, int s) 
{
if(isValidArrangement(al, s))
{
// the arrangement is valid
// hence, there is no need to proceed further
return al;
}

// Sorting the list or array al
Collections.sort(al);

// Declaring a set st that keeps the elements and their
// occurrence count.
TreeSet<Pair> st = new TreeSet<>(new PairComparator());


// Iterating over the list or array al
// Iterating until the element is the same
// Incrementing the element count by 1. 
// Inserting the element and its occurrence count in the set st
for (int j = 0; j < s; j++)
{

int k = j;
while (j < s && k < s && (al.get(j).equals(al.get(k))))
{
k = k + 1;
}
st.add(new Pair(k - j, al.get(j)));

j = k - 1;
}

int prv = -1;
int prvFreq = 0;

// Declaring an empty array or list solAl
ArrayList<Integer> solAl = new ArrayList<>();

while (st.size() != 0)
{
Pair pr = st.last();
st.remove(pr);
solAl.add(pr.second);

if (prvFreq > 0)
{
st.add(new Pair(prvFreq, prv));
}

prvFreq = pr.first - 1;
prv = pr.second;
}

// calculating the new size of the 
// rearranged array list
int newSize = solAl.size();

// if the new size after the rearrangement
// if the array list is not equal to the size s
// then, the valid rearrangement is not possible
if(newSize != s)
{
return new ArrayList<Integer>();
}

return solAl;
}


// main method
public static void main(String argvs[])
{
// creating an object of the class UniqueAdjEle1 
UniqueAdjEle1 obj = new UniqueAdjEle1();

// input 1
ArrayList<Integer> inArr = new ArrayList<Integer>
(
Arrays.asList(7, 7, 6, 8)
);

// computing the size of the 
// input array
int size = inArr.size();
System.out.println("For the input array: ");
for(int i = 0; i < size; i++)
{
System.out.print(inArr.get(i) + " ");
}
System.out.println();
ArrayList<Integer> ans = obj.rearrangeArr(inArr, size);
if(ans.size() > 0)
{
System.out.println("The valid arrangement is: ");

for(int i = 0; i < size; i++)
{
System.out.print(ans.get(i) + " ");
}
}
else
{
System.out.println("The valid arrangement is not possible. ");
}

System.out.println( "\n" );

// input 2
inArr = new ArrayList<Integer>
(
Arrays.asList(2, 4, 8, 9, 5, 7, 3, 6, 1)
);

// computing the size of the 
// input array
size = inArr.size();

System.out.println("For the input array: ");

for(int i = 0; i < size; i++)
{
System.out.print(inArr.get(i) + " ");
}

System.out.println();

ans = obj.rearrangeArr(inArr, size);

if(ans.size() > 0)
{
System.out.println("The valid arrangement is: ");

for(int i = 0; i < size; i++)
{
System.out.print(ans.get(i) + " ");
}
}
else
{
System.out.println("The valid arrangement is not possible. ");
}

System.out.println( "\n" );

// input 3
inArr = new ArrayList<Integer>
(
Arrays.asList(3, 3, 3, 3, 3)
);

// computing the size of the 
// input array
size = inArr.size();

System.out.println("For the input array: ");

for(int i = 0; i < size; i++)
{
System.out.print(inArr.get(i) + " ");
}

System.out.println();

ans = obj.rearrangeArr(inArr, size);
if(ans.size() > 0)
{
System.out.println("The valid arrangement is: ");

for(int i = 0; i < size; i++)
{
System.out.print(ans.get(i) + " ");
}
}
else
{
System.out.println("The valid arrangement is not possible. ");
}

}

}
 Output: For the input array: 
7 7 6 8 
The valid arrangement is: 
7 8 7 6 

For the input array: 
2 4 8 9 5 7 3 6 1 
The valid arrangement is: 
2 4 8 9 5 7 3 6 1 

For the input array: 
3 3 3 3 3 
The valid arrangement is not possible.
 Complexity Analysis: Since the program is using sorting, the time complexity of the program is O(N * log(N)). The program uses a set to store the elements and their occurrence count. The program is also using an auxiliary array (arr). Thus, making the space complexity of the program as (N), where N is the total number of elements present in the input array. Note: Instead of Set, a priority queue can also be used. In that case, also, the time and space complexity remain the same. Next Topic# ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/unequal-adjacent-elements-in-java Unequal Adjacent Elements in Java - Javatpoint ? SCROLL TO TOP Home Java Programs OOPs String Exception Multithreading Collections JavaFX JSP Spring Spring Boot Projects Interview Questions Java Tutorial What is Java History of Java Features of Java C++ vs Java Hello Java Program Program Internal How to set path? JDK, JRE and JVM JVM: Java Virtual Machine Java Variables Java Data Types Unicode System Operators Keywords Control Statements Java Control Statements Java If-else Java Switch Java For Loop Java While Loop Java Do While Loop Java Break Java Continue Java Comments Java Programs Java Object Class Java OOPs Concepts Naming Convention Object and Class Method Constructor static keyword this keyword Java Inheritance Inheritance(IS-A) Aggregation(HAS-A) Java Polymorphism Method Overloading Method Overriding Covariant Return Type super keyword Instance Initializer block final keyword Runtime Polymorphism Dynamic Binding instanceof operator Java Abstraction Abstract class Interface Abstract vs Interface Java Encapsulation Package Access Modifiers Encapsulation Java Array Java Array Java OOPs Misc Object class Object Cloning Math class Wrapper Class Java Recursion Call By Value strictfp keyword javadoc tool Command Line Arg Object vs Class Overloading vs Overriding Java String Java Regex Exception Handling Java Inner classes Java Multithreading Java I/O Java Networking Java AWT & Events Java Swing JavaFX Java Applet Java Reflection Java Date Java Conversion Java Collection Java JDBC Java Misc Java New Features RMI Internationalization Interview Questions Java MCQ next ? ? prev Unequal Adjacent Elements in Java An array inArr containing n numbers (positive or negative) is given. The task is to return the array after the rearrangement of elements of the integers in such a way that no two adjacent elements are equal. If there are multiple valid arrangements, then any one valid arrangement can be returned. If the input array does not contain any valid arrangement, then an appropriate message can be displayed on the console. Example 1: Input int inArr[] = {7, 7, 6, 8} Output: {7, 6, 7, 8} Explanation: There are many valid arrangements possible. Those valid arrangements are mentioned below. {7, 6, 7, 8}, {7, 6, 8, 7}, {7, 8, 7, 6}, {7, 8, 6, 7}, {8, 7, 6, 7}, {6, 7, 8, 7}. Out of which {7, 6, 7, 8} is mentioned in the output. Example 2: Input int inArr[] = {2, 4, 8, 9, 5, 7, 3, 6, 1} Output: {2, 4, 8, 9, 5, 7, 3, 6, 1} Explanation: The input array is given in such a way that there are no two elements that are of the same value. Hence, the input arrays are themselves the answer. Example 3: Input int arr[] = {3, 3, 3, 3, 3} Output: no valid arrangement is possible where adjacent elements are of different values. Explanation: All the elements are of the same value. Hence, no valid arrangement is possible. Approach: Brute Force In this approach, we compute all the arrangements of the input array. If any valid arrangement comes, we return that arrangement. If no valid arrangement is possible, display the appropriate message. For computing the valid arrangement, first, we will sort the array in ascending order. Then we will find the next permutation of the sorted array and check whether it is a valid arrangement or not. If it is a valid arrangement, then we can return that arrangement. If not, then we will find the next permutation and continue to do so until we find a valid arrangement or all the arrangements are exhausted. If the arrangements are exhausted, then we can say that no valid arrangement is there for the given input array, and the same is illustrated in the following program. FileName: UniqueAdjEle.java 
// important import statements
import java.util.Collections;
import java.util.ArrayList;
import java.util.Arrays;


public class UniqueAdjEle 
{
    // swapping the elements in the array list al
    // that are present at the index j and k
    private void swapEle(ArrayList<Integer> al, int j, int k) 
    {
        int temp = al.get(j);
        al.set(j, al.get(k));
        al.set(k, temp);
    }
    // reversing the array list from j to k
    private void reverseArrList(ArrayList<Integer> al, int j, int k) 
    {
        while (j < k) 
        {
            swapEle(al, j, k);
            j = j + 1;
            k = k - 1;
        }
    }

    private boolean nextPermutation(ArrayList<Integer> al) 
    {
        // if the list has no elements
        // or the single element, then
        // there is no need to proceed further
        if (al == null || al.size() <= 1) 
        {
            return false;
        }

        int j = al.size() - 2;

        while (j >= 0 && al.get(j).intValue() >= al.get(j + 1).intValue()) 
        {

            // Finding the first j that is breaking descending order
            j = j - 1;
        }

        if (j >= 0) 
        {
            // if the control reaching
            // here, then it means the array
            // is not entirely descending

            // Starting from the end
            int k = al.size() - 1;

            while (al.get(k).intValue() <= al.get(j).intValue()) 
            {
                // Finding the rightmost first larger id than k
                k = k - 1;
            }

            // Switching j and k
            swapEle(al, j, k);

            // Reversing in the descending sequence
            reverseArrList(al, j + 1, al.size() - 1);

            return true;
        } else 
        {
            // Reversing the whole sequence.
            reverseArrList(al, 0, al.size() - 1);
            return false;
        }
    }
    // a Boolean method that checks whether the elements of the array list al 
    // have the valid arrangement or not.
    public boolean isValidArrangement(ArrayList<Integer> al, int s)
    {
        int chk = 1;

            for (int j = 1; j < s; j++) 
            {
                if (al.get(j) == al.get(j - 1)) 
                {
                    chk = 0;
                    break;
                }
            }

            return chk == 1;
    }

    public ArrayList<Integer> rearrangeArr(ArrayList<Integer> al, int s) 
    {   
        if(isValidArrangement(al, s))
        {
            return al;
        }
        // sorting the list so we can compute the next permutation
        Collections.sort(al);
       
        // Iterating the array list and 
        // checking whether it is a valid arrangement or not
        // if yes, then we terminate the do-while loop.
        // Otherwise, we find the next permutation.
         while (nextPermutation(al))
         {
             if(isValidArrangement(al, s))
             {
                 return al;
             }
         }

        return new ArrayList<Integer>();
    }
    
    // main method
    public static void main(String argvs[])
    {
        // creating an object of the class UniqueAdjEle 
        UniqueAdjEle obj = new UniqueAdjEle();
        
        // input 1
        ArrayList<Integer> inArr = new ArrayList<Integer>
        (
            Arrays.asList(7, 7, 6, 8)
        );
        
        // computing the size of the 
        // input array
        int size = inArr.size();
        System.out.println("For the input array: ");
        for(int i = 0; i < size; i++)
        {
            System.out.print(inArr.get(i) + " ");
        }
        System.out.println();
        ArrayList<Integer> ans = obj.rearrangeArr(inArr, size);
        if(ans.size() > 0)
        {
        System.out.println("The valid arrangement is: ");
        
        for(int i = 0; i < size; i++)
        {
            System.out.print(ans.get(i) + " ");
        }
        }
        else
        {
            System.out.println("The valid arrangement is not possible. ");
        }
        
        System.out.println( "\n" );
        
        // input 2
        inArr = new ArrayList<Integer>
        (
            Arrays.asList(2, 4, 8, 9, 5, 7, 3, 6, 1)
        );
        
        // computing the size of the 
        // input array
        size = inArr.size();
        
        System.out.println("For the input array: ");
        
        for(int i = 0; i < size; i++)
        {
            System.out.print(inArr.get(i) + " ");
        }
        
        System.out.println();
        
        ans = obj.rearrangeArr(inArr, size);
        
        if(ans.size() > 0)
        {
        System.out.println("The valid arrangement is: ");
        
        for(int i = 0; i < size; i++)
        {
            System.out.print(ans.get(i) + " ");
        }
        }
        else
        {
            System.out.println("The valid arrangement is not possible. ");
        }
        
        System.out.println( "\n" );
        
        // input 3
        inArr = new ArrayList<Integer>
        (
            Arrays.asList(3, 3, 3, 3, 3)
        );
        
        // computing the size of the 
        // input array
        size = inArr.size();
        
        System.out.println("For the input array: ");
        
        for(int i = 0; i < size; i++)
        {
            System.out.print(inArr.get(i) + " ");
        }
        
        System.out.println();
        
        ans = obj.rearrangeArr(inArr, size);
        if(ans.size() > 0)
        {
        System.out.println("The valid arrangement is: ");
        
        for(int i = 0; i < size; i++)
        {
            System.out.print(ans.get(i) + " ");
        }
        }
        else
        {
            System.out.println("The valid arrangement is not possible. ");
        }
        
    }
    
    
    
}
 Output: For the input array: 
7 7 6 8 
The valid arrangement is: 
6 7 8 7 

For the input array: 
2 4 8 9 5 7 3 6 1 
The valid arrangement is: 
2 4 8 9 5 7 3 6 1 

For the input array: 
3 3 3 3 3 
The valid arrangement is not possible.
 Complexity Analysis: Since the program is computing the permutation, the time complexity of the program is O(N!), where N is the total number of elements present in the linked list. The program uses constant space; therefore, the space complexity of the program is O(1). The above program is not suitable for the larger inputs as the time complexity of the program is too high. Therefore, we must do some optimization to reduce the time complexity. Approach: Using Set It is a greedy approach where we put first that element which is occurring the most number of times in the input array. Using the set, we will put all the elements in the order of their occurrence count. The following are the steps involved in computing the answer. Step 1: Declare an empty array or list solAl. Step 2: Sort the array or list solAl. Step 3: Declare a set st that keeps the elements and their occurrence count. Step 4: Iterate over the list or array solAl: Iterate until the same element is encountered every time. Increment the element count by 1. Put the element and the occurrence count of the element in the set st. Step 5: Create a temporary variable for keeping the previous element and its occurrence count. Step 6: While the set st is not empty, do the following: Fetch the last element and get it added to the result. Delete that element from the set st. Reduce the occurrence count of the element popped by 1. If the occurrence count was non-zero of the previous elements, put it in the set. The current element should be treated as the previous element for the upcoming iteration. Step 7: Eventually, return the list or array solAl. Implementation The implementation of the above steps is mentioned below. FileName: UniqueAdjEle.java 
// important import statements
import java.util.Arrays;
import java.util.ArrayList;
import java.util.TreeSet;
import java.util.Collections;
import java.util.Comparator;

class PairComparator implements Comparator<Pair>
{

// Overriding the compare() method of the Comparator
public int compare(Pair p1, Pair p2)
{
if (p1.first < p2.first)
{
return -1;
}
else if(p1.first == p2.first)
{
return p1.second - p2.second;
}
else if (p1.first > p2.first)
{
return 1;
}

return 0;
}
}

// class Pair contains 
// two elements one is first
// other is second
class Pair 
{
int first; 
int second;
Pair(int first, int second)
{
this.first = first;
this.second = second;
}
}
public class UniqueAdjEle1 
{
// a boolean method that checks whether the elements of the array list al 
// have the valid arrangement or not.
public boolean isValidArrangement(ArrayList<Integer> al, int s)
{
int chk = 1;

for (int j = 1; j < s; j++) 
{
if (al.get(j) == al.get(j - 1)) 
{
chk = 0;
break;
}
}

return chk == 1;
}

public ArrayList<Integer> rearrangeArr(ArrayList<Integer> al, int s) 
{
if(isValidArrangement(al, s))
{
// the arrangement is valid
// hence, there is no need to proceed further
return al;
}

// Sorting the list or array al
Collections.sort(al);

// Declaring a set st that keeps the elements and their
// occurrence count.
TreeSet<Pair> st = new TreeSet<>(new PairComparator());


// Iterating over the list or array al
// Iterating until the element is the same
// Incrementing the element count by 1. 
// Inserting the element and its occurrence count in the set st
for (int j = 0; j < s; j++)
{

int k = j;
while (j < s && k < s && (al.get(j).equals(al.get(k))))
{
k = k + 1;
}
st.add(new Pair(k - j, al.get(j)));

j = k - 1;
}

int prv = -1;
int prvFreq = 0;

// Declaring an empty array or list solAl
ArrayList<Integer> solAl = new ArrayList<>();

while (st.size() != 0)
{
Pair pr = st.last();
st.remove(pr);
solAl.add(pr.second);

if (prvFreq > 0)
{
st.add(new Pair(prvFreq, prv));
}

prvFreq = pr.first - 1;
prv = pr.second;
}

// calculating the new size of the 
// rearranged array list
int newSize = solAl.size();

// if the new size after the rearrangement
// if the array list is not equal to the size s
// then, the valid rearrangement is not possible
if(newSize != s)
{
return new ArrayList<Integer>();
}

return solAl;
}


// main method
public static void main(String argvs[])
{
// creating an object of the class UniqueAdjEle1 
UniqueAdjEle1 obj = new UniqueAdjEle1();

// input 1
ArrayList<Integer> inArr = new ArrayList<Integer>
(
Arrays.asList(7, 7, 6, 8)
);

// computing the size of the 
// input array
int size = inArr.size();
System.out.println("For the input array: ");
for(int i = 0; i < size; i++)
{
System.out.print(inArr.get(i) + " ");
}
System.out.println();
ArrayList<Integer> ans = obj.rearrangeArr(inArr, size);
if(ans.size() > 0)
{
System.out.println("The valid arrangement is: ");

for(int i = 0; i < size; i++)
{
System.out.print(ans.get(i) + " ");
}
}
else
{
System.out.println("The valid arrangement is not possible. ");
}

System.out.println( "\n" );

// input 2
inArr = new ArrayList<Integer>
(
Arrays.asList(2, 4, 8, 9, 5, 7, 3, 6, 1)
);

// computing the size of the 
// input array
size = inArr.size();

System.out.println("For the input array: ");

for(int i = 0; i < size; i++)
{
System.out.print(inArr.get(i) + " ");
}

System.out.println();

ans = obj.rearrangeArr(inArr, size);

if(ans.size() > 0)
{
System.out.println("The valid arrangement is: ");

for(int i = 0; i < size; i++)
{
System.out.print(ans.get(i) + " ");
}
}
else
{
System.out.println("The valid arrangement is not possible. ");
}

System.out.println( "\n" );

// input 3
inArr = new ArrayList<Integer>
(
Arrays.asList(3, 3, 3, 3, 3)
);

// computing the size of the 
// input array
size = inArr.size();

System.out.println("For the input array: ");

for(int i = 0; i < size; i++)
{
System.out.print(inArr.get(i) + " ");
}

System.out.println();

ans = obj.rearrangeArr(inArr, size);
if(ans.size() > 0)
{
System.out.println("The valid arrangement is: ");

for(int i = 0; i < size; i++)
{
System.out.print(ans.get(i) + " ");
}
}
else
{
System.out.println("The valid arrangement is not possible. ");
}

}

}
 Output: For the input array: 
7 7 6 8 
The valid arrangement is: 
7 8 7 6 

For the input array: 
2 4 8 9 5 7 3 6 1 
The valid arrangement is: 
2 4 8 9 5 7 3 6 1 

For the input array: 
3 3 3 3 3 
The valid arrangement is not possible.
 Complexity Analysis: Since the program is using sorting, the time complexity of the program is O(N * log(N)). The program uses a set to store the elements and their occurrence count. The program is also using an auxiliary array (arr). Thus, making the space complexity of the program as (N), where N is the total number of elements present in the input array. Note: Instead of Set, a priority queue can also be used. In that case, also, the time and space complexity remain the same. Next Topic# ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/unequal-adjacent-elements-in-java Unequal Adjacent Elements in Java - Javatpoint ? SCROLL TO TOP Home Java Programs OOPs String Exception Multithreading Collections JavaFX JSP Spring Spring Boot Projects Interview Questions Java Tutorial What is Java History of Java Features of Java C++ vs Java Hello Java Program Program Internal How to set path? JDK, JRE and JVM JVM: Java Virtual Machine Java Variables Java Data Types Unicode System Operators Keywords Control Statements Java Control Statements Java If-else Java Switch Java For Loop Java While Loop Java Do While Loop Java Break Java Continue Java Comments Java Programs Java Object Class Java OOPs Concepts Naming Convention Object and Class Method Constructor static keyword this keyword Java Inheritance Inheritance(IS-A) Aggregation(HAS-A) Java Polymorphism Method Overloading Method Overriding Covariant Return Type super keyword Instance Initializer block final keyword Runtime Polymorphism Dynamic Binding instanceof operator Java Abstraction Abstract class Interface Abstract vs Interface Java Encapsulation Package Access Modifiers Encapsulation Java Array Java Array Java OOPs Misc Object class Object Cloning Math class Wrapper Class Java Recursion Call By Value strictfp keyword javadoc tool Command Line Arg Object vs Class Overloading vs Overriding Java String Java Regex Exception Handling Java Inner classes Java Multithreading Java I/O Java Networking Java AWT & Events Java Swing JavaFX Java Applet Java Reflection Java Date Java Conversion Java Collection Java JDBC Java Misc Java New Features RMI Internationalization Interview Questions Java MCQ next ? ? prev Unequal Adjacent Elements in Java An array inArr containing n numbers (positive or negative) is given. The task is to return the array after the rearrangement of elements of the integers in such a way that no two adjacent elements are equal. If there are multiple valid arrangements, then any one valid arrangement can be returned. If the input array does not contain any valid arrangement, then an appropriate message can be displayed on the console. Example 1: Input int inArr[] = {7, 7, 6, 8} Output: {7, 6, 7, 8} Explanation: There are many valid arrangements possible. Those valid arrangements are mentioned below. {7, 6, 7, 8}, {7, 6, 8, 7}, {7, 8, 7, 6}, {7, 8, 6, 7}, {8, 7, 6, 7}, {6, 7, 8, 7}. Out of which {7, 6, 7, 8} is mentioned in the output. Example 2: Input int inArr[] = {2, 4, 8, 9, 5, 7, 3, 6, 1} Output: {2, 4, 8, 9, 5, 7, 3, 6, 1} Explanation: The input array is given in such a way that there are no two elements that are of the same value. Hence, the input arrays are themselves the answer. Example 3: Input int arr[] = {3, 3, 3, 3, 3} Output: no valid arrangement is possible where adjacent elements are of different values. Explanation: All the elements are of the same value. Hence, no valid arrangement is possible. Approach: Brute Force In this approach, we compute all the arrangements of the input array. If any valid arrangement comes, we return that arrangement. If no valid arrangement is possible, display the appropriate message. For computing the valid arrangement, first, we will sort the array in ascending order. Then we will find the next permutation of the sorted array and check whether it is a valid arrangement or not. If it is a valid arrangement, then we can return that arrangement. If not, then we will find the next permutation and continue to do so until we find a valid arrangement or all the arrangements are exhausted. If the arrangements are exhausted, then we can say that no valid arrangement is there for the given input array, and the same is illustrated in the following program. FileName: UniqueAdjEle.java 
// important import statements
import java.util.Collections;
import java.util.ArrayList;
import java.util.Arrays;


public class UniqueAdjEle 
{
    // swapping the elements in the array list al
    // that are present at the index j and k
    private void swapEle(ArrayList<Integer> al, int j, int k) 
    {
        int temp = al.get(j);
        al.set(j, al.get(k));
        al.set(k, temp);
    }
    // reversing the array list from j to k
    private void reverseArrList(ArrayList<Integer> al, int j, int k) 
    {
        while (j < k) 
        {
            swapEle(al, j, k);
            j = j + 1;
            k = k - 1;
        }
    }

    private boolean nextPermutation(ArrayList<Integer> al) 
    {
        // if the list has no elements
        // or the single element, then
        // there is no need to proceed further
        if (al == null || al.size() <= 1) 
        {
            return false;
        }

        int j = al.size() - 2;

        while (j >= 0 && al.get(j).intValue() >= al.get(j + 1).intValue()) 
        {

            // Finding the first j that is breaking descending order
            j = j - 1;
        }

        if (j >= 0) 
        {
            // if the control reaching
            // here, then it means the array
            // is not entirely descending

            // Starting from the end
            int k = al.size() - 1;

            while (al.get(k).intValue() <= al.get(j).intValue()) 
            {
                // Finding the rightmost first larger id than k
                k = k - 1;
            }

            // Switching j and k
            swapEle(al, j, k);

            // Reversing in the descending sequence
            reverseArrList(al, j + 1, al.size() - 1);

            return true;
        } else 
        {
            // Reversing the whole sequence.
            reverseArrList(al, 0, al.size() - 1);
            return false;
        }
    }
    // a Boolean method that checks whether the elements of the array list al 
    // have the valid arrangement or not.
    public boolean isValidArrangement(ArrayList<Integer> al, int s)
    {
        int chk = 1;

            for (int j = 1; j < s; j++) 
            {
                if (al.get(j) == al.get(j - 1)) 
                {
                    chk = 0;
                    break;
                }
            }

            return chk == 1;
    }

    public ArrayList<Integer> rearrangeArr(ArrayList<Integer> al, int s) 
    {   
        if(isValidArrangement(al, s))
        {
            return al;
        }
        // sorting the list so we can compute the next permutation
        Collections.sort(al);
       
        // Iterating the array list and 
        // checking whether it is a valid arrangement or not
        // if yes, then we terminate the do-while loop.
        // Otherwise, we find the next permutation.
         while (nextPermutation(al))
         {
             if(isValidArrangement(al, s))
             {
                 return al;
             }
         }

        return new ArrayList<Integer>();
    }
    
    // main method
    public static void main(String argvs[])
    {
        // creating an object of the class UniqueAdjEle 
        UniqueAdjEle obj = new UniqueAdjEle();
        
        // input 1
        ArrayList<Integer> inArr = new ArrayList<Integer>
        (
            Arrays.asList(7, 7, 6, 8)
        );
        
        // computing the size of the 
        // input array
        int size = inArr.size();
        System.out.println("For the input array: ");
        for(int i = 0; i < size; i++)
        {
            System.out.print(inArr.get(i) + " ");
        }
        System.out.println();
        ArrayList<Integer> ans = obj.rearrangeArr(inArr, size);
        if(ans.size() > 0)
        {
        System.out.println("The valid arrangement is: ");
        
        for(int i = 0; i < size; i++)
        {
            System.out.print(ans.get(i) + " ");
        }
        }
        else
        {
            System.out.println("The valid arrangement is not possible. ");
        }
        
        System.out.println( "\n" );
        
        // input 2
        inArr = new ArrayList<Integer>
        (
            Arrays.asList(2, 4, 8, 9, 5, 7, 3, 6, 1)
        );
        
        // computing the size of the 
        // input array
        size = inArr.size();
        
        System.out.println("For the input array: ");
        
        for(int i = 0; i < size; i++)
        {
            System.out.print(inArr.get(i) + " ");
        }
        
        System.out.println();
        
        ans = obj.rearrangeArr(inArr, size);
        
        if(ans.size() > 0)
        {
        System.out.println("The valid arrangement is: ");
        
        for(int i = 0; i < size; i++)
        {
            System.out.print(ans.get(i) + " ");
        }
        }
        else
        {
            System.out.println("The valid arrangement is not possible. ");
        }
        
        System.out.println( "\n" );
        
        // input 3
        inArr = new ArrayList<Integer>
        (
            Arrays.asList(3, 3, 3, 3, 3)
        );
        
        // computing the size of the 
        // input array
        size = inArr.size();
        
        System.out.println("For the input array: ");
        
        for(int i = 0; i < size; i++)
        {
            System.out.print(inArr.get(i) + " ");
        }
        
        System.out.println();
        
        ans = obj.rearrangeArr(inArr, size);
        if(ans.size() > 0)
        {
        System.out.println("The valid arrangement is: ");
        
        for(int i = 0; i < size; i++)
        {
            System.out.print(ans.get(i) + " ");
        }
        }
        else
        {
            System.out.println("The valid arrangement is not possible. ");
        }
        
    }
    
    
    
}
 Output: For the input array: 
7 7 6 8 
The valid arrangement is: 
6 7 8 7 

For the input array: 
2 4 8 9 5 7 3 6 1 
The valid arrangement is: 
2 4 8 9 5 7 3 6 1 

For the input array: 
3 3 3 3 3 
The valid arrangement is not possible.
 Complexity Analysis: Since the program is computing the permutation, the time complexity of the program is O(N!), where N is the total number of elements present in the linked list. The program uses constant space; therefore, the space complexity of the program is O(1). The above program is not suitable for the larger inputs as the time complexity of the program is too high. Therefore, we must do some optimization to reduce the time complexity. Approach: Using Set It is a greedy approach where we put first that element which is occurring the most number of times in the input array. Using the set, we will put all the elements in the order of their occurrence count. The following are the steps involved in computing the answer. Step 1: Declare an empty array or list solAl. Step 2: Sort the array or list solAl. Step 3: Declare a set st that keeps the elements and their occurrence count. Step 4: Iterate over the list or array solAl: Iterate until the same element is encountered every time. Increment the element count by 1. Put the element and the occurrence count of the element in the set st. Step 5: Create a temporary variable for keeping the previous element and its occurrence count. Step 6: While the set st is not empty, do the following: Fetch the last element and get it added to the result. Delete that element from the set st. Reduce the occurrence count of the element popped by 1. If the occurrence count was non-zero of the previous elements, put it in the set. The current element should be treated as the previous element for the upcoming iteration. Step 7: Eventually, return the list or array solAl. Implementation The implementation of the above steps is mentioned below. FileName: UniqueAdjEle.java 
// important import statements
import java.util.Arrays;
import java.util.ArrayList;
import java.util.TreeSet;
import java.util.Collections;
import java.util.Comparator;

class PairComparator implements Comparator<Pair>
{

// Overriding the compare() method of the Comparator
public int compare(Pair p1, Pair p2)
{
if (p1.first < p2.first)
{
return -1;
}
else if(p1.first == p2.first)
{
return p1.second - p2.second;
}
else if (p1.first > p2.first)
{
return 1;
}

return 0;
}
}

// class Pair contains 
// two elements one is first
// other is second
class Pair 
{
int first; 
int second;
Pair(int first, int second)
{
this.first = first;
this.second = second;
}
}
public class UniqueAdjEle1 
{
// a boolean method that checks whether the elements of the array list al 
// have the valid arrangement or not.
public boolean isValidArrangement(ArrayList<Integer> al, int s)
{
int chk = 1;

for (int j = 1; j < s; j++) 
{
if (al.get(j) == al.get(j - 1)) 
{
chk = 0;
break;
}
}

return chk == 1;
}

public ArrayList<Integer> rearrangeArr(ArrayList<Integer> al, int s) 
{
if(isValidArrangement(al, s))
{
// the arrangement is valid
// hence, there is no need to proceed further
return al;
}

// Sorting the list or array al
Collections.sort(al);

// Declaring a set st that keeps the elements and their
// occurrence count.
TreeSet<Pair> st = new TreeSet<>(new PairComparator());


// Iterating over the list or array al
// Iterating until the element is the same
// Incrementing the element count by 1. 
// Inserting the element and its occurrence count in the set st
for (int j = 0; j < s; j++)
{

int k = j;
while (j < s && k < s && (al.get(j).equals(al.get(k))))
{
k = k + 1;
}
st.add(new Pair(k - j, al.get(j)));

j = k - 1;
}

int prv = -1;
int prvFreq = 0;

// Declaring an empty array or list solAl
ArrayList<Integer> solAl = new ArrayList<>();

while (st.size() != 0)
{
Pair pr = st.last();
st.remove(pr);
solAl.add(pr.second);

if (prvFreq > 0)
{
st.add(new Pair(prvFreq, prv));
}

prvFreq = pr.first - 1;
prv = pr.second;
}

// calculating the new size of the 
// rearranged array list
int newSize = solAl.size();

// if the new size after the rearrangement
// if the array list is not equal to the size s
// then, the valid rearrangement is not possible
if(newSize != s)
{
return new ArrayList<Integer>();
}

return solAl;
}


// main method
public static void main(String argvs[])
{
// creating an object of the class UniqueAdjEle1 
UniqueAdjEle1 obj = new UniqueAdjEle1();

// input 1
ArrayList<Integer> inArr = new ArrayList<Integer>
(
Arrays.asList(7, 7, 6, 8)
);

// computing the size of the 
// input array
int size = inArr.size();
System.out.println("For the input array: ");
for(int i = 0; i < size; i++)
{
System.out.print(inArr.get(i) + " ");
}
System.out.println();
ArrayList<Integer> ans = obj.rearrangeArr(inArr, size);
if(ans.size() > 0)
{
System.out.println("The valid arrangement is: ");

for(int i = 0; i < size; i++)
{
System.out.print(ans.get(i) + " ");
}
}
else
{
System.out.println("The valid arrangement is not possible. ");
}

System.out.println( "\n" );

// input 2
inArr = new ArrayList<Integer>
(
Arrays.asList(2, 4, 8, 9, 5, 7, 3, 6, 1)
);

// computing the size of the 
// input array
size = inArr.size();

System.out.println("For the input array: ");

for(int i = 0; i < size; i++)
{
System.out.print(inArr.get(i) + " ");
}

System.out.println();

ans = obj.rearrangeArr(inArr, size);

if(ans.size() > 0)
{
System.out.println("The valid arrangement is: ");

for(int i = 0; i < size; i++)
{
System.out.print(ans.get(i) + " ");
}
}
else
{
System.out.println("The valid arrangement is not possible. ");
}

System.out.println( "\n" );

// input 3
inArr = new ArrayList<Integer>
(
Arrays.asList(3, 3, 3, 3, 3)
);

// computing the size of the 
// input array
size = inArr.size();

System.out.println("For the input array: ");

for(int i = 0; i < size; i++)
{
System.out.print(inArr.get(i) + " ");
}

System.out.println();

ans = obj.rearrangeArr(inArr, size);
if(ans.size() > 0)
{
System.out.println("The valid arrangement is: ");

for(int i = 0; i < size; i++)
{
System.out.print(ans.get(i) + " ");
}
}
else
{
System.out.println("The valid arrangement is not possible. ");
}

}

}
 Output: For the input array: 
7 7 6 8 
The valid arrangement is: 
7 8 7 6 

For the input array: 
2 4 8 9 5 7 3 6 1 
The valid arrangement is: 
2 4 8 9 5 7 3 6 1 

For the input array: 
3 3 3 3 3 
The valid arrangement is not possible.
 Complexity Analysis: Since the program is using sorting, the time complexity of the program is O(N * log(N)). The program uses a set to store the elements and their occurrence count. The program is also using an auxiliary array (arr). Thus, making the space complexity of the program as (N), where N is the total number of elements present in the input array. Note: Instead of Set, a priority queue can also be used. In that case, also, the time and space complexity remain the same. Next Topic# ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/unequal-adjacent-elements-in-java Unequal Adjacent Elements in Java - Javatpoint ? SCROLL TO TOP Home Java Programs OOPs String Exception Multithreading Collections JavaFX JSP Spring Spring Boot Projects Interview Questions Java Tutorial What is Java History of Java Features of Java C++ vs Java Hello Java Program Program Internal How to set path? JDK, JRE and JVM JVM: Java Virtual Machine Java Variables Java Data Types Unicode System Operators Keywords Control Statements Java Control Statements Java If-else Java Switch Java For Loop Java While Loop Java Do While Loop Java Break Java Continue Java Comments Java Programs Java Object Class Java OOPs Concepts Naming Convention Object and Class Method Constructor static keyword this keyword Java Inheritance Inheritance(IS-A) Aggregation(HAS-A) Java Polymorphism Method Overloading Method Overriding Covariant Return Type super keyword Instance Initializer block final keyword Runtime Polymorphism Dynamic Binding instanceof operator Java Abstraction Abstract class Interface Abstract vs Interface Java Encapsulation Package Access Modifiers Encapsulation Java Array Java Array Java OOPs Misc Object class Object Cloning Math class Wrapper Class Java Recursion Call By Value strictfp keyword javadoc tool Command Line Arg Object vs Class Overloading vs Overriding Java String Java Regex Exception Handling Java Inner classes Java Multithreading Java I/O Java Networking Java AWT & Events Java Swing JavaFX Java Applet Java Reflection Java Date Java Conversion Java Collection Java JDBC Java Misc Java New Features RMI Internationalization Interview Questions Java MCQ next ? ? prev Unequal Adjacent Elements in Java An array inArr containing n numbers (positive or negative) is given. The task is to return the array after the rearrangement of elements of the integers in such a way that no two adjacent elements are equal. If there are multiple valid arrangements, then any one valid arrangement can be returned. If the input array does not contain any valid arrangement, then an appropriate message can be displayed on the console. Example 1: Input int inArr[] = {7, 7, 6, 8} Output: {7, 6, 7, 8} Explanation: There are many valid arrangements possible. Those valid arrangements are mentioned below. {7, 6, 7, 8}, {7, 6, 8, 7}, {7, 8, 7, 6}, {7, 8, 6, 7}, {8, 7, 6, 7}, {6, 7, 8, 7}. Out of which {7, 6, 7, 8} is mentioned in the output. Example 2: Input int inArr[] = {2, 4, 8, 9, 5, 7, 3, 6, 1} Output: {2, 4, 8, 9, 5, 7, 3, 6, 1} Explanation: The input array is given in such a way that there are no two elements that are of the same value. Hence, the input arrays are themselves the answer. Example 3: Input int arr[] = {3, 3, 3, 3, 3} Output: no valid arrangement is possible where adjacent elements are of different values. Explanation: All the elements are of the same value. Hence, no valid arrangement is possible. Approach: Brute Force In this approach, we compute all the arrangements of the input array. If any valid arrangement comes, we return that arrangement. If no valid arrangement is possible, display the appropriate message. For computing the valid arrangement, first, we will sort the array in ascending order. Then we will find the next permutation of the sorted array and check whether it is a valid arrangement or not. If it is a valid arrangement, then we can return that arrangement. If not, then we will find the next permutation and continue to do so until we find a valid arrangement or all the arrangements are exhausted. If the arrangements are exhausted, then we can say that no valid arrangement is there for the given input array, and the same is illustrated in the following program. FileName: UniqueAdjEle.java 
// important import statements
import java.util.Collections;
import java.util.ArrayList;
import java.util.Arrays;


public class UniqueAdjEle 
{
    // swapping the elements in the array list al
    // that are present at the index j and k
    private void swapEle(ArrayList<Integer> al, int j, int k) 
    {
        int temp = al.get(j);
        al.set(j, al.get(k));
        al.set(k, temp);
    }
    // reversing the array list from j to k
    private void reverseArrList(ArrayList<Integer> al, int j, int k) 
    {
        while (j < k) 
        {
            swapEle(al, j, k);
            j = j + 1;
            k = k - 1;
        }
    }

    private boolean nextPermutation(ArrayList<Integer> al) 
    {
        // if the list has no elements
        // or the single element, then
        // there is no need to proceed further
        if (al == null || al.size() <= 1) 
        {
            return false;
        }

        int j = al.size() - 2;

        while (j >= 0 && al.get(j).intValue() >= al.get(j + 1).intValue()) 
        {

            // Finding the first j that is breaking descending order
            j = j - 1;
        }

        if (j >= 0) 
        {
            // if the control reaching
            // here, then it means the array
            // is not entirely descending

            // Starting from the end
            int k = al.size() - 1;

            while (al.get(k).intValue() <= al.get(j).intValue()) 
            {
                // Finding the rightmost first larger id than k
                k = k - 1;
            }

            // Switching j and k
            swapEle(al, j, k);

            // Reversing in the descending sequence
            reverseArrList(al, j + 1, al.size() - 1);

            return true;
        } else 
        {
            // Reversing the whole sequence.
            reverseArrList(al, 0, al.size() - 1);
            return false;
        }
    }
    // a Boolean method that checks whether the elements of the array list al 
    // have the valid arrangement or not.
    public boolean isValidArrangement(ArrayList<Integer> al, int s)
    {
        int chk = 1;

            for (int j = 1; j < s; j++) 
            {
                if (al.get(j) == al.get(j - 1)) 
                {
                    chk = 0;
                    break;
                }
            }

            return chk == 1;
    }

    public ArrayList<Integer> rearrangeArr(ArrayList<Integer> al, int s) 
    {   
        if(isValidArrangement(al, s))
        {
            return al;
        }
        // sorting the list so we can compute the next permutation
        Collections.sort(al);
       
        // Iterating the array list and 
        // checking whether it is a valid arrangement or not
        // if yes, then we terminate the do-while loop.
        // Otherwise, we find the next permutation.
         while (nextPermutation(al))
         {
             if(isValidArrangement(al, s))
             {
                 return al;
             }
         }

        return new ArrayList<Integer>();
    }
    
    // main method
    public static void main(String argvs[])
    {
        // creating an object of the class UniqueAdjEle 
        UniqueAdjEle obj = new UniqueAdjEle();
        
        // input 1
        ArrayList<Integer> inArr = new ArrayList<Integer>
        (
            Arrays.asList(7, 7, 6, 8)
        );
        
        // computing the size of the 
        // input array
        int size = inArr.size();
        System.out.println("For the input array: ");
        for(int i = 0; i < size; i++)
        {
            System.out.print(inArr.get(i) + " ");
        }
        System.out.println();
        ArrayList<Integer> ans = obj.rearrangeArr(inArr, size);
        if(ans.size() > 0)
        {
        System.out.println("The valid arrangement is: ");
        
        for(int i = 0; i < size; i++)
        {
            System.out.print(ans.get(i) + " ");
        }
        }
        else
        {
            System.out.println("The valid arrangement is not possible. ");
        }
        
        System.out.println( "\n" );
        
        // input 2
        inArr = new ArrayList<Integer>
        (
            Arrays.asList(2, 4, 8, 9, 5, 7, 3, 6, 1)
        );
        
        // computing the size of the 
        // input array
        size = inArr.size();
        
        System.out.println("For the input array: ");
        
        for(int i = 0; i < size; i++)
        {
            System.out.print(inArr.get(i) + " ");
        }
        
        System.out.println();
        
        ans = obj.rearrangeArr(inArr, size);
        
        if(ans.size() > 0)
        {
        System.out.println("The valid arrangement is: ");
        
        for(int i = 0; i < size; i++)
        {
            System.out.print(ans.get(i) + " ");
        }
        }
        else
        {
            System.out.println("The valid arrangement is not possible. ");
        }
        
        System.out.println( "\n" );
        
        // input 3
        inArr = new ArrayList<Integer>
        (
            Arrays.asList(3, 3, 3, 3, 3)
        );
        
        // computing the size of the 
        // input array
        size = inArr.size();
        
        System.out.println("For the input array: ");
        
        for(int i = 0; i < size; i++)
        {
            System.out.print(inArr.get(i) + " ");
        }
        
        System.out.println();
        
        ans = obj.rearrangeArr(inArr, size);
        if(ans.size() > 0)
        {
        System.out.println("The valid arrangement is: ");
        
        for(int i = 0; i < size; i++)
        {
            System.out.print(ans.get(i) + " ");
        }
        }
        else
        {
            System.out.println("The valid arrangement is not possible. ");
        }
        
    }
    
    
    
}
 Output: For the input array: 
7 7 6 8 
The valid arrangement is: 
6 7 8 7 

For the input array: 
2 4 8 9 5 7 3 6 1 
The valid arrangement is: 
2 4 8 9 5 7 3 6 1 

For the input array: 
3 3 3 3 3 
The valid arrangement is not possible.
 Complexity Analysis: Since the program is computing the permutation, the time complexity of the program is O(N!), where N is the total number of elements present in the linked list. The program uses constant space; therefore, the space complexity of the program is O(1). The above program is not suitable for the larger inputs as the time complexity of the program is too high. Therefore, we must do some optimization to reduce the time complexity. Approach: Using Set It is a greedy approach where we put first that element which is occurring the most number of times in the input array. Using the set, we will put all the elements in the order of their occurrence count. The following are the steps involved in computing the answer. Step 1: Declare an empty array or list solAl. Step 2: Sort the array or list solAl. Step 3: Declare a set st that keeps the elements and their occurrence count. Step 4: Iterate over the list or array solAl: Iterate until the same element is encountered every time. Increment the element count by 1. Put the element and the occurrence count of the element in the set st. Step 5: Create a temporary variable for keeping the previous element and its occurrence count. Step 6: While the set st is not empty, do the following: Fetch the last element and get it added to the result. Delete that element from the set st. Reduce the occurrence count of the element popped by 1. If the occurrence count was non-zero of the previous elements, put it in the set. The current element should be treated as the previous element for the upcoming iteration. Step 7: Eventually, return the list or array solAl. Implementation The implementation of the above steps is mentioned below. FileName: UniqueAdjEle.java 
// important import statements
import java.util.Arrays;
import java.util.ArrayList;
import java.util.TreeSet;
import java.util.Collections;
import java.util.Comparator;

class PairComparator implements Comparator<Pair>
{

// Overriding the compare() method of the Comparator
public int compare(Pair p1, Pair p2)
{
if (p1.first < p2.first)
{
return -1;
}
else if(p1.first == p2.first)
{
return p1.second - p2.second;
}
else if (p1.first > p2.first)
{
return 1;
}

return 0;
}
}

// class Pair contains 
// two elements one is first
// other is second
class Pair 
{
int first; 
int second;
Pair(int first, int second)
{
this.first = first;
this.second = second;
}
}
public class UniqueAdjEle1 
{
// a boolean method that checks whether the elements of the array list al 
// have the valid arrangement or not.
public boolean isValidArrangement(ArrayList<Integer> al, int s)
{
int chk = 1;

for (int j = 1; j < s; j++) 
{
if (al.get(j) == al.get(j - 1)) 
{
chk = 0;
break;
}
}

return chk == 1;
}

public ArrayList<Integer> rearrangeArr(ArrayList<Integer> al, int s) 
{
if(isValidArrangement(al, s))
{
// the arrangement is valid
// hence, there is no need to proceed further
return al;
}

// Sorting the list or array al
Collections.sort(al);

// Declaring a set st that keeps the elements and their
// occurrence count.
TreeSet<Pair> st = new TreeSet<>(new PairComparator());


// Iterating over the list or array al
// Iterating until the element is the same
// Incrementing the element count by 1. 
// Inserting the element and its occurrence count in the set st
for (int j = 0; j < s; j++)
{

int k = j;
while (j < s && k < s && (al.get(j).equals(al.get(k))))
{
k = k + 1;
}
st.add(new Pair(k - j, al.get(j)));

j = k - 1;
}

int prv = -1;
int prvFreq = 0;

// Declaring an empty array or list solAl
ArrayList<Integer> solAl = new ArrayList<>();

while (st.size() != 0)
{
Pair pr = st.last();
st.remove(pr);
solAl.add(pr.second);

if (prvFreq > 0)
{
st.add(new Pair(prvFreq, prv));
}

prvFreq = pr.first - 1;
prv = pr.second;
}

// calculating the new size of the 
// rearranged array list
int newSize = solAl.size();

// if the new size after the rearrangement
// if the array list is not equal to the size s
// then, the valid rearrangement is not possible
if(newSize != s)
{
return new ArrayList<Integer>();
}

return solAl;
}


// main method
public static void main(String argvs[])
{
// creating an object of the class UniqueAdjEle1 
UniqueAdjEle1 obj = new UniqueAdjEle1();

// input 1
ArrayList<Integer> inArr = new ArrayList<Integer>
(
Arrays.asList(7, 7, 6, 8)
);

// computing the size of the 
// input array
int size = inArr.size();
System.out.println("For the input array: ");
for(int i = 0; i < size; i++)
{
System.out.print(inArr.get(i) + " ");
}
System.out.println();
ArrayList<Integer> ans = obj.rearrangeArr(inArr, size);
if(ans.size() > 0)
{
System.out.println("The valid arrangement is: ");

for(int i = 0; i < size; i++)
{
System.out.print(ans.get(i) + " ");
}
}
else
{
System.out.println("The valid arrangement is not possible. ");
}

System.out.println( "\n" );

// input 2
inArr = new ArrayList<Integer>
(
Arrays.asList(2, 4, 8, 9, 5, 7, 3, 6, 1)
);

// computing the size of the 
// input array
size = inArr.size();

System.out.println("For the input array: ");

for(int i = 0; i < size; i++)
{
System.out.print(inArr.get(i) + " ");
}

System.out.println();

ans = obj.rearrangeArr(inArr, size);

if(ans.size() > 0)
{
System.out.println("The valid arrangement is: ");

for(int i = 0; i < size; i++)
{
System.out.print(ans.get(i) + " ");
}
}
else
{
System.out.println("The valid arrangement is not possible. ");
}

System.out.println( "\n" );

// input 3
inArr = new ArrayList<Integer>
(
Arrays.asList(3, 3, 3, 3, 3)
);

// computing the size of the 
// input array
size = inArr.size();

System.out.println("For the input array: ");

for(int i = 0; i < size; i++)
{
System.out.print(inArr.get(i) + " ");
}

System.out.println();

ans = obj.rearrangeArr(inArr, size);
if(ans.size() > 0)
{
System.out.println("The valid arrangement is: ");

for(int i = 0; i < size; i++)
{
System.out.print(ans.get(i) + " ");
}
}
else
{
System.out.println("The valid arrangement is not possible. ");
}

}

}
 Output: For the input array: 
7 7 6 8 
The valid arrangement is: 
7 8 7 6 

For the input array: 
2 4 8 9 5 7 3 6 1 
The valid arrangement is: 
2 4 8 9 5 7 3 6 1 

For the input array: 
3 3 3 3 3 
The valid arrangement is not possible.
 Complexity Analysis: Since the program is using sorting, the time complexity of the program is O(N * log(N)). The program uses a set to store the elements and their occurrence count. The program is also using an auxiliary array (arr). Thus, making the space complexity of the program as (N), where N is the total number of elements present in the input array. Note: Instead of Set, a priority queue can also be used. In that case, also, the time and space complexity remain the same. Next Topic# ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/unequal-adjacent-elements-in-java Unequal Adjacent Elements in Java - Javatpoint ? SCROLL TO TOP Home Java Programs OOPs String Exception Multithreading Collections JavaFX JSP Spring Spring Boot Projects Interview Questions Java Tutorial What is Java History of Java Features of Java C++ vs Java Hello Java Program Program Internal How to set path? JDK, JRE and JVM JVM: Java Virtual Machine Java Variables Java Data Types Unicode System Operators Keywords Control Statements Java Control Statements Java If-else Java Switch Java For Loop Java While Loop Java Do While Loop Java Break Java Continue Java Comments Java Programs Java Object Class Java OOPs Concepts Naming Convention Object and Class Method Constructor static keyword this keyword Java Inheritance Inheritance(IS-A) Aggregation(HAS-A) Java Polymorphism Method Overloading Method Overriding Covariant Return Type super keyword Instance Initializer block final keyword Runtime Polymorphism Dynamic Binding instanceof operator Java Abstraction Abstract class Interface Abstract vs Interface Java Encapsulation Package Access Modifiers Encapsulation Java Array Java Array Java OOPs Misc Object class Object Cloning Math class Wrapper Class Java Recursion Call By Value strictfp keyword javadoc tool Command Line Arg Object vs Class Overloading vs Overriding Java String Java Regex Exception Handling Java Inner classes Java Multithreading Java I/O Java Networking Java AWT & Events Java Swing JavaFX Java Applet Java Reflection Java Date Java Conversion Java Collection Java JDBC Java Misc Java New Features RMI Internationalization Interview Questions Java MCQ next ? ? prev Unequal Adjacent Elements in Java An array inArr containing n numbers (positive or negative) is given. The task is to return the array after the rearrangement of elements of the integers in such a way that no two adjacent elements are equal. If there are multiple valid arrangements, then any one valid arrangement can be returned. If the input array does not contain any valid arrangement, then an appropriate message can be displayed on the console. Example 1: Input int inArr[] = {7, 7, 6, 8} Output: {7, 6, 7, 8} Explanation: There are many valid arrangements possible. Those valid arrangements are mentioned below. {7, 6, 7, 8}, {7, 6, 8, 7}, {7, 8, 7, 6}, {7, 8, 6, 7}, {8, 7, 6, 7}, {6, 7, 8, 7}. Out of which {7, 6, 7, 8} is mentioned in the output. Example 2: Input int inArr[] = {2, 4, 8, 9, 5, 7, 3, 6, 1} Output: {2, 4, 8, 9, 5, 7, 3, 6, 1} Explanation: The input array is given in such a way that there are no two elements that are of the same value. Hence, the input arrays are themselves the answer. Example 3: Input int arr[] = {3, 3, 3, 3, 3} Output: no valid arrangement is possible where adjacent elements are of different values. Explanation: All the elements are of the same value. Hence, no valid arrangement is possible. Approach: Brute Force In this approach, we compute all the arrangements of the input array. If any valid arrangement comes, we return that arrangement. If no valid arrangement is possible, display the appropriate message. For computing the valid arrangement, first, we will sort the array in ascending order. Then we will find the next permutation of the sorted array and check whether it is a valid arrangement or not. If it is a valid arrangement, then we can return that arrangement. If not, then we will find the next permutation and continue to do so until we find a valid arrangement or all the arrangements are exhausted. If the arrangements are exhausted, then we can say that no valid arrangement is there for the given input array, and the same is illustrated in the following program. FileName: UniqueAdjEle.java 
// important import statements
import java.util.Collections;
import java.util.ArrayList;
import java.util.Arrays;


public class UniqueAdjEle 
{
    // swapping the elements in the array list al
    // that are present at the index j and k
    private void swapEle(ArrayList<Integer> al, int j, int k) 
    {
        int temp = al.get(j);
        al.set(j, al.get(k));
        al.set(k, temp);
    }
    // reversing the array list from j to k
    private void reverseArrList(ArrayList<Integer> al, int j, int k) 
    {
        while (j < k) 
        {
            swapEle(al, j, k);
            j = j + 1;
            k = k - 1;
        }
    }

    private boolean nextPermutation(ArrayList<Integer> al) 
    {
        // if the list has no elements
        // or the single element, then
        // there is no need to proceed further
        if (al == null || al.size() <= 1) 
        {
            return false;
        }

        int j = al.size() - 2;

        while (j >= 0 && al.get(j).intValue() >= al.get(j + 1).intValue()) 
        {

            // Finding the first j that is breaking descending order
            j = j - 1;
        }

        if (j >= 0) 
        {
            // if the control reaching
            // here, then it means the array
            // is not entirely descending

            // Starting from the end
            int k = al.size() - 1;

            while (al.get(k).intValue() <= al.get(j).intValue()) 
            {
                // Finding the rightmost first larger id than k
                k = k - 1;
            }

            // Switching j and k
            swapEle(al, j, k);

            // Reversing in the descending sequence
            reverseArrList(al, j + 1, al.size() - 1);

            return true;
        } else 
        {
            // Reversing the whole sequence.
            reverseArrList(al, 0, al.size() - 1);
            return false;
        }
    }
    // a Boolean method that checks whether the elements of the array list al 
    // have the valid arrangement or not.
    public boolean isValidArrangement(ArrayList<Integer> al, int s)
    {
        int chk = 1;

            for (int j = 1; j < s; j++) 
            {
                if (al.get(j) == al.get(j - 1)) 
                {
                    chk = 0;
                    break;
                }
            }

            return chk == 1;
    }

    public ArrayList<Integer> rearrangeArr(ArrayList<Integer> al, int s) 
    {   
        if(isValidArrangement(al, s))
        {
            return al;
        }
        // sorting the list so we can compute the next permutation
        Collections.sort(al);
       
        // Iterating the array list and 
        // checking whether it is a valid arrangement or not
        // if yes, then we terminate the do-while loop.
        // Otherwise, we find the next permutation.
         while (nextPermutation(al))
         {
             if(isValidArrangement(al, s))
             {
                 return al;
             }
         }

        return new ArrayList<Integer>();
    }
    
    // main method
    public static void main(String argvs[])
    {
        // creating an object of the class UniqueAdjEle 
        UniqueAdjEle obj = new UniqueAdjEle();
        
        // input 1
        ArrayList<Integer> inArr = new ArrayList<Integer>
        (
            Arrays.asList(7, 7, 6, 8)
        );
        
        // computing the size of the 
        // input array
        int size = inArr.size();
        System.out.println("For the input array: ");
        for(int i = 0; i < size; i++)
        {
            System.out.print(inArr.get(i) + " ");
        }
        System.out.println();
        ArrayList<Integer> ans = obj.rearrangeArr(inArr, size);
        if(ans.size() > 0)
        {
        System.out.println("The valid arrangement is: ");
        
        for(int i = 0; i < size; i++)
        {
            System.out.print(ans.get(i) + " ");
        }
        }
        else
        {
            System.out.println("The valid arrangement is not possible. ");
        }
        
        System.out.println( "\n" );
        
        // input 2
        inArr = new ArrayList<Integer>
        (
            Arrays.asList(2, 4, 8, 9, 5, 7, 3, 6, 1)
        );
        
        // computing the size of the 
        // input array
        size = inArr.size();
        
        System.out.println("For the input array: ");
        
        for(int i = 0; i < size; i++)
        {
            System.out.print(inArr.get(i) + " ");
        }
        
        System.out.println();
        
        ans = obj.rearrangeArr(inArr, size);
        
        if(ans.size() > 0)
        {
        System.out.println("The valid arrangement is: ");
        
        for(int i = 0; i < size; i++)
        {
            System.out.print(ans.get(i) + " ");
        }
        }
        else
        {
            System.out.println("The valid arrangement is not possible. ");
        }
        
        System.out.println( "\n" );
        
        // input 3
        inArr = new ArrayList<Integer>
        (
            Arrays.asList(3, 3, 3, 3, 3)
        );
        
        // computing the size of the 
        // input array
        size = inArr.size();
        
        System.out.println("For the input array: ");
        
        for(int i = 0; i < size; i++)
        {
            System.out.print(inArr.get(i) + " ");
        }
        
        System.out.println();
        
        ans = obj.rearrangeArr(inArr, size);
        if(ans.size() > 0)
        {
        System.out.println("The valid arrangement is: ");
        
        for(int i = 0; i < size; i++)
        {
            System.out.print(ans.get(i) + " ");
        }
        }
        else
        {
            System.out.println("The valid arrangement is not possible. ");
        }
        
    }
    
    
    
}
 Output: For the input array: 
7 7 6 8 
The valid arrangement is: 
6 7 8 7 

For the input array: 
2 4 8 9 5 7 3 6 1 
The valid arrangement is: 
2 4 8 9 5 7 3 6 1 

For the input array: 
3 3 3 3 3 
The valid arrangement is not possible.
 Complexity Analysis: Since the program is computing the permutation, the time complexity of the program is O(N!), where N is the total number of elements present in the linked list. The program uses constant space; therefore, the space complexity of the program is O(1). The above program is not suitable for the larger inputs as the time complexity of the program is too high. Therefore, we must do some optimization to reduce the time complexity. Approach: Using Set It is a greedy approach where we put first that element which is occurring the most number of times in the input array. Using the set, we will put all the elements in the order of their occurrence count. The following are the steps involved in computing the answer. Step 1: Declare an empty array or list solAl. Step 2: Sort the array or list solAl. Step 3: Declare a set st that keeps the elements and their occurrence count. Step 4: Iterate over the list or array solAl: Iterate until the same element is encountered every time. Increment the element count by 1. Put the element and the occurrence count of the element in the set st. Step 5: Create a temporary variable for keeping the previous element and its occurrence count. Step 6: While the set st is not empty, do the following: Fetch the last element and get it added to the result. Delete that element from the set st. Reduce the occurrence count of the element popped by 1. If the occurrence count was non-zero of the previous elements, put it in the set. The current element should be treated as the previous element for the upcoming iteration. Step 7: Eventually, return the list or array solAl. Implementation The implementation of the above steps is mentioned below. FileName: UniqueAdjEle.java 
// important import statements
import java.util.Arrays;
import java.util.ArrayList;
import java.util.TreeSet;
import java.util.Collections;
import java.util.Comparator;

class PairComparator implements Comparator<Pair>
{

// Overriding the compare() method of the Comparator
public int compare(Pair p1, Pair p2)
{
if (p1.first < p2.first)
{
return -1;
}
else if(p1.first == p2.first)
{
return p1.second - p2.second;
}
else if (p1.first > p2.first)
{
return 1;
}

return 0;
}
}

// class Pair contains 
// two elements one is first
// other is second
class Pair 
{
int first; 
int second;
Pair(int first, int second)
{
this.first = first;
this.second = second;
}
}
public class UniqueAdjEle1 
{
// a boolean method that checks whether the elements of the array list al 
// have the valid arrangement or not.
public boolean isValidArrangement(ArrayList<Integer> al, int s)
{
int chk = 1;

for (int j = 1; j < s; j++) 
{
if (al.get(j) == al.get(j - 1)) 
{
chk = 0;
break;
}
}

return chk == 1;
}

public ArrayList<Integer> rearrangeArr(ArrayList<Integer> al, int s) 
{
if(isValidArrangement(al, s))
{
// the arrangement is valid
// hence, there is no need to proceed further
return al;
}

// Sorting the list or array al
Collections.sort(al);

// Declaring a set st that keeps the elements and their
// occurrence count.
TreeSet<Pair> st = new TreeSet<>(new PairComparator());


// Iterating over the list or array al
// Iterating until the element is the same
// Incrementing the element count by 1. 
// Inserting the element and its occurrence count in the set st
for (int j = 0; j < s; j++)
{

int k = j;
while (j < s && k < s && (al.get(j).equals(al.get(k))))
{
k = k + 1;
}
st.add(new Pair(k - j, al.get(j)));

j = k - 1;
}

int prv = -1;
int prvFreq = 0;

// Declaring an empty array or list solAl
ArrayList<Integer> solAl = new ArrayList<>();

while (st.size() != 0)
{
Pair pr = st.last();
st.remove(pr);
solAl.add(pr.second);

if (prvFreq > 0)
{
st.add(new Pair(prvFreq, prv));
}

prvFreq = pr.first - 1;
prv = pr.second;
}

// calculating the new size of the 
// rearranged array list
int newSize = solAl.size();

// if the new size after the rearrangement
// if the array list is not equal to the size s
// then, the valid rearrangement is not possible
if(newSize != s)
{
return new ArrayList<Integer>();
}

return solAl;
}


// main method
public static void main(String argvs[])
{
// creating an object of the class UniqueAdjEle1 
UniqueAdjEle1 obj = new UniqueAdjEle1();

// input 1
ArrayList<Integer> inArr = new ArrayList<Integer>
(
Arrays.asList(7, 7, 6, 8)
);

// computing the size of the 
// input array
int size = inArr.size();
System.out.println("For the input array: ");
for(int i = 0; i < size; i++)
{
System.out.print(inArr.get(i) + " ");
}
System.out.println();
ArrayList<Integer> ans = obj.rearrangeArr(inArr, size);
if(ans.size() > 0)
{
System.out.println("The valid arrangement is: ");

for(int i = 0; i < size; i++)
{
System.out.print(ans.get(i) + " ");
}
}
else
{
System.out.println("The valid arrangement is not possible. ");
}

System.out.println( "\n" );

// input 2
inArr = new ArrayList<Integer>
(
Arrays.asList(2, 4, 8, 9, 5, 7, 3, 6, 1)
);

// computing the size of the 
// input array
size = inArr.size();

System.out.println("For the input array: ");

for(int i = 0; i < size; i++)
{
System.out.print(inArr.get(i) + " ");
}

System.out.println();

ans = obj.rearrangeArr(inArr, size);

if(ans.size() > 0)
{
System.out.println("The valid arrangement is: ");

for(int i = 0; i < size; i++)
{
System.out.print(ans.get(i) + " ");
}
}
else
{
System.out.println("The valid arrangement is not possible. ");
}

System.out.println( "\n" );

// input 3
inArr = new ArrayList<Integer>
(
Arrays.asList(3, 3, 3, 3, 3)
);

// computing the size of the 
// input array
size = inArr.size();

System.out.println("For the input array: ");

for(int i = 0; i < size; i++)
{
System.out.print(inArr.get(i) + " ");
}

System.out.println();

ans = obj.rearrangeArr(inArr, size);
if(ans.size() > 0)
{
System.out.println("The valid arrangement is: ");

for(int i = 0; i < size; i++)
{
System.out.print(ans.get(i) + " ");
}
}
else
{
System.out.println("The valid arrangement is not possible. ");
}

}

}
 Output: For the input array: 
7 7 6 8 
The valid arrangement is: 
7 8 7 6 

For the input array: 
2 4 8 9 5 7 3 6 1 
The valid arrangement is: 
2 4 8 9 5 7 3 6 1 

For the input array: 
3 3 3 3 3 
The valid arrangement is not possible.
 Complexity Analysis: Since the program is using sorting, the time complexity of the program is O(N * log(N)). The program uses a set to store the elements and their occurrence count. The program is also using an auxiliary array (arr). Thus, making the space complexity of the program as (N), where N is the total number of elements present in the input array. Note: Instead of Set, a priority queue can also be used. In that case, also, the time and space complexity remain the same. Next Topic# ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/unequal-adjacent-elements-in-java Unequal Adjacent Elements in Java - Javatpoint ? SCROLL TO TOP Home Java Programs OOPs String Exception Multithreading Collections JavaFX JSP Spring Spring Boot Projects Interview Questions Java Tutorial What is Java History of Java Features of Java C++ vs Java Hello Java Program Program Internal How to set path? JDK, JRE and JVM JVM: Java Virtual Machine Java Variables Java Data Types Unicode System Operators Keywords Control Statements Java Control Statements Java If-else Java Switch Java For Loop Java While Loop Java Do While Loop Java Break Java Continue Java Comments Java Programs Java Object Class Java OOPs Concepts Naming Convention Object and Class Method Constructor static keyword this keyword Java Inheritance Inheritance(IS-A) Aggregation(HAS-A) Java Polymorphism Method Overloading Method Overriding Covariant Return Type super keyword Instance Initializer block final keyword Runtime Polymorphism Dynamic Binding instanceof operator Java Abstraction Abstract class Interface Abstract vs Interface Java Encapsulation Package Access Modifiers Encapsulation Java Array Java Array Java OOPs Misc Object class Object Cloning Math class Wrapper Class Java Recursion Call By Value strictfp keyword javadoc tool Command Line Arg Object vs Class Overloading vs Overriding Java String Java Regex Exception Handling Java Inner classes Java Multithreading Java I/O Java Networking Java AWT & Events Java Swing JavaFX Java Applet Java Reflection Java Date Java Conversion Java Collection Java JDBC Java Misc Java New Features RMI Internationalization Interview Questions Java MCQ next ? ? prev Unequal Adjacent Elements in Java An array inArr containing n numbers (positive or negative) is given. The task is to return the array after the rearrangement of elements of the integers in such a way that no two adjacent elements are equal. If there are multiple valid arrangements, then any one valid arrangement can be returned. If the input array does not contain any valid arrangement, then an appropriate message can be displayed on the console. Example 1: Input int inArr[] = {7, 7, 6, 8} Output: {7, 6, 7, 8} Explanation: There are many valid arrangements possible. Those valid arrangements are mentioned below. {7, 6, 7, 8}, {7, 6, 8, 7}, {7, 8, 7, 6}, {7, 8, 6, 7}, {8, 7, 6, 7}, {6, 7, 8, 7}. Out of which {7, 6, 7, 8} is mentioned in the output. Example 2: Input int inArr[] = {2, 4, 8, 9, 5, 7, 3, 6, 1} Output: {2, 4, 8, 9, 5, 7, 3, 6, 1} Explanation: The input array is given in such a way that there are no two elements that are of the same value. Hence, the input arrays are themselves the answer. Example 3: Input int arr[] = {3, 3, 3, 3, 3} Output: no valid arrangement is possible where adjacent elements are of different values. Explanation: All the elements are of the same value. Hence, no valid arrangement is possible. Approach: Brute Force In this approach, we compute all the arrangements of the input array. If any valid arrangement comes, we return that arrangement. If no valid arrangement is possible, display the appropriate message. For computing the valid arrangement, first, we will sort the array in ascending order. Then we will find the next permutation of the sorted array and check whether it is a valid arrangement or not. If it is a valid arrangement, then we can return that arrangement. If not, then we will find the next permutation and continue to do so until we find a valid arrangement or all the arrangements are exhausted. If the arrangements are exhausted, then we can say that no valid arrangement is there for the given input array, and the same is illustrated in the following program. FileName: UniqueAdjEle.java 
// important import statements
import java.util.Collections;
import java.util.ArrayList;
import java.util.Arrays;


public class UniqueAdjEle 
{
    // swapping the elements in the array list al
    // that are present at the index j and k
    private void swapEle(ArrayList<Integer> al, int j, int k) 
    {
        int temp = al.get(j);
        al.set(j, al.get(k));
        al.set(k, temp);
    }
    // reversing the array list from j to k
    private void reverseArrList(ArrayList<Integer> al, int j, int k) 
    {
        while (j < k) 
        {
            swapEle(al, j, k);
            j = j + 1;
            k = k - 1;
        }
    }

    private boolean nextPermutation(ArrayList<Integer> al) 
    {
        // if the list has no elements
        // or the single element, then
        // there is no need to proceed further
        if (al == null || al.size() <= 1) 
        {
            return false;
        }

        int j = al.size() - 2;

        while (j >= 0 && al.get(j).intValue() >= al.get(j + 1).intValue()) 
        {

            // Finding the first j that is breaking descending order
            j = j - 1;
        }

        if (j >= 0) 
        {
            // if the control reaching
            // here, then it means the array
            // is not entirely descending

            // Starting from the end
            int k = al.size() - 1;

            while (al.get(k).intValue() <= al.get(j).intValue()) 
            {
                // Finding the rightmost first larger id than k
                k = k - 1;
            }

            // Switching j and k
            swapEle(al, j, k);

            // Reversing in the descending sequence
            reverseArrList(al, j + 1, al.size() - 1);

            return true;
        } else 
        {
            // Reversing the whole sequence.
            reverseArrList(al, 0, al.size() - 1);
            return false;
        }
    }
    // a Boolean method that checks whether the elements of the array list al 
    // have the valid arrangement or not.
    public boolean isValidArrangement(ArrayList<Integer> al, int s)
    {
        int chk = 1;

            for (int j = 1; j < s; j++) 
            {
                if (al.get(j) == al.get(j - 1)) 
                {
                    chk = 0;
                    break;
                }
            }

            return chk == 1;
    }

    public ArrayList<Integer> rearrangeArr(ArrayList<Integer> al, int s) 
    {   
        if(isValidArrangement(al, s))
        {
            return al;
        }
        // sorting the list so we can compute the next permutation
        Collections.sort(al);
       
        // Iterating the array list and 
        // checking whether it is a valid arrangement or not
        // if yes, then we terminate the do-while loop.
        // Otherwise, we find the next permutation.
         while (nextPermutation(al))
         {
             if(isValidArrangement(al, s))
             {
                 return al;
             }
         }

        return new ArrayList<Integer>();
    }
    
    // main method
    public static void main(String argvs[])
    {
        // creating an object of the class UniqueAdjEle 
        UniqueAdjEle obj = new UniqueAdjEle();
        
        // input 1
        ArrayList<Integer> inArr = new ArrayList<Integer>
        (
            Arrays.asList(7, 7, 6, 8)
        );
        
        // computing the size of the 
        // input array
        int size = inArr.size();
        System.out.println("For the input array: ");
        for(int i = 0; i < size; i++)
        {
            System.out.print(inArr.get(i) + " ");
        }
        System.out.println();
        ArrayList<Integer> ans = obj.rearrangeArr(inArr, size);
        if(ans.size() > 0)
        {
        System.out.println("The valid arrangement is: ");
        
        for(int i = 0; i < size; i++)
        {
            System.out.print(ans.get(i) + " ");
        }
        }
        else
        {
            System.out.println("The valid arrangement is not possible. ");
        }
        
        System.out.println( "\n" );
        
        // input 2
        inArr = new ArrayList<Integer>
        (
            Arrays.asList(2, 4, 8, 9, 5, 7, 3, 6, 1)
        );
        
        // computing the size of the 
        // input array
        size = inArr.size();
        
        System.out.println("For the input array: ");
        
        for(int i = 0; i < size; i++)
        {
            System.out.print(inArr.get(i) + " ");
        }
        
        System.out.println();
        
        ans = obj.rearrangeArr(inArr, size);
        
        if(ans.size() > 0)
        {
        System.out.println("The valid arrangement is: ");
        
        for(int i = 0; i < size; i++)
        {
            System.out.print(ans.get(i) + " ");
        }
        }
        else
        {
            System.out.println("The valid arrangement is not possible. ");
        }
        
        System.out.println( "\n" );
        
        // input 3
        inArr = new ArrayList<Integer>
        (
            Arrays.asList(3, 3, 3, 3, 3)
        );
        
        // computing the size of the 
        // input array
        size = inArr.size();
        
        System.out.println("For the input array: ");
        
        for(int i = 0; i < size; i++)
        {
            System.out.print(inArr.get(i) + " ");
        }
        
        System.out.println();
        
        ans = obj.rearrangeArr(inArr, size);
        if(ans.size() > 0)
        {
        System.out.println("The valid arrangement is: ");
        
        for(int i = 0; i < size; i++)
        {
            System.out.print(ans.get(i) + " ");
        }
        }
        else
        {
            System.out.println("The valid arrangement is not possible. ");
        }
        
    }
    
    
    
}
 Output: For the input array: 
7 7 6 8 
The valid arrangement is: 
6 7 8 7 

For the input array: 
2 4 8 9 5 7 3 6 1 
The valid arrangement is: 
2 4 8 9 5 7 3 6 1 

For the input array: 
3 3 3 3 3 
The valid arrangement is not possible.
 Complexity Analysis: Since the program is computing the permutation, the time complexity of the program is O(N!), where N is the total number of elements present in the linked list. The program uses constant space; therefore, the space complexity of the program is O(1). The above program is not suitable for the larger inputs as the time complexity of the program is too high. Therefore, we must do some optimization to reduce the time complexity. Approach: Using Set It is a greedy approach where we put first that element which is occurring the most number of times in the input array. Using the set, we will put all the elements in the order of their occurrence count. The following are the steps involved in computing the answer. Step 1: Declare an empty array or list solAl. Step 2: Sort the array or list solAl. Step 3: Declare a set st that keeps the elements and their occurrence count. Step 4: Iterate over the list or array solAl: Iterate until the same element is encountered every time. Increment the element count by 1. Put the element and the occurrence count of the element in the set st. Step 5: Create a temporary variable for keeping the previous element and its occurrence count. Step 6: While the set st is not empty, do the following: Fetch the last element and get it added to the result. Delete that element from the set st. Reduce the occurrence count of the element popped by 1. If the occurrence count was non-zero of the previous elements, put it in the set. The current element should be treated as the previous element for the upcoming iteration. Step 7: Eventually, return the list or array solAl. Implementation The implementation of the above steps is mentioned below. FileName: UniqueAdjEle.java 
// important import statements
import java.util.Arrays;
import java.util.ArrayList;
import java.util.TreeSet;
import java.util.Collections;
import java.util.Comparator;

class PairComparator implements Comparator<Pair>
{

// Overriding the compare() method of the Comparator
public int compare(Pair p1, Pair p2)
{
if (p1.first < p2.first)
{
return -1;
}
else if(p1.first == p2.first)
{
return p1.second - p2.second;
}
else if (p1.first > p2.first)
{
return 1;
}

return 0;
}
}

// class Pair contains 
// two elements one is first
// other is second
class Pair 
{
int first; 
int second;
Pair(int first, int second)
{
this.first = first;
this.second = second;
}
}
public class UniqueAdjEle1 
{
// a boolean method that checks whether the elements of the array list al 
// have the valid arrangement or not.
public boolean isValidArrangement(ArrayList<Integer> al, int s)
{
int chk = 1;

for (int j = 1; j < s; j++) 
{
if (al.get(j) == al.get(j - 1)) 
{
chk = 0;
break;
}
}

return chk == 1;
}

public ArrayList<Integer> rearrangeArr(ArrayList<Integer> al, int s) 
{
if(isValidArrangement(al, s))
{
// the arrangement is valid
// hence, there is no need to proceed further
return al;
}

// Sorting the list or array al
Collections.sort(al);

// Declaring a set st that keeps the elements and their
// occurrence count.
TreeSet<Pair> st = new TreeSet<>(new PairComparator());


// Iterating over the list or array al
// Iterating until the element is the same
// Incrementing the element count by 1. 
// Inserting the element and its occurrence count in the set st
for (int j = 0; j < s; j++)
{

int k = j;
while (j < s && k < s && (al.get(j).equals(al.get(k))))
{
k = k + 1;
}
st.add(new Pair(k - j, al.get(j)));

j = k - 1;
}

int prv = -1;
int prvFreq = 0;

// Declaring an empty array or list solAl
ArrayList<Integer> solAl = new ArrayList<>();

while (st.size() != 0)
{
Pair pr = st.last();
st.remove(pr);
solAl.add(pr.second);

if (prvFreq > 0)
{
st.add(new Pair(prvFreq, prv));
}

prvFreq = pr.first - 1;
prv = pr.second;
}

// calculating the new size of the 
// rearranged array list
int newSize = solAl.size();

// if the new size after the rearrangement
// if the array list is not equal to the size s
// then, the valid rearrangement is not possible
if(newSize != s)
{
return new ArrayList<Integer>();
}

return solAl;
}


// main method
public static void main(String argvs[])
{
// creating an object of the class UniqueAdjEle1 
UniqueAdjEle1 obj = new UniqueAdjEle1();

// input 1
ArrayList<Integer> inArr = new ArrayList<Integer>
(
Arrays.asList(7, 7, 6, 8)
);

// computing the size of the 
// input array
int size = inArr.size();
System.out.println("For the input array: ");
for(int i = 0; i < size; i++)
{
System.out.print(inArr.get(i) + " ");
}
System.out.println();
ArrayList<Integer> ans = obj.rearrangeArr(inArr, size);
if(ans.size() > 0)
{
System.out.println("The valid arrangement is: ");

for(int i = 0; i < size; i++)
{
System.out.print(ans.get(i) + " ");
}
}
else
{
System.out.println("The valid arrangement is not possible. ");
}

System.out.println( "\n" );

// input 2
inArr = new ArrayList<Integer>
(
Arrays.asList(2, 4, 8, 9, 5, 7, 3, 6, 1)
);

// computing the size of the 
// input array
size = inArr.size();

System.out.println("For the input array: ");

for(int i = 0; i < size; i++)
{
System.out.print(inArr.get(i) + " ");
}

System.out.println();

ans = obj.rearrangeArr(inArr, size);

if(ans.size() > 0)
{
System.out.println("The valid arrangement is: ");

for(int i = 0; i < size; i++)
{
System.out.print(ans.get(i) + " ");
}
}
else
{
System.out.println("The valid arrangement is not possible. ");
}

System.out.println( "\n" );

// input 3
inArr = new ArrayList<Integer>
(
Arrays.asList(3, 3, 3, 3, 3)
);

// computing the size of the 
// input array
size = inArr.size();

System.out.println("For the input array: ");

for(int i = 0; i < size; i++)
{
System.out.print(inArr.get(i) + " ");
}

System.out.println();

ans = obj.rearrangeArr(inArr, size);
if(ans.size() > 0)
{
System.out.println("The valid arrangement is: ");

for(int i = 0; i < size; i++)
{
System.out.print(ans.get(i) + " ");
}
}
else
{
System.out.println("The valid arrangement is not possible. ");
}

}

}
 Output: For the input array: 
7 7 6 8 
The valid arrangement is: 
7 8 7 6 

For the input array: 
2 4 8 9 5 7 3 6 1 
The valid arrangement is: 
2 4 8 9 5 7 3 6 1 

For the input array: 
3 3 3 3 3 
The valid arrangement is not possible.
 Complexity Analysis: Since the program is using sorting, the time complexity of the program is O(N * log(N)). The program uses a set to store the elements and their occurrence count. The program is also using an auxiliary array (arr). Thus, making the space complexity of the program as (N), where N is the total number of elements present in the input array. Note: Instead of Set, a priority queue can also be used. In that case, also, the time and space complexity remain the same. Next Topic# ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/unequal-adjacent-elements-in-java Unequal Adjacent Elements in Java - Javatpoint ? SCROLL TO TOP Home Java Programs OOPs String Exception Multithreading Collections JavaFX JSP Spring Spring Boot Projects Interview Questions Java Tutorial What is Java History of Java Features of Java C++ vs Java Hello Java Program Program Internal How to set path? JDK, JRE and JVM JVM: Java Virtual Machine Java Variables Java Data Types Unicode System Operators Keywords Control Statements Java Control Statements Java If-else Java Switch Java For Loop Java While Loop Java Do While Loop Java Break Java Continue Java Comments Java Programs Java Object Class Java OOPs Concepts Naming Convention Object and Class Method Constructor static keyword this keyword Java Inheritance Inheritance(IS-A) Aggregation(HAS-A) Java Polymorphism Method Overloading Method Overriding Covariant Return Type super keyword Instance Initializer block final keyword Runtime Polymorphism Dynamic Binding instanceof operator Java Abstraction Abstract class Interface Abstract vs Interface Java Encapsulation Package Access Modifiers Encapsulation Java Array Java Array Java OOPs Misc Object class Object Cloning Math class Wrapper Class Java Recursion Call By Value strictfp keyword javadoc tool Command Line Arg Object vs Class Overloading vs Overriding Java String Java Regex Exception Handling Java Inner classes Java Multithreading Java I/O Java Networking Java AWT & Events Java Swing JavaFX Java Applet Java Reflection Java Date Java Conversion Java Collection Java JDBC Java Misc Java New Features RMI Internationalization Interview Questions Java MCQ next ? ? prev Unequal Adjacent Elements in Java An array inArr containing n numbers (positive or negative) is given. The task is to return the array after the rearrangement of elements of the integers in such a way that no two adjacent elements are equal. If there are multiple valid arrangements, then any one valid arrangement can be returned. If the input array does not contain any valid arrangement, then an appropriate message can be displayed on the console. Example 1: Input int inArr[] = {7, 7, 6, 8} Output: {7, 6, 7, 8} Explanation: There are many valid arrangements possible. Those valid arrangements are mentioned below. {7, 6, 7, 8}, {7, 6, 8, 7}, {7, 8, 7, 6}, {7, 8, 6, 7}, {8, 7, 6, 7}, {6, 7, 8, 7}. Out of which {7, 6, 7, 8} is mentioned in the output. Example 2: Input int inArr[] = {2, 4, 8, 9, 5, 7, 3, 6, 1} Output: {2, 4, 8, 9, 5, 7, 3, 6, 1} Explanation: The input array is given in such a way that there are no two elements that are of the same value. Hence, the input arrays are themselves the answer. Example 3: Input int arr[] = {3, 3, 3, 3, 3} Output: no valid arrangement is possible where adjacent elements are of different values. Explanation: All the elements are of the same value. Hence, no valid arrangement is possible. Approach: Brute Force In this approach, we compute all the arrangements of the input array. If any valid arrangement comes, we return that arrangement. If no valid arrangement is possible, display the appropriate message. For computing the valid arrangement, first, we will sort the array in ascending order. Then we will find the next permutation of the sorted array and check whether it is a valid arrangement or not. If it is a valid arrangement, then we can return that arrangement. If not, then we will find the next permutation and continue to do so until we find a valid arrangement or all the arrangements are exhausted. If the arrangements are exhausted, then we can say that no valid arrangement is there for the given input array, and the same is illustrated in the following program. FileName: UniqueAdjEle.java 
// important import statements
import java.util.Collections;
import java.util.ArrayList;
import java.util.Arrays;


public class UniqueAdjEle 
{
    // swapping the elements in the array list al
    // that are present at the index j and k
    private void swapEle(ArrayList<Integer> al, int j, int k) 
    {
        int temp = al.get(j);
        al.set(j, al.get(k));
        al.set(k, temp);
    }
    // reversing the array list from j to k
    private void reverseArrList(ArrayList<Integer> al, int j, int k) 
    {
        while (j < k) 
        {
            swapEle(al, j, k);
            j = j + 1;
            k = k - 1;
        }
    }

    private boolean nextPermutation(ArrayList<Integer> al) 
    {
        // if the list has no elements
        // or the single element, then
        // there is no need to proceed further
        if (al == null || al.size() <= 1) 
        {
            return false;
        }

        int j = al.size() - 2;

        while (j >= 0 && al.get(j).intValue() >= al.get(j + 1).intValue()) 
        {

            // Finding the first j that is breaking descending order
            j = j - 1;
        }

        if (j >= 0) 
        {
            // if the control reaching
            // here, then it means the array
            // is not entirely descending

            // Starting from the end
            int k = al.size() - 1;

            while (al.get(k).intValue() <= al.get(j).intValue()) 
            {
                // Finding the rightmost first larger id than k
                k = k - 1;
            }

            // Switching j and k
            swapEle(al, j, k);

            // Reversing in the descending sequence
            reverseArrList(al, j + 1, al.size() - 1);

            return true;
        } else 
        {
            // Reversing the whole sequence.
            reverseArrList(al, 0, al.size() - 1);
            return false;
        }
    }
    // a Boolean method that checks whether the elements of the array list al 
    // have the valid arrangement or not.
    public boolean isValidArrangement(ArrayList<Integer> al, int s)
    {
        int chk = 1;

            for (int j = 1; j < s; j++) 
            {
                if (al.get(j) == al.get(j - 1)) 
                {
                    chk = 0;
                    break;
                }
            }

            return chk == 1;
    }

    public ArrayList<Integer> rearrangeArr(ArrayList<Integer> al, int s) 
    {   
        if(isValidArrangement(al, s))
        {
            return al;
        }
        // sorting the list so we can compute the next permutation
        Collections.sort(al);
       
        // Iterating the array list and 
        // checking whether it is a valid arrangement or not
        // if yes, then we terminate the do-while loop.
        // Otherwise, we find the next permutation.
         while (nextPermutation(al))
         {
             if(isValidArrangement(al, s))
             {
                 return al;
             }
         }

        return new ArrayList<Integer>();
    }
    
    // main method
    public static void main(String argvs[])
    {
        // creating an object of the class UniqueAdjEle 
        UniqueAdjEle obj = new UniqueAdjEle();
        
        // input 1
        ArrayList<Integer> inArr = new ArrayList<Integer>
        (
            Arrays.asList(7, 7, 6, 8)
        );
        
        // computing the size of the 
        // input array
        int size = inArr.size();
        System.out.println("For the input array: ");
        for(int i = 0; i < size; i++)
        {
            System.out.print(inArr.get(i) + " ");
        }
        System.out.println();
        ArrayList<Integer> ans = obj.rearrangeArr(inArr, size);
        if(ans.size() > 0)
        {
        System.out.println("The valid arrangement is: ");
        
        for(int i = 0; i < size; i++)
        {
            System.out.print(ans.get(i) + " ");
        }
        }
        else
        {
            System.out.println("The valid arrangement is not possible. ");
        }
        
        System.out.println( "\n" );
        
        // input 2
        inArr = new ArrayList<Integer>
        (
            Arrays.asList(2, 4, 8, 9, 5, 7, 3, 6, 1)
        );
        
        // computing the size of the 
        // input array
        size = inArr.size();
        
        System.out.println("For the input array: ");
        
        for(int i = 0; i < size; i++)
        {
            System.out.print(inArr.get(i) + " ");
        }
        
        System.out.println();
        
        ans = obj.rearrangeArr(inArr, size);
        
        if(ans.size() > 0)
        {
        System.out.println("The valid arrangement is: ");
        
        for(int i = 0; i < size; i++)
        {
            System.out.print(ans.get(i) + " ");
        }
        }
        else
        {
            System.out.println("The valid arrangement is not possible. ");
        }
        
        System.out.println( "\n" );
        
        // input 3
        inArr = new ArrayList<Integer>
        (
            Arrays.asList(3, 3, 3, 3, 3)
        );
        
        // computing the size of the 
        // input array
        size = inArr.size();
        
        System.out.println("For the input array: ");
        
        for(int i = 0; i < size; i++)
        {
            System.out.print(inArr.get(i) + " ");
        }
        
        System.out.println();
        
        ans = obj.rearrangeArr(inArr, size);
        if(ans.size() > 0)
        {
        System.out.println("The valid arrangement is: ");
        
        for(int i = 0; i < size; i++)
        {
            System.out.print(ans.get(i) + " ");
        }
        }
        else
        {
            System.out.println("The valid arrangement is not possible. ");
        }
        
    }
    
    
    
}
 Output: For the input array: 
7 7 6 8 
The valid arrangement is: 
6 7 8 7 

For the input array: 
2 4 8 9 5 7 3 6 1 
The valid arrangement is: 
2 4 8 9 5 7 3 6 1 

For the input array: 
3 3 3 3 3 
The valid arrangement is not possible.
 Complexity Analysis: Since the program is computing the permutation, the time complexity of the program is O(N!), where N is the total number of elements present in the linked list. The program uses constant space; therefore, the space complexity of the program is O(1). The above program is not suitable for the larger inputs as the time complexity of the program is too high. Therefore, we must do some optimization to reduce the time complexity. Approach: Using Set It is a greedy approach where we put first that element which is occurring the most number of times in the input array. Using the set, we will put all the elements in the order of their occurrence count. The following are the steps involved in computing the answer. Step 1: Declare an empty array or list solAl. Step 2: Sort the array or list solAl. Step 3: Declare a set st that keeps the elements and their occurrence count. Step 4: Iterate over the list or array solAl: Iterate until the same element is encountered every time. Increment the element count by 1. Put the element and the occurrence count of the element in the set st. Step 5: Create a temporary variable for keeping the previous element and its occurrence count. Step 6: While the set st is not empty, do the following: Fetch the last element and get it added to the result. Delete that element from the set st. Reduce the occurrence count of the element popped by 1. If the occurrence count was non-zero of the previous elements, put it in the set. The current element should be treated as the previous element for the upcoming iteration. Step 7: Eventually, return the list or array solAl. Implementation The implementation of the above steps is mentioned below. FileName: UniqueAdjEle.java 
// important import statements
import java.util.Arrays;
import java.util.ArrayList;
import java.util.TreeSet;
import java.util.Collections;
import java.util.Comparator;

class PairComparator implements Comparator<Pair>
{

// Overriding the compare() method of the Comparator
public int compare(Pair p1, Pair p2)
{
if (p1.first < p2.first)
{
return -1;
}
else if(p1.first == p2.first)
{
return p1.second - p2.second;
}
else if (p1.first > p2.first)
{
return 1;
}

return 0;
}
}

// class Pair contains 
// two elements one is first
// other is second
class Pair 
{
int first; 
int second;
Pair(int first, int second)
{
this.first = first;
this.second = second;
}
}
public class UniqueAdjEle1 
{
// a boolean method that checks whether the elements of the array list al 
// have the valid arrangement or not.
public boolean isValidArrangement(ArrayList<Integer> al, int s)
{
int chk = 1;

for (int j = 1; j < s; j++) 
{
if (al.get(j) == al.get(j - 1)) 
{
chk = 0;
break;
}
}

return chk == 1;
}

public ArrayList<Integer> rearrangeArr(ArrayList<Integer> al, int s) 
{
if(isValidArrangement(al, s))
{
// the arrangement is valid
// hence, there is no need to proceed further
return al;
}

// Sorting the list or array al
Collections.sort(al);

// Declaring a set st that keeps the elements and their
// occurrence count.
TreeSet<Pair> st = new TreeSet<>(new PairComparator());


// Iterating over the list or array al
// Iterating until the element is the same
// Incrementing the element count by 1. 
// Inserting the element and its occurrence count in the set st
for (int j = 0; j < s; j++)
{

int k = j;
while (j < s && k < s && (al.get(j).equals(al.get(k))))
{
k = k + 1;
}
st.add(new Pair(k - j, al.get(j)));

j = k - 1;
}

int prv = -1;
int prvFreq = 0;

// Declaring an empty array or list solAl
ArrayList<Integer> solAl = new ArrayList<>();

while (st.size() != 0)
{
Pair pr = st.last();
st.remove(pr);
solAl.add(pr.second);

if (prvFreq > 0)
{
st.add(new Pair(prvFreq, prv));
}

prvFreq = pr.first - 1;
prv = pr.second;
}

// calculating the new size of the 
// rearranged array list
int newSize = solAl.size();

// if the new size after the rearrangement
// if the array list is not equal to the size s
// then, the valid rearrangement is not possible
if(newSize != s)
{
return new ArrayList<Integer>();
}

return solAl;
}


// main method
public static void main(String argvs[])
{
// creating an object of the class UniqueAdjEle1 
UniqueAdjEle1 obj = new UniqueAdjEle1();

// input 1
ArrayList<Integer> inArr = new ArrayList<Integer>
(
Arrays.asList(7, 7, 6, 8)
);

// computing the size of the 
// input array
int size = inArr.size();
System.out.println("For the input array: ");
for(int i = 0; i < size; i++)
{
System.out.print(inArr.get(i) + " ");
}
System.out.println();
ArrayList<Integer> ans = obj.rearrangeArr(inArr, size);
if(ans.size() > 0)
{
System.out.println("The valid arrangement is: ");

for(int i = 0; i < size; i++)
{
System.out.print(ans.get(i) + " ");
}
}
else
{
System.out.println("The valid arrangement is not possible. ");
}

System.out.println( "\n" );

// input 2
inArr = new ArrayList<Integer>
(
Arrays.asList(2, 4, 8, 9, 5, 7, 3, 6, 1)
);

// computing the size of the 
// input array
size = inArr.size();

System.out.println("For the input array: ");

for(int i = 0; i < size; i++)
{
System.out.print(inArr.get(i) + " ");
}

System.out.println();

ans = obj.rearrangeArr(inArr, size);

if(ans.size() > 0)
{
System.out.println("The valid arrangement is: ");

for(int i = 0; i < size; i++)
{
System.out.print(ans.get(i) + " ");
}
}
else
{
System.out.println("The valid arrangement is not possible. ");
}

System.out.println( "\n" );

// input 3
inArr = new ArrayList<Integer>
(
Arrays.asList(3, 3, 3, 3, 3)
);

// computing the size of the 
// input array
size = inArr.size();

System.out.println("For the input array: ");

for(int i = 0; i < size; i++)
{
System.out.print(inArr.get(i) + " ");
}

System.out.println();

ans = obj.rearrangeArr(inArr, size);
if(ans.size() > 0)
{
System.out.println("The valid arrangement is: ");

for(int i = 0; i < size; i++)
{
System.out.print(ans.get(i) + " ");
}
}
else
{
System.out.println("The valid arrangement is not possible. ");
}

}

}
 Output: For the input array: 
7 7 6 8 
The valid arrangement is: 
7 8 7 6 

For the input array: 
2 4 8 9 5 7 3 6 1 
The valid arrangement is: 
2 4 8 9 5 7 3 6 1 

For the input array: 
3 3 3 3 3 
The valid arrangement is not possible.
 Complexity Analysis: Since the program is using sorting, the time complexity of the program is O(N * log(N)). The program uses a set to store the elements and their occurrence count. The program is also using an auxiliary array (arr). Thus, making the space complexity of the program as (N), where N is the total number of elements present in the input array. Note: Instead of Set, a priority queue can also be used. In that case, also, the time and space complexity remain the same. Next Topic# ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/unequal-adjacent-elements-in-java Unequal Adjacent Elements in Java - Javatpoint ? SCROLL TO TOP Home Java Programs OOPs String Exception Multithreading Collections JavaFX JSP Spring Spring Boot Projects Interview Questions Java Tutorial What is Java History of Java Features of Java C++ vs Java Hello Java Program Program Internal How to set path? JDK, JRE and JVM JVM: Java Virtual Machine Java Variables Java Data Types Unicode System Operators Keywords Control Statements Java Control Statements Java If-else Java Switch Java For Loop Java While Loop Java Do While Loop Java Break Java Continue Java Comments Java Programs Java Object Class Java OOPs Concepts Naming Convention Object and Class Method Constructor static keyword this keyword Java Inheritance Inheritance(IS-A) Aggregation(HAS-A) Java Polymorphism Method Overloading Method Overriding Covariant Return Type super keyword Instance Initializer block final keyword Runtime Polymorphism Dynamic Binding instanceof operator Java Abstraction Abstract class Interface Abstract vs Interface Java Encapsulation Package Access Modifiers Encapsulation Java Array Java Array Java OOPs Misc Object class Object Cloning Math class Wrapper Class Java Recursion Call By Value strictfp keyword javadoc tool Command Line Arg Object vs Class Overloading vs Overriding Java String Java Regex Exception Handling Java Inner classes Java Multithreading Java I/O Java Networking Java AWT & Events Java Swing JavaFX Java Applet Java Reflection Java Date Java Conversion Java Collection Java JDBC Java Misc Java New Features RMI Internationalization Interview Questions Java MCQ next ? ? prev Unequal Adjacent Elements in Java An array inArr containing n numbers (positive or negative) is given. The task is to return the array after the rearrangement of elements of the integers in such a way that no two adjacent elements are equal. If there are multiple valid arrangements, then any one valid arrangement can be returned. If the input array does not contain any valid arrangement, then an appropriate message can be displayed on the console. Example 1: Input int inArr[] = {7, 7, 6, 8} Output: {7, 6, 7, 8} Explanation: There are many valid arrangements possible. Those valid arrangements are mentioned below. {7, 6, 7, 8}, {7, 6, 8, 7}, {7, 8, 7, 6}, {7, 8, 6, 7}, {8, 7, 6, 7}, {6, 7, 8, 7}. Out of which {7, 6, 7, 8} is mentioned in the output. Example 2: Input int inArr[] = {2, 4, 8, 9, 5, 7, 3, 6, 1} Output: {2, 4, 8, 9, 5, 7, 3, 6, 1} Explanation: The input array is given in such a way that there are no two elements that are of the same value. Hence, the input arrays are themselves the answer. Example 3: Input int arr[] = {3, 3, 3, 3, 3} Output: no valid arrangement is possible where adjacent elements are of different values. Explanation: All the elements are of the same value. Hence, no valid arrangement is possible. Approach: Brute Force In this approach, we compute all the arrangements of the input array. If any valid arrangement comes, we return that arrangement. If no valid arrangement is possible, display the appropriate message. For computing the valid arrangement, first, we will sort the array in ascending order. Then we will find the next permutation of the sorted array and check whether it is a valid arrangement or not. If it is a valid arrangement, then we can return that arrangement. If not, then we will find the next permutation and continue to do so until we find a valid arrangement or all the arrangements are exhausted. If the arrangements are exhausted, then we can say that no valid arrangement is there for the given input array, and the same is illustrated in the following program. FileName: UniqueAdjEle.java 
// important import statements
import java.util.Collections;
import java.util.ArrayList;
import java.util.Arrays;


public class UniqueAdjEle 
{
    // swapping the elements in the array list al
    // that are present at the index j and k
    private void swapEle(ArrayList<Integer> al, int j, int k) 
    {
        int temp = al.get(j);
        al.set(j, al.get(k));
        al.set(k, temp);
    }
    // reversing the array list from j to k
    private void reverseArrList(ArrayList<Integer> al, int j, int k) 
    {
        while (j < k) 
        {
            swapEle(al, j, k);
            j = j + 1;
            k = k - 1;
        }
    }

    private boolean nextPermutation(ArrayList<Integer> al) 
    {
        // if the list has no elements
        // or the single element, then
        // there is no need to proceed further
        if (al == null || al.size() <= 1) 
        {
            return false;
        }

        int j = al.size() - 2;

        while (j >= 0 && al.get(j).intValue() >= al.get(j + 1).intValue()) 
        {

            // Finding the first j that is breaking descending order
            j = j - 1;
        }

        if (j >= 0) 
        {
            // if the control reaching
            // here, then it means the array
            // is not entirely descending

            // Starting from the end
            int k = al.size() - 1;

            while (al.get(k).intValue() <= al.get(j).intValue()) 
            {
                // Finding the rightmost first larger id than k
                k = k - 1;
            }

            // Switching j and k
            swapEle(al, j, k);

            // Reversing in the descending sequence
            reverseArrList(al, j + 1, al.size() - 1);

            return true;
        } else 
        {
            // Reversing the whole sequence.
            reverseArrList(al, 0, al.size() - 1);
            return false;
        }
    }
    // a Boolean method that checks whether the elements of the array list al 
    // have the valid arrangement or not.
    public boolean isValidArrangement(ArrayList<Integer> al, int s)
    {
        int chk = 1;

            for (int j = 1; j < s; j++) 
            {
                if (al.get(j) == al.get(j - 1)) 
                {
                    chk = 0;
                    break;
                }
            }

            return chk == 1;
    }

    public ArrayList<Integer> rearrangeArr(ArrayList<Integer> al, int s) 
    {   
        if(isValidArrangement(al, s))
        {
            return al;
        }
        // sorting the list so we can compute the next permutation
        Collections.sort(al);
       
        // Iterating the array list and 
        // checking whether it is a valid arrangement or not
        // if yes, then we terminate the do-while loop.
        // Otherwise, we find the next permutation.
         while (nextPermutation(al))
         {
             if(isValidArrangement(al, s))
             {
                 return al;
             }
         }

        return new ArrayList<Integer>();
    }
    
    // main method
    public static void main(String argvs[])
    {
        // creating an object of the class UniqueAdjEle 
        UniqueAdjEle obj = new UniqueAdjEle();
        
        // input 1
        ArrayList<Integer> inArr = new ArrayList<Integer>
        (
            Arrays.asList(7, 7, 6, 8)
        );
        
        // computing the size of the 
        // input array
        int size = inArr.size();
        System.out.println("For the input array: ");
        for(int i = 0; i < size; i++)
        {
            System.out.print(inArr.get(i) + " ");
        }
        System.out.println();
        ArrayList<Integer> ans = obj.rearrangeArr(inArr, size);
        if(ans.size() > 0)
        {
        System.out.println("The valid arrangement is: ");
        
        for(int i = 0; i < size; i++)
        {
            System.out.print(ans.get(i) + " ");
        }
        }
        else
        {
            System.out.println("The valid arrangement is not possible. ");
        }
        
        System.out.println( "\n" );
        
        // input 2
        inArr = new ArrayList<Integer>
        (
            Arrays.asList(2, 4, 8, 9, 5, 7, 3, 6, 1)
        );
        
        // computing the size of the 
        // input array
        size = inArr.size();
        
        System.out.println("For the input array: ");
        
        for(int i = 0; i < size; i++)
        {
            System.out.print(inArr.get(i) + " ");
        }
        
        System.out.println();
        
        ans = obj.rearrangeArr(inArr, size);
        
        if(ans.size() > 0)
        {
        System.out.println("The valid arrangement is: ");
        
        for(int i = 0; i < size; i++)
        {
            System.out.print(ans.get(i) + " ");
        }
        }
        else
        {
            System.out.println("The valid arrangement is not possible. ");
        }
        
        System.out.println( "\n" );
        
        // input 3
        inArr = new ArrayList<Integer>
        (
            Arrays.asList(3, 3, 3, 3, 3)
        );
        
        // computing the size of the 
        // input array
        size = inArr.size();
        
        System.out.println("For the input array: ");
        
        for(int i = 0; i < size; i++)
        {
            System.out.print(inArr.get(i) + " ");
        }
        
        System.out.println();
        
        ans = obj.rearrangeArr(inArr, size);
        if(ans.size() > 0)
        {
        System.out.println("The valid arrangement is: ");
        
        for(int i = 0; i < size; i++)
        {
            System.out.print(ans.get(i) + " ");
        }
        }
        else
        {
            System.out.println("The valid arrangement is not possible. ");
        }
        
    }
    
    
    
}
 Output: For the input array: 
7 7 6 8 
The valid arrangement is: 
6 7 8 7 

For the input array: 
2 4 8 9 5 7 3 6 1 
The valid arrangement is: 
2 4 8 9 5 7 3 6 1 

For the input array: 
3 3 3 3 3 
The valid arrangement is not possible.
 Complexity Analysis: Since the program is computing the permutation, the time complexity of the program is O(N!), where N is the total number of elements present in the linked list. The program uses constant space; therefore, the space complexity of the program is O(1). The above program is not suitable for the larger inputs as the time complexity of the program is too high. Therefore, we must do some optimization to reduce the time complexity. Approach: Using Set It is a greedy approach where we put first that element which is occurring the most number of times in the input array. Using the set, we will put all the elements in the order of their occurrence count. The following are the steps involved in computing the answer. Step 1: Declare an empty array or list solAl. Step 2: Sort the array or list solAl. Step 3: Declare a set st that keeps the elements and their occurrence count. Step 4: Iterate over the list or array solAl: Iterate until the same element is encountered every time. Increment the element count by 1. Put the element and the occurrence count of the element in the set st. Step 5: Create a temporary variable for keeping the previous element and its occurrence count. Step 6: While the set st is not empty, do the following: Fetch the last element and get it added to the result. Delete that element from the set st. Reduce the occurrence count of the element popped by 1. If the occurrence count was non-zero of the previous elements, put it in the set. The current element should be treated as the previous element for the upcoming iteration. Step 7: Eventually, return the list or array solAl. Implementation The implementation of the above steps is mentioned below. FileName: UniqueAdjEle.java 
// important import statements
import java.util.Arrays;
import java.util.ArrayList;
import java.util.TreeSet;
import java.util.Collections;
import java.util.Comparator;

class PairComparator implements Comparator<Pair>
{

// Overriding the compare() method of the Comparator
public int compare(Pair p1, Pair p2)
{
if (p1.first < p2.first)
{
return -1;
}
else if(p1.first == p2.first)
{
return p1.second - p2.second;
}
else if (p1.first > p2.first)
{
return 1;
}

return 0;
}
}

// class Pair contains 
// two elements one is first
// other is second
class Pair 
{
int first; 
int second;
Pair(int first, int second)
{
this.first = first;
this.second = second;
}
}
public class UniqueAdjEle1 
{
// a boolean method that checks whether the elements of the array list al 
// have the valid arrangement or not.
public boolean isValidArrangement(ArrayList<Integer> al, int s)
{
int chk = 1;

for (int j = 1; j < s; j++) 
{
if (al.get(j) == al.get(j - 1)) 
{
chk = 0;
break;
}
}

return chk == 1;
}

public ArrayList<Integer> rearrangeArr(ArrayList<Integer> al, int s) 
{
if(isValidArrangement(al, s))
{
// the arrangement is valid
// hence, there is no need to proceed further
return al;
}

// Sorting the list or array al
Collections.sort(al);

// Declaring a set st that keeps the elements and their
// occurrence count.
TreeSet<Pair> st = new TreeSet<>(new PairComparator());


// Iterating over the list or array al
// Iterating until the element is the same
// Incrementing the element count by 1. 
// Inserting the element and its occurrence count in the set st
for (int j = 0; j < s; j++)
{

int k = j;
while (j < s && k < s && (al.get(j).equals(al.get(k))))
{
k = k + 1;
}
st.add(new Pair(k - j, al.get(j)));

j = k - 1;
}

int prv = -1;
int prvFreq = 0;

// Declaring an empty array or list solAl
ArrayList<Integer> solAl = new ArrayList<>();

while (st.size() != 0)
{
Pair pr = st.last();
st.remove(pr);
solAl.add(pr.second);

if (prvFreq > 0)
{
st.add(new Pair(prvFreq, prv));
}

prvFreq = pr.first - 1;
prv = pr.second;
}

// calculating the new size of the 
// rearranged array list
int newSize = solAl.size();

// if the new size after the rearrangement
// if the array list is not equal to the size s
// then, the valid rearrangement is not possible
if(newSize != s)
{
return new ArrayList<Integer>();
}

return solAl;
}


// main method
public static void main(String argvs[])
{
// creating an object of the class UniqueAdjEle1 
UniqueAdjEle1 obj = new UniqueAdjEle1();

// input 1
ArrayList<Integer> inArr = new ArrayList<Integer>
(
Arrays.asList(7, 7, 6, 8)
);

// computing the size of the 
// input array
int size = inArr.size();
System.out.println("For the input array: ");
for(int i = 0; i < size; i++)
{
System.out.print(inArr.get(i) + " ");
}
System.out.println();
ArrayList<Integer> ans = obj.rearrangeArr(inArr, size);
if(ans.size() > 0)
{
System.out.println("The valid arrangement is: ");

for(int i = 0; i < size; i++)
{
System.out.print(ans.get(i) + " ");
}
}
else
{
System.out.println("The valid arrangement is not possible. ");
}

System.out.println( "\n" );

// input 2
inArr = new ArrayList<Integer>
(
Arrays.asList(2, 4, 8, 9, 5, 7, 3, 6, 1)
);

// computing the size of the 
// input array
size = inArr.size();

System.out.println("For the input array: ");

for(int i = 0; i < size; i++)
{
System.out.print(inArr.get(i) + " ");
}

System.out.println();

ans = obj.rearrangeArr(inArr, size);

if(ans.size() > 0)
{
System.out.println("The valid arrangement is: ");

for(int i = 0; i < size; i++)
{
System.out.print(ans.get(i) + " ");
}
}
else
{
System.out.println("The valid arrangement is not possible. ");
}

System.out.println( "\n" );

// input 3
inArr = new ArrayList<Integer>
(
Arrays.asList(3, 3, 3, 3, 3)
);

// computing the size of the 
// input array
size = inArr.size();

System.out.println("For the input array: ");

for(int i = 0; i < size; i++)
{
System.out.print(inArr.get(i) + " ");
}

System.out.println();

ans = obj.rearrangeArr(inArr, size);
if(ans.size() > 0)
{
System.out.println("The valid arrangement is: ");

for(int i = 0; i < size; i++)
{
System.out.print(ans.get(i) + " ");
}
}
else
{
System.out.println("The valid arrangement is not possible. ");
}

}

}
 Output: For the input array: 
7 7 6 8 
The valid arrangement is: 
7 8 7 6 

For the input array: 
2 4 8 9 5 7 3 6 1 
The valid arrangement is: 
2 4 8 9 5 7 3 6 1 

For the input array: 
3 3 3 3 3 
The valid arrangement is not possible.
 Complexity Analysis: Since the program is using sorting, the time complexity of the program is O(N * log(N)). The program uses a set to store the elements and their occurrence count. The program is also using an auxiliary array (arr). Thus, making the space complexity of the program as (N), where N is the total number of elements present in the input array. Note: Instead of Set, a priority queue can also be used. In that case, also, the time and space complexity remain the same. Next Topic# ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/unequal-adjacent-elements-in-java Unequal Adjacent Elements in Java - Javatpoint ? SCROLL TO TOP Home Java Programs OOPs String Exception Multithreading Collections JavaFX JSP Spring Spring Boot Projects Interview Questions Java Tutorial What is Java History of Java Features of Java C++ vs Java Hello Java Program Program Internal How to set path? JDK, JRE and JVM JVM: Java Virtual Machine Java Variables Java Data Types Unicode System Operators Keywords Control Statements Java Control Statements Java If-else Java Switch Java For Loop Java While Loop Java Do While Loop Java Break Java Continue Java Comments Java Programs Java Object Class Java OOPs Concepts Naming Convention Object and Class Method Constructor static keyword this keyword Java Inheritance Inheritance(IS-A) Aggregation(HAS-A) Java Polymorphism Method Overloading Method Overriding Covariant Return Type super keyword Instance Initializer block final keyword Runtime Polymorphism Dynamic Binding instanceof operator Java Abstraction Abstract class Interface Abstract vs Interface Java Encapsulation Package Access Modifiers Encapsulation Java Array Java Array Java OOPs Misc Object class Object Cloning Math class Wrapper Class Java Recursion Call By Value strictfp keyword javadoc tool Command Line Arg Object vs Class Overloading vs Overriding Java String Java Regex Exception Handling Java Inner classes Java Multithreading Java I/O Java Networking Java AWT & Events Java Swing JavaFX Java Applet Java Reflection Java Date Java Conversion Java Collection Java JDBC Java Misc Java New Features RMI Internationalization Interview Questions Java MCQ next ? ? prev Unequal Adjacent Elements in Java An array inArr containing n numbers (positive or negative) is given. The task is to return the array after the rearrangement of elements of the integers in such a way that no two adjacent elements are equal. If there are multiple valid arrangements, then any one valid arrangement can be returned. If the input array does not contain any valid arrangement, then an appropriate message can be displayed on the console. Example 1: Input int inArr[] = {7, 7, 6, 8} Output: {7, 6, 7, 8} Explanation: There are many valid arrangements possible. Those valid arrangements are mentioned below. {7, 6, 7, 8}, {7, 6, 8, 7}, {7, 8, 7, 6}, {7, 8, 6, 7}, {8, 7, 6, 7}, {6, 7, 8, 7}. Out of which {7, 6, 7, 8} is mentioned in the output. Example 2: Input int inArr[] = {2, 4, 8, 9, 5, 7, 3, 6, 1} Output: {2, 4, 8, 9, 5, 7, 3, 6, 1} Explanation: The input array is given in such a way that there are no two elements that are of the same value. Hence, the input arrays are themselves the answer. Example 3: Input int arr[] = {3, 3, 3, 3, 3} Output: no valid arrangement is possible where adjacent elements are of different values. Explanation: All the elements are of the same value. Hence, no valid arrangement is possible. Approach: Brute Force In this approach, we compute all the arrangements of the input array. If any valid arrangement comes, we return that arrangement. If no valid arrangement is possible, display the appropriate message. For computing the valid arrangement, first, we will sort the array in ascending order. Then we will find the next permutation of the sorted array and check whether it is a valid arrangement or not. If it is a valid arrangement, then we can return that arrangement. If not, then we will find the next permutation and continue to do so until we find a valid arrangement or all the arrangements are exhausted. If the arrangements are exhausted, then we can say that no valid arrangement is there for the given input array, and the same is illustrated in the following program. FileName: UniqueAdjEle.java 
// important import statements
import java.util.Collections;
import java.util.ArrayList;
import java.util.Arrays;


public class UniqueAdjEle 
{
    // swapping the elements in the array list al
    // that are present at the index j and k
    private void swapEle(ArrayList<Integer> al, int j, int k) 
    {
        int temp = al.get(j);
        al.set(j, al.get(k));
        al.set(k, temp);
    }
    // reversing the array list from j to k
    private void reverseArrList(ArrayList<Integer> al, int j, int k) 
    {
        while (j < k) 
        {
            swapEle(al, j, k);
            j = j + 1;
            k = k - 1;
        }
    }

    private boolean nextPermutation(ArrayList<Integer> al) 
    {
        // if the list has no elements
        // or the single element, then
        // there is no need to proceed further
        if (al == null || al.size() <= 1) 
        {
            return false;
        }

        int j = al.size() - 2;

        while (j >= 0 && al.get(j).intValue() >= al.get(j + 1).intValue()) 
        {

            // Finding the first j that is breaking descending order
            j = j - 1;
        }

        if (j >= 0) 
        {
            // if the control reaching
            // here, then it means the array
            // is not entirely descending

            // Starting from the end
            int k = al.size() - 1;

            while (al.get(k).intValue() <= al.get(j).intValue()) 
            {
                // Finding the rightmost first larger id than k
                k = k - 1;
            }

            // Switching j and k
            swapEle(al, j, k);

            // Reversing in the descending sequence
            reverseArrList(al, j + 1, al.size() - 1);

            return true;
        } else 
        {
            // Reversing the whole sequence.
            reverseArrList(al, 0, al.size() - 1);
            return false;
        }
    }
    // a Boolean method that checks whether the elements of the array list al 
    // have the valid arrangement or not.
    public boolean isValidArrangement(ArrayList<Integer> al, int s)
    {
        int chk = 1;

            for (int j = 1; j < s; j++) 
            {
                if (al.get(j) == al.get(j - 1)) 
                {
                    chk = 0;
                    break;
                }
            }

            return chk == 1;
    }

    public ArrayList<Integer> rearrangeArr(ArrayList<Integer> al, int s) 
    {   
        if(isValidArrangement(al, s))
        {
            return al;
        }
        // sorting the list so we can compute the next permutation
        Collections.sort(al);
       
        // Iterating the array list and 
        // checking whether it is a valid arrangement or not
        // if yes, then we terminate the do-while loop.
        // Otherwise, we find the next permutation.
         while (nextPermutation(al))
         {
             if(isValidArrangement(al, s))
             {
                 return al;
             }
         }

        return new ArrayList<Integer>();
    }
    
    // main method
    public static void main(String argvs[])
    {
        // creating an object of the class UniqueAdjEle 
        UniqueAdjEle obj = new UniqueAdjEle();
        
        // input 1
        ArrayList<Integer> inArr = new ArrayList<Integer>
        (
            Arrays.asList(7, 7, 6, 8)
        );
        
        // computing the size of the 
        // input array
        int size = inArr.size();
        System.out.println("For the input array: ");
        for(int i = 0; i < size; i++)
        {
            System.out.print(inArr.get(i) + " ");
        }
        System.out.println();
        ArrayList<Integer> ans = obj.rearrangeArr(inArr, size);
        if(ans.size() > 0)
        {
        System.out.println("The valid arrangement is: ");
        
        for(int i = 0; i < size; i++)
        {
            System.out.print(ans.get(i) + " ");
        }
        }
        else
        {
            System.out.println("The valid arrangement is not possible. ");
        }
        
        System.out.println( "\n" );
        
        // input 2
        inArr = new ArrayList<Integer>
        (
            Arrays.asList(2, 4, 8, 9, 5, 7, 3, 6, 1)
        );
        
        // computing the size of the 
        // input array
        size = inArr.size();
        
        System.out.println("For the input array: ");
        
        for(int i = 0; i < size; i++)
        {
            System.out.print(inArr.get(i) + " ");
        }
        
        System.out.println();
        
        ans = obj.rearrangeArr(inArr, size);
        
        if(ans.size() > 0)
        {
        System.out.println("The valid arrangement is: ");
        
        for(int i = 0; i < size; i++)
        {
            System.out.print(ans.get(i) + " ");
        }
        }
        else
        {
            System.out.println("The valid arrangement is not possible. ");
        }
        
        System.out.println( "\n" );
        
        // input 3
        inArr = new ArrayList<Integer>
        (
            Arrays.asList(3, 3, 3, 3, 3)
        );
        
        // computing the size of the 
        // input array
        size = inArr.size();
        
        System.out.println("For the input array: ");
        
        for(int i = 0; i < size; i++)
        {
            System.out.print(inArr.get(i) + " ");
        }
        
        System.out.println();
        
        ans = obj.rearrangeArr(inArr, size);
        if(ans.size() > 0)
        {
        System.out.println("The valid arrangement is: ");
        
        for(int i = 0; i < size; i++)
        {
            System.out.print(ans.get(i) + " ");
        }
        }
        else
        {
            System.out.println("The valid arrangement is not possible. ");
        }
        
    }
    
    
    
}
 Output: For the input array: 
7 7 6 8 
The valid arrangement is: 
6 7 8 7 

For the input array: 
2 4 8 9 5 7 3 6 1 
The valid arrangement is: 
2 4 8 9 5 7 3 6 1 

For the input array: 
3 3 3 3 3 
The valid arrangement is not possible.
 Complexity Analysis: Since the program is computing the permutation, the time complexity of the program is O(N!), where N is the total number of elements present in the linked list. The program uses constant space; therefore, the space complexity of the program is O(1). The above program is not suitable for the larger inputs as the time complexity of the program is too high. Therefore, we must do some optimization to reduce the time complexity. Approach: Using Set It is a greedy approach where we put first that element which is occurring the most number of times in the input array. Using the set, we will put all the elements in the order of their occurrence count. The following are the steps involved in computing the answer. Step 1: Declare an empty array or list solAl. Step 2: Sort the array or list solAl. Step 3: Declare a set st that keeps the elements and their occurrence count. Step 4: Iterate over the list or array solAl: Iterate until the same element is encountered every time. Increment the element count by 1. Put the element and the occurrence count of the element in the set st. Step 5: Create a temporary variable for keeping the previous element and its occurrence count. Step 6: While the set st is not empty, do the following: Fetch the last element and get it added to the result. Delete that element from the set st. Reduce the occurrence count of the element popped by 1. If the occurrence count was non-zero of the previous elements, put it in the set. The current element should be treated as the previous element for the upcoming iteration. Step 7: Eventually, return the list or array solAl. Implementation The implementation of the above steps is mentioned below. FileName: UniqueAdjEle.java 
// important import statements
import java.util.Arrays;
import java.util.ArrayList;
import java.util.TreeSet;
import java.util.Collections;
import java.util.Comparator;

class PairComparator implements Comparator<Pair>
{

// Overriding the compare() method of the Comparator
public int compare(Pair p1, Pair p2)
{
if (p1.first < p2.first)
{
return -1;
}
else if(p1.first == p2.first)
{
return p1.second - p2.second;
}
else if (p1.first > p2.first)
{
return 1;
}

return 0;
}
}

// class Pair contains 
// two elements one is first
// other is second
class Pair 
{
int first; 
int second;
Pair(int first, int second)
{
this.first = first;
this.second = second;
}
}
public class UniqueAdjEle1 
{
// a boolean method that checks whether the elements of the array list al 
// have the valid arrangement or not.
public boolean isValidArrangement(ArrayList<Integer> al, int s)
{
int chk = 1;

for (int j = 1; j < s; j++) 
{
if (al.get(j) == al.get(j - 1)) 
{
chk = 0;
break;
}
}

return chk == 1;
}

public ArrayList<Integer> rearrangeArr(ArrayList<Integer> al, int s) 
{
if(isValidArrangement(al, s))
{
// the arrangement is valid
// hence, there is no need to proceed further
return al;
}

// Sorting the list or array al
Collections.sort(al);

// Declaring a set st that keeps the elements and their
// occurrence count.
TreeSet<Pair> st = new TreeSet<>(new PairComparator());


// Iterating over the list or array al
// Iterating until the element is the same
// Incrementing the element count by 1. 
// Inserting the element and its occurrence count in the set st
for (int j = 0; j < s; j++)
{

int k = j;
while (j < s && k < s && (al.get(j).equals(al.get(k))))
{
k = k + 1;
}
st.add(new Pair(k - j, al.get(j)));

j = k - 1;
}

int prv = -1;
int prvFreq = 0;

// Declaring an empty array or list solAl
ArrayList<Integer> solAl = new ArrayList<>();

while (st.size() != 0)
{
Pair pr = st.last();
st.remove(pr);
solAl.add(pr.second);

if (prvFreq > 0)
{
st.add(new Pair(prvFreq, prv));
}

prvFreq = pr.first - 1;
prv = pr.second;
}

// calculating the new size of the 
// rearranged array list
int newSize = solAl.size();

// if the new size after the rearrangement
// if the array list is not equal to the size s
// then, the valid rearrangement is not possible
if(newSize != s)
{
return new ArrayList<Integer>();
}

return solAl;
}


// main method
public static void main(String argvs[])
{
// creating an object of the class UniqueAdjEle1 
UniqueAdjEle1 obj = new UniqueAdjEle1();

// input 1
ArrayList<Integer> inArr = new ArrayList<Integer>
(
Arrays.asList(7, 7, 6, 8)
);

// computing the size of the 
// input array
int size = inArr.size();
System.out.println("For the input array: ");
for(int i = 0; i < size; i++)
{
System.out.print(inArr.get(i) + " ");
}
System.out.println();
ArrayList<Integer> ans = obj.rearrangeArr(inArr, size);
if(ans.size() > 0)
{
System.out.println("The valid arrangement is: ");

for(int i = 0; i < size; i++)
{
System.out.print(ans.get(i) + " ");
}
}
else
{
System.out.println("The valid arrangement is not possible. ");
}

System.out.println( "\n" );

// input 2
inArr = new ArrayList<Integer>
(
Arrays.asList(2, 4, 8, 9, 5, 7, 3, 6, 1)
);

// computing the size of the 
// input array
size = inArr.size();

System.out.println("For the input array: ");

for(int i = 0; i < size; i++)
{
System.out.print(inArr.get(i) + " ");
}

System.out.println();

ans = obj.rearrangeArr(inArr, size);

if(ans.size() > 0)
{
System.out.println("The valid arrangement is: ");

for(int i = 0; i < size; i++)
{
System.out.print(ans.get(i) + " ");
}
}
else
{
System.out.println("The valid arrangement is not possible. ");
}

System.out.println( "\n" );

// input 3
inArr = new ArrayList<Integer>
(
Arrays.asList(3, 3, 3, 3, 3)
);

// computing the size of the 
// input array
size = inArr.size();

System.out.println("For the input array: ");

for(int i = 0; i < size; i++)
{
System.out.print(inArr.get(i) + " ");
}

System.out.println();

ans = obj.rearrangeArr(inArr, size);
if(ans.size() > 0)
{
System.out.println("The valid arrangement is: ");

for(int i = 0; i < size; i++)
{
System.out.print(ans.get(i) + " ");
}
}
else
{
System.out.println("The valid arrangement is not possible. ");
}

}

}
 Output: For the input array: 
7 7 6 8 
The valid arrangement is: 
7 8 7 6 

For the input array: 
2 4 8 9 5 7 3 6 1 
The valid arrangement is: 
2 4 8 9 5 7 3 6 1 

For the input array: 
3 3 3 3 3 
The valid arrangement is not possible.
 Complexity Analysis: Since the program is using sorting, the time complexity of the program is O(N * log(N)). The program uses a set to store the elements and their occurrence count. The program is also using an auxiliary array (arr). Thus, making the space complexity of the program as (N), where N is the total number of elements present in the input array. Note: Instead of Set, a priority queue can also be used. In that case, also, the time and space complexity remain the same. Next Topic# ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/unequal-adjacent-elements-in-java Unequal Adjacent Elements in Java - Javatpoint ? SCROLL TO TOP Home Java Programs OOPs String Exception Multithreading Collections JavaFX JSP Spring Spring Boot Projects Interview Questions Java Tutorial What is Java History of Java Features of Java C++ vs Java Hello Java Program Program Internal How to set path? JDK, JRE and JVM JVM: Java Virtual Machine Java Variables Java Data Types Unicode System Operators Keywords Control Statements Java Control Statements Java If-else Java Switch Java For Loop Java While Loop Java Do While Loop Java Break Java Continue Java Comments Java Programs Java Object Class Java OOPs Concepts Naming Convention Object and Class Method Constructor static keyword this keyword Java Inheritance Inheritance(IS-A) Aggregation(HAS-A) Java Polymorphism Method Overloading Method Overriding Covariant Return Type super keyword Instance Initializer block final keyword Runtime Polymorphism Dynamic Binding instanceof operator Java Abstraction Abstract class Interface Abstract vs Interface Java Encapsulation Package Access Modifiers Encapsulation Java Array Java Array Java OOPs Misc Object class Object Cloning Math class Wrapper Class Java Recursion Call By Value strictfp keyword javadoc tool Command Line Arg Object vs Class Overloading vs Overriding Java String Java Regex Exception Handling Java Inner classes Java Multithreading Java I/O Java Networking Java AWT & Events Java Swing JavaFX Java Applet Java Reflection Java Date Java Conversion Java Collection Java JDBC Java Misc Java New Features RMI Internationalization Interview Questions Java MCQ next ? ? prev Unequal Adjacent Elements in Java An array inArr containing n numbers (positive or negative) is given. The task is to return the array after the rearrangement of elements of the integers in such a way that no two adjacent elements are equal. If there are multiple valid arrangements, then any one valid arrangement can be returned. If the input array does not contain any valid arrangement, then an appropriate message can be displayed on the console. Example 1: Input int inArr[] = {7, 7, 6, 8} Output: {7, 6, 7, 8} Explanation: There are many valid arrangements possible. Those valid arrangements are mentioned below. {7, 6, 7, 8}, {7, 6, 8, 7}, {7, 8, 7, 6}, {7, 8, 6, 7}, {8, 7, 6, 7}, {6, 7, 8, 7}. Out of which {7, 6, 7, 8} is mentioned in the output. Example 2: Input int inArr[] = {2, 4, 8, 9, 5, 7, 3, 6, 1} Output: {2, 4, 8, 9, 5, 7, 3, 6, 1} Explanation: The input array is given in such a way that there are no two elements that are of the same value. Hence, the input arrays are themselves the answer. Example 3: Input int arr[] = {3, 3, 3, 3, 3} Output: no valid arrangement is possible where adjacent elements are of different values. Explanation: All the elements are of the same value. Hence, no valid arrangement is possible. Approach: Brute Force In this approach, we compute all the arrangements of the input array. If any valid arrangement comes, we return that arrangement. If no valid arrangement is possible, display the appropriate message. For computing the valid arrangement, first, we will sort the array in ascending order. Then we will find the next permutation of the sorted array and check whether it is a valid arrangement or not. If it is a valid arrangement, then we can return that arrangement. If not, then we will find the next permutation and continue to do so until we find a valid arrangement or all the arrangements are exhausted. If the arrangements are exhausted, then we can say that no valid arrangement is there for the given input array, and the same is illustrated in the following program. FileName: UniqueAdjEle.java 
// important import statements
import java.util.Collections;
import java.util.ArrayList;
import java.util.Arrays;


public class UniqueAdjEle 
{
    // swapping the elements in the array list al
    // that are present at the index j and k
    private void swapEle(ArrayList<Integer> al, int j, int k) 
    {
        int temp = al.get(j);
        al.set(j, al.get(k));
        al.set(k, temp);
    }
    // reversing the array list from j to k
    private void reverseArrList(ArrayList<Integer> al, int j, int k) 
    {
        while (j < k) 
        {
            swapEle(al, j, k);
            j = j + 1;
            k = k - 1;
        }
    }

    private boolean nextPermutation(ArrayList<Integer> al) 
    {
        // if the list has no elements
        // or the single element, then
        // there is no need to proceed further
        if (al == null || al.size() <= 1) 
        {
            return false;
        }

        int j = al.size() - 2;

        while (j >= 0 && al.get(j).intValue() >= al.get(j + 1).intValue()) 
        {

            // Finding the first j that is breaking descending order
            j = j - 1;
        }

        if (j >= 0) 
        {
            // if the control reaching
            // here, then it means the array
            // is not entirely descending

            // Starting from the end
            int k = al.size() - 1;

            while (al.get(k).intValue() <= al.get(j).intValue()) 
            {
                // Finding the rightmost first larger id than k
                k = k - 1;
            }

            // Switching j and k
            swapEle(al, j, k);

            // Reversing in the descending sequence
            reverseArrList(al, j + 1, al.size() - 1);

            return true;
        } else 
        {
            // Reversing the whole sequence.
            reverseArrList(al, 0, al.size() - 1);
            return false;
        }
    }
    // a Boolean method that checks whether the elements of the array list al 
    // have the valid arrangement or not.
    public boolean isValidArrangement(ArrayList<Integer> al, int s)
    {
        int chk = 1;

            for (int j = 1; j < s; j++) 
            {
                if (al.get(j) == al.get(j - 1)) 
                {
                    chk = 0;
                    break;
                }
            }

            return chk == 1;
    }

    public ArrayList<Integer> rearrangeArr(ArrayList<Integer> al, int s) 
    {   
        if(isValidArrangement(al, s))
        {
            return al;
        }
        // sorting the list so we can compute the next permutation
        Collections.sort(al);
       
        // Iterating the array list and 
        // checking whether it is a valid arrangement or not
        // if yes, then we terminate the do-while loop.
        // Otherwise, we find the next permutation.
         while (nextPermutation(al))
         {
             if(isValidArrangement(al, s))
             {
                 return al;
             }
         }

        return new ArrayList<Integer>();
    }
    
    // main method
    public static void main(String argvs[])
    {
        // creating an object of the class UniqueAdjEle 
        UniqueAdjEle obj = new UniqueAdjEle();
        
        // input 1
        ArrayList<Integer> inArr = new ArrayList<Integer>
        (
            Arrays.asList(7, 7, 6, 8)
        );
        
        // computing the size of the 
        // input array
        int size = inArr.size();
        System.out.println("For the input array: ");
        for(int i = 0; i < size; i++)
        {
            System.out.print(inArr.get(i) + " ");
        }
        System.out.println();
        ArrayList<Integer> ans = obj.rearrangeArr(inArr, size);
        if(ans.size() > 0)
        {
        System.out.println("The valid arrangement is: ");
        
        for(int i = 0; i < size; i++)
        {
            System.out.print(ans.get(i) + " ");
        }
        }
        else
        {
            System.out.println("The valid arrangement is not possible. ");
        }
        
        System.out.println( "\n" );
        
        // input 2
        inArr = new ArrayList<Integer>
        (
            Arrays.asList(2, 4, 8, 9, 5, 7, 3, 6, 1)
        );
        
        // computing the size of the 
        // input array
        size = inArr.size();
        
        System.out.println("For the input array: ");
        
        for(int i = 0; i < size; i++)
        {
            System.out.print(inArr.get(i) + " ");
        }
        
        System.out.println();
        
        ans = obj.rearrangeArr(inArr, size);
        
        if(ans.size() > 0)
        {
        System.out.println("The valid arrangement is: ");
        
        for(int i = 0; i < size; i++)
        {
            System.out.print(ans.get(i) + " ");
        }
        }
        else
        {
            System.out.println("The valid arrangement is not possible. ");
        }
        
        System.out.println( "\n" );
        
        // input 3
        inArr = new ArrayList<Integer>
        (
            Arrays.asList(3, 3, 3, 3, 3)
        );
        
        // computing the size of the 
        // input array
        size = inArr.size();
        
        System.out.println("For the input array: ");
        
        for(int i = 0; i < size; i++)
        {
            System.out.print(inArr.get(i) + " ");
        }
        
        System.out.println();
        
        ans = obj.rearrangeArr(inArr, size);
        if(ans.size() > 0)
        {
        System.out.println("The valid arrangement is: ");
        
        for(int i = 0; i < size; i++)
        {
            System.out.print(ans.get(i) + " ");
        }
        }
        else
        {
            System.out.println("The valid arrangement is not possible. ");
        }
        
    }
    
    
    
}
 Output: For the input array: 
7 7 6 8 
The valid arrangement is: 
6 7 8 7 

For the input array: 
2 4 8 9 5 7 3 6 1 
The valid arrangement is: 
2 4 8 9 5 7 3 6 1 

For the input array: 
3 3 3 3 3 
The valid arrangement is not possible.
 Complexity Analysis: Since the program is computing the permutation, the time complexity of the program is O(N!), where N is the total number of elements present in the linked list. The program uses constant space; therefore, the space complexity of the program is O(1). The above program is not suitable for the larger inputs as the time complexity of the program is too high. Therefore, we must do some optimization to reduce the time complexity. Approach: Using Set It is a greedy approach where we put first that element which is occurring the most number of times in the input array. Using the set, we will put all the elements in the order of their occurrence count. The following are the steps involved in computing the answer. Step 1: Declare an empty array or list solAl. Step 2: Sort the array or list solAl. Step 3: Declare a set st that keeps the elements and their occurrence count. Step 4: Iterate over the list or array solAl: Iterate until the same element is encountered every time. Increment the element count by 1. Put the element and the occurrence count of the element in the set st. Step 5: Create a temporary variable for keeping the previous element and its occurrence count. Step 6: While the set st is not empty, do the following: Fetch the last element and get it added to the result. Delete that element from the set st. Reduce the occurrence count of the element popped by 1. If the occurrence count was non-zero of the previous elements, put it in the set. The current element should be treated as the previous element for the upcoming iteration. Step 7: Eventually, return the list or array solAl. Implementation The implementation of the above steps is mentioned below. FileName: UniqueAdjEle.java 
// important import statements
import java.util.Arrays;
import java.util.ArrayList;
import java.util.TreeSet;
import java.util.Collections;
import java.util.Comparator;

class PairComparator implements Comparator<Pair>
{

// Overriding the compare() method of the Comparator
public int compare(Pair p1, Pair p2)
{
if (p1.first < p2.first)
{
return -1;
}
else if(p1.first == p2.first)
{
return p1.second - p2.second;
}
else if (p1.first > p2.first)
{
return 1;
}

return 0;
}
}

// class Pair contains 
// two elements one is first
// other is second
class Pair 
{
int first; 
int second;
Pair(int first, int second)
{
this.first = first;
this.second = second;
}
}
public class UniqueAdjEle1 
{
// a boolean method that checks whether the elements of the array list al 
// have the valid arrangement or not.
public boolean isValidArrangement(ArrayList<Integer> al, int s)
{
int chk = 1;

for (int j = 1; j < s; j++) 
{
if (al.get(j) == al.get(j - 1)) 
{
chk = 0;
break;
}
}

return chk == 1;
}

public ArrayList<Integer> rearrangeArr(ArrayList<Integer> al, int s) 
{
if(isValidArrangement(al, s))
{
// the arrangement is valid
// hence, there is no need to proceed further
return al;
}

// Sorting the list or array al
Collections.sort(al);

// Declaring a set st that keeps the elements and their
// occurrence count.
TreeSet<Pair> st = new TreeSet<>(new PairComparator());


// Iterating over the list or array al
// Iterating until the element is the same
// Incrementing the element count by 1. 
// Inserting the element and its occurrence count in the set st
for (int j = 0; j < s; j++)
{

int k = j;
while (j < s && k < s && (al.get(j).equals(al.get(k))))
{
k = k + 1;
}
st.add(new Pair(k - j, al.get(j)));

j = k - 1;
}

int prv = -1;
int prvFreq = 0;

// Declaring an empty array or list solAl
ArrayList<Integer> solAl = new ArrayList<>();

while (st.size() != 0)
{
Pair pr = st.last();
st.remove(pr);
solAl.add(pr.second);

if (prvFreq > 0)
{
st.add(new Pair(prvFreq, prv));
}

prvFreq = pr.first - 1;
prv = pr.second;
}

// calculating the new size of the 
// rearranged array list
int newSize = solAl.size();

// if the new size after the rearrangement
// if the array list is not equal to the size s
// then, the valid rearrangement is not possible
if(newSize != s)
{
return new ArrayList<Integer>();
}

return solAl;
}


// main method
public static void main(String argvs[])
{
// creating an object of the class UniqueAdjEle1 
UniqueAdjEle1 obj = new UniqueAdjEle1();

// input 1
ArrayList<Integer> inArr = new ArrayList<Integer>
(
Arrays.asList(7, 7, 6, 8)
);

// computing the size of the 
// input array
int size = inArr.size();
System.out.println("For the input array: ");
for(int i = 0; i < size; i++)
{
System.out.print(inArr.get(i) + " ");
}
System.out.println();
ArrayList<Integer> ans = obj.rearrangeArr(inArr, size);
if(ans.size() > 0)
{
System.out.println("The valid arrangement is: ");

for(int i = 0; i < size; i++)
{
System.out.print(ans.get(i) + " ");
}
}
else
{
System.out.println("The valid arrangement is not possible. ");
}

System.out.println( "\n" );

// input 2
inArr = new ArrayList<Integer>
(
Arrays.asList(2, 4, 8, 9, 5, 7, 3, 6, 1)
);

// computing the size of the 
// input array
size = inArr.size();

System.out.println("For the input array: ");

for(int i = 0; i < size; i++)
{
System.out.print(inArr.get(i) + " ");
}

System.out.println();

ans = obj.rearrangeArr(inArr, size);

if(ans.size() > 0)
{
System.out.println("The valid arrangement is: ");

for(int i = 0; i < size; i++)
{
System.out.print(ans.get(i) + " ");
}
}
else
{
System.out.println("The valid arrangement is not possible. ");
}

System.out.println( "\n" );

// input 3
inArr = new ArrayList<Integer>
(
Arrays.asList(3, 3, 3, 3, 3)
);

// computing the size of the 
// input array
size = inArr.size();

System.out.println("For the input array: ");

for(int i = 0; i < size; i++)
{
System.out.print(inArr.get(i) + " ");
}

System.out.println();

ans = obj.rearrangeArr(inArr, size);
if(ans.size() > 0)
{
System.out.println("The valid arrangement is: ");

for(int i = 0; i < size; i++)
{
System.out.print(ans.get(i) + " ");
}
}
else
{
System.out.println("The valid arrangement is not possible. ");
}

}

}
 Output: For the input array: 
7 7 6 8 
The valid arrangement is: 
7 8 7 6 

For the input array: 
2 4 8 9 5 7 3 6 1 
The valid arrangement is: 
2 4 8 9 5 7 3 6 1 

For the input array: 
3 3 3 3 3 
The valid arrangement is not possible.
 Complexity Analysis: Since the program is using sorting, the time complexity of the program is O(N * log(N)). The program uses a set to store the elements and their occurrence count. The program is also using an auxiliary array (arr). Thus, making the space complexity of the program as (N), where N is the total number of elements present in the input array. Note: Instead of Set, a priority queue can also be used. In that case, also, the time and space complexity remain the same. Next Topic# ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/unequal-adjacent-elements-in-java Unequal Adjacent Elements in Java - Javatpoint ? SCROLL TO TOP Home Java Programs OOPs String Exception Multithreading Collections JavaFX JSP Spring Spring Boot Projects Interview Questions Java Tutorial What is Java History of Java Features of Java C++ vs Java Hello Java Program Program Internal How to set path? JDK, JRE and JVM JVM: Java Virtual Machine Java Variables Java Data Types Unicode System Operators Keywords Control Statements Java Control Statements Java If-else Java Switch Java For Loop Java While Loop Java Do While Loop Java Break Java Continue Java Comments Java Programs Java Object Class Java OOPs Concepts Naming Convention Object and Class Method Constructor static keyword this keyword Java Inheritance Inheritance(IS-A) Aggregation(HAS-A) Java Polymorphism Method Overloading Method Overriding Covariant Return Type super keyword Instance Initializer block final keyword Runtime Polymorphism Dynamic Binding instanceof operator Java Abstraction Abstract class Interface Abstract vs Interface Java Encapsulation Package Access Modifiers Encapsulation Java Array Java Array Java OOPs Misc Object class Object Cloning Math class Wrapper Class Java Recursion Call By Value strictfp keyword javadoc tool Command Line Arg Object vs Class Overloading vs Overriding Java String Java Regex Exception Handling Java Inner classes Java Multithreading Java I/O Java Networking Java AWT & Events Java Swing JavaFX Java Applet Java Reflection Java Date Java Conversion Java Collection Java JDBC Java Misc Java New Features RMI Internationalization Interview Questions Java MCQ next ? ? prev Unequal Adjacent Elements in Java An array inArr containing n numbers (positive or negative) is given. The task is to return the array after the rearrangement of elements of the integers in such a way that no two adjacent elements are equal. If there are multiple valid arrangements, then any one valid arrangement can be returned. If the input array does not contain any valid arrangement, then an appropriate message can be displayed on the console. Example 1: Input int inArr[] = {7, 7, 6, 8} Output: {7, 6, 7, 8} Explanation: There are many valid arrangements possible. Those valid arrangements are mentioned below. {7, 6, 7, 8}, {7, 6, 8, 7}, {7, 8, 7, 6}, {7, 8, 6, 7}, {8, 7, 6, 7}, {6, 7, 8, 7}. Out of which {7, 6, 7, 8} is mentioned in the output. Example 2: Input int inArr[] = {2, 4, 8, 9, 5, 7, 3, 6, 1} Output: {2, 4, 8, 9, 5, 7, 3, 6, 1} Explanation: The input array is given in such a way that there are no two elements that are of the same value. Hence, the input arrays are themselves the answer. Example 3: Input int arr[] = {3, 3, 3, 3, 3} Output: no valid arrangement is possible where adjacent elements are of different values. Explanation: All the elements are of the same value. Hence, no valid arrangement is possible. Approach: Brute Force In this approach, we compute all the arrangements of the input array. If any valid arrangement comes, we return that arrangement. If no valid arrangement is possible, display the appropriate message. For computing the valid arrangement, first, we will sort the array in ascending order. Then we will find the next permutation of the sorted array and check whether it is a valid arrangement or not. If it is a valid arrangement, then we can return that arrangement. If not, then we will find the next permutation and continue to do so until we find a valid arrangement or all the arrangements are exhausted. If the arrangements are exhausted, then we can say that no valid arrangement is there for the given input array, and the same is illustrated in the following program. FileName: UniqueAdjEle.java 
// important import statements
import java.util.Collections;
import java.util.ArrayList;
import java.util.Arrays;


public class UniqueAdjEle 
{
    // swapping the elements in the array list al
    // that are present at the index j and k
    private void swapEle(ArrayList<Integer> al, int j, int k) 
    {
        int temp = al.get(j);
        al.set(j, al.get(k));
        al.set(k, temp);
    }
    // reversing the array list from j to k
    private void reverseArrList(ArrayList<Integer> al, int j, int k) 
    {
        while (j < k) 
        {
            swapEle(al, j, k);
            j = j + 1;
            k = k - 1;
        }
    }

    private boolean nextPermutation(ArrayList<Integer> al) 
    {
        // if the list has no elements
        // or the single element, then
        // there is no need to proceed further
        if (al == null || al.size() <= 1) 
        {
            return false;
        }

        int j = al.size() - 2;

        while (j >= 0 && al.get(j).intValue() >= al.get(j + 1).intValue()) 
        {

            // Finding the first j that is breaking descending order
            j = j - 1;
        }

        if (j >= 0) 
        {
            // if the control reaching
            // here, then it means the array
            // is not entirely descending

            // Starting from the end
            int k = al.size() - 1;

            while (al.get(k).intValue() <= al.get(j).intValue()) 
            {
                // Finding the rightmost first larger id than k
                k = k - 1;
            }

            // Switching j and k
            swapEle(al, j, k);

            // Reversing in the descending sequence
            reverseArrList(al, j + 1, al.size() - 1);

            return true;
        } else 
        {
            // Reversing the whole sequence.
            reverseArrList(al, 0, al.size() - 1);
            return false;
        }
    }
    // a Boolean method that checks whether the elements of the array list al 
    // have the valid arrangement or not.
    public boolean isValidArrangement(ArrayList<Integer> al, int s)
    {
        int chk = 1;

            for (int j = 1; j < s; j++) 
            {
                if (al.get(j) == al.get(j - 1)) 
                {
                    chk = 0;
                    break;
                }
            }

            return chk == 1;
    }

    public ArrayList<Integer> rearrangeArr(ArrayList<Integer> al, int s) 
    {   
        if(isValidArrangement(al, s))
        {
            return al;
        }
        // sorting the list so we can compute the next permutation
        Collections.sort(al);
       
        // Iterating the array list and 
        // checking whether it is a valid arrangement or not
        // if yes, then we terminate the do-while loop.
        // Otherwise, we find the next permutation.
         while (nextPermutation(al))
         {
             if(isValidArrangement(al, s))
             {
                 return al;
             }
         }

        return new ArrayList<Integer>();
    }
    
    // main method
    public static void main(String argvs[])
    {
        // creating an object of the class UniqueAdjEle 
        UniqueAdjEle obj = new UniqueAdjEle();
        
        // input 1
        ArrayList<Integer> inArr = new ArrayList<Integer>
        (
            Arrays.asList(7, 7, 6, 8)
        );
        
        // computing the size of the 
        // input array
        int size = inArr.size();
        System.out.println("For the input array: ");
        for(int i = 0; i < size; i++)
        {
            System.out.print(inArr.get(i) + " ");
        }
        System.out.println();
        ArrayList<Integer> ans = obj.rearrangeArr(inArr, size);
        if(ans.size() > 0)
        {
        System.out.println("The valid arrangement is: ");
        
        for(int i = 0; i < size; i++)
        {
            System.out.print(ans.get(i) + " ");
        }
        }
        else
        {
            System.out.println("The valid arrangement is not possible. ");
        }
        
        System.out.println( "\n" );
        
        // input 2
        inArr = new ArrayList<Integer>
        (
            Arrays.asList(2, 4, 8, 9, 5, 7, 3, 6, 1)
        );
        
        // computing the size of the 
        // input array
        size = inArr.size();
        
        System.out.println("For the input array: ");
        
        for(int i = 0; i < size; i++)
        {
            System.out.print(inArr.get(i) + " ");
        }
        
        System.out.println();
        
        ans = obj.rearrangeArr(inArr, size);
        
        if(ans.size() > 0)
        {
        System.out.println("The valid arrangement is: ");
        
        for(int i = 0; i < size; i++)
        {
            System.out.print(ans.get(i) + " ");
        }
        }
        else
        {
            System.out.println("The valid arrangement is not possible. ");
        }
        
        System.out.println( "\n" );
        
        // input 3
        inArr = new ArrayList<Integer>
        (
            Arrays.asList(3, 3, 3, 3, 3)
        );
        
        // computing the size of the 
        // input array
        size = inArr.size();
        
        System.out.println("For the input array: ");
        
        for(int i = 0; i < size; i++)
        {
            System.out.print(inArr.get(i) + " ");
        }
        
        System.out.println();
        
        ans = obj.rearrangeArr(inArr, size);
        if(ans.size() > 0)
        {
        System.out.println("The valid arrangement is: ");
        
        for(int i = 0; i < size; i++)
        {
            System.out.print(ans.get(i) + " ");
        }
        }
        else
        {
            System.out.println("The valid arrangement is not possible. ");
        }
        
    }
    
    
    
}
 Output: For the input array: 
7 7 6 8 
The valid arrangement is: 
6 7 8 7 

For the input array: 
2 4 8 9 5 7 3 6 1 
The valid arrangement is: 
2 4 8 9 5 7 3 6 1 

For the input array: 
3 3 3 3 3 
The valid arrangement is not possible.
 Complexity Analysis: Since the program is computing the permutation, the time complexity of the program is O(N!), where N is the total number of elements present in the linked list. The program uses constant space; therefore, the space complexity of the program is O(1). The above program is not suitable for the larger inputs as the time complexity of the program is too high. Therefore, we must do some optimization to reduce the time complexity. Approach: Using Set It is a greedy approach where we put first that element which is occurring the most number of times in the input array. Using the set, we will put all the elements in the order of their occurrence count. The following are the steps involved in computing the answer. Step 1: Declare an empty array or list solAl. Step 2: Sort the array or list solAl. Step 3: Declare a set st that keeps the elements and their occurrence count. Step 4: Iterate over the list or array solAl: Iterate until the same element is encountered every time. Increment the element count by 1. Put the element and the occurrence count of the element in the set st. Step 5: Create a temporary variable for keeping the previous element and its occurrence count. Step 6: While the set st is not empty, do the following: Fetch the last element and get it added to the result. Delete that element from the set st. Reduce the occurrence count of the element popped by 1. If the occurrence count was non-zero of the previous elements, put it in the set. The current element should be treated as the previous element for the upcoming iteration. Step 7: Eventually, return the list or array solAl. Implementation The implementation of the above steps is mentioned below. FileName: UniqueAdjEle.java 
// important import statements
import java.util.Arrays;
import java.util.ArrayList;
import java.util.TreeSet;
import java.util.Collections;
import java.util.Comparator;

class PairComparator implements Comparator<Pair>
{

// Overriding the compare() method of the Comparator
public int compare(Pair p1, Pair p2)
{
if (p1.first < p2.first)
{
return -1;
}
else if(p1.first == p2.first)
{
return p1.second - p2.second;
}
else if (p1.first > p2.first)
{
return 1;
}

return 0;
}
}

// class Pair contains 
// two elements one is first
// other is second
class Pair 
{
int first; 
int second;
Pair(int first, int second)
{
this.first = first;
this.second = second;
}
}
public class UniqueAdjEle1 
{
// a boolean method that checks whether the elements of the array list al 
// have the valid arrangement or not.
public boolean isValidArrangement(ArrayList<Integer> al, int s)
{
int chk = 1;

for (int j = 1; j < s; j++) 
{
if (al.get(j) == al.get(j - 1)) 
{
chk = 0;
break;
}
}

return chk == 1;
}

public ArrayList<Integer> rearrangeArr(ArrayList<Integer> al, int s) 
{
if(isValidArrangement(al, s))
{
// the arrangement is valid
// hence, there is no need to proceed further
return al;
}

// Sorting the list or array al
Collections.sort(al);

// Declaring a set st that keeps the elements and their
// occurrence count.
TreeSet<Pair> st = new TreeSet<>(new PairComparator());


// Iterating over the list or array al
// Iterating until the element is the same
// Incrementing the element count by 1. 
// Inserting the element and its occurrence count in the set st
for (int j = 0; j < s; j++)
{

int k = j;
while (j < s && k < s && (al.get(j).equals(al.get(k))))
{
k = k + 1;
}
st.add(new Pair(k - j, al.get(j)));

j = k - 1;
}

int prv = -1;
int prvFreq = 0;

// Declaring an empty array or list solAl
ArrayList<Integer> solAl = new ArrayList<>();

while (st.size() != 0)
{
Pair pr = st.last();
st.remove(pr);
solAl.add(pr.second);

if (prvFreq > 0)
{
st.add(new Pair(prvFreq, prv));
}

prvFreq = pr.first - 1;
prv = pr.second;
}

// calculating the new size of the 
// rearranged array list
int newSize = solAl.size();

// if the new size after the rearrangement
// if the array list is not equal to the size s
// then, the valid rearrangement is not possible
if(newSize != s)
{
return new ArrayList<Integer>();
}

return solAl;
}


// main method
public static void main(String argvs[])
{
// creating an object of the class UniqueAdjEle1 
UniqueAdjEle1 obj = new UniqueAdjEle1();

// input 1
ArrayList<Integer> inArr = new ArrayList<Integer>
(
Arrays.asList(7, 7, 6, 8)
);

// computing the size of the 
// input array
int size = inArr.size();
System.out.println("For the input array: ");
for(int i = 0; i < size; i++)
{
System.out.print(inArr.get(i) + " ");
}
System.out.println();
ArrayList<Integer> ans = obj.rearrangeArr(inArr, size);
if(ans.size() > 0)
{
System.out.println("The valid arrangement is: ");

for(int i = 0; i < size; i++)
{
System.out.print(ans.get(i) + " ");
}
}
else
{
System.out.println("The valid arrangement is not possible. ");
}

System.out.println( "\n" );

// input 2
inArr = new ArrayList<Integer>
(
Arrays.asList(2, 4, 8, 9, 5, 7, 3, 6, 1)
);

// computing the size of the 
// input array
size = inArr.size();

System.out.println("For the input array: ");

for(int i = 0; i < size; i++)
{
System.out.print(inArr.get(i) + " ");
}

System.out.println();

ans = obj.rearrangeArr(inArr, size);

if(ans.size() > 0)
{
System.out.println("The valid arrangement is: ");

for(int i = 0; i < size; i++)
{
System.out.print(ans.get(i) + " ");
}
}
else
{
System.out.println("The valid arrangement is not possible. ");
}

System.out.println( "\n" );

// input 3
inArr = new ArrayList<Integer>
(
Arrays.asList(3, 3, 3, 3, 3)
);

// computing the size of the 
// input array
size = inArr.size();

System.out.println("For the input array: ");

for(int i = 0; i < size; i++)
{
System.out.print(inArr.get(i) + " ");
}

System.out.println();

ans = obj.rearrangeArr(inArr, size);
if(ans.size() > 0)
{
System.out.println("The valid arrangement is: ");

for(int i = 0; i < size; i++)
{
System.out.print(ans.get(i) + " ");
}
}
else
{
System.out.println("The valid arrangement is not possible. ");
}

}

}
 Output: For the input array: 
7 7 6 8 
The valid arrangement is: 
7 8 7 6 

For the input array: 
2 4 8 9 5 7 3 6 1 
The valid arrangement is: 
2 4 8 9 5 7 3 6 1 

For the input array: 
3 3 3 3 3 
The valid arrangement is not possible.
 Complexity Analysis: Since the program is using sorting, the time complexity of the program is O(N * log(N)). The program uses a set to store the elements and their occurrence count. The program is also using an auxiliary array (arr). Thus, making the space complexity of the program as (N), where N is the total number of elements present in the input array. Note: Instead of Set, a priority queue can also be used. In that case, also, the time and space complexity remain the same. Next Topic# ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/unequal-adjacent-elements-in-java Unequal Adjacent Elements in Java - Javatpoint ? SCROLL TO TOP Home Java Programs OOPs String Exception Multithreading Collections JavaFX JSP Spring Spring Boot Projects Interview Questions Java Tutorial What is Java History of Java Features of Java C++ vs Java Hello Java Program Program Internal How to set path? JDK, JRE and JVM JVM: Java Virtual Machine Java Variables Java Data Types Unicode System Operators Keywords Control Statements Java Control Statements Java If-else Java Switch Java For Loop Java While Loop Java Do While Loop Java Break Java Continue Java Comments Java Programs Java Object Class Java OOPs Concepts Naming Convention Object and Class Method Constructor static keyword this keyword Java Inheritance Inheritance(IS-A) Aggregation(HAS-A) Java Polymorphism Method Overloading Method Overriding Covariant Return Type super keyword Instance Initializer block final keyword Runtime Polymorphism Dynamic Binding instanceof operator Java Abstraction Abstract class Interface Abstract vs Interface Java Encapsulation Package Access Modifiers Encapsulation Java Array Java Array Java OOPs Misc Object class Object Cloning Math class Wrapper Class Java Recursion Call By Value strictfp keyword javadoc tool Command Line Arg Object vs Class Overloading vs Overriding Java String Java Regex Exception Handling Java Inner classes Java Multithreading Java I/O Java Networking Java AWT & Events Java Swing JavaFX Java Applet Java Reflection Java Date Java Conversion Java Collection Java JDBC Java Misc Java New Features RMI Internationalization Interview Questions Java MCQ next ? ? prev Unequal Adjacent Elements in Java An array inArr containing n numbers (positive or negative) is given. The task is to return the array after the rearrangement of elements of the integers in such a way that no two adjacent elements are equal. If there are multiple valid arrangements, then any one valid arrangement can be returned. If the input array does not contain any valid arrangement, then an appropriate message can be displayed on the console. Example 1: Input int inArr[] = {7, 7, 6, 8} Output: {7, 6, 7, 8} Explanation: There are many valid arrangements possible. Those valid arrangements are mentioned below. {7, 6, 7, 8}, {7, 6, 8, 7}, {7, 8, 7, 6}, {7, 8, 6, 7}, {8, 7, 6, 7}, {6, 7, 8, 7}. Out of which {7, 6, 7, 8} is mentioned in the output. Example 2: Input int inArr[] = {2, 4, 8, 9, 5, 7, 3, 6, 1} Output: {2, 4, 8, 9, 5, 7, 3, 6, 1} Explanation: The input array is given in such a way that there are no two elements that are of the same value. Hence, the input arrays are themselves the answer. Example 3: Input int arr[] = {3, 3, 3, 3, 3} Output: no valid arrangement is possible where adjacent elements are of different values. Explanation: All the elements are of the same value. Hence, no valid arrangement is possible. Approach: Brute Force In this approach, we compute all the arrangements of the input array. If any valid arrangement comes, we return that arrangement. If no valid arrangement is possible, display the appropriate message. For computing the valid arrangement, first, we will sort the array in ascending order. Then we will find the next permutation of the sorted array and check whether it is a valid arrangement or not. If it is a valid arrangement, then we can return that arrangement. If not, then we will find the next permutation and continue to do so until we find a valid arrangement or all the arrangements are exhausted. If the arrangements are exhausted, then we can say that no valid arrangement is there for the given input array, and the same is illustrated in the following program. FileName: UniqueAdjEle.java 
// important import statements
import java.util.Collections;
import java.util.ArrayList;
import java.util.Arrays;


public class UniqueAdjEle 
{
    // swapping the elements in the array list al
    // that are present at the index j and k
    private void swapEle(ArrayList<Integer> al, int j, int k) 
    {
        int temp = al.get(j);
        al.set(j, al.get(k));
        al.set(k, temp);
    }
    // reversing the array list from j to k
    private void reverseArrList(ArrayList<Integer> al, int j, int k) 
    {
        while (j < k) 
        {
            swapEle(al, j, k);
            j = j + 1;
            k = k - 1;
        }
    }

    private boolean nextPermutation(ArrayList<Integer> al) 
    {
        // if the list has no elements
        // or the single element, then
        // there is no need to proceed further
        if (al == null || al.size() <= 1) 
        {
            return false;
        }

        int j = al.size() - 2;

        while (j >= 0 && al.get(j).intValue() >= al.get(j + 1).intValue()) 
        {

            // Finding the first j that is breaking descending order
            j = j - 1;
        }

        if (j >= 0) 
        {
            // if the control reaching
            // here, then it means the array
            // is not entirely descending

            // Starting from the end
            int k = al.size() - 1;

            while (al.get(k).intValue() <= al.get(j).intValue()) 
            {
                // Finding the rightmost first larger id than k
                k = k - 1;
            }

            // Switching j and k
            swapEle(al, j, k);

            // Reversing in the descending sequence
            reverseArrList(al, j + 1, al.size() - 1);

            return true;
        } else 
        {
            // Reversing the whole sequence.
            reverseArrList(al, 0, al.size() - 1);
            return false;
        }
    }
    // a Boolean method that checks whether the elements of the array list al 
    // have the valid arrangement or not.
    public boolean isValidArrangement(ArrayList<Integer> al, int s)
    {
        int chk = 1;

            for (int j = 1; j < s; j++) 
            {
                if (al.get(j) == al.get(j - 1)) 
                {
                    chk = 0;
                    break;
                }
            }

            return chk == 1;
    }

    public ArrayList<Integer> rearrangeArr(ArrayList<Integer> al, int s) 
    {   
        if(isValidArrangement(al, s))
        {
            return al;
        }
        // sorting the list so we can compute the next permutation
        Collections.sort(al);
       
        // Iterating the array list and 
        // checking whether it is a valid arrangement or not
        // if yes, then we terminate the do-while loop.
        // Otherwise, we find the next permutation.
         while (nextPermutation(al))
         {
             if(isValidArrangement(al, s))
             {
                 return al;
             }
         }

        return new ArrayList<Integer>();
    }
    
    // main method
    public static void main(String argvs[])
    {
        // creating an object of the class UniqueAdjEle 
        UniqueAdjEle obj = new UniqueAdjEle();
        
        // input 1
        ArrayList<Integer> inArr = new ArrayList<Integer>
        (
            Arrays.asList(7, 7, 6, 8)
        );
        
        // computing the size of the 
        // input array
        int size = inArr.size();
        System.out.println("For the input array: ");
        for(int i = 0; i < size; i++)
        {
            System.out.print(inArr.get(i) + " ");
        }
        System.out.println();
        ArrayList<Integer> ans = obj.rearrangeArr(inArr, size);
        if(ans.size() > 0)
        {
        System.out.println("The valid arrangement is: ");
        
        for(int i = 0; i < size; i++)
        {
            System.out.print(ans.get(i) + " ");
        }
        }
        else
        {
            System.out.println("The valid arrangement is not possible. ");
        }
        
        System.out.println( "\n" );
        
        // input 2
        inArr = new ArrayList<Integer>
        (
            Arrays.asList(2, 4, 8, 9, 5, 7, 3, 6, 1)
        );
        
        // computing the size of the 
        // input array
        size = inArr.size();
        
        System.out.println("For the input array: ");
        
        for(int i = 0; i < size; i++)
        {
            System.out.print(inArr.get(i) + " ");
        }
        
        System.out.println();
        
        ans = obj.rearrangeArr(inArr, size);
        
        if(ans.size() > 0)
        {
        System.out.println("The valid arrangement is: ");
        
        for(int i = 0; i < size; i++)
        {
            System.out.print(ans.get(i) + " ");
        }
        }
        else
        {
            System.out.println("The valid arrangement is not possible. ");
        }
        
        System.out.println( "\n" );
        
        // input 3
        inArr = new ArrayList<Integer>
        (
            Arrays.asList(3, 3, 3, 3, 3)
        );
        
        // computing the size of the 
        // input array
        size = inArr.size();
        
        System.out.println("For the input array: ");
        
        for(int i = 0; i < size; i++)
        {
            System.out.print(inArr.get(i) + " ");
        }
        
        System.out.println();
        
        ans = obj.rearrangeArr(inArr, size);
        if(ans.size() > 0)
        {
        System.out.println("The valid arrangement is: ");
        
        for(int i = 0; i < size; i++)
        {
            System.out.print(ans.get(i) + " ");
        }
        }
        else
        {
            System.out.println("The valid arrangement is not possible. ");
        }
        
    }
    
    
    
}
 Output: For the input array: 
7 7 6 8 
The valid arrangement is: 
6 7 8 7 

For the input array: 
2 4 8 9 5 7 3 6 1 
The valid arrangement is: 
2 4 8 9 5 7 3 6 1 

For the input array: 
3 3 3 3 3 
The valid arrangement is not possible.
 Complexity Analysis: Since the program is computing the permutation, the time complexity of the program is O(N!), where N is the total number of elements present in the linked list. The program uses constant space; therefore, the space complexity of the program is O(1). The above program is not suitable for the larger inputs as the time complexity of the program is too high. Therefore, we must do some optimization to reduce the time complexity. Approach: Using Set It is a greedy approach where we put first that element which is occurring the most number of times in the input array. Using the set, we will put all the elements in the order of their occurrence count. The following are the steps involved in computing the answer. Step 1: Declare an empty array or list solAl. Step 2: Sort the array or list solAl. Step 3: Declare a set st that keeps the elements and their occurrence count. Step 4: Iterate over the list or array solAl: Iterate until the same element is encountered every time. Increment the element count by 1. Put the element and the occurrence count of the element in the set st. Step 5: Create a temporary variable for keeping the previous element and its occurrence count. Step 6: While the set st is not empty, do the following: Fetch the last element and get it added to the result. Delete that element from the set st. Reduce the occurrence count of the element popped by 1. If the occurrence count was non-zero of the previous elements, put it in the set. The current element should be treated as the previous element for the upcoming iteration. Step 7: Eventually, return the list or array solAl. Implementation The implementation of the above steps is mentioned below. FileName: UniqueAdjEle.java 
// important import statements
import java.util.Arrays;
import java.util.ArrayList;
import java.util.TreeSet;
import java.util.Collections;
import java.util.Comparator;

class PairComparator implements Comparator<Pair>
{

// Overriding the compare() method of the Comparator
public int compare(Pair p1, Pair p2)
{
if (p1.first < p2.first)
{
return -1;
}
else if(p1.first == p2.first)
{
return p1.second - p2.second;
}
else if (p1.first > p2.first)
{
return 1;
}

return 0;
}
}

// class Pair contains 
// two elements one is first
// other is second
class Pair 
{
int first; 
int second;
Pair(int first, int second)
{
this.first = first;
this.second = second;
}
}
public class UniqueAdjEle1 
{
// a boolean method that checks whether the elements of the array list al 
// have the valid arrangement or not.
public boolean isValidArrangement(ArrayList<Integer> al, int s)
{
int chk = 1;

for (int j = 1; j < s; j++) 
{
if (al.get(j) == al.get(j - 1)) 
{
chk = 0;
break;
}
}

return chk == 1;
}

public ArrayList<Integer> rearrangeArr(ArrayList<Integer> al, int s) 
{
if(isValidArrangement(al, s))
{
// the arrangement is valid
// hence, there is no need to proceed further
return al;
}

// Sorting the list or array al
Collections.sort(al);

// Declaring a set st that keeps the elements and their
// occurrence count.
TreeSet<Pair> st = new TreeSet<>(new PairComparator());


// Iterating over the list or array al
// Iterating until the element is the same
// Incrementing the element count by 1. 
// Inserting the element and its occurrence count in the set st
for (int j = 0; j < s; j++)
{

int k = j;
while (j < s && k < s && (al.get(j).equals(al.get(k))))
{
k = k + 1;
}
st.add(new Pair(k - j, al.get(j)));

j = k - 1;
}

int prv = -1;
int prvFreq = 0;

// Declaring an empty array or list solAl
ArrayList<Integer> solAl = new ArrayList<>();

while (st.size() != 0)
{
Pair pr = st.last();
st.remove(pr);
solAl.add(pr.second);

if (prvFreq > 0)
{
st.add(new Pair(prvFreq, prv));
}

prvFreq = pr.first - 1;
prv = pr.second;
}

// calculating the new size of the 
// rearranged array list
int newSize = solAl.size();

// if the new size after the rearrangement
// if the array list is not equal to the size s
// then, the valid rearrangement is not possible
if(newSize != s)
{
return new ArrayList<Integer>();
}

return solAl;
}


// main method
public static void main(String argvs[])
{
// creating an object of the class UniqueAdjEle1 
UniqueAdjEle1 obj = new UniqueAdjEle1();

// input 1
ArrayList<Integer> inArr = new ArrayList<Integer>
(
Arrays.asList(7, 7, 6, 8)
);

// computing the size of the 
// input array
int size = inArr.size();
System.out.println("For the input array: ");
for(int i = 0; i < size; i++)
{
System.out.print(inArr.get(i) + " ");
}
System.out.println();
ArrayList<Integer> ans = obj.rearrangeArr(inArr, size);
if(ans.size() > 0)
{
System.out.println("The valid arrangement is: ");

for(int i = 0; i < size; i++)
{
System.out.print(ans.get(i) + " ");
}
}
else
{
System.out.println("The valid arrangement is not possible. ");
}

System.out.println( "\n" );

// input 2
inArr = new ArrayList<Integer>
(
Arrays.asList(2, 4, 8, 9, 5, 7, 3, 6, 1)
);

// computing the size of the 
// input array
size = inArr.size();

System.out.println("For the input array: ");

for(int i = 0; i < size; i++)
{
System.out.print(inArr.get(i) + " ");
}

System.out.println();

ans = obj.rearrangeArr(inArr, size);

if(ans.size() > 0)
{
System.out.println("The valid arrangement is: ");

for(int i = 0; i < size; i++)
{
System.out.print(ans.get(i) + " ");
}
}
else
{
System.out.println("The valid arrangement is not possible. ");
}

System.out.println( "\n" );

// input 3
inArr = new ArrayList<Integer>
(
Arrays.asList(3, 3, 3, 3, 3)
);

// computing the size of the 
// input array
size = inArr.size();

System.out.println("For the input array: ");

for(int i = 0; i < size; i++)
{
System.out.print(inArr.get(i) + " ");
}

System.out.println();

ans = obj.rearrangeArr(inArr, size);
if(ans.size() > 0)
{
System.out.println("The valid arrangement is: ");

for(int i = 0; i < size; i++)
{
System.out.print(ans.get(i) + " ");
}
}
else
{
System.out.println("The valid arrangement is not possible. ");
}

}

}
 Output: For the input array: 
7 7 6 8 
The valid arrangement is: 
7 8 7 6 

For the input array: 
2 4 8 9 5 7 3 6 1 
The valid arrangement is: 
2 4 8 9 5 7 3 6 1 

For the input array: 
3 3 3 3 3 
The valid arrangement is not possible.
 Complexity Analysis: Since the program is using sorting, the time complexity of the program is O(N * log(N)). The program uses a set to store the elements and their occurrence count. The program is also using an auxiliary array (arr). Thus, making the space complexity of the program as (N), where N is the total number of elements present in the input array. Note: Instead of Set, a priority queue can also be used. In that case, also, the time and space complexity remain the same. Next Topic# ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/unequal-adjacent-elements-in-java Unequal Adjacent Elements in Java - Javatpoint ? SCROLL TO TOP Home Java Programs OOPs String Exception Multithreading Collections JavaFX JSP Spring Spring Boot Projects Interview Questions Java Tutorial What is Java History of Java Features of Java C++ vs Java Hello Java Program Program Internal How to set path? JDK, JRE and JVM JVM: Java Virtual Machine Java Variables Java Data Types Unicode System Operators Keywords Control Statements Java Control Statements Java If-else Java Switch Java For Loop Java While Loop Java Do While Loop Java Break Java Continue Java Comments Java Programs Java Object Class Java OOPs Concepts Naming Convention Object and Class Method Constructor static keyword this keyword Java Inheritance Inheritance(IS-A) Aggregation(HAS-A) Java Polymorphism Method Overloading Method Overriding Covariant Return Type super keyword Instance Initializer block final keyword Runtime Polymorphism Dynamic Binding instanceof operator Java Abstraction Abstract class Interface Abstract vs Interface Java Encapsulation Package Access Modifiers Encapsulation Java Array Java Array Java OOPs Misc Object class Object Cloning Math class Wrapper Class Java Recursion Call By Value strictfp keyword javadoc tool Command Line Arg Object vs Class Overloading vs Overriding Java String Java Regex Exception Handling Java Inner classes Java Multithreading Java I/O Java Networking Java AWT & Events Java Swing JavaFX Java Applet Java Reflection Java Date Java Conversion Java Collection Java JDBC Java Misc Java New Features RMI Internationalization Interview Questions Java MCQ next ? ? prev Unequal Adjacent Elements in Java An array inArr containing n numbers (positive or negative) is given. The task is to return the array after the rearrangement of elements of the integers in such a way that no two adjacent elements are equal. If there are multiple valid arrangements, then any one valid arrangement can be returned. If the input array does not contain any valid arrangement, then an appropriate message can be displayed on the console. Example 1: Input int inArr[] = {7, 7, 6, 8} Output: {7, 6, 7, 8} Explanation: There are many valid arrangements possible. Those valid arrangements are mentioned below. {7, 6, 7, 8}, {7, 6, 8, 7}, {7, 8, 7, 6}, {7, 8, 6, 7}, {8, 7, 6, 7}, {6, 7, 8, 7}. Out of which {7, 6, 7, 8} is mentioned in the output. Example 2: Input int inArr[] = {2, 4, 8, 9, 5, 7, 3, 6, 1} Output: {2, 4, 8, 9, 5, 7, 3, 6, 1} Explanation: The input array is given in such a way that there are no two elements that are of the same value. Hence, the input arrays are themselves the answer. Example 3: Input int arr[] = {3, 3, 3, 3, 3} Output: no valid arrangement is possible where adjacent elements are of different values. Explanation: All the elements are of the same value. Hence, no valid arrangement is possible. Approach: Brute Force In this approach, we compute all the arrangements of the input array. If any valid arrangement comes, we return that arrangement. If no valid arrangement is possible, display the appropriate message. For computing the valid arrangement, first, we will sort the array in ascending order. Then we will find the next permutation of the sorted array and check whether it is a valid arrangement or not. If it is a valid arrangement, then we can return that arrangement. If not, then we will find the next permutation and continue to do so until we find a valid arrangement or all the arrangements are exhausted. If the arrangements are exhausted, then we can say that no valid arrangement is there for the given input array, and the same is illustrated in the following program. FileName: UniqueAdjEle.java 
// important import statements
import java.util.Collections;
import java.util.ArrayList;
import java.util.Arrays;


public class UniqueAdjEle 
{
    // swapping the elements in the array list al
    // that are present at the index j and k
    private void swapEle(ArrayList<Integer> al, int j, int k) 
    {
        int temp = al.get(j);
        al.set(j, al.get(k));
        al.set(k, temp);
    }
    // reversing the array list from j to k
    private void reverseArrList(ArrayList<Integer> al, int j, int k) 
    {
        while (j < k) 
        {
            swapEle(al, j, k);
            j = j + 1;
            k = k - 1;
        }
    }

    private boolean nextPermutation(ArrayList<Integer> al) 
    {
        // if the list has no elements
        // or the single element, then
        // there is no need to proceed further
        if (al == null || al.size() <= 1) 
        {
            return false;
        }

        int j = al.size() - 2;

        while (j >= 0 && al.get(j).intValue() >= al.get(j + 1).intValue()) 
        {

            // Finding the first j that is breaking descending order
            j = j - 1;
        }

        if (j >= 0) 
        {
            // if the control reaching
            // here, then it means the array
            // is not entirely descending

            // Starting from the end
            int k = al.size() - 1;

            while (al.get(k).intValue() <= al.get(j).intValue()) 
            {
                // Finding the rightmost first larger id than k
                k = k - 1;
            }

            // Switching j and k
            swapEle(al, j, k);

            // Reversing in the descending sequence
            reverseArrList(al, j + 1, al.size() - 1);

            return true;
        } else 
        {
            // Reversing the whole sequence.
            reverseArrList(al, 0, al.size() - 1);
            return false;
        }
    }
    // a Boolean method that checks whether the elements of the array list al 
    // have the valid arrangement or not.
    public boolean isValidArrangement(ArrayList<Integer> al, int s)
    {
        int chk = 1;

            for (int j = 1; j < s; j++) 
            {
                if (al.get(j) == al.get(j - 1)) 
                {
                    chk = 0;
                    break;
                }
            }

            return chk == 1;
    }

    public ArrayList<Integer> rearrangeArr(ArrayList<Integer> al, int s) 
    {   
        if(isValidArrangement(al, s))
        {
            return al;
        }
        // sorting the list so we can compute the next permutation
        Collections.sort(al);
       
        // Iterating the array list and 
        // checking whether it is a valid arrangement or not
        // if yes, then we terminate the do-while loop.
        // Otherwise, we find the next permutation.
         while (nextPermutation(al))
         {
             if(isValidArrangement(al, s))
             {
                 return al;
             }
         }

        return new ArrayList<Integer>();
    }
    
    // main method
    public static void main(String argvs[])
    {
        // creating an object of the class UniqueAdjEle 
        UniqueAdjEle obj = new UniqueAdjEle();
        
        // input 1
        ArrayList<Integer> inArr = new ArrayList<Integer>
        (
            Arrays.asList(7, 7, 6, 8)
        );
        
        // computing the size of the 
        // input array
        int size = inArr.size();
        System.out.println("For the input array: ");
        for(int i = 0; i < size; i++)
        {
            System.out.print(inArr.get(i) + " ");
        }
        System.out.println();
        ArrayList<Integer> ans = obj.rearrangeArr(inArr, size);
        if(ans.size() > 0)
        {
        System.out.println("The valid arrangement is: ");
        
        for(int i = 0; i < size; i++)
        {
            System.out.print(ans.get(i) + " ");
        }
        }
        else
        {
            System.out.println("The valid arrangement is not possible. ");
        }
        
        System.out.println( "\n" );
        
        // input 2
        inArr = new ArrayList<Integer>
        (
            Arrays.asList(2, 4, 8, 9, 5, 7, 3, 6, 1)
        );
        
        // computing the size of the 
        // input array
        size = inArr.size();
        
        System.out.println("For the input array: ");
        
        for(int i = 0; i < size; i++)
        {
            System.out.print(inArr.get(i) + " ");
        }
        
        System.out.println();
        
        ans = obj.rearrangeArr(inArr, size);
        
        if(ans.size() > 0)
        {
        System.out.println("The valid arrangement is: ");
        
        for(int i = 0; i < size; i++)
        {
            System.out.print(ans.get(i) + " ");
        }
        }
        else
        {
            System.out.println("The valid arrangement is not possible. ");
        }
        
        System.out.println( "\n" );
        
        // input 3
        inArr = new ArrayList<Integer>
        (
            Arrays.asList(3, 3, 3, 3, 3)
        );
        
        // computing the size of the 
        // input array
        size = inArr.size();
        
        System.out.println("For the input array: ");
        
        for(int i = 0; i < size; i++)
        {
            System.out.print(inArr.get(i) + " ");
        }
        
        System.out.println();
        
        ans = obj.rearrangeArr(inArr, size);
        if(ans.size() > 0)
        {
        System.out.println("The valid arrangement is: ");
        
        for(int i = 0; i < size; i++)
        {
            System.out.print(ans.get(i) + " ");
        }
        }
        else
        {
            System.out.println("The valid arrangement is not possible. ");
        }
        
    }
    
    
    
}
 Output: For the input array: 
7 7 6 8 
The valid arrangement is: 
6 7 8 7 

For the input array: 
2 4 8 9 5 7 3 6 1 
The valid arrangement is: 
2 4 8 9 5 7 3 6 1 

For the input array: 
3 3 3 3 3 
The valid arrangement is not possible.
 Complexity Analysis: Since the program is computing the permutation, the time complexity of the program is O(N!), where N is the total number of elements present in the linked list. The program uses constant space; therefore, the space complexity of the program is O(1). The above program is not suitable for the larger inputs as the time complexity of the program is too high. Therefore, we must do some optimization to reduce the time complexity. Approach: Using Set It is a greedy approach where we put first that element which is occurring the most number of times in the input array. Using the set, we will put all the elements in the order of their occurrence count. The following are the steps involved in computing the answer. Step 1: Declare an empty array or list solAl. Step 2: Sort the array or list solAl. Step 3: Declare a set st that keeps the elements and their occurrence count. Step 4: Iterate over the list or array solAl: Iterate until the same element is encountered every time. Increment the element count by 1. Put the element and the occurrence count of the element in the set st. Step 5: Create a temporary variable for keeping the previous element and its occurrence count. Step 6: While the set st is not empty, do the following: Fetch the last element and get it added to the result. Delete that element from the set st. Reduce the occurrence count of the element popped by 1. If the occurrence count was non-zero of the previous elements, put it in the set. The current element should be treated as the previous element for the upcoming iteration. Step 7: Eventually, return the list or array solAl. Implementation The implementation of the above steps is mentioned below. FileName: UniqueAdjEle.java 
// important import statements
import java.util.Arrays;
import java.util.ArrayList;
import java.util.TreeSet;
import java.util.Collections;
import java.util.Comparator;

class PairComparator implements Comparator<Pair>
{

// Overriding the compare() method of the Comparator
public int compare(Pair p1, Pair p2)
{
if (p1.first < p2.first)
{
return -1;
}
else if(p1.first == p2.first)
{
return p1.second - p2.second;
}
else if (p1.first > p2.first)
{
return 1;
}

return 0;
}
}

// class Pair contains 
// two elements one is first
// other is second
class Pair 
{
int first; 
int second;
Pair(int first, int second)
{
this.first = first;
this.second = second;
}
}
public class UniqueAdjEle1 
{
// a boolean method that checks whether the elements of the array list al 
// have the valid arrangement or not.
public boolean isValidArrangement(ArrayList<Integer> al, int s)
{
int chk = 1;

for (int j = 1; j < s; j++) 
{
if (al.get(j) == al.get(j - 1)) 
{
chk = 0;
break;
}
}

return chk == 1;
}

public ArrayList<Integer> rearrangeArr(ArrayList<Integer> al, int s) 
{
if(isValidArrangement(al, s))
{
// the arrangement is valid
// hence, there is no need to proceed further
return al;
}

// Sorting the list or array al
Collections.sort(al);

// Declaring a set st that keeps the elements and their
// occurrence count.
TreeSet<Pair> st = new TreeSet<>(new PairComparator());


// Iterating over the list or array al
// Iterating until the element is the same
// Incrementing the element count by 1. 
// Inserting the element and its occurrence count in the set st
for (int j = 0; j < s; j++)
{

int k = j;
while (j < s && k < s && (al.get(j).equals(al.get(k))))
{
k = k + 1;
}
st.add(new Pair(k - j, al.get(j)));

j = k - 1;
}

int prv = -1;
int prvFreq = 0;

// Declaring an empty array or list solAl
ArrayList<Integer> solAl = new ArrayList<>();

while (st.size() != 0)
{
Pair pr = st.last();
st.remove(pr);
solAl.add(pr.second);

if (prvFreq > 0)
{
st.add(new Pair(prvFreq, prv));
}

prvFreq = pr.first - 1;
prv = pr.second;
}

// calculating the new size of the 
// rearranged array list
int newSize = solAl.size();

// if the new size after the rearrangement
// if the array list is not equal to the size s
// then, the valid rearrangement is not possible
if(newSize != s)
{
return new ArrayList<Integer>();
}

return solAl;
}


// main method
public static void main(String argvs[])
{
// creating an object of the class UniqueAdjEle1 
UniqueAdjEle1 obj = new UniqueAdjEle1();

// input 1
ArrayList<Integer> inArr = new ArrayList<Integer>
(
Arrays.asList(7, 7, 6, 8)
);

// computing the size of the 
// input array
int size = inArr.size();
System.out.println("For the input array: ");
for(int i = 0; i < size; i++)
{
System.out.print(inArr.get(i) + " ");
}
System.out.println();
ArrayList<Integer> ans = obj.rearrangeArr(inArr, size);
if(ans.size() > 0)
{
System.out.println("The valid arrangement is: ");

for(int i = 0; i < size; i++)
{
System.out.print(ans.get(i) + " ");
}
}
else
{
System.out.println("The valid arrangement is not possible. ");
}

System.out.println( "\n" );

// input 2
inArr = new ArrayList<Integer>
(
Arrays.asList(2, 4, 8, 9, 5, 7, 3, 6, 1)
);

// computing the size of the 
// input array
size = inArr.size();

System.out.println("For the input array: ");

for(int i = 0; i < size; i++)
{
System.out.print(inArr.get(i) + " ");
}

System.out.println();

ans = obj.rearrangeArr(inArr, size);

if(ans.size() > 0)
{
System.out.println("The valid arrangement is: ");

for(int i = 0; i < size; i++)
{
System.out.print(ans.get(i) + " ");
}
}
else
{
System.out.println("The valid arrangement is not possible. ");
}

System.out.println( "\n" );

// input 3
inArr = new ArrayList<Integer>
(
Arrays.asList(3, 3, 3, 3, 3)
);

// computing the size of the 
// input array
size = inArr.size();

System.out.println("For the input array: ");

for(int i = 0; i < size; i++)
{
System.out.print(inArr.get(i) + " ");
}

System.out.println();

ans = obj.rearrangeArr(inArr, size);
if(ans.size() > 0)
{
System.out.println("The valid arrangement is: ");

for(int i = 0; i < size; i++)
{
System.out.print(ans.get(i) + " ");
}
}
else
{
System.out.println("The valid arrangement is not possible. ");
}

}

}
 Output: For the input array: 
7 7 6 8 
The valid arrangement is: 
7 8 7 6 

For the input array: 
2 4 8 9 5 7 3 6 1 
The valid arrangement is: 
2 4 8 9 5 7 3 6 1 

For the input array: 
3 3 3 3 3 
The valid arrangement is not possible.
 Complexity Analysis: Since the program is using sorting, the time complexity of the program is O(N * log(N)). The program uses a set to store the elements and their occurrence count. The program is also using an auxiliary array (arr). Thus, making the space complexity of the program as (N), where N is the total number of elements present in the input array. Note: Instead of Set, a priority queue can also be used. In that case, also, the time and space complexity remain the same. Next Topic# ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/unequal-adjacent-elements-in-java Unequal Adjacent Elements in Java - Javatpoint ? SCROLL TO TOP Home Java Programs OOPs String Exception Multithreading Collections JavaFX JSP Spring Spring Boot Projects Interview Questions Java Tutorial What is Java History of Java Features of Java C++ vs Java Hello Java Program Program Internal How to set path? JDK, JRE and JVM JVM: Java Virtual Machine Java Variables Java Data Types Unicode System Operators Keywords Control Statements Java Control Statements Java If-else Java Switch Java For Loop Java While Loop Java Do While Loop Java Break Java Continue Java Comments Java Programs Java Object Class Java OOPs Concepts Naming Convention Object and Class Method Constructor static keyword this keyword Java Inheritance Inheritance(IS-A) Aggregation(HAS-A) Java Polymorphism Method Overloading Method Overriding Covariant Return Type super keyword Instance Initializer block final keyword Runtime Polymorphism Dynamic Binding instanceof operator Java Abstraction Abstract class Interface Abstract vs Interface Java Encapsulation Package Access Modifiers Encapsulation Java Array Java Array Java OOPs Misc Object class Object Cloning Math class Wrapper Class Java Recursion Call By Value strictfp keyword javadoc tool Command Line Arg Object vs Class Overloading vs Overriding Java String Java Regex Exception Handling Java Inner classes Java Multithreading Java I/O Java Networking Java AWT & Events Java Swing JavaFX Java Applet Java Reflection Java Date Java Conversion Java Collection Java JDBC Java Misc Java New Features RMI Internationalization Interview Questions Java MCQ next ? ? prev Unequal Adjacent Elements in Java An array inArr containing n numbers (positive or negative) is given. The task is to return the array after the rearrangement of elements of the integers in such a way that no two adjacent elements are equal. If there are multiple valid arrangements, then any one valid arrangement can be returned. If the input array does not contain any valid arrangement, then an appropriate message can be displayed on the console. Example 1: Input int inArr[] = {7, 7, 6, 8} Output: {7, 6, 7, 8} Explanation: There are many valid arrangements possible. Those valid arrangements are mentioned below. {7, 6, 7, 8}, {7, 6, 8, 7}, {7, 8, 7, 6}, {7, 8, 6, 7}, {8, 7, 6, 7}, {6, 7, 8, 7}. Out of which {7, 6, 7, 8} is mentioned in the output. Example 2: Input int inArr[] = {2, 4, 8, 9, 5, 7, 3, 6, 1} Output: {2, 4, 8, 9, 5, 7, 3, 6, 1} Explanation: The input array is given in such a way that there are no two elements that are of the same value. Hence, the input arrays are themselves the answer. Example 3: Input int arr[] = {3, 3, 3, 3, 3} Output: no valid arrangement is possible where adjacent elements are of different values. Explanation: All the elements are of the same value. Hence, no valid arrangement is possible. Approach: Brute Force In this approach, we compute all the arrangements of the input array. If any valid arrangement comes, we return that arrangement. If no valid arrangement is possible, display the appropriate message. For computing the valid arrangement, first, we will sort the array in ascending order. Then we will find the next permutation of the sorted array and check whether it is a valid arrangement or not. If it is a valid arrangement, then we can return that arrangement. If not, then we will find the next permutation and continue to do so until we find a valid arrangement or all the arrangements are exhausted. If the arrangements are exhausted, then we can say that no valid arrangement is there for the given input array, and the same is illustrated in the following program. FileName: UniqueAdjEle.java 
// important import statements
import java.util.Collections;
import java.util.ArrayList;
import java.util.Arrays;


public class UniqueAdjEle 
{
    // swapping the elements in the array list al
    // that are present at the index j and k
    private void swapEle(ArrayList<Integer> al, int j, int k) 
    {
        int temp = al.get(j);
        al.set(j, al.get(k));
        al.set(k, temp);
    }
    // reversing the array list from j to k
    private void reverseArrList(ArrayList<Integer> al, int j, int k) 
    {
        while (j < k) 
        {
            swapEle(al, j, k);
            j = j + 1;
            k = k - 1;
        }
    }

    private boolean nextPermutation(ArrayList<Integer> al) 
    {
        // if the list has no elements
        // or the single element, then
        // there is no need to proceed further
        if (al == null || al.size() <= 1) 
        {
            return false;
        }

        int j = al.size() - 2;

        while (j >= 0 && al.get(j).intValue() >= al.get(j + 1).intValue()) 
        {

            // Finding the first j that is breaking descending order
            j = j - 1;
        }

        if (j >= 0) 
        {
            // if the control reaching
            // here, then it means the array
            // is not entirely descending

            // Starting from the end
            int k = al.size() - 1;

            while (al.get(k).intValue() <= al.get(j).intValue()) 
            {
                // Finding the rightmost first larger id than k
                k = k - 1;
            }

            // Switching j and k
            swapEle(al, j, k);

            // Reversing in the descending sequence
            reverseArrList(al, j + 1, al.size() - 1);

            return true;
        } else 
        {
            // Reversing the whole sequence.
            reverseArrList(al, 0, al.size() - 1);
            return false;
        }
    }
    // a Boolean method that checks whether the elements of the array list al 
    // have the valid arrangement or not.
    public boolean isValidArrangement(ArrayList<Integer> al, int s)
    {
        int chk = 1;

            for (int j = 1; j < s; j++) 
            {
                if (al.get(j) == al.get(j - 1)) 
                {
                    chk = 0;
                    break;
                }
            }

            return chk == 1;
    }

    public ArrayList<Integer> rearrangeArr(ArrayList<Integer> al, int s) 
    {   
        if(isValidArrangement(al, s))
        {
            return al;
        }
        // sorting the list so we can compute the next permutation
        Collections.sort(al);
       
        // Iterating the array list and 
        // checking whether it is a valid arrangement or not
        // if yes, then we terminate the do-while loop.
        // Otherwise, we find the next permutation.
         while (nextPermutation(al))
         {
             if(isValidArrangement(al, s))
             {
                 return al;
             }
         }

        return new ArrayList<Integer>();
    }
    
    // main method
    public static void main(String argvs[])
    {
        // creating an object of the class UniqueAdjEle 
        UniqueAdjEle obj = new UniqueAdjEle();
        
        // input 1
        ArrayList<Integer> inArr = new ArrayList<Integer>
        (
            Arrays.asList(7, 7, 6, 8)
        );
        
        // computing the size of the 
        // input array
        int size = inArr.size();
        System.out.println("For the input array: ");
        for(int i = 0; i < size; i++)
        {
            System.out.print(inArr.get(i) + " ");
        }
        System.out.println();
        ArrayList<Integer> ans = obj.rearrangeArr(inArr, size);
        if(ans.size() > 0)
        {
        System.out.println("The valid arrangement is: ");
        
        for(int i = 0; i < size; i++)
        {
            System.out.print(ans.get(i) + " ");
        }
        }
        else
        {
            System.out.println("The valid arrangement is not possible. ");
        }
        
        System.out.println( "\n" );
        
        // input 2
        inArr = new ArrayList<Integer>
        (
            Arrays.asList(2, 4, 8, 9, 5, 7, 3, 6, 1)
        );
        
        // computing the size of the 
        // input array
        size = inArr.size();
        
        System.out.println("For the input array: ");
        
        for(int i = 0; i < size; i++)
        {
            System.out.print(inArr.get(i) + " ");
        }
        
        System.out.println();
        
        ans = obj.rearrangeArr(inArr, size);
        
        if(ans.size() > 0)
        {
        System.out.println("The valid arrangement is: ");
        
        for(int i = 0; i < size; i++)
        {
            System.out.print(ans.get(i) + " ");
        }
        }
        else
        {
            System.out.println("The valid arrangement is not possible. ");
        }
        
        System.out.println( "\n" );
        
        // input 3
        inArr = new ArrayList<Integer>
        (
            Arrays.asList(3, 3, 3, 3, 3)
        );
        
        // computing the size of the 
        // input array
        size = inArr.size();
        
        System.out.println("For the input array: ");
        
        for(int i = 0; i < size; i++)
        {
            System.out.print(inArr.get(i) + " ");
        }
        
        System.out.println();
        
        ans = obj.rearrangeArr(inArr, size);
        if(ans.size() > 0)
        {
        System.out.println("The valid arrangement is: ");
        
        for(int i = 0; i < size; i++)
        {
            System.out.print(ans.get(i) + " ");
        }
        }
        else
        {
            System.out.println("The valid arrangement is not possible. ");
        }
        
    }
    
    
    
}
 Output: For the input array: 
7 7 6 8 
The valid arrangement is: 
6 7 8 7 

For the input array: 
2 4 8 9 5 7 3 6 1 
The valid arrangement is: 
2 4 8 9 5 7 3 6 1 

For the input array: 
3 3 3 3 3 
The valid arrangement is not possible.
 Complexity Analysis: Since the program is computing the permutation, the time complexity of the program is O(N!), where N is the total number of elements present in the linked list. The program uses constant space; therefore, the space complexity of the program is O(1). The above program is not suitable for the larger inputs as the time complexity of the program is too high. Therefore, we must do some optimization to reduce the time complexity. Approach: Using Set It is a greedy approach where we put first that element which is occurring the most number of times in the input array. Using the set, we will put all the elements in the order of their occurrence count. The following are the steps involved in computing the answer. Step 1: Declare an empty array or list solAl. Step 2: Sort the array or list solAl. Step 3: Declare a set st that keeps the elements and their occurrence count. Step 4: Iterate over the list or array solAl: Iterate until the same element is encountered every time. Increment the element count by 1. Put the element and the occurrence count of the element in the set st. Step 5: Create a temporary variable for keeping the previous element and its occurrence count. Step 6: While the set st is not empty, do the following: Fetch the last element and get it added to the result. Delete that element from the set st. Reduce the occurrence count of the element popped by 1. If the occurrence count was non-zero of the previous elements, put it in the set. The current element should be treated as the previous element for the upcoming iteration. Step 7: Eventually, return the list or array solAl. Implementation The implementation of the above steps is mentioned below. FileName: UniqueAdjEle.java 
// important import statements
import java.util.Arrays;
import java.util.ArrayList;
import java.util.TreeSet;
import java.util.Collections;
import java.util.Comparator;

class PairComparator implements Comparator<Pair>
{

// Overriding the compare() method of the Comparator
public int compare(Pair p1, Pair p2)
{
if (p1.first < p2.first)
{
return -1;
}
else if(p1.first == p2.first)
{
return p1.second - p2.second;
}
else if (p1.first > p2.first)
{
return 1;
}

return 0;
}
}

// class Pair contains 
// two elements one is first
// other is second
class Pair 
{
int first; 
int second;
Pair(int first, int second)
{
this.first = first;
this.second = second;
}
}
public class UniqueAdjEle1 
{
// a boolean method that checks whether the elements of the array list al 
// have the valid arrangement or not.
public boolean isValidArrangement(ArrayList<Integer> al, int s)
{
int chk = 1;

for (int j = 1; j < s; j++) 
{
if (al.get(j) == al.get(j - 1)) 
{
chk = 0;
break;
}
}

return chk == 1;
}

public ArrayList<Integer> rearrangeArr(ArrayList<Integer> al, int s) 
{
if(isValidArrangement(al, s))
{
// the arrangement is valid
// hence, there is no need to proceed further
return al;
}

// Sorting the list or array al
Collections.sort(al);

// Declaring a set st that keeps the elements and their
// occurrence count.
TreeSet<Pair> st = new TreeSet<>(new PairComparator());


// Iterating over the list or array al
// Iterating until the element is the same
// Incrementing the element count by 1. 
// Inserting the element and its occurrence count in the set st
for (int j = 0; j < s; j++)
{

int k = j;
while (j < s && k < s && (al.get(j).equals(al.get(k))))
{
k = k + 1;
}
st.add(new Pair(k - j, al.get(j)));

j = k - 1;
}

int prv = -1;
int prvFreq = 0;

// Declaring an empty array or list solAl
ArrayList<Integer> solAl = new ArrayList<>();

while (st.size() != 0)
{
Pair pr = st.last();
st.remove(pr);
solAl.add(pr.second);

if (prvFreq > 0)
{
st.add(new Pair(prvFreq, prv));
}

prvFreq = pr.first - 1;
prv = pr.second;
}

// calculating the new size of the 
// rearranged array list
int newSize = solAl.size();

// if the new size after the rearrangement
// if the array list is not equal to the size s
// then, the valid rearrangement is not possible
if(newSize != s)
{
return new ArrayList<Integer>();
}

return solAl;
}


// main method
public static void main(String argvs[])
{
// creating an object of the class UniqueAdjEle1 
UniqueAdjEle1 obj = new UniqueAdjEle1();

// input 1
ArrayList<Integer> inArr = new ArrayList<Integer>
(
Arrays.asList(7, 7, 6, 8)
);

// computing the size of the 
// input array
int size = inArr.size();
System.out.println("For the input array: ");
for(int i = 0; i < size; i++)
{
System.out.print(inArr.get(i) + " ");
}
System.out.println();
ArrayList<Integer> ans = obj.rearrangeArr(inArr, size);
if(ans.size() > 0)
{
System.out.println("The valid arrangement is: ");

for(int i = 0; i < size; i++)
{
System.out.print(ans.get(i) + " ");
}
}
else
{
System.out.println("The valid arrangement is not possible. ");
}

System.out.println( "\n" );

// input 2
inArr = new ArrayList<Integer>
(
Arrays.asList(2, 4, 8, 9, 5, 7, 3, 6, 1)
);

// computing the size of the 
// input array
size = inArr.size();

System.out.println("For the input array: ");

for(int i = 0; i < size; i++)
{
System.out.print(inArr.get(i) + " ");
}

System.out.println();

ans = obj.rearrangeArr(inArr, size);

if(ans.size() > 0)
{
System.out.println("The valid arrangement is: ");

for(int i = 0; i < size; i++)
{
System.out.print(ans.get(i) + " ");
}
}
else
{
System.out.println("The valid arrangement is not possible. ");
}

System.out.println( "\n" );

// input 3
inArr = new ArrayList<Integer>
(
Arrays.asList(3, 3, 3, 3, 3)
);

// computing the size of the 
// input array
size = inArr.size();

System.out.println("For the input array: ");

for(int i = 0; i < size; i++)
{
System.out.print(inArr.get(i) + " ");
}

System.out.println();

ans = obj.rearrangeArr(inArr, size);
if(ans.size() > 0)
{
System.out.println("The valid arrangement is: ");

for(int i = 0; i < size; i++)
{
System.out.print(ans.get(i) + " ");
}
}
else
{
System.out.println("The valid arrangement is not possible. ");
}

}

}
 Output: For the input array: 
7 7 6 8 
The valid arrangement is: 
7 8 7 6 

For the input array: 
2 4 8 9 5 7 3 6 1 
The valid arrangement is: 
2 4 8 9 5 7 3 6 1 

For the input array: 
3 3 3 3 3 
The valid arrangement is not possible.
 Complexity Analysis: Since the program is using sorting, the time complexity of the program is O(N * log(N)). The program uses a set to store the elements and their occurrence count. The program is also using an auxiliary array (arr). Thus, making the space complexity of the program as (N), where N is the total number of elements present in the input array. Note: Instead of Set, a priority queue can also be used. In that case, also, the time and space complexity remain the same. Next Topic# ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/unequal-adjacent-elements-in-java Unequal Adjacent Elements in Java - Javatpoint ? SCROLL TO TOP Home Java Programs OOPs String Exception Multithreading Collections JavaFX JSP Spring Spring Boot Projects Interview Questions Java Tutorial What is Java History of Java Features of Java C++ vs Java Hello Java Program Program Internal How to set path? JDK, JRE and JVM JVM: Java Virtual Machine Java Variables Java Data Types Unicode System Operators Keywords Control Statements Java Control Statements Java If-else Java Switch Java For Loop Java While Loop Java Do While Loop Java Break Java Continue Java Comments Java Programs Java Object Class Java OOPs Concepts Naming Convention Object and Class Method Constructor static keyword this keyword Java Inheritance Inheritance(IS-A) Aggregation(HAS-A) Java Polymorphism Method Overloading Method Overriding Covariant Return Type super keyword Instance Initializer block final keyword Runtime Polymorphism Dynamic Binding instanceof operator Java Abstraction Abstract class Interface Abstract vs Interface Java Encapsulation Package Access Modifiers Encapsulation Java Array Java Array Java OOPs Misc Object class Object Cloning Math class Wrapper Class Java Recursion Call By Value strictfp keyword javadoc tool Command Line Arg Object vs Class Overloading vs Overriding Java String Java Regex Exception Handling Java Inner classes Java Multithreading Java I/O Java Networking Java AWT & Events Java Swing JavaFX Java Applet Java Reflection Java Date Java Conversion Java Collection Java JDBC Java Misc Java New Features RMI Internationalization Interview Questions Java MCQ next ? ? prev Unequal Adjacent Elements in Java An array inArr containing n numbers (positive or negative) is given. The task is to return the array after the rearrangement of elements of the integers in such a way that no two adjacent elements are equal. If there are multiple valid arrangements, then any one valid arrangement can be returned. If the input array does not contain any valid arrangement, then an appropriate message can be displayed on the console. Example 1: Input int inArr[] = {7, 7, 6, 8} Output: {7, 6, 7, 8} Explanation: There are many valid arrangements possible. Those valid arrangements are mentioned below. {7, 6, 7, 8}, {7, 6, 8, 7}, {7, 8, 7, 6}, {7, 8, 6, 7}, {8, 7, 6, 7}, {6, 7, 8, 7}. Out of which {7, 6, 7, 8} is mentioned in the output. Example 2: Input int inArr[] = {2, 4, 8, 9, 5, 7, 3, 6, 1} Output: {2, 4, 8, 9, 5, 7, 3, 6, 1} Explanation: The input array is given in such a way that there are no two elements that are of the same value. Hence, the input arrays are themselves the answer. Example 3: Input int arr[] = {3, 3, 3, 3, 3} Output: no valid arrangement is possible where adjacent elements are of different values. Explanation: All the elements are of the same value. Hence, no valid arrangement is possible. Approach: Brute Force In this approach, we compute all the arrangements of the input array. If any valid arrangement comes, we return that arrangement. If no valid arrangement is possible, display the appropriate message. For computing the valid arrangement, first, we will sort the array in ascending order. Then we will find the next permutation of the sorted array and check whether it is a valid arrangement or not. If it is a valid arrangement, then we can return that arrangement. If not, then we will find the next permutation and continue to do so until we find a valid arrangement or all the arrangements are exhausted. If the arrangements are exhausted, then we can say that no valid arrangement is there for the given input array, and the same is illustrated in the following program. FileName: UniqueAdjEle.java 
// important import statements
import java.util.Collections;
import java.util.ArrayList;
import java.util.Arrays;


public class UniqueAdjEle 
{
    // swapping the elements in the array list al
    // that are present at the index j and k
    private void swapEle(ArrayList<Integer> al, int j, int k) 
    {
        int temp = al.get(j);
        al.set(j, al.get(k));
        al.set(k, temp);
    }
    // reversing the array list from j to k
    private void reverseArrList(ArrayList<Integer> al, int j, int k) 
    {
        while (j < k) 
        {
            swapEle(al, j, k);
            j = j + 1;
            k = k - 1;
        }
    }

    private boolean nextPermutation(ArrayList<Integer> al) 
    {
        // if the list has no elements
        // or the single element, then
        // there is no need to proceed further
        if (al == null || al.size() <= 1) 
        {
            return false;
        }

        int j = al.size() - 2;

        while (j >= 0 && al.get(j).intValue() >= al.get(j + 1).intValue()) 
        {

            // Finding the first j that is breaking descending order
            j = j - 1;
        }

        if (j >= 0) 
        {
            // if the control reaching
            // here, then it means the array
            // is not entirely descending

            // Starting from the end
            int k = al.size() - 1;

            while (al.get(k).intValue() <= al.get(j).intValue()) 
            {
                // Finding the rightmost first larger id than k
                k = k - 1;
            }

            // Switching j and k
            swapEle(al, j, k);

            // Reversing in the descending sequence
            reverseArrList(al, j + 1, al.size() - 1);

            return true;
        } else 
        {
            // Reversing the whole sequence.
            reverseArrList(al, 0, al.size() - 1);
            return false;
        }
    }
    // a Boolean method that checks whether the elements of the array list al 
    // have the valid arrangement or not.
    public boolean isValidArrangement(ArrayList<Integer> al, int s)
    {
        int chk = 1;

            for (int j = 1; j < s; j++) 
            {
                if (al.get(j) == al.get(j - 1)) 
                {
                    chk = 0;
                    break;
                }
            }

            return chk == 1;
    }

    public ArrayList<Integer> rearrangeArr(ArrayList<Integer> al, int s) 
    {   
        if(isValidArrangement(al, s))
        {
            return al;
        }
        // sorting the list so we can compute the next permutation
        Collections.sort(al);
       
        // Iterating the array list and 
        // checking whether it is a valid arrangement or not
        // if yes, then we terminate the do-while loop.
        // Otherwise, we find the next permutation.
         while (nextPermutation(al))
         {
             if(isValidArrangement(al, s))
             {
                 return al;
             }
         }

        return new ArrayList<Integer>();
    }
    
    // main method
    public static void main(String argvs[])
    {
        // creating an object of the class UniqueAdjEle 
        UniqueAdjEle obj = new UniqueAdjEle();
        
        // input 1
        ArrayList<Integer> inArr = new ArrayList<Integer>
        (
            Arrays.asList(7, 7, 6, 8)
        );
        
        // computing the size of the 
        // input array
        int size = inArr.size();
        System.out.println("For the input array: ");
        for(int i = 0; i < size; i++)
        {
            System.out.print(inArr.get(i) + " ");
        }
        System.out.println();
        ArrayList<Integer> ans = obj.rearrangeArr(inArr, size);
        if(ans.size() > 0)
        {
        System.out.println("The valid arrangement is: ");
        
        for(int i = 0; i < size; i++)
        {
            System.out.print(ans.get(i) + " ");
        }
        }
        else
        {
            System.out.println("The valid arrangement is not possible. ");
        }
        
        System.out.println( "\n" );
        
        // input 2
        inArr = new ArrayList<Integer>
        (
            Arrays.asList(2, 4, 8, 9, 5, 7, 3, 6, 1)
        );
        
        // computing the size of the 
        // input array
        size = inArr.size();
        
        System.out.println("For the input array: ");
        
        for(int i = 0; i < size; i++)
        {
            System.out.print(inArr.get(i) + " ");
        }
        
        System.out.println();
        
        ans = obj.rearrangeArr(inArr, size);
        
        if(ans.size() > 0)
        {
        System.out.println("The valid arrangement is: ");
        
        for(int i = 0; i < size; i++)
        {
            System.out.print(ans.get(i) + " ");
        }
        }
        else
        {
            System.out.println("The valid arrangement is not possible. ");
        }
        
        System.out.println( "\n" );
        
        // input 3
        inArr = new ArrayList<Integer>
        (
            Arrays.asList(3, 3, 3, 3, 3)
        );
        
        // computing the size of the 
        // input array
        size = inArr.size();
        
        System.out.println("For the input array: ");
        
        for(int i = 0; i < size; i++)
        {
            System.out.print(inArr.get(i) + " ");
        }
        
        System.out.println();
        
        ans = obj.rearrangeArr(inArr, size);
        if(ans.size() > 0)
        {
        System.out.println("The valid arrangement is: ");
        
        for(int i = 0; i < size; i++)
        {
            System.out.print(ans.get(i) + " ");
        }
        }
        else
        {
            System.out.println("The valid arrangement is not possible. ");
        }
        
    }
    
    
    
}
 Output: For the input array: 
7 7 6 8 
The valid arrangement is: 
6 7 8 7 

For the input array: 
2 4 8 9 5 7 3 6 1 
The valid arrangement is: 
2 4 8 9 5 7 3 6 1 

For the input array: 
3 3 3 3 3 
The valid arrangement is not possible.
 Complexity Analysis: Since the program is computing the permutation, the time complexity of the program is O(N!), where N is the total number of elements present in the linked list. The program uses constant space; therefore, the space complexity of the program is O(1). The above program is not suitable for the larger inputs as the time complexity of the program is too high. Therefore, we must do some optimization to reduce the time complexity. Approach: Using Set It is a greedy approach where we put first that element which is occurring the most number of times in the input array. Using the set, we will put all the elements in the order of their occurrence count. The following are the steps involved in computing the answer. Step 1: Declare an empty array or list solAl. Step 2: Sort the array or list solAl. Step 3: Declare a set st that keeps the elements and their occurrence count. Step 4: Iterate over the list or array solAl: Iterate until the same element is encountered every time. Increment the element count by 1. Put the element and the occurrence count of the element in the set st. Step 5: Create a temporary variable for keeping the previous element and its occurrence count. Step 6: While the set st is not empty, do the following: Fetch the last element and get it added to the result. Delete that element from the set st. Reduce the occurrence count of the element popped by 1. If the occurrence count was non-zero of the previous elements, put it in the set. The current element should be treated as the previous element for the upcoming iteration. Step 7: Eventually, return the list or array solAl. Implementation The implementation of the above steps is mentioned below. FileName: UniqueAdjEle.java 
// important import statements
import java.util.Arrays;
import java.util.ArrayList;
import java.util.TreeSet;
import java.util.Collections;
import java.util.Comparator;

class PairComparator implements Comparator<Pair>
{

// Overriding the compare() method of the Comparator
public int compare(Pair p1, Pair p2)
{
if (p1.first < p2.first)
{
return -1;
}
else if(p1.first == p2.first)
{
return p1.second - p2.second;
}
else if (p1.first > p2.first)
{
return 1;
}

return 0;
}
}

// class Pair contains 
// two elements one is first
// other is second
class Pair 
{
int first; 
int second;
Pair(int first, int second)
{
this.first = first;
this.second = second;
}
}
public class UniqueAdjEle1 
{
// a boolean method that checks whether the elements of the array list al 
// have the valid arrangement or not.
public boolean isValidArrangement(ArrayList<Integer> al, int s)
{
int chk = 1;

for (int j = 1; j < s; j++) 
{
if (al.get(j) == al.get(j - 1)) 
{
chk = 0;
break;
}
}

return chk == 1;
}

public ArrayList<Integer> rearrangeArr(ArrayList<Integer> al, int s) 
{
if(isValidArrangement(al, s))
{
// the arrangement is valid
// hence, there is no need to proceed further
return al;
}

// Sorting the list or array al
Collections.sort(al);

// Declaring a set st that keeps the elements and their
// occurrence count.
TreeSet<Pair> st = new TreeSet<>(new PairComparator());


// Iterating over the list or array al
// Iterating until the element is the same
// Incrementing the element count by 1. 
// Inserting the element and its occurrence count in the set st
for (int j = 0; j < s; j++)
{

int k = j;
while (j < s && k < s && (al.get(j).equals(al.get(k))))
{
k = k + 1;
}
st.add(new Pair(k - j, al.get(j)));

j = k - 1;
}

int prv = -1;
int prvFreq = 0;

// Declaring an empty array or list solAl
ArrayList<Integer> solAl = new ArrayList<>();

while (st.size() != 0)
{
Pair pr = st.last();
st.remove(pr);
solAl.add(pr.second);

if (prvFreq > 0)
{
st.add(new Pair(prvFreq, prv));
}

prvFreq = pr.first - 1;
prv = pr.second;
}

// calculating the new size of the 
// rearranged array list
int newSize = solAl.size();

// if the new size after the rearrangement
// if the array list is not equal to the size s
// then, the valid rearrangement is not possible
if(newSize != s)
{
return new ArrayList<Integer>();
}

return solAl;
}


// main method
public static void main(String argvs[])
{
// creating an object of the class UniqueAdjEle1 
UniqueAdjEle1 obj = new UniqueAdjEle1();

// input 1
ArrayList<Integer> inArr = new ArrayList<Integer>
(
Arrays.asList(7, 7, 6, 8)
);

// computing the size of the 
// input array
int size = inArr.size();
System.out.println("For the input array: ");
for(int i = 0; i < size; i++)
{
System.out.print(inArr.get(i) + " ");
}
System.out.println();
ArrayList<Integer> ans = obj.rearrangeArr(inArr, size);
if(ans.size() > 0)
{
System.out.println("The valid arrangement is: ");

for(int i = 0; i < size; i++)
{
System.out.print(ans.get(i) + " ");
}
}
else
{
System.out.println("The valid arrangement is not possible. ");
}

System.out.println( "\n" );

// input 2
inArr = new ArrayList<Integer>
(
Arrays.asList(2, 4, 8, 9, 5, 7, 3, 6, 1)
);

// computing the size of the 
// input array
size = inArr.size();

System.out.println("For the input array: ");

for(int i = 0; i < size; i++)
{
System.out.print(inArr.get(i) + " ");
}

System.out.println();

ans = obj.rearrangeArr(inArr, size);

if(ans.size() > 0)
{
System.out.println("The valid arrangement is: ");

for(int i = 0; i < size; i++)
{
System.out.print(ans.get(i) + " ");
}
}
else
{
System.out.println("The valid arrangement is not possible. ");
}

System.out.println( "\n" );

// input 3
inArr = new ArrayList<Integer>
(
Arrays.asList(3, 3, 3, 3, 3)
);

// computing the size of the 
// input array
size = inArr.size();

System.out.println("For the input array: ");

for(int i = 0; i < size; i++)
{
System.out.print(inArr.get(i) + " ");
}

System.out.println();

ans = obj.rearrangeArr(inArr, size);
if(ans.size() > 0)
{
System.out.println("The valid arrangement is: ");

for(int i = 0; i < size; i++)
{
System.out.print(ans.get(i) + " ");
}
}
else
{
System.out.println("The valid arrangement is not possible. ");
}

}

}
 Output: For the input array: 
7 7 6 8 
The valid arrangement is: 
7 8 7 6 

For the input array: 
2 4 8 9 5 7 3 6 1 
The valid arrangement is: 
2 4 8 9 5 7 3 6 1 

For the input array: 
3 3 3 3 3 
The valid arrangement is not possible.
 Complexity Analysis: Since the program is using sorting, the time complexity of the program is O(N * log(N)). The program uses a set to store the elements and their occurrence count. The program is also using an auxiliary array (arr). Thus, making the space complexity of the program as (N), where N is the total number of elements present in the input array. Note: Instead of Set, a priority queue can also be used. In that case, also, the time and space complexity remain the same. Next Topic# ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/unequal-adjacent-elements-in-java Unequal Adjacent Elements in Java - Javatpoint ? SCROLL TO TOP Home Java Programs OOPs String Exception Multithreading Collections JavaFX JSP Spring Spring Boot Projects Interview Questions Java Tutorial What is Java History of Java Features of Java C++ vs Java Hello Java Program Program Internal How to set path? JDK, JRE and JVM JVM: Java Virtual Machine Java Variables Java Data Types Unicode System Operators Keywords Control Statements Java Control Statements Java If-else Java Switch Java For Loop Java While Loop Java Do While Loop Java Break Java Continue Java Comments Java Programs Java Object Class Java OOPs Concepts Naming Convention Object and Class Method Constructor static keyword this keyword Java Inheritance Inheritance(IS-A) Aggregation(HAS-A) Java Polymorphism Method Overloading Method Overriding Covariant Return Type super keyword Instance Initializer block final keyword Runtime Polymorphism Dynamic Binding instanceof operator Java Abstraction Abstract class Interface Abstract vs Interface Java Encapsulation Package Access Modifiers Encapsulation Java Array Java Array Java OOPs Misc Object class Object Cloning Math class Wrapper Class Java Recursion Call By Value strictfp keyword javadoc tool Command Line Arg Object vs Class Overloading vs Overriding Java String Java Regex Exception Handling Java Inner classes Java Multithreading Java I/O Java Networking Java AWT & Events Java Swing JavaFX Java Applet Java Reflection Java Date Java Conversion Java Collection Java JDBC Java Misc Java New Features RMI Internationalization Interview Questions Java MCQ next ? ? prev Unequal Adjacent Elements in Java An array inArr containing n numbers (positive or negative) is given. The task is to return the array after the rearrangement of elements of the integers in such a way that no two adjacent elements are equal. If there are multiple valid arrangements, then any one valid arrangement can be returned. If the input array does not contain any valid arrangement, then an appropriate message can be displayed on the console. Example 1: Input int inArr[] = {7, 7, 6, 8} Output: {7, 6, 7, 8} Explanation: There are many valid arrangements possible. Those valid arrangements are mentioned below. {7, 6, 7, 8}, {7, 6, 8, 7}, {7, 8, 7, 6}, {7, 8, 6, 7}, {8, 7, 6, 7}, {6, 7, 8, 7}. Out of which {7, 6, 7, 8} is mentioned in the output. Example 2: Input int inArr[] = {2, 4, 8, 9, 5, 7, 3, 6, 1} Output: {2, 4, 8, 9, 5, 7, 3, 6, 1} Explanation: The input array is given in such a way that there are no two elements that are of the same value. Hence, the input arrays are themselves the answer. Example 3: Input int arr[] = {3, 3, 3, 3, 3} Output: no valid arrangement is possible where adjacent elements are of different values. Explanation: All the elements are of the same value. Hence, no valid arrangement is possible. Approach: Brute Force In this approach, we compute all the arrangements of the input array. If any valid arrangement comes, we return that arrangement. If no valid arrangement is possible, display the appropriate message. For computing the valid arrangement, first, we will sort the array in ascending order. Then we will find the next permutation of the sorted array and check whether it is a valid arrangement or not. If it is a valid arrangement, then we can return that arrangement. If not, then we will find the next permutation and continue to do so until we find a valid arrangement or all the arrangements are exhausted. If the arrangements are exhausted, then we can say that no valid arrangement is there for the given input array, and the same is illustrated in the following program. FileName: UniqueAdjEle.java 
// important import statements
import java.util.Collections;
import java.util.ArrayList;
import java.util.Arrays;


public class UniqueAdjEle 
{
    // swapping the elements in the array list al
    // that are present at the index j and k
    private void swapEle(ArrayList<Integer> al, int j, int k) 
    {
        int temp = al.get(j);
        al.set(j, al.get(k));
        al.set(k, temp);
    }
    // reversing the array list from j to k
    private void reverseArrList(ArrayList<Integer> al, int j, int k) 
    {
        while (j < k) 
        {
            swapEle(al, j, k);
            j = j + 1;
            k = k - 1;
        }
    }

    private boolean nextPermutation(ArrayList<Integer> al) 
    {
        // if the list has no elements
        // or the single element, then
        // there is no need to proceed further
        if (al == null || al.size() <= 1) 
        {
            return false;
        }

        int j = al.size() - 2;

        while (j >= 0 && al.get(j).intValue() >= al.get(j + 1).intValue()) 
        {

            // Finding the first j that is breaking descending order
            j = j - 1;
        }

        if (j >= 0) 
        {
            // if the control reaching
            // here, then it means the array
            // is not entirely descending

            // Starting from the end
            int k = al.size() - 1;

            while (al.get(k).intValue() <= al.get(j).intValue()) 
            {
                // Finding the rightmost first larger id than k
                k = k - 1;
            }

            // Switching j and k
            swapEle(al, j, k);

            // Reversing in the descending sequence
            reverseArrList(al, j + 1, al.size() - 1);

            return true;
        } else 
        {
            // Reversing the whole sequence.
            reverseArrList(al, 0, al.size() - 1);
            return false;
        }
    }
    // a Boolean method that checks whether the elements of the array list al 
    // have the valid arrangement or not.
    public boolean isValidArrangement(ArrayList<Integer> al, int s)
    {
        int chk = 1;

            for (int j = 1; j < s; j++) 
            {
                if (al.get(j) == al.get(j - 1)) 
                {
                    chk = 0;
                    break;
                }
            }

            return chk == 1;
    }

    public ArrayList<Integer> rearrangeArr(ArrayList<Integer> al, int s) 
    {   
        if(isValidArrangement(al, s))
        {
            return al;
        }
        // sorting the list so we can compute the next permutation
        Collections.sort(al);
       
        // Iterating the array list and 
        // checking whether it is a valid arrangement or not
        // if yes, then we terminate the do-while loop.
        // Otherwise, we find the next permutation.
         while (nextPermutation(al))
         {
             if(isValidArrangement(al, s))
             {
                 return al;
             }
         }

        return new ArrayList<Integer>();
    }
    
    // main method
    public static void main(String argvs[])
    {
        // creating an object of the class UniqueAdjEle 
        UniqueAdjEle obj = new UniqueAdjEle();
        
        // input 1
        ArrayList<Integer> inArr = new ArrayList<Integer>
        (
            Arrays.asList(7, 7, 6, 8)
        );
        
        // computing the size of the 
        // input array
        int size = inArr.size();
        System.out.println("For the input array: ");
        for(int i = 0; i < size; i++)
        {
            System.out.print(inArr.get(i) + " ");
        }
        System.out.println();
        ArrayList<Integer> ans = obj.rearrangeArr(inArr, size);
        if(ans.size() > 0)
        {
        System.out.println("The valid arrangement is: ");
        
        for(int i = 0; i < size; i++)
        {
            System.out.print(ans.get(i) + " ");
        }
        }
        else
        {
            System.out.println("The valid arrangement is not possible. ");
        }
        
        System.out.println( "\n" );
        
        // input 2
        inArr = new ArrayList<Integer>
        (
            Arrays.asList(2, 4, 8, 9, 5, 7, 3, 6, 1)
        );
        
        // computing the size of the 
        // input array
        size = inArr.size();
        
        System.out.println("For the input array: ");
        
        for(int i = 0; i < size; i++)
        {
            System.out.print(inArr.get(i) + " ");
        }
        
        System.out.println();
        
        ans = obj.rearrangeArr(inArr, size);
        
        if(ans.size() > 0)
        {
        System.out.println("The valid arrangement is: ");
        
        for(int i = 0; i < size; i++)
        {
            System.out.print(ans.get(i) + " ");
        }
        }
        else
        {
            System.out.println("The valid arrangement is not possible. ");
        }
        
        System.out.println( "\n" );
        
        // input 3
        inArr = new ArrayList<Integer>
        (
            Arrays.asList(3, 3, 3, 3, 3)
        );
        
        // computing the size of the 
        // input array
        size = inArr.size();
        
        System.out.println("For the input array: ");
        
        for(int i = 0; i < size; i++)
        {
            System.out.print(inArr.get(i) + " ");
        }
        
        System.out.println();
        
        ans = obj.rearrangeArr(inArr, size);
        if(ans.size() > 0)
        {
        System.out.println("The valid arrangement is: ");
        
        for(int i = 0; i < size; i++)
        {
            System.out.print(ans.get(i) + " ");
        }
        }
        else
        {
            System.out.println("The valid arrangement is not possible. ");
        }
        
    }
    
    
    
}
 Output: For the input array: 
7 7 6 8 
The valid arrangement is: 
6 7 8 7 

For the input array: 
2 4 8 9 5 7 3 6 1 
The valid arrangement is: 
2 4 8 9 5 7 3 6 1 

For the input array: 
3 3 3 3 3 
The valid arrangement is not possible.
 Complexity Analysis: Since the program is computing the permutation, the time complexity of the program is O(N!), where N is the total number of elements present in the linked list. The program uses constant space; therefore, the space complexity of the program is O(1). The above program is not suitable for the larger inputs as the time complexity of the program is too high. Therefore, we must do some optimization to reduce the time complexity. Approach: Using Set It is a greedy approach where we put first that element which is occurring the most number of times in the input array. Using the set, we will put all the elements in the order of their occurrence count. The following are the steps involved in computing the answer. Step 1: Declare an empty array or list solAl. Step 2: Sort the array or list solAl. Step 3: Declare a set st that keeps the elements and their occurrence count. Step 4: Iterate over the list or array solAl: Iterate until the same element is encountered every time. Increment the element count by 1. Put the element and the occurrence count of the element in the set st. Step 5: Create a temporary variable for keeping the previous element and its occurrence count. Step 6: While the set st is not empty, do the following: Fetch the last element and get it added to the result. Delete that element from the set st. Reduce the occurrence count of the element popped by 1. If the occurrence count was non-zero of the previous elements, put it in the set. The current element should be treated as the previous element for the upcoming iteration. Step 7: Eventually, return the list or array solAl. Implementation The implementation of the above steps is mentioned below. FileName: UniqueAdjEle.java 
// important import statements
import java.util.Arrays;
import java.util.ArrayList;
import java.util.TreeSet;
import java.util.Collections;
import java.util.Comparator;

class PairComparator implements Comparator<Pair>
{

// Overriding the compare() method of the Comparator
public int compare(Pair p1, Pair p2)
{
if (p1.first < p2.first)
{
return -1;
}
else if(p1.first == p2.first)
{
return p1.second - p2.second;
}
else if (p1.first > p2.first)
{
return 1;
}

return 0;
}
}

// class Pair contains 
// two elements one is first
// other is second
class Pair 
{
int first; 
int second;
Pair(int first, int second)
{
this.first = first;
this.second = second;
}
}
public class UniqueAdjEle1 
{
// a boolean method that checks whether the elements of the array list al 
// have the valid arrangement or not.
public boolean isValidArrangement(ArrayList<Integer> al, int s)
{
int chk = 1;

for (int j = 1; j < s; j++) 
{
if (al.get(j) == al.get(j - 1)) 
{
chk = 0;
break;
}
}

return chk == 1;
}

public ArrayList<Integer> rearrangeArr(ArrayList<Integer> al, int s) 
{
if(isValidArrangement(al, s))
{
// the arrangement is valid
// hence, there is no need to proceed further
return al;
}

// Sorting the list or array al
Collections.sort(al);

// Declaring a set st that keeps the elements and their
// occurrence count.
TreeSet<Pair> st = new TreeSet<>(new PairComparator());


// Iterating over the list or array al
// Iterating until the element is the same
// Incrementing the element count by 1. 
// Inserting the element and its occurrence count in the set st
for (int j = 0; j < s; j++)
{

int k = j;
while (j < s && k < s && (al.get(j).equals(al.get(k))))
{
k = k + 1;
}
st.add(new Pair(k - j, al.get(j)));

j = k - 1;
}

int prv = -1;
int prvFreq = 0;

// Declaring an empty array or list solAl
ArrayList<Integer> solAl = new ArrayList<>();

while (st.size() != 0)
{
Pair pr = st.last();
st.remove(pr);
solAl.add(pr.second);

if (prvFreq > 0)
{
st.add(new Pair(prvFreq, prv));
}

prvFreq = pr.first - 1;
prv = pr.second;
}

// calculating the new size of the 
// rearranged array list
int newSize = solAl.size();

// if the new size after the rearrangement
// if the array list is not equal to the size s
// then, the valid rearrangement is not possible
if(newSize != s)
{
return new ArrayList<Integer>();
}

return solAl;
}


// main method
public static void main(String argvs[])
{
// creating an object of the class UniqueAdjEle1 
UniqueAdjEle1 obj = new UniqueAdjEle1();

// input 1
ArrayList<Integer> inArr = new ArrayList<Integer>
(
Arrays.asList(7, 7, 6, 8)
);

// computing the size of the 
// input array
int size = inArr.size();
System.out.println("For the input array: ");
for(int i = 0; i < size; i++)
{
System.out.print(inArr.get(i) + " ");
}
System.out.println();
ArrayList<Integer> ans = obj.rearrangeArr(inArr, size);
if(ans.size() > 0)
{
System.out.println("The valid arrangement is: ");

for(int i = 0; i < size; i++)
{
System.out.print(ans.get(i) + " ");
}
}
else
{
System.out.println("The valid arrangement is not possible. ");
}

System.out.println( "\n" );

// input 2
inArr = new ArrayList<Integer>
(
Arrays.asList(2, 4, 8, 9, 5, 7, 3, 6, 1)
);

// computing the size of the 
// input array
size = inArr.size();

System.out.println("For the input array: ");

for(int i = 0; i < size; i++)
{
System.out.print(inArr.get(i) + " ");
}

System.out.println();

ans = obj.rearrangeArr(inArr, size);

if(ans.size() > 0)
{
System.out.println("The valid arrangement is: ");

for(int i = 0; i < size; i++)
{
System.out.print(ans.get(i) + " ");
}
}
else
{
System.out.println("The valid arrangement is not possible. ");
}

System.out.println( "\n" );

// input 3
inArr = new ArrayList<Integer>
(
Arrays.asList(3, 3, 3, 3, 3)
);

// computing the size of the 
// input array
size = inArr.size();

System.out.println("For the input array: ");

for(int i = 0; i < size; i++)
{
System.out.print(inArr.get(i) + " ");
}

System.out.println();

ans = obj.rearrangeArr(inArr, size);
if(ans.size() > 0)
{
System.out.println("The valid arrangement is: ");

for(int i = 0; i < size; i++)
{
System.out.print(ans.get(i) + " ");
}
}
else
{
System.out.println("The valid arrangement is not possible. ");
}

}

}
 Output: For the input array: 
7 7 6 8 
The valid arrangement is: 
7 8 7 6 

For the input array: 
2 4 8 9 5 7 3 6 1 
The valid arrangement is: 
2 4 8 9 5 7 3 6 1 

For the input array: 
3 3 3 3 3 
The valid arrangement is not possible.
 Complexity Analysis: Since the program is using sorting, the time complexity of the program is O(N * log(N)). The program uses a set to store the elements and their occurrence count. The program is also using an auxiliary array (arr). Thus, making the space complexity of the program as (N), where N is the total number of elements present in the input array. Note: Instead of Set, a priority queue can also be used. In that case, also, the time and space complexity remain the same. Next Topic# ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/unequal-adjacent-elements-in-java Unequal Adjacent Elements in Java - Javatpoint ? SCROLL TO TOP Home Java Programs OOPs String Exception Multithreading Collections JavaFX JSP Spring Spring Boot Projects Interview Questions Java Tutorial What is Java History of Java Features of Java C++ vs Java Hello Java Program Program Internal How to set path? JDK, JRE and JVM JVM: Java Virtual Machine Java Variables Java Data Types Unicode System Operators Keywords Control Statements Java Control Statements Java If-else Java Switch Java For Loop Java While Loop Java Do While Loop Java Break Java Continue Java Comments Java Programs Java Object Class Java OOPs Concepts Naming Convention Object and Class Method Constructor static keyword this keyword Java Inheritance Inheritance(IS-A) Aggregation(HAS-A) Java Polymorphism Method Overloading Method Overriding Covariant Return Type super keyword Instance Initializer block final keyword Runtime Polymorphism Dynamic Binding instanceof operator Java Abstraction Abstract class Interface Abstract vs Interface Java Encapsulation Package Access Modifiers Encapsulation Java Array Java Array Java OOPs Misc Object class Object Cloning Math class Wrapper Class Java Recursion Call By Value strictfp keyword javadoc tool Command Line Arg Object vs Class Overloading vs Overriding Java String Java Regex Exception Handling Java Inner classes Java Multithreading Java I/O Java Networking Java AWT & Events Java Swing JavaFX Java Applet Java Reflection Java Date Java Conversion Java Collection Java JDBC Java Misc Java New Features RMI Internationalization Interview Questions Java MCQ next ? ? prev Unequal Adjacent Elements in Java An array inArr containing n numbers (positive or negative) is given. The task is to return the array after the rearrangement of elements of the integers in such a way that no two adjacent elements are equal. If there are multiple valid arrangements, then any one valid arrangement can be returned. If the input array does not contain any valid arrangement, then an appropriate message can be displayed on the console. Example 1: Input int inArr[] = {7, 7, 6, 8} Output: {7, 6, 7, 8} Explanation: There are many valid arrangements possible. Those valid arrangements are mentioned below. {7, 6, 7, 8}, {7, 6, 8, 7}, {7, 8, 7, 6}, {7, 8, 6, 7}, {8, 7, 6, 7}, {6, 7, 8, 7}. Out of which {7, 6, 7, 8} is mentioned in the output. Example 2: Input int inArr[] = {2, 4, 8, 9, 5, 7, 3, 6, 1} Output: {2, 4, 8, 9, 5, 7, 3, 6, 1} Explanation: The input array is given in such a way that there are no two elements that are of the same value. Hence, the input arrays are themselves the answer. Example 3: Input int arr[] = {3, 3, 3, 3, 3} Output: no valid arrangement is possible where adjacent elements are of different values. Explanation: All the elements are of the same value. Hence, no valid arrangement is possible. Approach: Brute Force In this approach, we compute all the arrangements of the input array. If any valid arrangement comes, we return that arrangement. If no valid arrangement is possible, display the appropriate message. For computing the valid arrangement, first, we will sort the array in ascending order. Then we will find the next permutation of the sorted array and check whether it is a valid arrangement or not. If it is a valid arrangement, then we can return that arrangement. If not, then we will find the next permutation and continue to do so until we find a valid arrangement or all the arrangements are exhausted. If the arrangements are exhausted, then we can say that no valid arrangement is there for the given input array, and the same is illustrated in the following program. FileName: UniqueAdjEle.java 
// important import statements
import java.util.Collections;
import java.util.ArrayList;
import java.util.Arrays;


public class UniqueAdjEle 
{
    // swapping the elements in the array list al
    // that are present at the index j and k
    private void swapEle(ArrayList<Integer> al, int j, int k) 
    {
        int temp = al.get(j);
        al.set(j, al.get(k));
        al.set(k, temp);
    }
    // reversing the array list from j to k
    private void reverseArrList(ArrayList<Integer> al, int j, int k) 
    {
        while (j < k) 
        {
            swapEle(al, j, k);
            j = j + 1;
            k = k - 1;
        }
    }

    private boolean nextPermutation(ArrayList<Integer> al) 
    {
        // if the list has no elements
        // or the single element, then
        // there is no need to proceed further
        if (al == null || al.size() <= 1) 
        {
            return false;
        }

        int j = al.size() - 2;

        while (j >= 0 && al.get(j).intValue() >= al.get(j + 1).intValue()) 
        {

            // Finding the first j that is breaking descending order
            j = j - 1;
        }

        if (j >= 0) 
        {
            // if the control reaching
            // here, then it means the array
            // is not entirely descending

            // Starting from the end
            int k = al.size() - 1;

            while (al.get(k).intValue() <= al.get(j).intValue()) 
            {
                // Finding the rightmost first larger id than k
                k = k - 1;
            }

            // Switching j and k
            swapEle(al, j, k);

            // Reversing in the descending sequence
            reverseArrList(al, j + 1, al.size() - 1);

            return true;
        } else 
        {
            // Reversing the whole sequence.
            reverseArrList(al, 0, al.size() - 1);
            return false;
        }
    }
    // a Boolean method that checks whether the elements of the array list al 
    // have the valid arrangement or not.
    public boolean isValidArrangement(ArrayList<Integer> al, int s)
    {
        int chk = 1;

            for (int j = 1; j < s; j++) 
            {
                if (al.get(j) == al.get(j - 1)) 
                {
                    chk = 0;
                    break;
                }
            }

            return chk == 1;
    }

    public ArrayList<Integer> rearrangeArr(ArrayList<Integer> al, int s) 
    {   
        if(isValidArrangement(al, s))
        {
            return al;
        }
        // sorting the list so we can compute the next permutation
        Collections.sort(al);
       
        // Iterating the array list and 
        // checking whether it is a valid arrangement or not
        // if yes, then we terminate the do-while loop.
        // Otherwise, we find the next permutation.
         while (nextPermutation(al))
         {
             if(isValidArrangement(al, s))
             {
                 return al;
             }
         }

        return new ArrayList<Integer>();
    }
    
    // main method
    public static void main(String argvs[])
    {
        // creating an object of the class UniqueAdjEle 
        UniqueAdjEle obj = new UniqueAdjEle();
        
        // input 1
        ArrayList<Integer> inArr = new ArrayList<Integer>
        (
            Arrays.asList(7, 7, 6, 8)
        );
        
        // computing the size of the 
        // input array
        int size = inArr.size();
        System.out.println("For the input array: ");
        for(int i = 0; i < size; i++)
        {
            System.out.print(inArr.get(i) + " ");
        }
        System.out.println();
        ArrayList<Integer> ans = obj.rearrangeArr(inArr, size);
        if(ans.size() > 0)
        {
        System.out.println("The valid arrangement is: ");
        
        for(int i = 0; i < size; i++)
        {
            System.out.print(ans.get(i) + " ");
        }
        }
        else
        {
            System.out.println("The valid arrangement is not possible. ");
        }
        
        System.out.println( "\n" );
        
        // input 2
        inArr = new ArrayList<Integer>
        (
            Arrays.asList(2, 4, 8, 9, 5, 7, 3, 6, 1)
        );
        
        // computing the size of the 
        // input array
        size = inArr.size();
        
        System.out.println("For the input array: ");
        
        for(int i = 0; i < size; i++)
        {
            System.out.print(inArr.get(i) + " ");
        }
        
        System.out.println();
        
        ans = obj.rearrangeArr(inArr, size);
        
        if(ans.size() > 0)
        {
        System.out.println("The valid arrangement is: ");
        
        for(int i = 0; i < size; i++)
        {
            System.out.print(ans.get(i) + " ");
        }
        }
        else
        {
            System.out.println("The valid arrangement is not possible. ");
        }
        
        System.out.println( "\n" );
        
        // input 3
        inArr = new ArrayList<Integer>
        (
            Arrays.asList(3, 3, 3, 3, 3)
        );
        
        // computing the size of the 
        // input array
        size = inArr.size();
        
        System.out.println("For the input array: ");
        
        for(int i = 0; i < size; i++)
        {
            System.out.print(inArr.get(i) + " ");
        }
        
        System.out.println();
        
        ans = obj.rearrangeArr(inArr, size);
        if(ans.size() > 0)
        {
        System.out.println("The valid arrangement is: ");
        
        for(int i = 0; i < size; i++)
        {
            System.out.print(ans.get(i) + " ");
        }
        }
        else
        {
            System.out.println("The valid arrangement is not possible. ");
        }
        
    }
    
    
    
}
 Output: For the input array: 
7 7 6 8 
The valid arrangement is: 
6 7 8 7 

For the input array: 
2 4 8 9 5 7 3 6 1 
The valid arrangement is: 
2 4 8 9 5 7 3 6 1 

For the input array: 
3 3 3 3 3 
The valid arrangement is not possible.
 Complexity Analysis: Since the program is computing the permutation, the time complexity of the program is O(N!), where N is the total number of elements present in the linked list. The program uses constant space; therefore, the space complexity of the program is O(1). The above program is not suitable for the larger inputs as the time complexity of the program is too high. Therefore, we must do some optimization to reduce the time complexity. Approach: Using Set It is a greedy approach where we put first that element which is occurring the most number of times in the input array. Using the set, we will put all the elements in the order of their occurrence count. The following are the steps involved in computing the answer. Step 1: Declare an empty array or list solAl. Step 2: Sort the array or list solAl. Step 3: Declare a set st that keeps the elements and their occurrence count. Step 4: Iterate over the list or array solAl: Iterate until the same element is encountered every time. Increment the element count by 1. Put the element and the occurrence count of the element in the set st. Step 5: Create a temporary variable for keeping the previous element and its occurrence count. Step 6: While the set st is not empty, do the following: Fetch the last element and get it added to the result. Delete that element from the set st. Reduce the occurrence count of the element popped by 1. If the occurrence count was non-zero of the previous elements, put it in the set. The current element should be treated as the previous element for the upcoming iteration. Step 7: Eventually, return the list or array solAl. Implementation The implementation of the above steps is mentioned below. FileName: UniqueAdjEle.java 
// important import statements
import java.util.Arrays;
import java.util.ArrayList;
import java.util.TreeSet;
import java.util.Collections;
import java.util.Comparator;

class PairComparator implements Comparator<Pair>
{

// Overriding the compare() method of the Comparator
public int compare(Pair p1, Pair p2)
{
if (p1.first < p2.first)
{
return -1;
}
else if(p1.first == p2.first)
{
return p1.second - p2.second;
}
else if (p1.first > p2.first)
{
return 1;
}

return 0;
}
}

// class Pair contains 
// two elements one is first
// other is second
class Pair 
{
int first; 
int second;
Pair(int first, int second)
{
this.first = first;
this.second = second;
}
}
public class UniqueAdjEle1 
{
// a boolean method that checks whether the elements of the array list al 
// have the valid arrangement or not.
public boolean isValidArrangement(ArrayList<Integer> al, int s)
{
int chk = 1;

for (int j = 1; j < s; j++) 
{
if (al.get(j) == al.get(j - 1)) 
{
chk = 0;
break;
}
}

return chk == 1;
}

public ArrayList<Integer> rearrangeArr(ArrayList<Integer> al, int s) 
{
if(isValidArrangement(al, s))
{
// the arrangement is valid
// hence, there is no need to proceed further
return al;
}

// Sorting the list or array al
Collections.sort(al);

// Declaring a set st that keeps the elements and their
// occurrence count.
TreeSet<Pair> st = new TreeSet<>(new PairComparator());


// Iterating over the list or array al
// Iterating until the element is the same
// Incrementing the element count by 1. 
// Inserting the element and its occurrence count in the set st
for (int j = 0; j < s; j++)
{

int k = j;
while (j < s && k < s && (al.get(j).equals(al.get(k))))
{
k = k + 1;
}
st.add(new Pair(k - j, al.get(j)));

j = k - 1;
}

int prv = -1;
int prvFreq = 0;

// Declaring an empty array or list solAl
ArrayList<Integer> solAl = new ArrayList<>();

while (st.size() != 0)
{
Pair pr = st.last();
st.remove(pr);
solAl.add(pr.second);

if (prvFreq > 0)
{
st.add(new Pair(prvFreq, prv));
}

prvFreq = pr.first - 1;
prv = pr.second;
}

// calculating the new size of the 
// rearranged array list
int newSize = solAl.size();

// if the new size after the rearrangement
// if the array list is not equal to the size s
// then, the valid rearrangement is not possible
if(newSize != s)
{
return new ArrayList<Integer>();
}

return solAl;
}


// main method
public static void main(String argvs[])
{
// creating an object of the class UniqueAdjEle1 
UniqueAdjEle1 obj = new UniqueAdjEle1();

// input 1
ArrayList<Integer> inArr = new ArrayList<Integer>
(
Arrays.asList(7, 7, 6, 8)
);

// computing the size of the 
// input array
int size = inArr.size();
System.out.println("For the input array: ");
for(int i = 0; i < size; i++)
{
System.out.print(inArr.get(i) + " ");
}
System.out.println();
ArrayList<Integer> ans = obj.rearrangeArr(inArr, size);
if(ans.size() > 0)
{
System.out.println("The valid arrangement is: ");

for(int i = 0; i < size; i++)
{
System.out.print(ans.get(i) + " ");
}
}
else
{
System.out.println("The valid arrangement is not possible. ");
}

System.out.println( "\n" );

// input 2
inArr = new ArrayList<Integer>
(
Arrays.asList(2, 4, 8, 9, 5, 7, 3, 6, 1)
);

// computing the size of the 
// input array
size = inArr.size();

System.out.println("For the input array: ");

for(int i = 0; i < size; i++)
{
System.out.print(inArr.get(i) + " ");
}

System.out.println();

ans = obj.rearrangeArr(inArr, size);

if(ans.size() > 0)
{
System.out.println("The valid arrangement is: ");

for(int i = 0; i < size; i++)
{
System.out.print(ans.get(i) + " ");
}
}
else
{
System.out.println("The valid arrangement is not possible. ");
}

System.out.println( "\n" );

// input 3
inArr = new ArrayList<Integer>
(
Arrays.asList(3, 3, 3, 3, 3)
);

// computing the size of the 
// input array
size = inArr.size();

System.out.println("For the input array: ");

for(int i = 0; i < size; i++)
{
System.out.print(inArr.get(i) + " ");
}

System.out.println();

ans = obj.rearrangeArr(inArr, size);
if(ans.size() > 0)
{
System.out.println("The valid arrangement is: ");

for(int i = 0; i < size; i++)
{
System.out.print(ans.get(i) + " ");
}
}
else
{
System.out.println("The valid arrangement is not possible. ");
}

}

}
 Output: For the input array: 
7 7 6 8 
The valid arrangement is: 
7 8 7 6 

For the input array: 
2 4 8 9 5 7 3 6 1 
The valid arrangement is: 
2 4 8 9 5 7 3 6 1 

For the input array: 
3 3 3 3 3 
The valid arrangement is not possible.
 Complexity Analysis: Since the program is using sorting, the time complexity of the program is O(N * log(N)). The program uses a set to store the elements and their occurrence count. The program is also using an auxiliary array (arr). Thus, making the space complexity of the program as (N), where N is the total number of elements present in the input array. Note: Instead of Set, a priority queue can also be used. In that case, also, the time and space complexity remain the same. Next Topic# ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/unequal-adjacent-elements-in-java Unequal Adjacent Elements in Java - Javatpoint ? SCROLL TO TOP Home Java Programs OOPs String Exception Multithreading Collections JavaFX JSP Spring Spring Boot Projects Interview Questions Java Tutorial What is Java History of Java Features of Java C++ vs Java Hello Java Program Program Internal How to set path? JDK, JRE and JVM JVM: Java Virtual Machine Java Variables Java Data Types Unicode System Operators Keywords Control Statements Java Control Statements Java If-else Java Switch Java For Loop Java While Loop Java Do While Loop Java Break Java Continue Java Comments Java Programs Java Object Class Java OOPs Concepts Naming Convention Object and Class Method Constructor static keyword this keyword Java Inheritance Inheritance(IS-A) Aggregation(HAS-A) Java Polymorphism Method Overloading Method Overriding Covariant Return Type super keyword Instance Initializer block final keyword Runtime Polymorphism Dynamic Binding instanceof operator Java Abstraction Abstract class Interface Abstract vs Interface Java Encapsulation Package Access Modifiers Encapsulation Java Array Java Array Java OOPs Misc Object class Object Cloning Math class Wrapper Class Java Recursion Call By Value strictfp keyword javadoc tool Command Line Arg Object vs Class Overloading vs Overriding Java String Java Regex Exception Handling Java Inner classes Java Multithreading Java I/O Java Networking Java AWT & Events Java Swing JavaFX Java Applet Java Reflection Java Date Java Conversion Java Collection Java JDBC Java Misc Java New Features RMI Internationalization Interview Questions Java MCQ next ? ? prev Unequal Adjacent Elements in Java An array inArr containing n numbers (positive or negative) is given. The task is to return the array after the rearrangement of elements of the integers in such a way that no two adjacent elements are equal. If there are multiple valid arrangements, then any one valid arrangement can be returned. If the input array does not contain any valid arrangement, then an appropriate message can be displayed on the console. Example 1: Input int inArr[] = {7, 7, 6, 8} Output: {7, 6, 7, 8} Explanation: There are many valid arrangements possible. Those valid arrangements are mentioned below. {7, 6, 7, 8}, {7, 6, 8, 7}, {7, 8, 7, 6}, {7, 8, 6, 7}, {8, 7, 6, 7}, {6, 7, 8, 7}. Out of which {7, 6, 7, 8} is mentioned in the output. Example 2: Input int inArr[] = {2, 4, 8, 9, 5, 7, 3, 6, 1} Output: {2, 4, 8, 9, 5, 7, 3, 6, 1} Explanation: The input array is given in such a way that there are no two elements that are of the same value. Hence, the input arrays are themselves the answer. Example 3: Input int arr[] = {3, 3, 3, 3, 3} Output: no valid arrangement is possible where adjacent elements are of different values. Explanation: All the elements are of the same value. Hence, no valid arrangement is possible. Approach: Brute Force In this approach, we compute all the arrangements of the input array. If any valid arrangement comes, we return that arrangement. If no valid arrangement is possible, display the appropriate message. For computing the valid arrangement, first, we will sort the array in ascending order. Then we will find the next permutation of the sorted array and check whether it is a valid arrangement or not. If it is a valid arrangement, then we can return that arrangement. If not, then we will find the next permutation and continue to do so until we find a valid arrangement or all the arrangements are exhausted. If the arrangements are exhausted, then we can say that no valid arrangement is there for the given input array, and the same is illustrated in the following program. FileName: UniqueAdjEle.java 
// important import statements
import java.util.Collections;
import java.util.ArrayList;
import java.util.Arrays;


public class UniqueAdjEle 
{
    // swapping the elements in the array list al
    // that are present at the index j and k
    private void swapEle(ArrayList<Integer> al, int j, int k) 
    {
        int temp = al.get(j);
        al.set(j, al.get(k));
        al.set(k, temp);
    }
    // reversing the array list from j to k
    private void reverseArrList(ArrayList<Integer> al, int j, int k) 
    {
        while (j < k) 
        {
            swapEle(al, j, k);
            j = j + 1;
            k = k - 1;
        }
    }

    private boolean nextPermutation(ArrayList<Integer> al) 
    {
        // if the list has no elements
        // or the single element, then
        // there is no need to proceed further
        if (al == null || al.size() <= 1) 
        {
            return false;
        }

        int j = al.size() - 2;

        while (j >= 0 && al.get(j).intValue() >= al.get(j + 1).intValue()) 
        {

            // Finding the first j that is breaking descending order
            j = j - 1;
        }

        if (j >= 0) 
        {
            // if the control reaching
            // here, then it means the array
            // is not entirely descending

            // Starting from the end
            int k = al.size() - 1;

            while (al.get(k).intValue() <= al.get(j).intValue()) 
            {
                // Finding the rightmost first larger id than k
                k = k - 1;
            }

            // Switching j and k
            swapEle(al, j, k);

            // Reversing in the descending sequence
            reverseArrList(al, j + 1, al.size() - 1);

            return true;
        } else 
        {
            // Reversing the whole sequence.
            reverseArrList(al, 0, al.size() - 1);
            return false;
        }
    }
    // a Boolean method that checks whether the elements of the array list al 
    // have the valid arrangement or not.
    public boolean isValidArrangement(ArrayList<Integer> al, int s)
    {
        int chk = 1;

            for (int j = 1; j < s; j++) 
            {
                if (al.get(j) == al.get(j - 1)) 
                {
                    chk = 0;
                    break;
                }
            }

            return chk == 1;
    }

    public ArrayList<Integer> rearrangeArr(ArrayList<Integer> al, int s) 
    {   
        if(isValidArrangement(al, s))
        {
            return al;
        }
        // sorting the list so we can compute the next permutation
        Collections.sort(al);
       
        // Iterating the array list and 
        // checking whether it is a valid arrangement or not
        // if yes, then we terminate the do-while loop.
        // Otherwise, we find the next permutation.
         while (nextPermutation(al))
         {
             if(isValidArrangement(al, s))
             {
                 return al;
             }
         }

        return new ArrayList<Integer>();
    }
    
    // main method
    public static void main(String argvs[])
    {
        // creating an object of the class UniqueAdjEle 
        UniqueAdjEle obj = new UniqueAdjEle();
        
        // input 1
        ArrayList<Integer> inArr = new ArrayList<Integer>
        (
            Arrays.asList(7, 7, 6, 8)
        );
        
        // computing the size of the 
        // input array
        int size = inArr.size();
        System.out.println("For the input array: ");
        for(int i = 0; i < size; i++)
        {
            System.out.print(inArr.get(i) + " ");
        }
        System.out.println();
        ArrayList<Integer> ans = obj.rearrangeArr(inArr, size);
        if(ans.size() > 0)
        {
        System.out.println("The valid arrangement is: ");
        
        for(int i = 0; i < size; i++)
        {
            System.out.print(ans.get(i) + " ");
        }
        }
        else
        {
            System.out.println("The valid arrangement is not possible. ");
        }
        
        System.out.println( "\n" );
        
        // input 2
        inArr = new ArrayList<Integer>
        (
            Arrays.asList(2, 4, 8, 9, 5, 7, 3, 6, 1)
        );
        
        // computing the size of the 
        // input array
        size = inArr.size();
        
        System.out.println("For the input array: ");
        
        for(int i = 0; i < size; i++)
        {
            System.out.print(inArr.get(i) + " ");
        }
        
        System.out.println();
        
        ans = obj.rearrangeArr(inArr, size);
        
        if(ans.size() > 0)
        {
        System.out.println("The valid arrangement is: ");
        
        for(int i = 0; i < size; i++)
        {
            System.out.print(ans.get(i) + " ");
        }
        }
        else
        {
            System.out.println("The valid arrangement is not possible. ");
        }
        
        System.out.println( "\n" );
        
        // input 3
        inArr = new ArrayList<Integer>
        (
            Arrays.asList(3, 3, 3, 3, 3)
        );
        
        // computing the size of the 
        // input array
        size = inArr.size();
        
        System.out.println("For the input array: ");
        
        for(int i = 0; i < size; i++)
        {
            System.out.print(inArr.get(i) + " ");
        }
        
        System.out.println();
        
        ans = obj.rearrangeArr(inArr, size);
        if(ans.size() > 0)
        {
        System.out.println("The valid arrangement is: ");
        
        for(int i = 0; i < size; i++)
        {
            System.out.print(ans.get(i) + " ");
        }
        }
        else
        {
            System.out.println("The valid arrangement is not possible. ");
        }
        
    }
    
    
    
}
 Output: For the input array: 
7 7 6 8 
The valid arrangement is: 
6 7 8 7 

For the input array: 
2 4 8 9 5 7 3 6 1 
The valid arrangement is: 
2 4 8 9 5 7 3 6 1 

For the input array: 
3 3 3 3 3 
The valid arrangement is not possible.
 Complexity Analysis: Since the program is computing the permutation, the time complexity of the program is O(N!), where N is the total number of elements present in the linked list. The program uses constant space; therefore, the space complexity of the program is O(1). The above program is not suitable for the larger inputs as the time complexity of the program is too high. Therefore, we must do some optimization to reduce the time complexity. Approach: Using Set It is a greedy approach where we put first that element which is occurring the most number of times in the input array. Using the set, we will put all the elements in the order of their occurrence count. The following are the steps involved in computing the answer. Step 1: Declare an empty array or list solAl. Step 2: Sort the array or list solAl. Step 3: Declare a set st that keeps the elements and their occurrence count. Step 4: Iterate over the list or array solAl: Iterate until the same element is encountered every time. Increment the element count by 1. Put the element and the occurrence count of the element in the set st. Step 5: Create a temporary variable for keeping the previous element and its occurrence count. Step 6: While the set st is not empty, do the following: Fetch the last element and get it added to the result. Delete that element from the set st. Reduce the occurrence count of the element popped by 1. If the occurrence count was non-zero of the previous elements, put it in the set. The current element should be treated as the previous element for the upcoming iteration. Step 7: Eventually, return the list or array solAl. Implementation The implementation of the above steps is mentioned below. FileName: UniqueAdjEle.java 
// important import statements
import java.util.Arrays;
import java.util.ArrayList;
import java.util.TreeSet;
import java.util.Collections;
import java.util.Comparator;

class PairComparator implements Comparator<Pair>
{

// Overriding the compare() method of the Comparator
public int compare(Pair p1, Pair p2)
{
if (p1.first < p2.first)
{
return -1;
}
else if(p1.first == p2.first)
{
return p1.second - p2.second;
}
else if (p1.first > p2.first)
{
return 1;
}

return 0;
}
}

// class Pair contains 
// two elements one is first
// other is second
class Pair 
{
int first; 
int second;
Pair(int first, int second)
{
this.first = first;
this.second = second;
}
}
public class UniqueAdjEle1 
{
// a boolean method that checks whether the elements of the array list al 
// have the valid arrangement or not.
public boolean isValidArrangement(ArrayList<Integer> al, int s)
{
int chk = 1;

for (int j = 1; j < s; j++) 
{
if (al.get(j) == al.get(j - 1)) 
{
chk = 0;
break;
}
}

return chk == 1;
}

public ArrayList<Integer> rearrangeArr(ArrayList<Integer> al, int s) 
{
if(isValidArrangement(al, s))
{
// the arrangement is valid
// hence, there is no need to proceed further
return al;
}

// Sorting the list or array al
Collections.sort(al);

// Declaring a set st that keeps the elements and their
// occurrence count.
TreeSet<Pair> st = new TreeSet<>(new PairComparator());


// Iterating over the list or array al
// Iterating until the element is the same
// Incrementing the element count by 1. 
// Inserting the element and its occurrence count in the set st
for (int j = 0; j < s; j++)
{

int k = j;
while (j < s && k < s && (al.get(j).equals(al.get(k))))
{
k = k + 1;
}
st.add(new Pair(k - j, al.get(j)));

j = k - 1;
}

int prv = -1;
int prvFreq = 0;

// Declaring an empty array or list solAl
ArrayList<Integer> solAl = new ArrayList<>();

while (st.size() != 0)
{
Pair pr = st.last();
st.remove(pr);
solAl.add(pr.second);

if (prvFreq > 0)
{
st.add(new Pair(prvFreq, prv));
}

prvFreq = pr.first - 1;
prv = pr.second;
}

// calculating the new size of the 
// rearranged array list
int newSize = solAl.size();

// if the new size after the rearrangement
// if the array list is not equal to the size s
// then, the valid rearrangement is not possible
if(newSize != s)
{
return new ArrayList<Integer>();
}

return solAl;
}


// main method
public static void main(String argvs[])
{
// creating an object of the class UniqueAdjEle1 
UniqueAdjEle1 obj = new UniqueAdjEle1();

// input 1
ArrayList<Integer> inArr = new ArrayList<Integer>
(
Arrays.asList(7, 7, 6, 8)
);

// computing the size of the 
// input array
int size = inArr.size();
System.out.println("For the input array: ");
for(int i = 0; i < size; i++)
{
System.out.print(inArr.get(i) + " ");
}
System.out.println();
ArrayList<Integer> ans = obj.rearrangeArr(inArr, size);
if(ans.size() > 0)
{
System.out.println("The valid arrangement is: ");

for(int i = 0; i < size; i++)
{
System.out.print(ans.get(i) + " ");
}
}
else
{
System.out.println("The valid arrangement is not possible. ");
}

System.out.println( "\n" );

// input 2
inArr = new ArrayList<Integer>
(
Arrays.asList(2, 4, 8, 9, 5, 7, 3, 6, 1)
);

// computing the size of the 
// input array
size = inArr.size();

System.out.println("For the input array: ");

for(int i = 0; i < size; i++)
{
System.out.print(inArr.get(i) + " ");
}

System.out.println();

ans = obj.rearrangeArr(inArr, size);

if(ans.size() > 0)
{
System.out.println("The valid arrangement is: ");

for(int i = 0; i < size; i++)
{
System.out.print(ans.get(i) + " ");
}
}
else
{
System.out.println("The valid arrangement is not possible. ");
}

System.out.println( "\n" );

// input 3
inArr = new ArrayList<Integer>
(
Arrays.asList(3, 3, 3, 3, 3)
);

// computing the size of the 
// input array
size = inArr.size();

System.out.println("For the input array: ");

for(int i = 0; i < size; i++)
{
System.out.print(inArr.get(i) + " ");
}

System.out.println();

ans = obj.rearrangeArr(inArr, size);
if(ans.size() > 0)
{
System.out.println("The valid arrangement is: ");

for(int i = 0; i < size; i++)
{
System.out.print(ans.get(i) + " ");
}
}
else
{
System.out.println("The valid arrangement is not possible. ");
}

}

}
 Output: For the input array: 
7 7 6 8 
The valid arrangement is: 
7 8 7 6 

For the input array: 
2 4 8 9 5 7 3 6 1 
The valid arrangement is: 
2 4 8 9 5 7 3 6 1 

For the input array: 
3 3 3 3 3 
The valid arrangement is not possible.
 Complexity Analysis: Since the program is using sorting, the time complexity of the program is O(N * log(N)). The program uses a set to store the elements and their occurrence count. The program is also using an auxiliary array (arr). Thus, making the space complexity of the program as (N), where N is the total number of elements present in the input array. Note: Instead of Set, a priority queue can also be used. In that case, also, the time and space complexity remain the same. Next Topic# ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.