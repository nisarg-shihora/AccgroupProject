https://www.javatpoint.com/plus-one-to-array-problem-in-java Plus One to Array Problem in Java - Javatpoint ? SCROLL TO TOP Home Java Programs OOPs String Exception Multithreading Collections JavaFX JSP Spring Spring Boot Projects Interview Questions Java Tutorial What is Java History of Java Features of Java C++ vs Java Hello Java Program Program Internal How to set path? JDK, JRE and JVM JVM: Java Virtual Machine Java Variables Java Data Types Unicode System Operators Keywords Control Statements Java Control Statements Java If-else Java Switch Java For Loop Java While Loop Java Do While Loop Java Break Java Continue Java Comments Java Programs Java Object Class Java OOPs Concepts Naming Convention Object and Class Method Constructor static keyword this keyword Java Inheritance Inheritance(IS-A) Aggregation(HAS-A) Java Polymorphism Method Overloading Method Overriding Covariant Return Type super keyword Instance Initializer block final keyword Runtime Polymorphism Dynamic Binding instanceof operator Java Abstraction Abstract class Interface Abstract vs Interface Java Encapsulation Package Access Modifiers Encapsulation Java Array Java Array Java OOPs Misc Object class Object Cloning Math class Wrapper Class Java Recursion Call By Value strictfp keyword javadoc tool Command Line Arg Object vs Class Overloading vs Overriding Java String Java Regex Exception Handling Java Inner classes Java Multithreading Java I/O Java Networking Java AWT & Events Java Swing JavaFX Java Applet Java Reflection Java Date Java Conversion Java Collection Java JDBC Java Misc Java New Features RMI Internationalization Interview Questions Java MCQ next ? ? prev Plus One to Array Problem in Java It is a very interesting problem frequently asked in interviews of top IT companies like Google, Amazon, TCS, Accenture, Adobe, Apple, Infosys, etc. By solving the problem, one wants to check the logical ability, critical thinking, and problem-solving skill of the interviewee. So, in this section, we are going to add (plus) one to an array problem in Java with different approaches and logic. Also, we will create Java programs for the same. Problem Statement In this problem, we have given an array in which each element represents a digit and the complete array represents a number. The digits are ordered from MSB to LSB in left to right order. Assume that there is no leading 0's in the number. The task is to add 1 to the number and return the result in the form of an array of digits. Let's understand it through examples. Example Input: arr = [2, 5, 9, 7] Output: [2, 5, 9, 8] It represents the number 2597. Add 1 to the most significant bit, we get 2598. The output will be [2, 5, 9, 8]. Let's see another example. Input: arr = [9, 9] Output: [1, 0, 0] It represents the number 99. Add 1 to the most significant bit, we get 100. The output will be [1, 0, 0]. Solution to The Problem Naive Approach The simple approach is that first convert the array into a number, add one to it, and return the result in the form of an array. But the approach is not applicable to the large array. So, we will process each digit one by one. Begin from the least significant bit and process each digit till the most significant bit. If the current digit is smaller than 9, add 1 to the current digit and return the array else assign zero to the current digit. If the last element is processed and it was also equal to 9, it means that all the digits were 9. So, we will increase the size of the array by one and assign 1 to the MSB. Return the resultant array. Plus One to Array Java Program PlusOneArray.java 
import java.util.Arrays; 
public class PlusOneArray
{
//function to add 1 to the array
public static int[] plusOne(int[] digits) 
{
int n = digits.length;
for(int i=n-1; i>=0; i--) 
{
if(digits[i] < 9) 
{
digits[i]++; 
return digits;
}
digits[i] = 0;
}
int[] newNumber = new int [n+1];
newNumber[0] = 1;
return newNumber;
}
//driver code
public static void main(String args[]) 
{
int [] arr = {6, 3, 8, 2}; 
//function calling
int[]ans=plusOne(arr); 
//prints the resultant array after adding 1 to MSB
System.out.println(Arrays.toString(ans));
}
}
 Output: [6, 3, 8, 3]
 Using Vector Another approach is using the vector. In this approach, we begin from the end of the vector. If the last element is 9, set it to 0, else exit from the loop. If all digits are 9, set 1 at starting, else increment the element at the position where the loop stopped. Note that no carry, division, and modulo is required. Let's implement the above approach in a Java program. PlusOneExample1.java 
import java.io.*;
import java.util.*;
public class PlusOneExample1
{
//function to add one to the array
static void plusOne(Vector<Integer> digits)
{
//initialize an index (digit of units)
int index= digits.size() - 1;
while (index >= 0 && digits.get(index) == 9)
{
//while the index is valid and the value at [index] == 9 set it as 0    
digits.set(index, 0);
//decement index by 1
index -= 1;
}
// if index < 0 (if all digits were 9)
if (index < 0)
{
//inserting 1 at the beginning of the vector 
digits.set(0, 1);
//adding an extra zero to the end of the vector 
digits.add(digits.size(),0);
}
//else increment the value at [index]
else
digits.set(index, digits.get(index) + 1);
}
//driver code
public static void main(String args[])
{
//creating an instance of the vector class and passing an array
Vector<Integer> digits = new Vector<Integer>(Arrays.asList(12, 45, 90, 34));
//function calling
plusOne(digits);
for (int digit : digits)
//prints the array after adding 1 to the array
System.out.print(digit + " ");
}
}
 Output: 12 45 90 35
 Let's see another approach. In this approach, first, we reverse the given array. After that take a carry variable to store the carry. Iterate over the array from starting and add 1. Carry to the value of that array at that index. Now check whether the value of that index is greater than equal to 9 or not. If yes, take the carry as the ten's value and the value at that index in the array will be the value present at the one place, else simply move on. 
if digits[i]>9 then carry = digits[i]/10 and digits[i]%=10
if digits[i]<=9 then carry = 0
 Repeat the above step until we reach the last element of the array. Note that if carry is not 0, simply add 1 to the array. At last, reverse the array, so that we can get the original array. Let's implement the above approach in a Java program. PlusOneExample2.java 
import java.io.*;
import java.util.*;
public class PlusOneExample2
{
//function to add one to the array    
public static void plusOne(Vector<Integer> digits, int n)
{
//revers the given array so that we can begin traversing from back
Collections.reverse(digits);
//defining a variable to store carry
int carry = 0;
for(int i = 0; i < n; i++)
{
//initially carry is 0, it is the base case
if(i == 0)
digits.set(i, digits.get(i) + 1 + carry);
//if carry is not equal to zero, add it to the array element at that position
else if(carry != 0)
digits.set(i, digits.get(i) + carry);
//now to get carry, i.e. if digits[i]>9 we get the value at tens place in carry or else if digits[i]<9 carry will be 0
carry = digits.get(i) / 10;
//now if carry is not equal to 0, so at that index, we should keep the value present at the ones place so we do digits[i]%10
if(carry != 0)digits.set(i, digits.get(i) % 10);
}
//after doing all that if carry is still there which means one more element is needed to be added to the array
if(carry != 0)
digits.set(digits.size() - 1, carry);
//again, revere the array so that we can get the original array
Collections.reverse(digits);
}
//driver code
public static void main (String args[])
{
//creating an instance of the vector class and passing an array
Vector<Integer> digits = new Vector<Integer>(Arrays.asList(9, 9, 9, 9, 9));
//determines the size of the array
int n = digits.size();
//function calling
plusOne(digits, n);
for(int i = 0; i < n; i++)
{
//prints the array after adding 1 to the array    
System.out.print(digits.get(i) + " ");
}
}
}
 Output: 1 0 0 0 0
 Complexity The time complexity of all the above approaches is O(n) because we have traversed over the array only once. Where n is the length of the array. The space complexity of the approach is O(1) if the array contains at least one digit smaller than 9, else O(n). Next TopicUnequal Adjacent Elements in Java ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/plus-one-to-array-problem-in-java Plus One to Array Problem in Java - Javatpoint ? SCROLL TO TOP Home Java Programs OOPs String Exception Multithreading Collections JavaFX JSP Spring Spring Boot Projects Interview Questions Java Tutorial What is Java History of Java Features of Java C++ vs Java Hello Java Program Program Internal How to set path? JDK, JRE and JVM JVM: Java Virtual Machine Java Variables Java Data Types Unicode System Operators Keywords Control Statements Java Control Statements Java If-else Java Switch Java For Loop Java While Loop Java Do While Loop Java Break Java Continue Java Comments Java Programs Java Object Class Java OOPs Concepts Naming Convention Object and Class Method Constructor static keyword this keyword Java Inheritance Inheritance(IS-A) Aggregation(HAS-A) Java Polymorphism Method Overloading Method Overriding Covariant Return Type super keyword Instance Initializer block final keyword Runtime Polymorphism Dynamic Binding instanceof operator Java Abstraction Abstract class Interface Abstract vs Interface Java Encapsulation Package Access Modifiers Encapsulation Java Array Java Array Java OOPs Misc Object class Object Cloning Math class Wrapper Class Java Recursion Call By Value strictfp keyword javadoc tool Command Line Arg Object vs Class Overloading vs Overriding Java String Java Regex Exception Handling Java Inner classes Java Multithreading Java I/O Java Networking Java AWT & Events Java Swing JavaFX Java Applet Java Reflection Java Date Java Conversion Java Collection Java JDBC Java Misc Java New Features RMI Internationalization Interview Questions Java MCQ next ? ? prev Plus One to Array Problem in Java It is a very interesting problem frequently asked in interviews of top IT companies like Google, Amazon, TCS, Accenture, Adobe, Apple, Infosys, etc. By solving the problem, one wants to check the logical ability, critical thinking, and problem-solving skill of the interviewee. So, in this section, we are going to add (plus) one to an array problem in Java with different approaches and logic. Also, we will create Java programs for the same. Problem Statement In this problem, we have given an array in which each element represents a digit and the complete array represents a number. The digits are ordered from MSB to LSB in left to right order. Assume that there is no leading 0's in the number. The task is to add 1 to the number and return the result in the form of an array of digits. Let's understand it through examples. Example Input: arr = [2, 5, 9, 7] Output: [2, 5, 9, 8] It represents the number 2597. Add 1 to the most significant bit, we get 2598. The output will be [2, 5, 9, 8]. Let's see another example. Input: arr = [9, 9] Output: [1, 0, 0] It represents the number 99. Add 1 to the most significant bit, we get 100. The output will be [1, 0, 0]. Solution to The Problem Naive Approach The simple approach is that first convert the array into a number, add one to it, and return the result in the form of an array. But the approach is not applicable to the large array. So, we will process each digit one by one. Begin from the least significant bit and process each digit till the most significant bit. If the current digit is smaller than 9, add 1 to the current digit and return the array else assign zero to the current digit. If the last element is processed and it was also equal to 9, it means that all the digits were 9. So, we will increase the size of the array by one and assign 1 to the MSB. Return the resultant array. Plus One to Array Java Program PlusOneArray.java 
import java.util.Arrays; 
public class PlusOneArray
{
//function to add 1 to the array
public static int[] plusOne(int[] digits) 
{
int n = digits.length;
for(int i=n-1; i>=0; i--) 
{
if(digits[i] < 9) 
{
digits[i]++; 
return digits;
}
digits[i] = 0;
}
int[] newNumber = new int [n+1];
newNumber[0] = 1;
return newNumber;
}
//driver code
public static void main(String args[]) 
{
int [] arr = {6, 3, 8, 2}; 
//function calling
int[]ans=plusOne(arr); 
//prints the resultant array after adding 1 to MSB
System.out.println(Arrays.toString(ans));
}
}
 Output: [6, 3, 8, 3]
 Using Vector Another approach is using the vector. In this approach, we begin from the end of the vector. If the last element is 9, set it to 0, else exit from the loop. If all digits are 9, set 1 at starting, else increment the element at the position where the loop stopped. Note that no carry, division, and modulo is required. Let's implement the above approach in a Java program. PlusOneExample1.java 
import java.io.*;
import java.util.*;
public class PlusOneExample1
{
//function to add one to the array
static void plusOne(Vector<Integer> digits)
{
//initialize an index (digit of units)
int index= digits.size() - 1;
while (index >= 0 && digits.get(index) == 9)
{
//while the index is valid and the value at [index] == 9 set it as 0    
digits.set(index, 0);
//decement index by 1
index -= 1;
}
// if index < 0 (if all digits were 9)
if (index < 0)
{
//inserting 1 at the beginning of the vector 
digits.set(0, 1);
//adding an extra zero to the end of the vector 
digits.add(digits.size(),0);
}
//else increment the value at [index]
else
digits.set(index, digits.get(index) + 1);
}
//driver code
public static void main(String args[])
{
//creating an instance of the vector class and passing an array
Vector<Integer> digits = new Vector<Integer>(Arrays.asList(12, 45, 90, 34));
//function calling
plusOne(digits);
for (int digit : digits)
//prints the array after adding 1 to the array
System.out.print(digit + " ");
}
}
 Output: 12 45 90 35
 Let's see another approach. In this approach, first, we reverse the given array. After that take a carry variable to store the carry. Iterate over the array from starting and add 1. Carry to the value of that array at that index. Now check whether the value of that index is greater than equal to 9 or not. If yes, take the carry as the ten's value and the value at that index in the array will be the value present at the one place, else simply move on. 
if digits[i]>9 then carry = digits[i]/10 and digits[i]%=10
if digits[i]<=9 then carry = 0
 Repeat the above step until we reach the last element of the array. Note that if carry is not 0, simply add 1 to the array. At last, reverse the array, so that we can get the original array. Let's implement the above approach in a Java program. PlusOneExample2.java 
import java.io.*;
import java.util.*;
public class PlusOneExample2
{
//function to add one to the array    
public static void plusOne(Vector<Integer> digits, int n)
{
//revers the given array so that we can begin traversing from back
Collections.reverse(digits);
//defining a variable to store carry
int carry = 0;
for(int i = 0; i < n; i++)
{
//initially carry is 0, it is the base case
if(i == 0)
digits.set(i, digits.get(i) + 1 + carry);
//if carry is not equal to zero, add it to the array element at that position
else if(carry != 0)
digits.set(i, digits.get(i) + carry);
//now to get carry, i.e. if digits[i]>9 we get the value at tens place in carry or else if digits[i]<9 carry will be 0
carry = digits.get(i) / 10;
//now if carry is not equal to 0, so at that index, we should keep the value present at the ones place so we do digits[i]%10
if(carry != 0)digits.set(i, digits.get(i) % 10);
}
//after doing all that if carry is still there which means one more element is needed to be added to the array
if(carry != 0)
digits.set(digits.size() - 1, carry);
//again, revere the array so that we can get the original array
Collections.reverse(digits);
}
//driver code
public static void main (String args[])
{
//creating an instance of the vector class and passing an array
Vector<Integer> digits = new Vector<Integer>(Arrays.asList(9, 9, 9, 9, 9));
//determines the size of the array
int n = digits.size();
//function calling
plusOne(digits, n);
for(int i = 0; i < n; i++)
{
//prints the array after adding 1 to the array    
System.out.print(digits.get(i) + " ");
}
}
}
 Output: 1 0 0 0 0
 Complexity The time complexity of all the above approaches is O(n) because we have traversed over the array only once. Where n is the length of the array. The space complexity of the approach is O(1) if the array contains at least one digit smaller than 9, else O(n). Next TopicUnequal Adjacent Elements in Java ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/plus-one-to-array-problem-in-java Plus One to Array Problem in Java - Javatpoint ? SCROLL TO TOP Home Java Programs OOPs String Exception Multithreading Collections JavaFX JSP Spring Spring Boot Projects Interview Questions Java Tutorial What is Java History of Java Features of Java C++ vs Java Hello Java Program Program Internal How to set path? JDK, JRE and JVM JVM: Java Virtual Machine Java Variables Java Data Types Unicode System Operators Keywords Control Statements Java Control Statements Java If-else Java Switch Java For Loop Java While Loop Java Do While Loop Java Break Java Continue Java Comments Java Programs Java Object Class Java OOPs Concepts Naming Convention Object and Class Method Constructor static keyword this keyword Java Inheritance Inheritance(IS-A) Aggregation(HAS-A) Java Polymorphism Method Overloading Method Overriding Covariant Return Type super keyword Instance Initializer block final keyword Runtime Polymorphism Dynamic Binding instanceof operator Java Abstraction Abstract class Interface Abstract vs Interface Java Encapsulation Package Access Modifiers Encapsulation Java Array Java Array Java OOPs Misc Object class Object Cloning Math class Wrapper Class Java Recursion Call By Value strictfp keyword javadoc tool Command Line Arg Object vs Class Overloading vs Overriding Java String Java Regex Exception Handling Java Inner classes Java Multithreading Java I/O Java Networking Java AWT & Events Java Swing JavaFX Java Applet Java Reflection Java Date Java Conversion Java Collection Java JDBC Java Misc Java New Features RMI Internationalization Interview Questions Java MCQ next ? ? prev Plus One to Array Problem in Java It is a very interesting problem frequently asked in interviews of top IT companies like Google, Amazon, TCS, Accenture, Adobe, Apple, Infosys, etc. By solving the problem, one wants to check the logical ability, critical thinking, and problem-solving skill of the interviewee. So, in this section, we are going to add (plus) one to an array problem in Java with different approaches and logic. Also, we will create Java programs for the same. Problem Statement In this problem, we have given an array in which each element represents a digit and the complete array represents a number. The digits are ordered from MSB to LSB in left to right order. Assume that there is no leading 0's in the number. The task is to add 1 to the number and return the result in the form of an array of digits. Let's understand it through examples. Example Input: arr = [2, 5, 9, 7] Output: [2, 5, 9, 8] It represents the number 2597. Add 1 to the most significant bit, we get 2598. The output will be [2, 5, 9, 8]. Let's see another example. Input: arr = [9, 9] Output: [1, 0, 0] It represents the number 99. Add 1 to the most significant bit, we get 100. The output will be [1, 0, 0]. Solution to The Problem Naive Approach The simple approach is that first convert the array into a number, add one to it, and return the result in the form of an array. But the approach is not applicable to the large array. So, we will process each digit one by one. Begin from the least significant bit and process each digit till the most significant bit. If the current digit is smaller than 9, add 1 to the current digit and return the array else assign zero to the current digit. If the last element is processed and it was also equal to 9, it means that all the digits were 9. So, we will increase the size of the array by one and assign 1 to the MSB. Return the resultant array. Plus One to Array Java Program PlusOneArray.java 
import java.util.Arrays; 
public class PlusOneArray
{
//function to add 1 to the array
public static int[] plusOne(int[] digits) 
{
int n = digits.length;
for(int i=n-1; i>=0; i--) 
{
if(digits[i] < 9) 
{
digits[i]++; 
return digits;
}
digits[i] = 0;
}
int[] newNumber = new int [n+1];
newNumber[0] = 1;
return newNumber;
}
//driver code
public static void main(String args[]) 
{
int [] arr = {6, 3, 8, 2}; 
//function calling
int[]ans=plusOne(arr); 
//prints the resultant array after adding 1 to MSB
System.out.println(Arrays.toString(ans));
}
}
 Output: [6, 3, 8, 3]
 Using Vector Another approach is using the vector. In this approach, we begin from the end of the vector. If the last element is 9, set it to 0, else exit from the loop. If all digits are 9, set 1 at starting, else increment the element at the position where the loop stopped. Note that no carry, division, and modulo is required. Let's implement the above approach in a Java program. PlusOneExample1.java 
import java.io.*;
import java.util.*;
public class PlusOneExample1
{
//function to add one to the array
static void plusOne(Vector<Integer> digits)
{
//initialize an index (digit of units)
int index= digits.size() - 1;
while (index >= 0 && digits.get(index) == 9)
{
//while the index is valid and the value at [index] == 9 set it as 0    
digits.set(index, 0);
//decement index by 1
index -= 1;
}
// if index < 0 (if all digits were 9)
if (index < 0)
{
//inserting 1 at the beginning of the vector 
digits.set(0, 1);
//adding an extra zero to the end of the vector 
digits.add(digits.size(),0);
}
//else increment the value at [index]
else
digits.set(index, digits.get(index) + 1);
}
//driver code
public static void main(String args[])
{
//creating an instance of the vector class and passing an array
Vector<Integer> digits = new Vector<Integer>(Arrays.asList(12, 45, 90, 34));
//function calling
plusOne(digits);
for (int digit : digits)
//prints the array after adding 1 to the array
System.out.print(digit + " ");
}
}
 Output: 12 45 90 35
 Let's see another approach. In this approach, first, we reverse the given array. After that take a carry variable to store the carry. Iterate over the array from starting and add 1. Carry to the value of that array at that index. Now check whether the value of that index is greater than equal to 9 or not. If yes, take the carry as the ten's value and the value at that index in the array will be the value present at the one place, else simply move on. 
if digits[i]>9 then carry = digits[i]/10 and digits[i]%=10
if digits[i]<=9 then carry = 0
 Repeat the above step until we reach the last element of the array. Note that if carry is not 0, simply add 1 to the array. At last, reverse the array, so that we can get the original array. Let's implement the above approach in a Java program. PlusOneExample2.java 
import java.io.*;
import java.util.*;
public class PlusOneExample2
{
//function to add one to the array    
public static void plusOne(Vector<Integer> digits, int n)
{
//revers the given array so that we can begin traversing from back
Collections.reverse(digits);
//defining a variable to store carry
int carry = 0;
for(int i = 0; i < n; i++)
{
//initially carry is 0, it is the base case
if(i == 0)
digits.set(i, digits.get(i) + 1 + carry);
//if carry is not equal to zero, add it to the array element at that position
else if(carry != 0)
digits.set(i, digits.get(i) + carry);
//now to get carry, i.e. if digits[i]>9 we get the value at tens place in carry or else if digits[i]<9 carry will be 0
carry = digits.get(i) / 10;
//now if carry is not equal to 0, so at that index, we should keep the value present at the ones place so we do digits[i]%10
if(carry != 0)digits.set(i, digits.get(i) % 10);
}
//after doing all that if carry is still there which means one more element is needed to be added to the array
if(carry != 0)
digits.set(digits.size() - 1, carry);
//again, revere the array so that we can get the original array
Collections.reverse(digits);
}
//driver code
public static void main (String args[])
{
//creating an instance of the vector class and passing an array
Vector<Integer> digits = new Vector<Integer>(Arrays.asList(9, 9, 9, 9, 9));
//determines the size of the array
int n = digits.size();
//function calling
plusOne(digits, n);
for(int i = 0; i < n; i++)
{
//prints the array after adding 1 to the array    
System.out.print(digits.get(i) + " ");
}
}
}
 Output: 1 0 0 0 0
 Complexity The time complexity of all the above approaches is O(n) because we have traversed over the array only once. Where n is the length of the array. The space complexity of the approach is O(1) if the array contains at least one digit smaller than 9, else O(n). Next TopicUnequal Adjacent Elements in Java ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/plus-one-to-array-problem-in-java Plus One to Array Problem in Java - Javatpoint ? SCROLL TO TOP Home Java Programs OOPs String Exception Multithreading Collections JavaFX JSP Spring Spring Boot Projects Interview Questions Java Tutorial What is Java History of Java Features of Java C++ vs Java Hello Java Program Program Internal How to set path? JDK, JRE and JVM JVM: Java Virtual Machine Java Variables Java Data Types Unicode System Operators Keywords Control Statements Java Control Statements Java If-else Java Switch Java For Loop Java While Loop Java Do While Loop Java Break Java Continue Java Comments Java Programs Java Object Class Java OOPs Concepts Naming Convention Object and Class Method Constructor static keyword this keyword Java Inheritance Inheritance(IS-A) Aggregation(HAS-A) Java Polymorphism Method Overloading Method Overriding Covariant Return Type super keyword Instance Initializer block final keyword Runtime Polymorphism Dynamic Binding instanceof operator Java Abstraction Abstract class Interface Abstract vs Interface Java Encapsulation Package Access Modifiers Encapsulation Java Array Java Array Java OOPs Misc Object class Object Cloning Math class Wrapper Class Java Recursion Call By Value strictfp keyword javadoc tool Command Line Arg Object vs Class Overloading vs Overriding Java String Java Regex Exception Handling Java Inner classes Java Multithreading Java I/O Java Networking Java AWT & Events Java Swing JavaFX Java Applet Java Reflection Java Date Java Conversion Java Collection Java JDBC Java Misc Java New Features RMI Internationalization Interview Questions Java MCQ next ? ? prev Plus One to Array Problem in Java It is a very interesting problem frequently asked in interviews of top IT companies like Google, Amazon, TCS, Accenture, Adobe, Apple, Infosys, etc. By solving the problem, one wants to check the logical ability, critical thinking, and problem-solving skill of the interviewee. So, in this section, we are going to add (plus) one to an array problem in Java with different approaches and logic. Also, we will create Java programs for the same. Problem Statement In this problem, we have given an array in which each element represents a digit and the complete array represents a number. The digits are ordered from MSB to LSB in left to right order. Assume that there is no leading 0's in the number. The task is to add 1 to the number and return the result in the form of an array of digits. Let's understand it through examples. Example Input: arr = [2, 5, 9, 7] Output: [2, 5, 9, 8] It represents the number 2597. Add 1 to the most significant bit, we get 2598. The output will be [2, 5, 9, 8]. Let's see another example. Input: arr = [9, 9] Output: [1, 0, 0] It represents the number 99. Add 1 to the most significant bit, we get 100. The output will be [1, 0, 0]. Solution to The Problem Naive Approach The simple approach is that first convert the array into a number, add one to it, and return the result in the form of an array. But the approach is not applicable to the large array. So, we will process each digit one by one. Begin from the least significant bit and process each digit till the most significant bit. If the current digit is smaller than 9, add 1 to the current digit and return the array else assign zero to the current digit. If the last element is processed and it was also equal to 9, it means that all the digits were 9. So, we will increase the size of the array by one and assign 1 to the MSB. Return the resultant array. Plus One to Array Java Program PlusOneArray.java 
import java.util.Arrays; 
public class PlusOneArray
{
//function to add 1 to the array
public static int[] plusOne(int[] digits) 
{
int n = digits.length;
for(int i=n-1; i>=0; i--) 
{
if(digits[i] < 9) 
{
digits[i]++; 
return digits;
}
digits[i] = 0;
}
int[] newNumber = new int [n+1];
newNumber[0] = 1;
return newNumber;
}
//driver code
public static void main(String args[]) 
{
int [] arr = {6, 3, 8, 2}; 
//function calling
int[]ans=plusOne(arr); 
//prints the resultant array after adding 1 to MSB
System.out.println(Arrays.toString(ans));
}
}
 Output: [6, 3, 8, 3]
 Using Vector Another approach is using the vector. In this approach, we begin from the end of the vector. If the last element is 9, set it to 0, else exit from the loop. If all digits are 9, set 1 at starting, else increment the element at the position where the loop stopped. Note that no carry, division, and modulo is required. Let's implement the above approach in a Java program. PlusOneExample1.java 
import java.io.*;
import java.util.*;
public class PlusOneExample1
{
//function to add one to the array
static void plusOne(Vector<Integer> digits)
{
//initialize an index (digit of units)
int index= digits.size() - 1;
while (index >= 0 && digits.get(index) == 9)
{
//while the index is valid and the value at [index] == 9 set it as 0    
digits.set(index, 0);
//decement index by 1
index -= 1;
}
// if index < 0 (if all digits were 9)
if (index < 0)
{
//inserting 1 at the beginning of the vector 
digits.set(0, 1);
//adding an extra zero to the end of the vector 
digits.add(digits.size(),0);
}
//else increment the value at [index]
else
digits.set(index, digits.get(index) + 1);
}
//driver code
public static void main(String args[])
{
//creating an instance of the vector class and passing an array
Vector<Integer> digits = new Vector<Integer>(Arrays.asList(12, 45, 90, 34));
//function calling
plusOne(digits);
for (int digit : digits)
//prints the array after adding 1 to the array
System.out.print(digit + " ");
}
}
 Output: 12 45 90 35
 Let's see another approach. In this approach, first, we reverse the given array. After that take a carry variable to store the carry. Iterate over the array from starting and add 1. Carry to the value of that array at that index. Now check whether the value of that index is greater than equal to 9 or not. If yes, take the carry as the ten's value and the value at that index in the array will be the value present at the one place, else simply move on. 
if digits[i]>9 then carry = digits[i]/10 and digits[i]%=10
if digits[i]<=9 then carry = 0
 Repeat the above step until we reach the last element of the array. Note that if carry is not 0, simply add 1 to the array. At last, reverse the array, so that we can get the original array. Let's implement the above approach in a Java program. PlusOneExample2.java 
import java.io.*;
import java.util.*;
public class PlusOneExample2
{
//function to add one to the array    
public static void plusOne(Vector<Integer> digits, int n)
{
//revers the given array so that we can begin traversing from back
Collections.reverse(digits);
//defining a variable to store carry
int carry = 0;
for(int i = 0; i < n; i++)
{
//initially carry is 0, it is the base case
if(i == 0)
digits.set(i, digits.get(i) + 1 + carry);
//if carry is not equal to zero, add it to the array element at that position
else if(carry != 0)
digits.set(i, digits.get(i) + carry);
//now to get carry, i.e. if digits[i]>9 we get the value at tens place in carry or else if digits[i]<9 carry will be 0
carry = digits.get(i) / 10;
//now if carry is not equal to 0, so at that index, we should keep the value present at the ones place so we do digits[i]%10
if(carry != 0)digits.set(i, digits.get(i) % 10);
}
//after doing all that if carry is still there which means one more element is needed to be added to the array
if(carry != 0)
digits.set(digits.size() - 1, carry);
//again, revere the array so that we can get the original array
Collections.reverse(digits);
}
//driver code
public static void main (String args[])
{
//creating an instance of the vector class and passing an array
Vector<Integer> digits = new Vector<Integer>(Arrays.asList(9, 9, 9, 9, 9));
//determines the size of the array
int n = digits.size();
//function calling
plusOne(digits, n);
for(int i = 0; i < n; i++)
{
//prints the array after adding 1 to the array    
System.out.print(digits.get(i) + " ");
}
}
}
 Output: 1 0 0 0 0
 Complexity The time complexity of all the above approaches is O(n) because we have traversed over the array only once. Where n is the length of the array. The space complexity of the approach is O(1) if the array contains at least one digit smaller than 9, else O(n). Next TopicUnequal Adjacent Elements in Java ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/plus-one-to-array-problem-in-java Plus One to Array Problem in Java - Javatpoint ? SCROLL TO TOP Home Java Programs OOPs String Exception Multithreading Collections JavaFX JSP Spring Spring Boot Projects Interview Questions Java Tutorial What is Java History of Java Features of Java C++ vs Java Hello Java Program Program Internal How to set path? JDK, JRE and JVM JVM: Java Virtual Machine Java Variables Java Data Types Unicode System Operators Keywords Control Statements Java Control Statements Java If-else Java Switch Java For Loop Java While Loop Java Do While Loop Java Break Java Continue Java Comments Java Programs Java Object Class Java OOPs Concepts Naming Convention Object and Class Method Constructor static keyword this keyword Java Inheritance Inheritance(IS-A) Aggregation(HAS-A) Java Polymorphism Method Overloading Method Overriding Covariant Return Type super keyword Instance Initializer block final keyword Runtime Polymorphism Dynamic Binding instanceof operator Java Abstraction Abstract class Interface Abstract vs Interface Java Encapsulation Package Access Modifiers Encapsulation Java Array Java Array Java OOPs Misc Object class Object Cloning Math class Wrapper Class Java Recursion Call By Value strictfp keyword javadoc tool Command Line Arg Object vs Class Overloading vs Overriding Java String Java Regex Exception Handling Java Inner classes Java Multithreading Java I/O Java Networking Java AWT & Events Java Swing JavaFX Java Applet Java Reflection Java Date Java Conversion Java Collection Java JDBC Java Misc Java New Features RMI Internationalization Interview Questions Java MCQ next ? ? prev Plus One to Array Problem in Java It is a very interesting problem frequently asked in interviews of top IT companies like Google, Amazon, TCS, Accenture, Adobe, Apple, Infosys, etc. By solving the problem, one wants to check the logical ability, critical thinking, and problem-solving skill of the interviewee. So, in this section, we are going to add (plus) one to an array problem in Java with different approaches and logic. Also, we will create Java programs for the same. Problem Statement In this problem, we have given an array in which each element represents a digit and the complete array represents a number. The digits are ordered from MSB to LSB in left to right order. Assume that there is no leading 0's in the number. The task is to add 1 to the number and return the result in the form of an array of digits. Let's understand it through examples. Example Input: arr = [2, 5, 9, 7] Output: [2, 5, 9, 8] It represents the number 2597. Add 1 to the most significant bit, we get 2598. The output will be [2, 5, 9, 8]. Let's see another example. Input: arr = [9, 9] Output: [1, 0, 0] It represents the number 99. Add 1 to the most significant bit, we get 100. The output will be [1, 0, 0]. Solution to The Problem Naive Approach The simple approach is that first convert the array into a number, add one to it, and return the result in the form of an array. But the approach is not applicable to the large array. So, we will process each digit one by one. Begin from the least significant bit and process each digit till the most significant bit. If the current digit is smaller than 9, add 1 to the current digit and return the array else assign zero to the current digit. If the last element is processed and it was also equal to 9, it means that all the digits were 9. So, we will increase the size of the array by one and assign 1 to the MSB. Return the resultant array. Plus One to Array Java Program PlusOneArray.java 
import java.util.Arrays; 
public class PlusOneArray
{
//function to add 1 to the array
public static int[] plusOne(int[] digits) 
{
int n = digits.length;
for(int i=n-1; i>=0; i--) 
{
if(digits[i] < 9) 
{
digits[i]++; 
return digits;
}
digits[i] = 0;
}
int[] newNumber = new int [n+1];
newNumber[0] = 1;
return newNumber;
}
//driver code
public static void main(String args[]) 
{
int [] arr = {6, 3, 8, 2}; 
//function calling
int[]ans=plusOne(arr); 
//prints the resultant array after adding 1 to MSB
System.out.println(Arrays.toString(ans));
}
}
 Output: [6, 3, 8, 3]
 Using Vector Another approach is using the vector. In this approach, we begin from the end of the vector. If the last element is 9, set it to 0, else exit from the loop. If all digits are 9, set 1 at starting, else increment the element at the position where the loop stopped. Note that no carry, division, and modulo is required. Let's implement the above approach in a Java program. PlusOneExample1.java 
import java.io.*;
import java.util.*;
public class PlusOneExample1
{
//function to add one to the array
static void plusOne(Vector<Integer> digits)
{
//initialize an index (digit of units)
int index= digits.size() - 1;
while (index >= 0 && digits.get(index) == 9)
{
//while the index is valid and the value at [index] == 9 set it as 0    
digits.set(index, 0);
//decement index by 1
index -= 1;
}
// if index < 0 (if all digits were 9)
if (index < 0)
{
//inserting 1 at the beginning of the vector 
digits.set(0, 1);
//adding an extra zero to the end of the vector 
digits.add(digits.size(),0);
}
//else increment the value at [index]
else
digits.set(index, digits.get(index) + 1);
}
//driver code
public static void main(String args[])
{
//creating an instance of the vector class and passing an array
Vector<Integer> digits = new Vector<Integer>(Arrays.asList(12, 45, 90, 34));
//function calling
plusOne(digits);
for (int digit : digits)
//prints the array after adding 1 to the array
System.out.print(digit + " ");
}
}
 Output: 12 45 90 35
 Let's see another approach. In this approach, first, we reverse the given array. After that take a carry variable to store the carry. Iterate over the array from starting and add 1. Carry to the value of that array at that index. Now check whether the value of that index is greater than equal to 9 or not. If yes, take the carry as the ten's value and the value at that index in the array will be the value present at the one place, else simply move on. 
if digits[i]>9 then carry = digits[i]/10 and digits[i]%=10
if digits[i]<=9 then carry = 0
 Repeat the above step until we reach the last element of the array. Note that if carry is not 0, simply add 1 to the array. At last, reverse the array, so that we can get the original array. Let's implement the above approach in a Java program. PlusOneExample2.java 
import java.io.*;
import java.util.*;
public class PlusOneExample2
{
//function to add one to the array    
public static void plusOne(Vector<Integer> digits, int n)
{
//revers the given array so that we can begin traversing from back
Collections.reverse(digits);
//defining a variable to store carry
int carry = 0;
for(int i = 0; i < n; i++)
{
//initially carry is 0, it is the base case
if(i == 0)
digits.set(i, digits.get(i) + 1 + carry);
//if carry is not equal to zero, add it to the array element at that position
else if(carry != 0)
digits.set(i, digits.get(i) + carry);
//now to get carry, i.e. if digits[i]>9 we get the value at tens place in carry or else if digits[i]<9 carry will be 0
carry = digits.get(i) / 10;
//now if carry is not equal to 0, so at that index, we should keep the value present at the ones place so we do digits[i]%10
if(carry != 0)digits.set(i, digits.get(i) % 10);
}
//after doing all that if carry is still there which means one more element is needed to be added to the array
if(carry != 0)
digits.set(digits.size() - 1, carry);
//again, revere the array so that we can get the original array
Collections.reverse(digits);
}
//driver code
public static void main (String args[])
{
//creating an instance of the vector class and passing an array
Vector<Integer> digits = new Vector<Integer>(Arrays.asList(9, 9, 9, 9, 9));
//determines the size of the array
int n = digits.size();
//function calling
plusOne(digits, n);
for(int i = 0; i < n; i++)
{
//prints the array after adding 1 to the array    
System.out.print(digits.get(i) + " ");
}
}
}
 Output: 1 0 0 0 0
 Complexity The time complexity of all the above approaches is O(n) because we have traversed over the array only once. Where n is the length of the array. The space complexity of the approach is O(1) if the array contains at least one digit smaller than 9, else O(n). Next TopicUnequal Adjacent Elements in Java ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/plus-one-to-array-problem-in-java Plus One to Array Problem in Java - Javatpoint ? SCROLL TO TOP Home Java Programs OOPs String Exception Multithreading Collections JavaFX JSP Spring Spring Boot Projects Interview Questions Java Tutorial What is Java History of Java Features of Java C++ vs Java Hello Java Program Program Internal How to set path? JDK, JRE and JVM JVM: Java Virtual Machine Java Variables Java Data Types Unicode System Operators Keywords Control Statements Java Control Statements Java If-else Java Switch Java For Loop Java While Loop Java Do While Loop Java Break Java Continue Java Comments Java Programs Java Object Class Java OOPs Concepts Naming Convention Object and Class Method Constructor static keyword this keyword Java Inheritance Inheritance(IS-A) Aggregation(HAS-A) Java Polymorphism Method Overloading Method Overriding Covariant Return Type super keyword Instance Initializer block final keyword Runtime Polymorphism Dynamic Binding instanceof operator Java Abstraction Abstract class Interface Abstract vs Interface Java Encapsulation Package Access Modifiers Encapsulation Java Array Java Array Java OOPs Misc Object class Object Cloning Math class Wrapper Class Java Recursion Call By Value strictfp keyword javadoc tool Command Line Arg Object vs Class Overloading vs Overriding Java String Java Regex Exception Handling Java Inner classes Java Multithreading Java I/O Java Networking Java AWT & Events Java Swing JavaFX Java Applet Java Reflection Java Date Java Conversion Java Collection Java JDBC Java Misc Java New Features RMI Internationalization Interview Questions Java MCQ next ? ? prev Plus One to Array Problem in Java It is a very interesting problem frequently asked in interviews of top IT companies like Google, Amazon, TCS, Accenture, Adobe, Apple, Infosys, etc. By solving the problem, one wants to check the logical ability, critical thinking, and problem-solving skill of the interviewee. So, in this section, we are going to add (plus) one to an array problem in Java with different approaches and logic. Also, we will create Java programs for the same. Problem Statement In this problem, we have given an array in which each element represents a digit and the complete array represents a number. The digits are ordered from MSB to LSB in left to right order. Assume that there is no leading 0's in the number. The task is to add 1 to the number and return the result in the form of an array of digits. Let's understand it through examples. Example Input: arr = [2, 5, 9, 7] Output: [2, 5, 9, 8] It represents the number 2597. Add 1 to the most significant bit, we get 2598. The output will be [2, 5, 9, 8]. Let's see another example. Input: arr = [9, 9] Output: [1, 0, 0] It represents the number 99. Add 1 to the most significant bit, we get 100. The output will be [1, 0, 0]. Solution to The Problem Naive Approach The simple approach is that first convert the array into a number, add one to it, and return the result in the form of an array. But the approach is not applicable to the large array. So, we will process each digit one by one. Begin from the least significant bit and process each digit till the most significant bit. If the current digit is smaller than 9, add 1 to the current digit and return the array else assign zero to the current digit. If the last element is processed and it was also equal to 9, it means that all the digits were 9. So, we will increase the size of the array by one and assign 1 to the MSB. Return the resultant array. Plus One to Array Java Program PlusOneArray.java 
import java.util.Arrays; 
public class PlusOneArray
{
//function to add 1 to the array
public static int[] plusOne(int[] digits) 
{
int n = digits.length;
for(int i=n-1; i>=0; i--) 
{
if(digits[i] < 9) 
{
digits[i]++; 
return digits;
}
digits[i] = 0;
}
int[] newNumber = new int [n+1];
newNumber[0] = 1;
return newNumber;
}
//driver code
public static void main(String args[]) 
{
int [] arr = {6, 3, 8, 2}; 
//function calling
int[]ans=plusOne(arr); 
//prints the resultant array after adding 1 to MSB
System.out.println(Arrays.toString(ans));
}
}
 Output: [6, 3, 8, 3]
 Using Vector Another approach is using the vector. In this approach, we begin from the end of the vector. If the last element is 9, set it to 0, else exit from the loop. If all digits are 9, set 1 at starting, else increment the element at the position where the loop stopped. Note that no carry, division, and modulo is required. Let's implement the above approach in a Java program. PlusOneExample1.java 
import java.io.*;
import java.util.*;
public class PlusOneExample1
{
//function to add one to the array
static void plusOne(Vector<Integer> digits)
{
//initialize an index (digit of units)
int index= digits.size() - 1;
while (index >= 0 && digits.get(index) == 9)
{
//while the index is valid and the value at [index] == 9 set it as 0    
digits.set(index, 0);
//decement index by 1
index -= 1;
}
// if index < 0 (if all digits were 9)
if (index < 0)
{
//inserting 1 at the beginning of the vector 
digits.set(0, 1);
//adding an extra zero to the end of the vector 
digits.add(digits.size(),0);
}
//else increment the value at [index]
else
digits.set(index, digits.get(index) + 1);
}
//driver code
public static void main(String args[])
{
//creating an instance of the vector class and passing an array
Vector<Integer> digits = new Vector<Integer>(Arrays.asList(12, 45, 90, 34));
//function calling
plusOne(digits);
for (int digit : digits)
//prints the array after adding 1 to the array
System.out.print(digit + " ");
}
}
 Output: 12 45 90 35
 Let's see another approach. In this approach, first, we reverse the given array. After that take a carry variable to store the carry. Iterate over the array from starting and add 1. Carry to the value of that array at that index. Now check whether the value of that index is greater than equal to 9 or not. If yes, take the carry as the ten's value and the value at that index in the array will be the value present at the one place, else simply move on. 
if digits[i]>9 then carry = digits[i]/10 and digits[i]%=10
if digits[i]<=9 then carry = 0
 Repeat the above step until we reach the last element of the array. Note that if carry is not 0, simply add 1 to the array. At last, reverse the array, so that we can get the original array. Let's implement the above approach in a Java program. PlusOneExample2.java 
import java.io.*;
import java.util.*;
public class PlusOneExample2
{
//function to add one to the array    
public static void plusOne(Vector<Integer> digits, int n)
{
//revers the given array so that we can begin traversing from back
Collections.reverse(digits);
//defining a variable to store carry
int carry = 0;
for(int i = 0; i < n; i++)
{
//initially carry is 0, it is the base case
if(i == 0)
digits.set(i, digits.get(i) + 1 + carry);
//if carry is not equal to zero, add it to the array element at that position
else if(carry != 0)
digits.set(i, digits.get(i) + carry);
//now to get carry, i.e. if digits[i]>9 we get the value at tens place in carry or else if digits[i]<9 carry will be 0
carry = digits.get(i) / 10;
//now if carry is not equal to 0, so at that index, we should keep the value present at the ones place so we do digits[i]%10
if(carry != 0)digits.set(i, digits.get(i) % 10);
}
//after doing all that if carry is still there which means one more element is needed to be added to the array
if(carry != 0)
digits.set(digits.size() - 1, carry);
//again, revere the array so that we can get the original array
Collections.reverse(digits);
}
//driver code
public static void main (String args[])
{
//creating an instance of the vector class and passing an array
Vector<Integer> digits = new Vector<Integer>(Arrays.asList(9, 9, 9, 9, 9));
//determines the size of the array
int n = digits.size();
//function calling
plusOne(digits, n);
for(int i = 0; i < n; i++)
{
//prints the array after adding 1 to the array    
System.out.print(digits.get(i) + " ");
}
}
}
 Output: 1 0 0 0 0
 Complexity The time complexity of all the above approaches is O(n) because we have traversed over the array only once. Where n is the length of the array. The space complexity of the approach is O(1) if the array contains at least one digit smaller than 9, else O(n). Next TopicUnequal Adjacent Elements in Java ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/plus-one-to-array-problem-in-java Plus One to Array Problem in Java - Javatpoint ? SCROLL TO TOP Home Java Programs OOPs String Exception Multithreading Collections JavaFX JSP Spring Spring Boot Projects Interview Questions Java Tutorial What is Java History of Java Features of Java C++ vs Java Hello Java Program Program Internal How to set path? JDK, JRE and JVM JVM: Java Virtual Machine Java Variables Java Data Types Unicode System Operators Keywords Control Statements Java Control Statements Java If-else Java Switch Java For Loop Java While Loop Java Do While Loop Java Break Java Continue Java Comments Java Programs Java Object Class Java OOPs Concepts Naming Convention Object and Class Method Constructor static keyword this keyword Java Inheritance Inheritance(IS-A) Aggregation(HAS-A) Java Polymorphism Method Overloading Method Overriding Covariant Return Type super keyword Instance Initializer block final keyword Runtime Polymorphism Dynamic Binding instanceof operator Java Abstraction Abstract class Interface Abstract vs Interface Java Encapsulation Package Access Modifiers Encapsulation Java Array Java Array Java OOPs Misc Object class Object Cloning Math class Wrapper Class Java Recursion Call By Value strictfp keyword javadoc tool Command Line Arg Object vs Class Overloading vs Overriding Java String Java Regex Exception Handling Java Inner classes Java Multithreading Java I/O Java Networking Java AWT & Events Java Swing JavaFX Java Applet Java Reflection Java Date Java Conversion Java Collection Java JDBC Java Misc Java New Features RMI Internationalization Interview Questions Java MCQ next ? ? prev Plus One to Array Problem in Java It is a very interesting problem frequently asked in interviews of top IT companies like Google, Amazon, TCS, Accenture, Adobe, Apple, Infosys, etc. By solving the problem, one wants to check the logical ability, critical thinking, and problem-solving skill of the interviewee. So, in this section, we are going to add (plus) one to an array problem in Java with different approaches and logic. Also, we will create Java programs for the same. Problem Statement In this problem, we have given an array in which each element represents a digit and the complete array represents a number. The digits are ordered from MSB to LSB in left to right order. Assume that there is no leading 0's in the number. The task is to add 1 to the number and return the result in the form of an array of digits. Let's understand it through examples. Example Input: arr = [2, 5, 9, 7] Output: [2, 5, 9, 8] It represents the number 2597. Add 1 to the most significant bit, we get 2598. The output will be [2, 5, 9, 8]. Let's see another example. Input: arr = [9, 9] Output: [1, 0, 0] It represents the number 99. Add 1 to the most significant bit, we get 100. The output will be [1, 0, 0]. Solution to The Problem Naive Approach The simple approach is that first convert the array into a number, add one to it, and return the result in the form of an array. But the approach is not applicable to the large array. So, we will process each digit one by one. Begin from the least significant bit and process each digit till the most significant bit. If the current digit is smaller than 9, add 1 to the current digit and return the array else assign zero to the current digit. If the last element is processed and it was also equal to 9, it means that all the digits were 9. So, we will increase the size of the array by one and assign 1 to the MSB. Return the resultant array. Plus One to Array Java Program PlusOneArray.java 
import java.util.Arrays; 
public class PlusOneArray
{
//function to add 1 to the array
public static int[] plusOne(int[] digits) 
{
int n = digits.length;
for(int i=n-1; i>=0; i--) 
{
if(digits[i] < 9) 
{
digits[i]++; 
return digits;
}
digits[i] = 0;
}
int[] newNumber = new int [n+1];
newNumber[0] = 1;
return newNumber;
}
//driver code
public static void main(String args[]) 
{
int [] arr = {6, 3, 8, 2}; 
//function calling
int[]ans=plusOne(arr); 
//prints the resultant array after adding 1 to MSB
System.out.println(Arrays.toString(ans));
}
}
 Output: [6, 3, 8, 3]
 Using Vector Another approach is using the vector. In this approach, we begin from the end of the vector. If the last element is 9, set it to 0, else exit from the loop. If all digits are 9, set 1 at starting, else increment the element at the position where the loop stopped. Note that no carry, division, and modulo is required. Let's implement the above approach in a Java program. PlusOneExample1.java 
import java.io.*;
import java.util.*;
public class PlusOneExample1
{
//function to add one to the array
static void plusOne(Vector<Integer> digits)
{
//initialize an index (digit of units)
int index= digits.size() - 1;
while (index >= 0 && digits.get(index) == 9)
{
//while the index is valid and the value at [index] == 9 set it as 0    
digits.set(index, 0);
//decement index by 1
index -= 1;
}
// if index < 0 (if all digits were 9)
if (index < 0)
{
//inserting 1 at the beginning of the vector 
digits.set(0, 1);
//adding an extra zero to the end of the vector 
digits.add(digits.size(),0);
}
//else increment the value at [index]
else
digits.set(index, digits.get(index) + 1);
}
//driver code
public static void main(String args[])
{
//creating an instance of the vector class and passing an array
Vector<Integer> digits = new Vector<Integer>(Arrays.asList(12, 45, 90, 34));
//function calling
plusOne(digits);
for (int digit : digits)
//prints the array after adding 1 to the array
System.out.print(digit + " ");
}
}
 Output: 12 45 90 35
 Let's see another approach. In this approach, first, we reverse the given array. After that take a carry variable to store the carry. Iterate over the array from starting and add 1. Carry to the value of that array at that index. Now check whether the value of that index is greater than equal to 9 or not. If yes, take the carry as the ten's value and the value at that index in the array will be the value present at the one place, else simply move on. 
if digits[i]>9 then carry = digits[i]/10 and digits[i]%=10
if digits[i]<=9 then carry = 0
 Repeat the above step until we reach the last element of the array. Note that if carry is not 0, simply add 1 to the array. At last, reverse the array, so that we can get the original array. Let's implement the above approach in a Java program. PlusOneExample2.java 
import java.io.*;
import java.util.*;
public class PlusOneExample2
{
//function to add one to the array    
public static void plusOne(Vector<Integer> digits, int n)
{
//revers the given array so that we can begin traversing from back
Collections.reverse(digits);
//defining a variable to store carry
int carry = 0;
for(int i = 0; i < n; i++)
{
//initially carry is 0, it is the base case
if(i == 0)
digits.set(i, digits.get(i) + 1 + carry);
//if carry is not equal to zero, add it to the array element at that position
else if(carry != 0)
digits.set(i, digits.get(i) + carry);
//now to get carry, i.e. if digits[i]>9 we get the value at tens place in carry or else if digits[i]<9 carry will be 0
carry = digits.get(i) / 10;
//now if carry is not equal to 0, so at that index, we should keep the value present at the ones place so we do digits[i]%10
if(carry != 0)digits.set(i, digits.get(i) % 10);
}
//after doing all that if carry is still there which means one more element is needed to be added to the array
if(carry != 0)
digits.set(digits.size() - 1, carry);
//again, revere the array so that we can get the original array
Collections.reverse(digits);
}
//driver code
public static void main (String args[])
{
//creating an instance of the vector class and passing an array
Vector<Integer> digits = new Vector<Integer>(Arrays.asList(9, 9, 9, 9, 9));
//determines the size of the array
int n = digits.size();
//function calling
plusOne(digits, n);
for(int i = 0; i < n; i++)
{
//prints the array after adding 1 to the array    
System.out.print(digits.get(i) + " ");
}
}
}
 Output: 1 0 0 0 0
 Complexity The time complexity of all the above approaches is O(n) because we have traversed over the array only once. Where n is the length of the array. The space complexity of the approach is O(1) if the array contains at least one digit smaller than 9, else O(n). Next TopicUnequal Adjacent Elements in Java ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/plus-one-to-array-problem-in-java Plus One to Array Problem in Java - Javatpoint ? SCROLL TO TOP Home Java Programs OOPs String Exception Multithreading Collections JavaFX JSP Spring Spring Boot Projects Interview Questions Java Tutorial What is Java History of Java Features of Java C++ vs Java Hello Java Program Program Internal How to set path? JDK, JRE and JVM JVM: Java Virtual Machine Java Variables Java Data Types Unicode System Operators Keywords Control Statements Java Control Statements Java If-else Java Switch Java For Loop Java While Loop Java Do While Loop Java Break Java Continue Java Comments Java Programs Java Object Class Java OOPs Concepts Naming Convention Object and Class Method Constructor static keyword this keyword Java Inheritance Inheritance(IS-A) Aggregation(HAS-A) Java Polymorphism Method Overloading Method Overriding Covariant Return Type super keyword Instance Initializer block final keyword Runtime Polymorphism Dynamic Binding instanceof operator Java Abstraction Abstract class Interface Abstract vs Interface Java Encapsulation Package Access Modifiers Encapsulation Java Array Java Array Java OOPs Misc Object class Object Cloning Math class Wrapper Class Java Recursion Call By Value strictfp keyword javadoc tool Command Line Arg Object vs Class Overloading vs Overriding Java String Java Regex Exception Handling Java Inner classes Java Multithreading Java I/O Java Networking Java AWT & Events Java Swing JavaFX Java Applet Java Reflection Java Date Java Conversion Java Collection Java JDBC Java Misc Java New Features RMI Internationalization Interview Questions Java MCQ next ? ? prev Plus One to Array Problem in Java It is a very interesting problem frequently asked in interviews of top IT companies like Google, Amazon, TCS, Accenture, Adobe, Apple, Infosys, etc. By solving the problem, one wants to check the logical ability, critical thinking, and problem-solving skill of the interviewee. So, in this section, we are going to add (plus) one to an array problem in Java with different approaches and logic. Also, we will create Java programs for the same. Problem Statement In this problem, we have given an array in which each element represents a digit and the complete array represents a number. The digits are ordered from MSB to LSB in left to right order. Assume that there is no leading 0's in the number. The task is to add 1 to the number and return the result in the form of an array of digits. Let's understand it through examples. Example Input: arr = [2, 5, 9, 7] Output: [2, 5, 9, 8] It represents the number 2597. Add 1 to the most significant bit, we get 2598. The output will be [2, 5, 9, 8]. Let's see another example. Input: arr = [9, 9] Output: [1, 0, 0] It represents the number 99. Add 1 to the most significant bit, we get 100. The output will be [1, 0, 0]. Solution to The Problem Naive Approach The simple approach is that first convert the array into a number, add one to it, and return the result in the form of an array. But the approach is not applicable to the large array. So, we will process each digit one by one. Begin from the least significant bit and process each digit till the most significant bit. If the current digit is smaller than 9, add 1 to the current digit and return the array else assign zero to the current digit. If the last element is processed and it was also equal to 9, it means that all the digits were 9. So, we will increase the size of the array by one and assign 1 to the MSB. Return the resultant array. Plus One to Array Java Program PlusOneArray.java 
import java.util.Arrays; 
public class PlusOneArray
{
//function to add 1 to the array
public static int[] plusOne(int[] digits) 
{
int n = digits.length;
for(int i=n-1; i>=0; i--) 
{
if(digits[i] < 9) 
{
digits[i]++; 
return digits;
}
digits[i] = 0;
}
int[] newNumber = new int [n+1];
newNumber[0] = 1;
return newNumber;
}
//driver code
public static void main(String args[]) 
{
int [] arr = {6, 3, 8, 2}; 
//function calling
int[]ans=plusOne(arr); 
//prints the resultant array after adding 1 to MSB
System.out.println(Arrays.toString(ans));
}
}
 Output: [6, 3, 8, 3]
 Using Vector Another approach is using the vector. In this approach, we begin from the end of the vector. If the last element is 9, set it to 0, else exit from the loop. If all digits are 9, set 1 at starting, else increment the element at the position where the loop stopped. Note that no carry, division, and modulo is required. Let's implement the above approach in a Java program. PlusOneExample1.java 
import java.io.*;
import java.util.*;
public class PlusOneExample1
{
//function to add one to the array
static void plusOne(Vector<Integer> digits)
{
//initialize an index (digit of units)
int index= digits.size() - 1;
while (index >= 0 && digits.get(index) == 9)
{
//while the index is valid and the value at [index] == 9 set it as 0    
digits.set(index, 0);
//decement index by 1
index -= 1;
}
// if index < 0 (if all digits were 9)
if (index < 0)
{
//inserting 1 at the beginning of the vector 
digits.set(0, 1);
//adding an extra zero to the end of the vector 
digits.add(digits.size(),0);
}
//else increment the value at [index]
else
digits.set(index, digits.get(index) + 1);
}
//driver code
public static void main(String args[])
{
//creating an instance of the vector class and passing an array
Vector<Integer> digits = new Vector<Integer>(Arrays.asList(12, 45, 90, 34));
//function calling
plusOne(digits);
for (int digit : digits)
//prints the array after adding 1 to the array
System.out.print(digit + " ");
}
}
 Output: 12 45 90 35
 Let's see another approach. In this approach, first, we reverse the given array. After that take a carry variable to store the carry. Iterate over the array from starting and add 1. Carry to the value of that array at that index. Now check whether the value of that index is greater than equal to 9 or not. If yes, take the carry as the ten's value and the value at that index in the array will be the value present at the one place, else simply move on. 
if digits[i]>9 then carry = digits[i]/10 and digits[i]%=10
if digits[i]<=9 then carry = 0
 Repeat the above step until we reach the last element of the array. Note that if carry is not 0, simply add 1 to the array. At last, reverse the array, so that we can get the original array. Let's implement the above approach in a Java program. PlusOneExample2.java 
import java.io.*;
import java.util.*;
public class PlusOneExample2
{
//function to add one to the array    
public static void plusOne(Vector<Integer> digits, int n)
{
//revers the given array so that we can begin traversing from back
Collections.reverse(digits);
//defining a variable to store carry
int carry = 0;
for(int i = 0; i < n; i++)
{
//initially carry is 0, it is the base case
if(i == 0)
digits.set(i, digits.get(i) + 1 + carry);
//if carry is not equal to zero, add it to the array element at that position
else if(carry != 0)
digits.set(i, digits.get(i) + carry);
//now to get carry, i.e. if digits[i]>9 we get the value at tens place in carry or else if digits[i]<9 carry will be 0
carry = digits.get(i) / 10;
//now if carry is not equal to 0, so at that index, we should keep the value present at the ones place so we do digits[i]%10
if(carry != 0)digits.set(i, digits.get(i) % 10);
}
//after doing all that if carry is still there which means one more element is needed to be added to the array
if(carry != 0)
digits.set(digits.size() - 1, carry);
//again, revere the array so that we can get the original array
Collections.reverse(digits);
}
//driver code
public static void main (String args[])
{
//creating an instance of the vector class and passing an array
Vector<Integer> digits = new Vector<Integer>(Arrays.asList(9, 9, 9, 9, 9));
//determines the size of the array
int n = digits.size();
//function calling
plusOne(digits, n);
for(int i = 0; i < n; i++)
{
//prints the array after adding 1 to the array    
System.out.print(digits.get(i) + " ");
}
}
}
 Output: 1 0 0 0 0
 Complexity The time complexity of all the above approaches is O(n) because we have traversed over the array only once. Where n is the length of the array. The space complexity of the approach is O(1) if the array contains at least one digit smaller than 9, else O(n). Next TopicUnequal Adjacent Elements in Java ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/plus-one-to-array-problem-in-java Plus One to Array Problem in Java - Javatpoint ? SCROLL TO TOP Home Java Programs OOPs String Exception Multithreading Collections JavaFX JSP Spring Spring Boot Projects Interview Questions Java Tutorial What is Java History of Java Features of Java C++ vs Java Hello Java Program Program Internal How to set path? JDK, JRE and JVM JVM: Java Virtual Machine Java Variables Java Data Types Unicode System Operators Keywords Control Statements Java Control Statements Java If-else Java Switch Java For Loop Java While Loop Java Do While Loop Java Break Java Continue Java Comments Java Programs Java Object Class Java OOPs Concepts Naming Convention Object and Class Method Constructor static keyword this keyword Java Inheritance Inheritance(IS-A) Aggregation(HAS-A) Java Polymorphism Method Overloading Method Overriding Covariant Return Type super keyword Instance Initializer block final keyword Runtime Polymorphism Dynamic Binding instanceof operator Java Abstraction Abstract class Interface Abstract vs Interface Java Encapsulation Package Access Modifiers Encapsulation Java Array Java Array Java OOPs Misc Object class Object Cloning Math class Wrapper Class Java Recursion Call By Value strictfp keyword javadoc tool Command Line Arg Object vs Class Overloading vs Overriding Java String Java Regex Exception Handling Java Inner classes Java Multithreading Java I/O Java Networking Java AWT & Events Java Swing JavaFX Java Applet Java Reflection Java Date Java Conversion Java Collection Java JDBC Java Misc Java New Features RMI Internationalization Interview Questions Java MCQ next ? ? prev Plus One to Array Problem in Java It is a very interesting problem frequently asked in interviews of top IT companies like Google, Amazon, TCS, Accenture, Adobe, Apple, Infosys, etc. By solving the problem, one wants to check the logical ability, critical thinking, and problem-solving skill of the interviewee. So, in this section, we are going to add (plus) one to an array problem in Java with different approaches and logic. Also, we will create Java programs for the same. Problem Statement In this problem, we have given an array in which each element represents a digit and the complete array represents a number. The digits are ordered from MSB to LSB in left to right order. Assume that there is no leading 0's in the number. The task is to add 1 to the number and return the result in the form of an array of digits. Let's understand it through examples. Example Input: arr = [2, 5, 9, 7] Output: [2, 5, 9, 8] It represents the number 2597. Add 1 to the most significant bit, we get 2598. The output will be [2, 5, 9, 8]. Let's see another example. Input: arr = [9, 9] Output: [1, 0, 0] It represents the number 99. Add 1 to the most significant bit, we get 100. The output will be [1, 0, 0]. Solution to The Problem Naive Approach The simple approach is that first convert the array into a number, add one to it, and return the result in the form of an array. But the approach is not applicable to the large array. So, we will process each digit one by one. Begin from the least significant bit and process each digit till the most significant bit. If the current digit is smaller than 9, add 1 to the current digit and return the array else assign zero to the current digit. If the last element is processed and it was also equal to 9, it means that all the digits were 9. So, we will increase the size of the array by one and assign 1 to the MSB. Return the resultant array. Plus One to Array Java Program PlusOneArray.java 
import java.util.Arrays; 
public class PlusOneArray
{
//function to add 1 to the array
public static int[] plusOne(int[] digits) 
{
int n = digits.length;
for(int i=n-1; i>=0; i--) 
{
if(digits[i] < 9) 
{
digits[i]++; 
return digits;
}
digits[i] = 0;
}
int[] newNumber = new int [n+1];
newNumber[0] = 1;
return newNumber;
}
//driver code
public static void main(String args[]) 
{
int [] arr = {6, 3, 8, 2}; 
//function calling
int[]ans=plusOne(arr); 
//prints the resultant array after adding 1 to MSB
System.out.println(Arrays.toString(ans));
}
}
 Output: [6, 3, 8, 3]
 Using Vector Another approach is using the vector. In this approach, we begin from the end of the vector. If the last element is 9, set it to 0, else exit from the loop. If all digits are 9, set 1 at starting, else increment the element at the position where the loop stopped. Note that no carry, division, and modulo is required. Let's implement the above approach in a Java program. PlusOneExample1.java 
import java.io.*;
import java.util.*;
public class PlusOneExample1
{
//function to add one to the array
static void plusOne(Vector<Integer> digits)
{
//initialize an index (digit of units)
int index= digits.size() - 1;
while (index >= 0 && digits.get(index) == 9)
{
//while the index is valid and the value at [index] == 9 set it as 0    
digits.set(index, 0);
//decement index by 1
index -= 1;
}
// if index < 0 (if all digits were 9)
if (index < 0)
{
//inserting 1 at the beginning of the vector 
digits.set(0, 1);
//adding an extra zero to the end of the vector 
digits.add(digits.size(),0);
}
//else increment the value at [index]
else
digits.set(index, digits.get(index) + 1);
}
//driver code
public static void main(String args[])
{
//creating an instance of the vector class and passing an array
Vector<Integer> digits = new Vector<Integer>(Arrays.asList(12, 45, 90, 34));
//function calling
plusOne(digits);
for (int digit : digits)
//prints the array after adding 1 to the array
System.out.print(digit + " ");
}
}
 Output: 12 45 90 35
 Let's see another approach. In this approach, first, we reverse the given array. After that take a carry variable to store the carry. Iterate over the array from starting and add 1. Carry to the value of that array at that index. Now check whether the value of that index is greater than equal to 9 or not. If yes, take the carry as the ten's value and the value at that index in the array will be the value present at the one place, else simply move on. 
if digits[i]>9 then carry = digits[i]/10 and digits[i]%=10
if digits[i]<=9 then carry = 0
 Repeat the above step until we reach the last element of the array. Note that if carry is not 0, simply add 1 to the array. At last, reverse the array, so that we can get the original array. Let's implement the above approach in a Java program. PlusOneExample2.java 
import java.io.*;
import java.util.*;
public class PlusOneExample2
{
//function to add one to the array    
public static void plusOne(Vector<Integer> digits, int n)
{
//revers the given array so that we can begin traversing from back
Collections.reverse(digits);
//defining a variable to store carry
int carry = 0;
for(int i = 0; i < n; i++)
{
//initially carry is 0, it is the base case
if(i == 0)
digits.set(i, digits.get(i) + 1 + carry);
//if carry is not equal to zero, add it to the array element at that position
else if(carry != 0)
digits.set(i, digits.get(i) + carry);
//now to get carry, i.e. if digits[i]>9 we get the value at tens place in carry or else if digits[i]<9 carry will be 0
carry = digits.get(i) / 10;
//now if carry is not equal to 0, so at that index, we should keep the value present at the ones place so we do digits[i]%10
if(carry != 0)digits.set(i, digits.get(i) % 10);
}
//after doing all that if carry is still there which means one more element is needed to be added to the array
if(carry != 0)
digits.set(digits.size() - 1, carry);
//again, revere the array so that we can get the original array
Collections.reverse(digits);
}
//driver code
public static void main (String args[])
{
//creating an instance of the vector class and passing an array
Vector<Integer> digits = new Vector<Integer>(Arrays.asList(9, 9, 9, 9, 9));
//determines the size of the array
int n = digits.size();
//function calling
plusOne(digits, n);
for(int i = 0; i < n; i++)
{
//prints the array after adding 1 to the array    
System.out.print(digits.get(i) + " ");
}
}
}
 Output: 1 0 0 0 0
 Complexity The time complexity of all the above approaches is O(n) because we have traversed over the array only once. Where n is the length of the array. The space complexity of the approach is O(1) if the array contains at least one digit smaller than 9, else O(n). Next TopicUnequal Adjacent Elements in Java ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/plus-one-to-array-problem-in-java Plus One to Array Problem in Java - Javatpoint ? SCROLL TO TOP Home Java Programs OOPs String Exception Multithreading Collections JavaFX JSP Spring Spring Boot Projects Interview Questions Java Tutorial What is Java History of Java Features of Java C++ vs Java Hello Java Program Program Internal How to set path? JDK, JRE and JVM JVM: Java Virtual Machine Java Variables Java Data Types Unicode System Operators Keywords Control Statements Java Control Statements Java If-else Java Switch Java For Loop Java While Loop Java Do While Loop Java Break Java Continue Java Comments Java Programs Java Object Class Java OOPs Concepts Naming Convention Object and Class Method Constructor static keyword this keyword Java Inheritance Inheritance(IS-A) Aggregation(HAS-A) Java Polymorphism Method Overloading Method Overriding Covariant Return Type super keyword Instance Initializer block final keyword Runtime Polymorphism Dynamic Binding instanceof operator Java Abstraction Abstract class Interface Abstract vs Interface Java Encapsulation Package Access Modifiers Encapsulation Java Array Java Array Java OOPs Misc Object class Object Cloning Math class Wrapper Class Java Recursion Call By Value strictfp keyword javadoc tool Command Line Arg Object vs Class Overloading vs Overriding Java String Java Regex Exception Handling Java Inner classes Java Multithreading Java I/O Java Networking Java AWT & Events Java Swing JavaFX Java Applet Java Reflection Java Date Java Conversion Java Collection Java JDBC Java Misc Java New Features RMI Internationalization Interview Questions Java MCQ next ? ? prev Plus One to Array Problem in Java It is a very interesting problem frequently asked in interviews of top IT companies like Google, Amazon, TCS, Accenture, Adobe, Apple, Infosys, etc. By solving the problem, one wants to check the logical ability, critical thinking, and problem-solving skill of the interviewee. So, in this section, we are going to add (plus) one to an array problem in Java with different approaches and logic. Also, we will create Java programs for the same. Problem Statement In this problem, we have given an array in which each element represents a digit and the complete array represents a number. The digits are ordered from MSB to LSB in left to right order. Assume that there is no leading 0's in the number. The task is to add 1 to the number and return the result in the form of an array of digits. Let's understand it through examples. Example Input: arr = [2, 5, 9, 7] Output: [2, 5, 9, 8] It represents the number 2597. Add 1 to the most significant bit, we get 2598. The output will be [2, 5, 9, 8]. Let's see another example. Input: arr = [9, 9] Output: [1, 0, 0] It represents the number 99. Add 1 to the most significant bit, we get 100. The output will be [1, 0, 0]. Solution to The Problem Naive Approach The simple approach is that first convert the array into a number, add one to it, and return the result in the form of an array. But the approach is not applicable to the large array. So, we will process each digit one by one. Begin from the least significant bit and process each digit till the most significant bit. If the current digit is smaller than 9, add 1 to the current digit and return the array else assign zero to the current digit. If the last element is processed and it was also equal to 9, it means that all the digits were 9. So, we will increase the size of the array by one and assign 1 to the MSB. Return the resultant array. Plus One to Array Java Program PlusOneArray.java 
import java.util.Arrays; 
public class PlusOneArray
{
//function to add 1 to the array
public static int[] plusOne(int[] digits) 
{
int n = digits.length;
for(int i=n-1; i>=0; i--) 
{
if(digits[i] < 9) 
{
digits[i]++; 
return digits;
}
digits[i] = 0;
}
int[] newNumber = new int [n+1];
newNumber[0] = 1;
return newNumber;
}
//driver code
public static void main(String args[]) 
{
int [] arr = {6, 3, 8, 2}; 
//function calling
int[]ans=plusOne(arr); 
//prints the resultant array after adding 1 to MSB
System.out.println(Arrays.toString(ans));
}
}
 Output: [6, 3, 8, 3]
 Using Vector Another approach is using the vector. In this approach, we begin from the end of the vector. If the last element is 9, set it to 0, else exit from the loop. If all digits are 9, set 1 at starting, else increment the element at the position where the loop stopped. Note that no carry, division, and modulo is required. Let's implement the above approach in a Java program. PlusOneExample1.java 
import java.io.*;
import java.util.*;
public class PlusOneExample1
{
//function to add one to the array
static void plusOne(Vector<Integer> digits)
{
//initialize an index (digit of units)
int index= digits.size() - 1;
while (index >= 0 && digits.get(index) == 9)
{
//while the index is valid and the value at [index] == 9 set it as 0    
digits.set(index, 0);
//decement index by 1
index -= 1;
}
// if index < 0 (if all digits were 9)
if (index < 0)
{
//inserting 1 at the beginning of the vector 
digits.set(0, 1);
//adding an extra zero to the end of the vector 
digits.add(digits.size(),0);
}
//else increment the value at [index]
else
digits.set(index, digits.get(index) + 1);
}
//driver code
public static void main(String args[])
{
//creating an instance of the vector class and passing an array
Vector<Integer> digits = new Vector<Integer>(Arrays.asList(12, 45, 90, 34));
//function calling
plusOne(digits);
for (int digit : digits)
//prints the array after adding 1 to the array
System.out.print(digit + " ");
}
}
 Output: 12 45 90 35
 Let's see another approach. In this approach, first, we reverse the given array. After that take a carry variable to store the carry. Iterate over the array from starting and add 1. Carry to the value of that array at that index. Now check whether the value of that index is greater than equal to 9 or not. If yes, take the carry as the ten's value and the value at that index in the array will be the value present at the one place, else simply move on. 
if digits[i]>9 then carry = digits[i]/10 and digits[i]%=10
if digits[i]<=9 then carry = 0
 Repeat the above step until we reach the last element of the array. Note that if carry is not 0, simply add 1 to the array. At last, reverse the array, so that we can get the original array. Let's implement the above approach in a Java program. PlusOneExample2.java 
import java.io.*;
import java.util.*;
public class PlusOneExample2
{
//function to add one to the array    
public static void plusOne(Vector<Integer> digits, int n)
{
//revers the given array so that we can begin traversing from back
Collections.reverse(digits);
//defining a variable to store carry
int carry = 0;
for(int i = 0; i < n; i++)
{
//initially carry is 0, it is the base case
if(i == 0)
digits.set(i, digits.get(i) + 1 + carry);
//if carry is not equal to zero, add it to the array element at that position
else if(carry != 0)
digits.set(i, digits.get(i) + carry);
//now to get carry, i.e. if digits[i]>9 we get the value at tens place in carry or else if digits[i]<9 carry will be 0
carry = digits.get(i) / 10;
//now if carry is not equal to 0, so at that index, we should keep the value present at the ones place so we do digits[i]%10
if(carry != 0)digits.set(i, digits.get(i) % 10);
}
//after doing all that if carry is still there which means one more element is needed to be added to the array
if(carry != 0)
digits.set(digits.size() - 1, carry);
//again, revere the array so that we can get the original array
Collections.reverse(digits);
}
//driver code
public static void main (String args[])
{
//creating an instance of the vector class and passing an array
Vector<Integer> digits = new Vector<Integer>(Arrays.asList(9, 9, 9, 9, 9));
//determines the size of the array
int n = digits.size();
//function calling
plusOne(digits, n);
for(int i = 0; i < n; i++)
{
//prints the array after adding 1 to the array    
System.out.print(digits.get(i) + " ");
}
}
}
 Output: 1 0 0 0 0
 Complexity The time complexity of all the above approaches is O(n) because we have traversed over the array only once. Where n is the length of the array. The space complexity of the approach is O(1) if the array contains at least one digit smaller than 9, else O(n). Next TopicUnequal Adjacent Elements in Java ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/plus-one-to-array-problem-in-java Plus One to Array Problem in Java - Javatpoint ? SCROLL TO TOP Home Java Programs OOPs String Exception Multithreading Collections JavaFX JSP Spring Spring Boot Projects Interview Questions Java Tutorial What is Java History of Java Features of Java C++ vs Java Hello Java Program Program Internal How to set path? JDK, JRE and JVM JVM: Java Virtual Machine Java Variables Java Data Types Unicode System Operators Keywords Control Statements Java Control Statements Java If-else Java Switch Java For Loop Java While Loop Java Do While Loop Java Break Java Continue Java Comments Java Programs Java Object Class Java OOPs Concepts Naming Convention Object and Class Method Constructor static keyword this keyword Java Inheritance Inheritance(IS-A) Aggregation(HAS-A) Java Polymorphism Method Overloading Method Overriding Covariant Return Type super keyword Instance Initializer block final keyword Runtime Polymorphism Dynamic Binding instanceof operator Java Abstraction Abstract class Interface Abstract vs Interface Java Encapsulation Package Access Modifiers Encapsulation Java Array Java Array Java OOPs Misc Object class Object Cloning Math class Wrapper Class Java Recursion Call By Value strictfp keyword javadoc tool Command Line Arg Object vs Class Overloading vs Overriding Java String Java Regex Exception Handling Java Inner classes Java Multithreading Java I/O Java Networking Java AWT & Events Java Swing JavaFX Java Applet Java Reflection Java Date Java Conversion Java Collection Java JDBC Java Misc Java New Features RMI Internationalization Interview Questions Java MCQ next ? ? prev Plus One to Array Problem in Java It is a very interesting problem frequently asked in interviews of top IT companies like Google, Amazon, TCS, Accenture, Adobe, Apple, Infosys, etc. By solving the problem, one wants to check the logical ability, critical thinking, and problem-solving skill of the interviewee. So, in this section, we are going to add (plus) one to an array problem in Java with different approaches and logic. Also, we will create Java programs for the same. Problem Statement In this problem, we have given an array in which each element represents a digit and the complete array represents a number. The digits are ordered from MSB to LSB in left to right order. Assume that there is no leading 0's in the number. The task is to add 1 to the number and return the result in the form of an array of digits. Let's understand it through examples. Example Input: arr = [2, 5, 9, 7] Output: [2, 5, 9, 8] It represents the number 2597. Add 1 to the most significant bit, we get 2598. The output will be [2, 5, 9, 8]. Let's see another example. Input: arr = [9, 9] Output: [1, 0, 0] It represents the number 99. Add 1 to the most significant bit, we get 100. The output will be [1, 0, 0]. Solution to The Problem Naive Approach The simple approach is that first convert the array into a number, add one to it, and return the result in the form of an array. But the approach is not applicable to the large array. So, we will process each digit one by one. Begin from the least significant bit and process each digit till the most significant bit. If the current digit is smaller than 9, add 1 to the current digit and return the array else assign zero to the current digit. If the last element is processed and it was also equal to 9, it means that all the digits were 9. So, we will increase the size of the array by one and assign 1 to the MSB. Return the resultant array. Plus One to Array Java Program PlusOneArray.java 
import java.util.Arrays; 
public class PlusOneArray
{
//function to add 1 to the array
public static int[] plusOne(int[] digits) 
{
int n = digits.length;
for(int i=n-1; i>=0; i--) 
{
if(digits[i] < 9) 
{
digits[i]++; 
return digits;
}
digits[i] = 0;
}
int[] newNumber = new int [n+1];
newNumber[0] = 1;
return newNumber;
}
//driver code
public static void main(String args[]) 
{
int [] arr = {6, 3, 8, 2}; 
//function calling
int[]ans=plusOne(arr); 
//prints the resultant array after adding 1 to MSB
System.out.println(Arrays.toString(ans));
}
}
 Output: [6, 3, 8, 3]
 Using Vector Another approach is using the vector. In this approach, we begin from the end of the vector. If the last element is 9, set it to 0, else exit from the loop. If all digits are 9, set 1 at starting, else increment the element at the position where the loop stopped. Note that no carry, division, and modulo is required. Let's implement the above approach in a Java program. PlusOneExample1.java 
import java.io.*;
import java.util.*;
public class PlusOneExample1
{
//function to add one to the array
static void plusOne(Vector<Integer> digits)
{
//initialize an index (digit of units)
int index= digits.size() - 1;
while (index >= 0 && digits.get(index) == 9)
{
//while the index is valid and the value at [index] == 9 set it as 0    
digits.set(index, 0);
//decement index by 1
index -= 1;
}
// if index < 0 (if all digits were 9)
if (index < 0)
{
//inserting 1 at the beginning of the vector 
digits.set(0, 1);
//adding an extra zero to the end of the vector 
digits.add(digits.size(),0);
}
//else increment the value at [index]
else
digits.set(index, digits.get(index) + 1);
}
//driver code
public static void main(String args[])
{
//creating an instance of the vector class and passing an array
Vector<Integer> digits = new Vector<Integer>(Arrays.asList(12, 45, 90, 34));
//function calling
plusOne(digits);
for (int digit : digits)
//prints the array after adding 1 to the array
System.out.print(digit + " ");
}
}
 Output: 12 45 90 35
 Let's see another approach. In this approach, first, we reverse the given array. After that take a carry variable to store the carry. Iterate over the array from starting and add 1. Carry to the value of that array at that index. Now check whether the value of that index is greater than equal to 9 or not. If yes, take the carry as the ten's value and the value at that index in the array will be the value present at the one place, else simply move on. 
if digits[i]>9 then carry = digits[i]/10 and digits[i]%=10
if digits[i]<=9 then carry = 0
 Repeat the above step until we reach the last element of the array. Note that if carry is not 0, simply add 1 to the array. At last, reverse the array, so that we can get the original array. Let's implement the above approach in a Java program. PlusOneExample2.java 
import java.io.*;
import java.util.*;
public class PlusOneExample2
{
//function to add one to the array    
public static void plusOne(Vector<Integer> digits, int n)
{
//revers the given array so that we can begin traversing from back
Collections.reverse(digits);
//defining a variable to store carry
int carry = 0;
for(int i = 0; i < n; i++)
{
//initially carry is 0, it is the base case
if(i == 0)
digits.set(i, digits.get(i) + 1 + carry);
//if carry is not equal to zero, add it to the array element at that position
else if(carry != 0)
digits.set(i, digits.get(i) + carry);
//now to get carry, i.e. if digits[i]>9 we get the value at tens place in carry or else if digits[i]<9 carry will be 0
carry = digits.get(i) / 10;
//now if carry is not equal to 0, so at that index, we should keep the value present at the ones place so we do digits[i]%10
if(carry != 0)digits.set(i, digits.get(i) % 10);
}
//after doing all that if carry is still there which means one more element is needed to be added to the array
if(carry != 0)
digits.set(digits.size() - 1, carry);
//again, revere the array so that we can get the original array
Collections.reverse(digits);
}
//driver code
public static void main (String args[])
{
//creating an instance of the vector class and passing an array
Vector<Integer> digits = new Vector<Integer>(Arrays.asList(9, 9, 9, 9, 9));
//determines the size of the array
int n = digits.size();
//function calling
plusOne(digits, n);
for(int i = 0; i < n; i++)
{
//prints the array after adding 1 to the array    
System.out.print(digits.get(i) + " ");
}
}
}
 Output: 1 0 0 0 0
 Complexity The time complexity of all the above approaches is O(n) because we have traversed over the array only once. Where n is the length of the array. The space complexity of the approach is O(1) if the array contains at least one digit smaller than 9, else O(n). Next TopicUnequal Adjacent Elements in Java ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/plus-one-to-array-problem-in-java Plus One to Array Problem in Java - Javatpoint ? SCROLL TO TOP Home Java Programs OOPs String Exception Multithreading Collections JavaFX JSP Spring Spring Boot Projects Interview Questions Java Tutorial What is Java History of Java Features of Java C++ vs Java Hello Java Program Program Internal How to set path? JDK, JRE and JVM JVM: Java Virtual Machine Java Variables Java Data Types Unicode System Operators Keywords Control Statements Java Control Statements Java If-else Java Switch Java For Loop Java While Loop Java Do While Loop Java Break Java Continue Java Comments Java Programs Java Object Class Java OOPs Concepts Naming Convention Object and Class Method Constructor static keyword this keyword Java Inheritance Inheritance(IS-A) Aggregation(HAS-A) Java Polymorphism Method Overloading Method Overriding Covariant Return Type super keyword Instance Initializer block final keyword Runtime Polymorphism Dynamic Binding instanceof operator Java Abstraction Abstract class Interface Abstract vs Interface Java Encapsulation Package Access Modifiers Encapsulation Java Array Java Array Java OOPs Misc Object class Object Cloning Math class Wrapper Class Java Recursion Call By Value strictfp keyword javadoc tool Command Line Arg Object vs Class Overloading vs Overriding Java String Java Regex Exception Handling Java Inner classes Java Multithreading Java I/O Java Networking Java AWT & Events Java Swing JavaFX Java Applet Java Reflection Java Date Java Conversion Java Collection Java JDBC Java Misc Java New Features RMI Internationalization Interview Questions Java MCQ next ? ? prev Plus One to Array Problem in Java It is a very interesting problem frequently asked in interviews of top IT companies like Google, Amazon, TCS, Accenture, Adobe, Apple, Infosys, etc. By solving the problem, one wants to check the logical ability, critical thinking, and problem-solving skill of the interviewee. So, in this section, we are going to add (plus) one to an array problem in Java with different approaches and logic. Also, we will create Java programs for the same. Problem Statement In this problem, we have given an array in which each element represents a digit and the complete array represents a number. The digits are ordered from MSB to LSB in left to right order. Assume that there is no leading 0's in the number. The task is to add 1 to the number and return the result in the form of an array of digits. Let's understand it through examples. Example Input: arr = [2, 5, 9, 7] Output: [2, 5, 9, 8] It represents the number 2597. Add 1 to the most significant bit, we get 2598. The output will be [2, 5, 9, 8]. Let's see another example. Input: arr = [9, 9] Output: [1, 0, 0] It represents the number 99. Add 1 to the most significant bit, we get 100. The output will be [1, 0, 0]. Solution to The Problem Naive Approach The simple approach is that first convert the array into a number, add one to it, and return the result in the form of an array. But the approach is not applicable to the large array. So, we will process each digit one by one. Begin from the least significant bit and process each digit till the most significant bit. If the current digit is smaller than 9, add 1 to the current digit and return the array else assign zero to the current digit. If the last element is processed and it was also equal to 9, it means that all the digits were 9. So, we will increase the size of the array by one and assign 1 to the MSB. Return the resultant array. Plus One to Array Java Program PlusOneArray.java 
import java.util.Arrays; 
public class PlusOneArray
{
//function to add 1 to the array
public static int[] plusOne(int[] digits) 
{
int n = digits.length;
for(int i=n-1; i>=0; i--) 
{
if(digits[i] < 9) 
{
digits[i]++; 
return digits;
}
digits[i] = 0;
}
int[] newNumber = new int [n+1];
newNumber[0] = 1;
return newNumber;
}
//driver code
public static void main(String args[]) 
{
int [] arr = {6, 3, 8, 2}; 
//function calling
int[]ans=plusOne(arr); 
//prints the resultant array after adding 1 to MSB
System.out.println(Arrays.toString(ans));
}
}
 Output: [6, 3, 8, 3]
 Using Vector Another approach is using the vector. In this approach, we begin from the end of the vector. If the last element is 9, set it to 0, else exit from the loop. If all digits are 9, set 1 at starting, else increment the element at the position where the loop stopped. Note that no carry, division, and modulo is required. Let's implement the above approach in a Java program. PlusOneExample1.java 
import java.io.*;
import java.util.*;
public class PlusOneExample1
{
//function to add one to the array
static void plusOne(Vector<Integer> digits)
{
//initialize an index (digit of units)
int index= digits.size() - 1;
while (index >= 0 && digits.get(index) == 9)
{
//while the index is valid and the value at [index] == 9 set it as 0    
digits.set(index, 0);
//decement index by 1
index -= 1;
}
// if index < 0 (if all digits were 9)
if (index < 0)
{
//inserting 1 at the beginning of the vector 
digits.set(0, 1);
//adding an extra zero to the end of the vector 
digits.add(digits.size(),0);
}
//else increment the value at [index]
else
digits.set(index, digits.get(index) + 1);
}
//driver code
public static void main(String args[])
{
//creating an instance of the vector class and passing an array
Vector<Integer> digits = new Vector<Integer>(Arrays.asList(12, 45, 90, 34));
//function calling
plusOne(digits);
for (int digit : digits)
//prints the array after adding 1 to the array
System.out.print(digit + " ");
}
}
 Output: 12 45 90 35
 Let's see another approach. In this approach, first, we reverse the given array. After that take a carry variable to store the carry. Iterate over the array from starting and add 1. Carry to the value of that array at that index. Now check whether the value of that index is greater than equal to 9 or not. If yes, take the carry as the ten's value and the value at that index in the array will be the value present at the one place, else simply move on. 
if digits[i]>9 then carry = digits[i]/10 and digits[i]%=10
if digits[i]<=9 then carry = 0
 Repeat the above step until we reach the last element of the array. Note that if carry is not 0, simply add 1 to the array. At last, reverse the array, so that we can get the original array. Let's implement the above approach in a Java program. PlusOneExample2.java 
import java.io.*;
import java.util.*;
public class PlusOneExample2
{
//function to add one to the array    
public static void plusOne(Vector<Integer> digits, int n)
{
//revers the given array so that we can begin traversing from back
Collections.reverse(digits);
//defining a variable to store carry
int carry = 0;
for(int i = 0; i < n; i++)
{
//initially carry is 0, it is the base case
if(i == 0)
digits.set(i, digits.get(i) + 1 + carry);
//if carry is not equal to zero, add it to the array element at that position
else if(carry != 0)
digits.set(i, digits.get(i) + carry);
//now to get carry, i.e. if digits[i]>9 we get the value at tens place in carry or else if digits[i]<9 carry will be 0
carry = digits.get(i) / 10;
//now if carry is not equal to 0, so at that index, we should keep the value present at the ones place so we do digits[i]%10
if(carry != 0)digits.set(i, digits.get(i) % 10);
}
//after doing all that if carry is still there which means one more element is needed to be added to the array
if(carry != 0)
digits.set(digits.size() - 1, carry);
//again, revere the array so that we can get the original array
Collections.reverse(digits);
}
//driver code
public static void main (String args[])
{
//creating an instance of the vector class and passing an array
Vector<Integer> digits = new Vector<Integer>(Arrays.asList(9, 9, 9, 9, 9));
//determines the size of the array
int n = digits.size();
//function calling
plusOne(digits, n);
for(int i = 0; i < n; i++)
{
//prints the array after adding 1 to the array    
System.out.print(digits.get(i) + " ");
}
}
}
 Output: 1 0 0 0 0
 Complexity The time complexity of all the above approaches is O(n) because we have traversed over the array only once. Where n is the length of the array. The space complexity of the approach is O(1) if the array contains at least one digit smaller than 9, else O(n). Next TopicUnequal Adjacent Elements in Java ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/plus-one-to-array-problem-in-java Plus One to Array Problem in Java - Javatpoint ? SCROLL TO TOP Home Java Programs OOPs String Exception Multithreading Collections JavaFX JSP Spring Spring Boot Projects Interview Questions Java Tutorial What is Java History of Java Features of Java C++ vs Java Hello Java Program Program Internal How to set path? JDK, JRE and JVM JVM: Java Virtual Machine Java Variables Java Data Types Unicode System Operators Keywords Control Statements Java Control Statements Java If-else Java Switch Java For Loop Java While Loop Java Do While Loop Java Break Java Continue Java Comments Java Programs Java Object Class Java OOPs Concepts Naming Convention Object and Class Method Constructor static keyword this keyword Java Inheritance Inheritance(IS-A) Aggregation(HAS-A) Java Polymorphism Method Overloading Method Overriding Covariant Return Type super keyword Instance Initializer block final keyword Runtime Polymorphism Dynamic Binding instanceof operator Java Abstraction Abstract class Interface Abstract vs Interface Java Encapsulation Package Access Modifiers Encapsulation Java Array Java Array Java OOPs Misc Object class Object Cloning Math class Wrapper Class Java Recursion Call By Value strictfp keyword javadoc tool Command Line Arg Object vs Class Overloading vs Overriding Java String Java Regex Exception Handling Java Inner classes Java Multithreading Java I/O Java Networking Java AWT & Events Java Swing JavaFX Java Applet Java Reflection Java Date Java Conversion Java Collection Java JDBC Java Misc Java New Features RMI Internationalization Interview Questions Java MCQ next ? ? prev Plus One to Array Problem in Java It is a very interesting problem frequently asked in interviews of top IT companies like Google, Amazon, TCS, Accenture, Adobe, Apple, Infosys, etc. By solving the problem, one wants to check the logical ability, critical thinking, and problem-solving skill of the interviewee. So, in this section, we are going to add (plus) one to an array problem in Java with different approaches and logic. Also, we will create Java programs for the same. Problem Statement In this problem, we have given an array in which each element represents a digit and the complete array represents a number. The digits are ordered from MSB to LSB in left to right order. Assume that there is no leading 0's in the number. The task is to add 1 to the number and return the result in the form of an array of digits. Let's understand it through examples. Example Input: arr = [2, 5, 9, 7] Output: [2, 5, 9, 8] It represents the number 2597. Add 1 to the most significant bit, we get 2598. The output will be [2, 5, 9, 8]. Let's see another example. Input: arr = [9, 9] Output: [1, 0, 0] It represents the number 99. Add 1 to the most significant bit, we get 100. The output will be [1, 0, 0]. Solution to The Problem Naive Approach The simple approach is that first convert the array into a number, add one to it, and return the result in the form of an array. But the approach is not applicable to the large array. So, we will process each digit one by one. Begin from the least significant bit and process each digit till the most significant bit. If the current digit is smaller than 9, add 1 to the current digit and return the array else assign zero to the current digit. If the last element is processed and it was also equal to 9, it means that all the digits were 9. So, we will increase the size of the array by one and assign 1 to the MSB. Return the resultant array. Plus One to Array Java Program PlusOneArray.java 
import java.util.Arrays; 
public class PlusOneArray
{
//function to add 1 to the array
public static int[] plusOne(int[] digits) 
{
int n = digits.length;
for(int i=n-1; i>=0; i--) 
{
if(digits[i] < 9) 
{
digits[i]++; 
return digits;
}
digits[i] = 0;
}
int[] newNumber = new int [n+1];
newNumber[0] = 1;
return newNumber;
}
//driver code
public static void main(String args[]) 
{
int [] arr = {6, 3, 8, 2}; 
//function calling
int[]ans=plusOne(arr); 
//prints the resultant array after adding 1 to MSB
System.out.println(Arrays.toString(ans));
}
}
 Output: [6, 3, 8, 3]
 Using Vector Another approach is using the vector. In this approach, we begin from the end of the vector. If the last element is 9, set it to 0, else exit from the loop. If all digits are 9, set 1 at starting, else increment the element at the position where the loop stopped. Note that no carry, division, and modulo is required. Let's implement the above approach in a Java program. PlusOneExample1.java 
import java.io.*;
import java.util.*;
public class PlusOneExample1
{
//function to add one to the array
static void plusOne(Vector<Integer> digits)
{
//initialize an index (digit of units)
int index= digits.size() - 1;
while (index >= 0 && digits.get(index) == 9)
{
//while the index is valid and the value at [index] == 9 set it as 0    
digits.set(index, 0);
//decement index by 1
index -= 1;
}
// if index < 0 (if all digits were 9)
if (index < 0)
{
//inserting 1 at the beginning of the vector 
digits.set(0, 1);
//adding an extra zero to the end of the vector 
digits.add(digits.size(),0);
}
//else increment the value at [index]
else
digits.set(index, digits.get(index) + 1);
}
//driver code
public static void main(String args[])
{
//creating an instance of the vector class and passing an array
Vector<Integer> digits = new Vector<Integer>(Arrays.asList(12, 45, 90, 34));
//function calling
plusOne(digits);
for (int digit : digits)
//prints the array after adding 1 to the array
System.out.print(digit + " ");
}
}
 Output: 12 45 90 35
 Let's see another approach. In this approach, first, we reverse the given array. After that take a carry variable to store the carry. Iterate over the array from starting and add 1. Carry to the value of that array at that index. Now check whether the value of that index is greater than equal to 9 or not. If yes, take the carry as the ten's value and the value at that index in the array will be the value present at the one place, else simply move on. 
if digits[i]>9 then carry = digits[i]/10 and digits[i]%=10
if digits[i]<=9 then carry = 0
 Repeat the above step until we reach the last element of the array. Note that if carry is not 0, simply add 1 to the array. At last, reverse the array, so that we can get the original array. Let's implement the above approach in a Java program. PlusOneExample2.java 
import java.io.*;
import java.util.*;
public class PlusOneExample2
{
//function to add one to the array    
public static void plusOne(Vector<Integer> digits, int n)
{
//revers the given array so that we can begin traversing from back
Collections.reverse(digits);
//defining a variable to store carry
int carry = 0;
for(int i = 0; i < n; i++)
{
//initially carry is 0, it is the base case
if(i == 0)
digits.set(i, digits.get(i) + 1 + carry);
//if carry is not equal to zero, add it to the array element at that position
else if(carry != 0)
digits.set(i, digits.get(i) + carry);
//now to get carry, i.e. if digits[i]>9 we get the value at tens place in carry or else if digits[i]<9 carry will be 0
carry = digits.get(i) / 10;
//now if carry is not equal to 0, so at that index, we should keep the value present at the ones place so we do digits[i]%10
if(carry != 0)digits.set(i, digits.get(i) % 10);
}
//after doing all that if carry is still there which means one more element is needed to be added to the array
if(carry != 0)
digits.set(digits.size() - 1, carry);
//again, revere the array so that we can get the original array
Collections.reverse(digits);
}
//driver code
public static void main (String args[])
{
//creating an instance of the vector class and passing an array
Vector<Integer> digits = new Vector<Integer>(Arrays.asList(9, 9, 9, 9, 9));
//determines the size of the array
int n = digits.size();
//function calling
plusOne(digits, n);
for(int i = 0; i < n; i++)
{
//prints the array after adding 1 to the array    
System.out.print(digits.get(i) + " ");
}
}
}
 Output: 1 0 0 0 0
 Complexity The time complexity of all the above approaches is O(n) because we have traversed over the array only once. Where n is the length of the array. The space complexity of the approach is O(1) if the array contains at least one digit smaller than 9, else O(n). Next TopicUnequal Adjacent Elements in Java ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/plus-one-to-array-problem-in-java Plus One to Array Problem in Java - Javatpoint ? SCROLL TO TOP Home Java Programs OOPs String Exception Multithreading Collections JavaFX JSP Spring Spring Boot Projects Interview Questions Java Tutorial What is Java History of Java Features of Java C++ vs Java Hello Java Program Program Internal How to set path? JDK, JRE and JVM JVM: Java Virtual Machine Java Variables Java Data Types Unicode System Operators Keywords Control Statements Java Control Statements Java If-else Java Switch Java For Loop Java While Loop Java Do While Loop Java Break Java Continue Java Comments Java Programs Java Object Class Java OOPs Concepts Naming Convention Object and Class Method Constructor static keyword this keyword Java Inheritance Inheritance(IS-A) Aggregation(HAS-A) Java Polymorphism Method Overloading Method Overriding Covariant Return Type super keyword Instance Initializer block final keyword Runtime Polymorphism Dynamic Binding instanceof operator Java Abstraction Abstract class Interface Abstract vs Interface Java Encapsulation Package Access Modifiers Encapsulation Java Array Java Array Java OOPs Misc Object class Object Cloning Math class Wrapper Class Java Recursion Call By Value strictfp keyword javadoc tool Command Line Arg Object vs Class Overloading vs Overriding Java String Java Regex Exception Handling Java Inner classes Java Multithreading Java I/O Java Networking Java AWT & Events Java Swing JavaFX Java Applet Java Reflection Java Date Java Conversion Java Collection Java JDBC Java Misc Java New Features RMI Internationalization Interview Questions Java MCQ next ? ? prev Plus One to Array Problem in Java It is a very interesting problem frequently asked in interviews of top IT companies like Google, Amazon, TCS, Accenture, Adobe, Apple, Infosys, etc. By solving the problem, one wants to check the logical ability, critical thinking, and problem-solving skill of the interviewee. So, in this section, we are going to add (plus) one to an array problem in Java with different approaches and logic. Also, we will create Java programs for the same. Problem Statement In this problem, we have given an array in which each element represents a digit and the complete array represents a number. The digits are ordered from MSB to LSB in left to right order. Assume that there is no leading 0's in the number. The task is to add 1 to the number and return the result in the form of an array of digits. Let's understand it through examples. Example Input: arr = [2, 5, 9, 7] Output: [2, 5, 9, 8] It represents the number 2597. Add 1 to the most significant bit, we get 2598. The output will be [2, 5, 9, 8]. Let's see another example. Input: arr = [9, 9] Output: [1, 0, 0] It represents the number 99. Add 1 to the most significant bit, we get 100. The output will be [1, 0, 0]. Solution to The Problem Naive Approach The simple approach is that first convert the array into a number, add one to it, and return the result in the form of an array. But the approach is not applicable to the large array. So, we will process each digit one by one. Begin from the least significant bit and process each digit till the most significant bit. If the current digit is smaller than 9, add 1 to the current digit and return the array else assign zero to the current digit. If the last element is processed and it was also equal to 9, it means that all the digits were 9. So, we will increase the size of the array by one and assign 1 to the MSB. Return the resultant array. Plus One to Array Java Program PlusOneArray.java 
import java.util.Arrays; 
public class PlusOneArray
{
//function to add 1 to the array
public static int[] plusOne(int[] digits) 
{
int n = digits.length;
for(int i=n-1; i>=0; i--) 
{
if(digits[i] < 9) 
{
digits[i]++; 
return digits;
}
digits[i] = 0;
}
int[] newNumber = new int [n+1];
newNumber[0] = 1;
return newNumber;
}
//driver code
public static void main(String args[]) 
{
int [] arr = {6, 3, 8, 2}; 
//function calling
int[]ans=plusOne(arr); 
//prints the resultant array after adding 1 to MSB
System.out.println(Arrays.toString(ans));
}
}
 Output: [6, 3, 8, 3]
 Using Vector Another approach is using the vector. In this approach, we begin from the end of the vector. If the last element is 9, set it to 0, else exit from the loop. If all digits are 9, set 1 at starting, else increment the element at the position where the loop stopped. Note that no carry, division, and modulo is required. Let's implement the above approach in a Java program. PlusOneExample1.java 
import java.io.*;
import java.util.*;
public class PlusOneExample1
{
//function to add one to the array
static void plusOne(Vector<Integer> digits)
{
//initialize an index (digit of units)
int index= digits.size() - 1;
while (index >= 0 && digits.get(index) == 9)
{
//while the index is valid and the value at [index] == 9 set it as 0    
digits.set(index, 0);
//decement index by 1
index -= 1;
}
// if index < 0 (if all digits were 9)
if (index < 0)
{
//inserting 1 at the beginning of the vector 
digits.set(0, 1);
//adding an extra zero to the end of the vector 
digits.add(digits.size(),0);
}
//else increment the value at [index]
else
digits.set(index, digits.get(index) + 1);
}
//driver code
public static void main(String args[])
{
//creating an instance of the vector class and passing an array
Vector<Integer> digits = new Vector<Integer>(Arrays.asList(12, 45, 90, 34));
//function calling
plusOne(digits);
for (int digit : digits)
//prints the array after adding 1 to the array
System.out.print(digit + " ");
}
}
 Output: 12 45 90 35
 Let's see another approach. In this approach, first, we reverse the given array. After that take a carry variable to store the carry. Iterate over the array from starting and add 1. Carry to the value of that array at that index. Now check whether the value of that index is greater than equal to 9 or not. If yes, take the carry as the ten's value and the value at that index in the array will be the value present at the one place, else simply move on. 
if digits[i]>9 then carry = digits[i]/10 and digits[i]%=10
if digits[i]<=9 then carry = 0
 Repeat the above step until we reach the last element of the array. Note that if carry is not 0, simply add 1 to the array. At last, reverse the array, so that we can get the original array. Let's implement the above approach in a Java program. PlusOneExample2.java 
import java.io.*;
import java.util.*;
public class PlusOneExample2
{
//function to add one to the array    
public static void plusOne(Vector<Integer> digits, int n)
{
//revers the given array so that we can begin traversing from back
Collections.reverse(digits);
//defining a variable to store carry
int carry = 0;
for(int i = 0; i < n; i++)
{
//initially carry is 0, it is the base case
if(i == 0)
digits.set(i, digits.get(i) + 1 + carry);
//if carry is not equal to zero, add it to the array element at that position
else if(carry != 0)
digits.set(i, digits.get(i) + carry);
//now to get carry, i.e. if digits[i]>9 we get the value at tens place in carry or else if digits[i]<9 carry will be 0
carry = digits.get(i) / 10;
//now if carry is not equal to 0, so at that index, we should keep the value present at the ones place so we do digits[i]%10
if(carry != 0)digits.set(i, digits.get(i) % 10);
}
//after doing all that if carry is still there which means one more element is needed to be added to the array
if(carry != 0)
digits.set(digits.size() - 1, carry);
//again, revere the array so that we can get the original array
Collections.reverse(digits);
}
//driver code
public static void main (String args[])
{
//creating an instance of the vector class and passing an array
Vector<Integer> digits = new Vector<Integer>(Arrays.asList(9, 9, 9, 9, 9));
//determines the size of the array
int n = digits.size();
//function calling
plusOne(digits, n);
for(int i = 0; i < n; i++)
{
//prints the array after adding 1 to the array    
System.out.print(digits.get(i) + " ");
}
}
}
 Output: 1 0 0 0 0
 Complexity The time complexity of all the above approaches is O(n) because we have traversed over the array only once. Where n is the length of the array. The space complexity of the approach is O(1) if the array contains at least one digit smaller than 9, else O(n). Next TopicUnequal Adjacent Elements in Java ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/plus-one-to-array-problem-in-java Plus One to Array Problem in Java - Javatpoint ? SCROLL TO TOP Home Java Programs OOPs String Exception Multithreading Collections JavaFX JSP Spring Spring Boot Projects Interview Questions Java Tutorial What is Java History of Java Features of Java C++ vs Java Hello Java Program Program Internal How to set path? JDK, JRE and JVM JVM: Java Virtual Machine Java Variables Java Data Types Unicode System Operators Keywords Control Statements Java Control Statements Java If-else Java Switch Java For Loop Java While Loop Java Do While Loop Java Break Java Continue Java Comments Java Programs Java Object Class Java OOPs Concepts Naming Convention Object and Class Method Constructor static keyword this keyword Java Inheritance Inheritance(IS-A) Aggregation(HAS-A) Java Polymorphism Method Overloading Method Overriding Covariant Return Type super keyword Instance Initializer block final keyword Runtime Polymorphism Dynamic Binding instanceof operator Java Abstraction Abstract class Interface Abstract vs Interface Java Encapsulation Package Access Modifiers Encapsulation Java Array Java Array Java OOPs Misc Object class Object Cloning Math class Wrapper Class Java Recursion Call By Value strictfp keyword javadoc tool Command Line Arg Object vs Class Overloading vs Overriding Java String Java Regex Exception Handling Java Inner classes Java Multithreading Java I/O Java Networking Java AWT & Events Java Swing JavaFX Java Applet Java Reflection Java Date Java Conversion Java Collection Java JDBC Java Misc Java New Features RMI Internationalization Interview Questions Java MCQ next ? ? prev Plus One to Array Problem in Java It is a very interesting problem frequently asked in interviews of top IT companies like Google, Amazon, TCS, Accenture, Adobe, Apple, Infosys, etc. By solving the problem, one wants to check the logical ability, critical thinking, and problem-solving skill of the interviewee. So, in this section, we are going to add (plus) one to an array problem in Java with different approaches and logic. Also, we will create Java programs for the same. Problem Statement In this problem, we have given an array in which each element represents a digit and the complete array represents a number. The digits are ordered from MSB to LSB in left to right order. Assume that there is no leading 0's in the number. The task is to add 1 to the number and return the result in the form of an array of digits. Let's understand it through examples. Example Input: arr = [2, 5, 9, 7] Output: [2, 5, 9, 8] It represents the number 2597. Add 1 to the most significant bit, we get 2598. The output will be [2, 5, 9, 8]. Let's see another example. Input: arr = [9, 9] Output: [1, 0, 0] It represents the number 99. Add 1 to the most significant bit, we get 100. The output will be [1, 0, 0]. Solution to The Problem Naive Approach The simple approach is that first convert the array into a number, add one to it, and return the result in the form of an array. But the approach is not applicable to the large array. So, we will process each digit one by one. Begin from the least significant bit and process each digit till the most significant bit. If the current digit is smaller than 9, add 1 to the current digit and return the array else assign zero to the current digit. If the last element is processed and it was also equal to 9, it means that all the digits were 9. So, we will increase the size of the array by one and assign 1 to the MSB. Return the resultant array. Plus One to Array Java Program PlusOneArray.java 
import java.util.Arrays; 
public class PlusOneArray
{
//function to add 1 to the array
public static int[] plusOne(int[] digits) 
{
int n = digits.length;
for(int i=n-1; i>=0; i--) 
{
if(digits[i] < 9) 
{
digits[i]++; 
return digits;
}
digits[i] = 0;
}
int[] newNumber = new int [n+1];
newNumber[0] = 1;
return newNumber;
}
//driver code
public static void main(String args[]) 
{
int [] arr = {6, 3, 8, 2}; 
//function calling
int[]ans=plusOne(arr); 
//prints the resultant array after adding 1 to MSB
System.out.println(Arrays.toString(ans));
}
}
 Output: [6, 3, 8, 3]
 Using Vector Another approach is using the vector. In this approach, we begin from the end of the vector. If the last element is 9, set it to 0, else exit from the loop. If all digits are 9, set 1 at starting, else increment the element at the position where the loop stopped. Note that no carry, division, and modulo is required. Let's implement the above approach in a Java program. PlusOneExample1.java 
import java.io.*;
import java.util.*;
public class PlusOneExample1
{
//function to add one to the array
static void plusOne(Vector<Integer> digits)
{
//initialize an index (digit of units)
int index= digits.size() - 1;
while (index >= 0 && digits.get(index) == 9)
{
//while the index is valid and the value at [index] == 9 set it as 0    
digits.set(index, 0);
//decement index by 1
index -= 1;
}
// if index < 0 (if all digits were 9)
if (index < 0)
{
//inserting 1 at the beginning of the vector 
digits.set(0, 1);
//adding an extra zero to the end of the vector 
digits.add(digits.size(),0);
}
//else increment the value at [index]
else
digits.set(index, digits.get(index) + 1);
}
//driver code
public static void main(String args[])
{
//creating an instance of the vector class and passing an array
Vector<Integer> digits = new Vector<Integer>(Arrays.asList(12, 45, 90, 34));
//function calling
plusOne(digits);
for (int digit : digits)
//prints the array after adding 1 to the array
System.out.print(digit + " ");
}
}
 Output: 12 45 90 35
 Let's see another approach. In this approach, first, we reverse the given array. After that take a carry variable to store the carry. Iterate over the array from starting and add 1. Carry to the value of that array at that index. Now check whether the value of that index is greater than equal to 9 or not. If yes, take the carry as the ten's value and the value at that index in the array will be the value present at the one place, else simply move on. 
if digits[i]>9 then carry = digits[i]/10 and digits[i]%=10
if digits[i]<=9 then carry = 0
 Repeat the above step until we reach the last element of the array. Note that if carry is not 0, simply add 1 to the array. At last, reverse the array, so that we can get the original array. Let's implement the above approach in a Java program. PlusOneExample2.java 
import java.io.*;
import java.util.*;
public class PlusOneExample2
{
//function to add one to the array    
public static void plusOne(Vector<Integer> digits, int n)
{
//revers the given array so that we can begin traversing from back
Collections.reverse(digits);
//defining a variable to store carry
int carry = 0;
for(int i = 0; i < n; i++)
{
//initially carry is 0, it is the base case
if(i == 0)
digits.set(i, digits.get(i) + 1 + carry);
//if carry is not equal to zero, add it to the array element at that position
else if(carry != 0)
digits.set(i, digits.get(i) + carry);
//now to get carry, i.e. if digits[i]>9 we get the value at tens place in carry or else if digits[i]<9 carry will be 0
carry = digits.get(i) / 10;
//now if carry is not equal to 0, so at that index, we should keep the value present at the ones place so we do digits[i]%10
if(carry != 0)digits.set(i, digits.get(i) % 10);
}
//after doing all that if carry is still there which means one more element is needed to be added to the array
if(carry != 0)
digits.set(digits.size() - 1, carry);
//again, revere the array so that we can get the original array
Collections.reverse(digits);
}
//driver code
public static void main (String args[])
{
//creating an instance of the vector class and passing an array
Vector<Integer> digits = new Vector<Integer>(Arrays.asList(9, 9, 9, 9, 9));
//determines the size of the array
int n = digits.size();
//function calling
plusOne(digits, n);
for(int i = 0; i < n; i++)
{
//prints the array after adding 1 to the array    
System.out.print(digits.get(i) + " ");
}
}
}
 Output: 1 0 0 0 0
 Complexity The time complexity of all the above approaches is O(n) because we have traversed over the array only once. Where n is the length of the array. The space complexity of the approach is O(1) if the array contains at least one digit smaller than 9, else O(n). Next TopicUnequal Adjacent Elements in Java ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/plus-one-to-array-problem-in-java Plus One to Array Problem in Java - Javatpoint ? SCROLL TO TOP Home Java Programs OOPs String Exception Multithreading Collections JavaFX JSP Spring Spring Boot Projects Interview Questions Java Tutorial What is Java History of Java Features of Java C++ vs Java Hello Java Program Program Internal How to set path? JDK, JRE and JVM JVM: Java Virtual Machine Java Variables Java Data Types Unicode System Operators Keywords Control Statements Java Control Statements Java If-else Java Switch Java For Loop Java While Loop Java Do While Loop Java Break Java Continue Java Comments Java Programs Java Object Class Java OOPs Concepts Naming Convention Object and Class Method Constructor static keyword this keyword Java Inheritance Inheritance(IS-A) Aggregation(HAS-A) Java Polymorphism Method Overloading Method Overriding Covariant Return Type super keyword Instance Initializer block final keyword Runtime Polymorphism Dynamic Binding instanceof operator Java Abstraction Abstract class Interface Abstract vs Interface Java Encapsulation Package Access Modifiers Encapsulation Java Array Java Array Java OOPs Misc Object class Object Cloning Math class Wrapper Class Java Recursion Call By Value strictfp keyword javadoc tool Command Line Arg Object vs Class Overloading vs Overriding Java String Java Regex Exception Handling Java Inner classes Java Multithreading Java I/O Java Networking Java AWT & Events Java Swing JavaFX Java Applet Java Reflection Java Date Java Conversion Java Collection Java JDBC Java Misc Java New Features RMI Internationalization Interview Questions Java MCQ next ? ? prev Plus One to Array Problem in Java It is a very interesting problem frequently asked in interviews of top IT companies like Google, Amazon, TCS, Accenture, Adobe, Apple, Infosys, etc. By solving the problem, one wants to check the logical ability, critical thinking, and problem-solving skill of the interviewee. So, in this section, we are going to add (plus) one to an array problem in Java with different approaches and logic. Also, we will create Java programs for the same. Problem Statement In this problem, we have given an array in which each element represents a digit and the complete array represents a number. The digits are ordered from MSB to LSB in left to right order. Assume that there is no leading 0's in the number. The task is to add 1 to the number and return the result in the form of an array of digits. Let's understand it through examples. Example Input: arr = [2, 5, 9, 7] Output: [2, 5, 9, 8] It represents the number 2597. Add 1 to the most significant bit, we get 2598. The output will be [2, 5, 9, 8]. Let's see another example. Input: arr = [9, 9] Output: [1, 0, 0] It represents the number 99. Add 1 to the most significant bit, we get 100. The output will be [1, 0, 0]. Solution to The Problem Naive Approach The simple approach is that first convert the array into a number, add one to it, and return the result in the form of an array. But the approach is not applicable to the large array. So, we will process each digit one by one. Begin from the least significant bit and process each digit till the most significant bit. If the current digit is smaller than 9, add 1 to the current digit and return the array else assign zero to the current digit. If the last element is processed and it was also equal to 9, it means that all the digits were 9. So, we will increase the size of the array by one and assign 1 to the MSB. Return the resultant array. Plus One to Array Java Program PlusOneArray.java 
import java.util.Arrays; 
public class PlusOneArray
{
//function to add 1 to the array
public static int[] plusOne(int[] digits) 
{
int n = digits.length;
for(int i=n-1; i>=0; i--) 
{
if(digits[i] < 9) 
{
digits[i]++; 
return digits;
}
digits[i] = 0;
}
int[] newNumber = new int [n+1];
newNumber[0] = 1;
return newNumber;
}
//driver code
public static void main(String args[]) 
{
int [] arr = {6, 3, 8, 2}; 
//function calling
int[]ans=plusOne(arr); 
//prints the resultant array after adding 1 to MSB
System.out.println(Arrays.toString(ans));
}
}
 Output: [6, 3, 8, 3]
 Using Vector Another approach is using the vector. In this approach, we begin from the end of the vector. If the last element is 9, set it to 0, else exit from the loop. If all digits are 9, set 1 at starting, else increment the element at the position where the loop stopped. Note that no carry, division, and modulo is required. Let's implement the above approach in a Java program. PlusOneExample1.java 
import java.io.*;
import java.util.*;
public class PlusOneExample1
{
//function to add one to the array
static void plusOne(Vector<Integer> digits)
{
//initialize an index (digit of units)
int index= digits.size() - 1;
while (index >= 0 && digits.get(index) == 9)
{
//while the index is valid and the value at [index] == 9 set it as 0    
digits.set(index, 0);
//decement index by 1
index -= 1;
}
// if index < 0 (if all digits were 9)
if (index < 0)
{
//inserting 1 at the beginning of the vector 
digits.set(0, 1);
//adding an extra zero to the end of the vector 
digits.add(digits.size(),0);
}
//else increment the value at [index]
else
digits.set(index, digits.get(index) + 1);
}
//driver code
public static void main(String args[])
{
//creating an instance of the vector class and passing an array
Vector<Integer> digits = new Vector<Integer>(Arrays.asList(12, 45, 90, 34));
//function calling
plusOne(digits);
for (int digit : digits)
//prints the array after adding 1 to the array
System.out.print(digit + " ");
}
}
 Output: 12 45 90 35
 Let's see another approach. In this approach, first, we reverse the given array. After that take a carry variable to store the carry. Iterate over the array from starting and add 1. Carry to the value of that array at that index. Now check whether the value of that index is greater than equal to 9 or not. If yes, take the carry as the ten's value and the value at that index in the array will be the value present at the one place, else simply move on. 
if digits[i]>9 then carry = digits[i]/10 and digits[i]%=10
if digits[i]<=9 then carry = 0
 Repeat the above step until we reach the last element of the array. Note that if carry is not 0, simply add 1 to the array. At last, reverse the array, so that we can get the original array. Let's implement the above approach in a Java program. PlusOneExample2.java 
import java.io.*;
import java.util.*;
public class PlusOneExample2
{
//function to add one to the array    
public static void plusOne(Vector<Integer> digits, int n)
{
//revers the given array so that we can begin traversing from back
Collections.reverse(digits);
//defining a variable to store carry
int carry = 0;
for(int i = 0; i < n; i++)
{
//initially carry is 0, it is the base case
if(i == 0)
digits.set(i, digits.get(i) + 1 + carry);
//if carry is not equal to zero, add it to the array element at that position
else if(carry != 0)
digits.set(i, digits.get(i) + carry);
//now to get carry, i.e. if digits[i]>9 we get the value at tens place in carry or else if digits[i]<9 carry will be 0
carry = digits.get(i) / 10;
//now if carry is not equal to 0, so at that index, we should keep the value present at the ones place so we do digits[i]%10
if(carry != 0)digits.set(i, digits.get(i) % 10);
}
//after doing all that if carry is still there which means one more element is needed to be added to the array
if(carry != 0)
digits.set(digits.size() - 1, carry);
//again, revere the array so that we can get the original array
Collections.reverse(digits);
}
//driver code
public static void main (String args[])
{
//creating an instance of the vector class and passing an array
Vector<Integer> digits = new Vector<Integer>(Arrays.asList(9, 9, 9, 9, 9));
//determines the size of the array
int n = digits.size();
//function calling
plusOne(digits, n);
for(int i = 0; i < n; i++)
{
//prints the array after adding 1 to the array    
System.out.print(digits.get(i) + " ");
}
}
}
 Output: 1 0 0 0 0
 Complexity The time complexity of all the above approaches is O(n) because we have traversed over the array only once. Where n is the length of the array. The space complexity of the approach is O(1) if the array contains at least one digit smaller than 9, else O(n). Next TopicUnequal Adjacent Elements in Java ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/plus-one-to-array-problem-in-java Plus One to Array Problem in Java - Javatpoint ? SCROLL TO TOP Home Java Programs OOPs String Exception Multithreading Collections JavaFX JSP Spring Spring Boot Projects Interview Questions Java Tutorial What is Java History of Java Features of Java C++ vs Java Hello Java Program Program Internal How to set path? JDK, JRE and JVM JVM: Java Virtual Machine Java Variables Java Data Types Unicode System Operators Keywords Control Statements Java Control Statements Java If-else Java Switch Java For Loop Java While Loop Java Do While Loop Java Break Java Continue Java Comments Java Programs Java Object Class Java OOPs Concepts Naming Convention Object and Class Method Constructor static keyword this keyword Java Inheritance Inheritance(IS-A) Aggregation(HAS-A) Java Polymorphism Method Overloading Method Overriding Covariant Return Type super keyword Instance Initializer block final keyword Runtime Polymorphism Dynamic Binding instanceof operator Java Abstraction Abstract class Interface Abstract vs Interface Java Encapsulation Package Access Modifiers Encapsulation Java Array Java Array Java OOPs Misc Object class Object Cloning Math class Wrapper Class Java Recursion Call By Value strictfp keyword javadoc tool Command Line Arg Object vs Class Overloading vs Overriding Java String Java Regex Exception Handling Java Inner classes Java Multithreading Java I/O Java Networking Java AWT & Events Java Swing JavaFX Java Applet Java Reflection Java Date Java Conversion Java Collection Java JDBC Java Misc Java New Features RMI Internationalization Interview Questions Java MCQ next ? ? prev Plus One to Array Problem in Java It is a very interesting problem frequently asked in interviews of top IT companies like Google, Amazon, TCS, Accenture, Adobe, Apple, Infosys, etc. By solving the problem, one wants to check the logical ability, critical thinking, and problem-solving skill of the interviewee. So, in this section, we are going to add (plus) one to an array problem in Java with different approaches and logic. Also, we will create Java programs for the same. Problem Statement In this problem, we have given an array in which each element represents a digit and the complete array represents a number. The digits are ordered from MSB to LSB in left to right order. Assume that there is no leading 0's in the number. The task is to add 1 to the number and return the result in the form of an array of digits. Let's understand it through examples. Example Input: arr = [2, 5, 9, 7] Output: [2, 5, 9, 8] It represents the number 2597. Add 1 to the most significant bit, we get 2598. The output will be [2, 5, 9, 8]. Let's see another example. Input: arr = [9, 9] Output: [1, 0, 0] It represents the number 99. Add 1 to the most significant bit, we get 100. The output will be [1, 0, 0]. Solution to The Problem Naive Approach The simple approach is that first convert the array into a number, add one to it, and return the result in the form of an array. But the approach is not applicable to the large array. So, we will process each digit one by one. Begin from the least significant bit and process each digit till the most significant bit. If the current digit is smaller than 9, add 1 to the current digit and return the array else assign zero to the current digit. If the last element is processed and it was also equal to 9, it means that all the digits were 9. So, we will increase the size of the array by one and assign 1 to the MSB. Return the resultant array. Plus One to Array Java Program PlusOneArray.java 
import java.util.Arrays; 
public class PlusOneArray
{
//function to add 1 to the array
public static int[] plusOne(int[] digits) 
{
int n = digits.length;
for(int i=n-1; i>=0; i--) 
{
if(digits[i] < 9) 
{
digits[i]++; 
return digits;
}
digits[i] = 0;
}
int[] newNumber = new int [n+1];
newNumber[0] = 1;
return newNumber;
}
//driver code
public static void main(String args[]) 
{
int [] arr = {6, 3, 8, 2}; 
//function calling
int[]ans=plusOne(arr); 
//prints the resultant array after adding 1 to MSB
System.out.println(Arrays.toString(ans));
}
}
 Output: [6, 3, 8, 3]
 Using Vector Another approach is using the vector. In this approach, we begin from the end of the vector. If the last element is 9, set it to 0, else exit from the loop. If all digits are 9, set 1 at starting, else increment the element at the position where the loop stopped. Note that no carry, division, and modulo is required. Let's implement the above approach in a Java program. PlusOneExample1.java 
import java.io.*;
import java.util.*;
public class PlusOneExample1
{
//function to add one to the array
static void plusOne(Vector<Integer> digits)
{
//initialize an index (digit of units)
int index= digits.size() - 1;
while (index >= 0 && digits.get(index) == 9)
{
//while the index is valid and the value at [index] == 9 set it as 0    
digits.set(index, 0);
//decement index by 1
index -= 1;
}
// if index < 0 (if all digits were 9)
if (index < 0)
{
//inserting 1 at the beginning of the vector 
digits.set(0, 1);
//adding an extra zero to the end of the vector 
digits.add(digits.size(),0);
}
//else increment the value at [index]
else
digits.set(index, digits.get(index) + 1);
}
//driver code
public static void main(String args[])
{
//creating an instance of the vector class and passing an array
Vector<Integer> digits = new Vector<Integer>(Arrays.asList(12, 45, 90, 34));
//function calling
plusOne(digits);
for (int digit : digits)
//prints the array after adding 1 to the array
System.out.print(digit + " ");
}
}
 Output: 12 45 90 35
 Let's see another approach. In this approach, first, we reverse the given array. After that take a carry variable to store the carry. Iterate over the array from starting and add 1. Carry to the value of that array at that index. Now check whether the value of that index is greater than equal to 9 or not. If yes, take the carry as the ten's value and the value at that index in the array will be the value present at the one place, else simply move on. 
if digits[i]>9 then carry = digits[i]/10 and digits[i]%=10
if digits[i]<=9 then carry = 0
 Repeat the above step until we reach the last element of the array. Note that if carry is not 0, simply add 1 to the array. At last, reverse the array, so that we can get the original array. Let's implement the above approach in a Java program. PlusOneExample2.java 
import java.io.*;
import java.util.*;
public class PlusOneExample2
{
//function to add one to the array    
public static void plusOne(Vector<Integer> digits, int n)
{
//revers the given array so that we can begin traversing from back
Collections.reverse(digits);
//defining a variable to store carry
int carry = 0;
for(int i = 0; i < n; i++)
{
//initially carry is 0, it is the base case
if(i == 0)
digits.set(i, digits.get(i) + 1 + carry);
//if carry is not equal to zero, add it to the array element at that position
else if(carry != 0)
digits.set(i, digits.get(i) + carry);
//now to get carry, i.e. if digits[i]>9 we get the value at tens place in carry or else if digits[i]<9 carry will be 0
carry = digits.get(i) / 10;
//now if carry is not equal to 0, so at that index, we should keep the value present at the ones place so we do digits[i]%10
if(carry != 0)digits.set(i, digits.get(i) % 10);
}
//after doing all that if carry is still there which means one more element is needed to be added to the array
if(carry != 0)
digits.set(digits.size() - 1, carry);
//again, revere the array so that we can get the original array
Collections.reverse(digits);
}
//driver code
public static void main (String args[])
{
//creating an instance of the vector class and passing an array
Vector<Integer> digits = new Vector<Integer>(Arrays.asList(9, 9, 9, 9, 9));
//determines the size of the array
int n = digits.size();
//function calling
plusOne(digits, n);
for(int i = 0; i < n; i++)
{
//prints the array after adding 1 to the array    
System.out.print(digits.get(i) + " ");
}
}
}
 Output: 1 0 0 0 0
 Complexity The time complexity of all the above approaches is O(n) because we have traversed over the array only once. Where n is the length of the array. The space complexity of the approach is O(1) if the array contains at least one digit smaller than 9, else O(n). Next TopicUnequal Adjacent Elements in Java ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/plus-one-to-array-problem-in-java Plus One to Array Problem in Java - Javatpoint ? SCROLL TO TOP Home Java Programs OOPs String Exception Multithreading Collections JavaFX JSP Spring Spring Boot Projects Interview Questions Java Tutorial What is Java History of Java Features of Java C++ vs Java Hello Java Program Program Internal How to set path? JDK, JRE and JVM JVM: Java Virtual Machine Java Variables Java Data Types Unicode System Operators Keywords Control Statements Java Control Statements Java If-else Java Switch Java For Loop Java While Loop Java Do While Loop Java Break Java Continue Java Comments Java Programs Java Object Class Java OOPs Concepts Naming Convention Object and Class Method Constructor static keyword this keyword Java Inheritance Inheritance(IS-A) Aggregation(HAS-A) Java Polymorphism Method Overloading Method Overriding Covariant Return Type super keyword Instance Initializer block final keyword Runtime Polymorphism Dynamic Binding instanceof operator Java Abstraction Abstract class Interface Abstract vs Interface Java Encapsulation Package Access Modifiers Encapsulation Java Array Java Array Java OOPs Misc Object class Object Cloning Math class Wrapper Class Java Recursion Call By Value strictfp keyword javadoc tool Command Line Arg Object vs Class Overloading vs Overriding Java String Java Regex Exception Handling Java Inner classes Java Multithreading Java I/O Java Networking Java AWT & Events Java Swing JavaFX Java Applet Java Reflection Java Date Java Conversion Java Collection Java JDBC Java Misc Java New Features RMI Internationalization Interview Questions Java MCQ next ? ? prev Plus One to Array Problem in Java It is a very interesting problem frequently asked in interviews of top IT companies like Google, Amazon, TCS, Accenture, Adobe, Apple, Infosys, etc. By solving the problem, one wants to check the logical ability, critical thinking, and problem-solving skill of the interviewee. So, in this section, we are going to add (plus) one to an array problem in Java with different approaches and logic. Also, we will create Java programs for the same. Problem Statement In this problem, we have given an array in which each element represents a digit and the complete array represents a number. The digits are ordered from MSB to LSB in left to right order. Assume that there is no leading 0's in the number. The task is to add 1 to the number and return the result in the form of an array of digits. Let's understand it through examples. Example Input: arr = [2, 5, 9, 7] Output: [2, 5, 9, 8] It represents the number 2597. Add 1 to the most significant bit, we get 2598. The output will be [2, 5, 9, 8]. Let's see another example. Input: arr = [9, 9] Output: [1, 0, 0] It represents the number 99. Add 1 to the most significant bit, we get 100. The output will be [1, 0, 0]. Solution to The Problem Naive Approach The simple approach is that first convert the array into a number, add one to it, and return the result in the form of an array. But the approach is not applicable to the large array. So, we will process each digit one by one. Begin from the least significant bit and process each digit till the most significant bit. If the current digit is smaller than 9, add 1 to the current digit and return the array else assign zero to the current digit. If the last element is processed and it was also equal to 9, it means that all the digits were 9. So, we will increase the size of the array by one and assign 1 to the MSB. Return the resultant array. Plus One to Array Java Program PlusOneArray.java 
import java.util.Arrays; 
public class PlusOneArray
{
//function to add 1 to the array
public static int[] plusOne(int[] digits) 
{
int n = digits.length;
for(int i=n-1; i>=0; i--) 
{
if(digits[i] < 9) 
{
digits[i]++; 
return digits;
}
digits[i] = 0;
}
int[] newNumber = new int [n+1];
newNumber[0] = 1;
return newNumber;
}
//driver code
public static void main(String args[]) 
{
int [] arr = {6, 3, 8, 2}; 
//function calling
int[]ans=plusOne(arr); 
//prints the resultant array after adding 1 to MSB
System.out.println(Arrays.toString(ans));
}
}
 Output: [6, 3, 8, 3]
 Using Vector Another approach is using the vector. In this approach, we begin from the end of the vector. If the last element is 9, set it to 0, else exit from the loop. If all digits are 9, set 1 at starting, else increment the element at the position where the loop stopped. Note that no carry, division, and modulo is required. Let's implement the above approach in a Java program. PlusOneExample1.java 
import java.io.*;
import java.util.*;
public class PlusOneExample1
{
//function to add one to the array
static void plusOne(Vector<Integer> digits)
{
//initialize an index (digit of units)
int index= digits.size() - 1;
while (index >= 0 && digits.get(index) == 9)
{
//while the index is valid and the value at [index] == 9 set it as 0    
digits.set(index, 0);
//decement index by 1
index -= 1;
}
// if index < 0 (if all digits were 9)
if (index < 0)
{
//inserting 1 at the beginning of the vector 
digits.set(0, 1);
//adding an extra zero to the end of the vector 
digits.add(digits.size(),0);
}
//else increment the value at [index]
else
digits.set(index, digits.get(index) + 1);
}
//driver code
public static void main(String args[])
{
//creating an instance of the vector class and passing an array
Vector<Integer> digits = new Vector<Integer>(Arrays.asList(12, 45, 90, 34));
//function calling
plusOne(digits);
for (int digit : digits)
//prints the array after adding 1 to the array
System.out.print(digit + " ");
}
}
 Output: 12 45 90 35
 Let's see another approach. In this approach, first, we reverse the given array. After that take a carry variable to store the carry. Iterate over the array from starting and add 1. Carry to the value of that array at that index. Now check whether the value of that index is greater than equal to 9 or not. If yes, take the carry as the ten's value and the value at that index in the array will be the value present at the one place, else simply move on. 
if digits[i]>9 then carry = digits[i]/10 and digits[i]%=10
if digits[i]<=9 then carry = 0
 Repeat the above step until we reach the last element of the array. Note that if carry is not 0, simply add 1 to the array. At last, reverse the array, so that we can get the original array. Let's implement the above approach in a Java program. PlusOneExample2.java 
import java.io.*;
import java.util.*;
public class PlusOneExample2
{
//function to add one to the array    
public static void plusOne(Vector<Integer> digits, int n)
{
//revers the given array so that we can begin traversing from back
Collections.reverse(digits);
//defining a variable to store carry
int carry = 0;
for(int i = 0; i < n; i++)
{
//initially carry is 0, it is the base case
if(i == 0)
digits.set(i, digits.get(i) + 1 + carry);
//if carry is not equal to zero, add it to the array element at that position
else if(carry != 0)
digits.set(i, digits.get(i) + carry);
//now to get carry, i.e. if digits[i]>9 we get the value at tens place in carry or else if digits[i]<9 carry will be 0
carry = digits.get(i) / 10;
//now if carry is not equal to 0, so at that index, we should keep the value present at the ones place so we do digits[i]%10
if(carry != 0)digits.set(i, digits.get(i) % 10);
}
//after doing all that if carry is still there which means one more element is needed to be added to the array
if(carry != 0)
digits.set(digits.size() - 1, carry);
//again, revere the array so that we can get the original array
Collections.reverse(digits);
}
//driver code
public static void main (String args[])
{
//creating an instance of the vector class and passing an array
Vector<Integer> digits = new Vector<Integer>(Arrays.asList(9, 9, 9, 9, 9));
//determines the size of the array
int n = digits.size();
//function calling
plusOne(digits, n);
for(int i = 0; i < n; i++)
{
//prints the array after adding 1 to the array    
System.out.print(digits.get(i) + " ");
}
}
}
 Output: 1 0 0 0 0
 Complexity The time complexity of all the above approaches is O(n) because we have traversed over the array only once. Where n is the length of the array. The space complexity of the approach is O(1) if the array contains at least one digit smaller than 9, else O(n). Next TopicUnequal Adjacent Elements in Java ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/plus-one-to-array-problem-in-java Plus One to Array Problem in Java - Javatpoint ? SCROLL TO TOP Home Java Programs OOPs String Exception Multithreading Collections JavaFX JSP Spring Spring Boot Projects Interview Questions Java Tutorial What is Java History of Java Features of Java C++ vs Java Hello Java Program Program Internal How to set path? JDK, JRE and JVM JVM: Java Virtual Machine Java Variables Java Data Types Unicode System Operators Keywords Control Statements Java Control Statements Java If-else Java Switch Java For Loop Java While Loop Java Do While Loop Java Break Java Continue Java Comments Java Programs Java Object Class Java OOPs Concepts Naming Convention Object and Class Method Constructor static keyword this keyword Java Inheritance Inheritance(IS-A) Aggregation(HAS-A) Java Polymorphism Method Overloading Method Overriding Covariant Return Type super keyword Instance Initializer block final keyword Runtime Polymorphism Dynamic Binding instanceof operator Java Abstraction Abstract class Interface Abstract vs Interface Java Encapsulation Package Access Modifiers Encapsulation Java Array Java Array Java OOPs Misc Object class Object Cloning Math class Wrapper Class Java Recursion Call By Value strictfp keyword javadoc tool Command Line Arg Object vs Class Overloading vs Overriding Java String Java Regex Exception Handling Java Inner classes Java Multithreading Java I/O Java Networking Java AWT & Events Java Swing JavaFX Java Applet Java Reflection Java Date Java Conversion Java Collection Java JDBC Java Misc Java New Features RMI Internationalization Interview Questions Java MCQ next ? ? prev Plus One to Array Problem in Java It is a very interesting problem frequently asked in interviews of top IT companies like Google, Amazon, TCS, Accenture, Adobe, Apple, Infosys, etc. By solving the problem, one wants to check the logical ability, critical thinking, and problem-solving skill of the interviewee. So, in this section, we are going to add (plus) one to an array problem in Java with different approaches and logic. Also, we will create Java programs for the same. Problem Statement In this problem, we have given an array in which each element represents a digit and the complete array represents a number. The digits are ordered from MSB to LSB in left to right order. Assume that there is no leading 0's in the number. The task is to add 1 to the number and return the result in the form of an array of digits. Let's understand it through examples. Example Input: arr = [2, 5, 9, 7] Output: [2, 5, 9, 8] It represents the number 2597. Add 1 to the most significant bit, we get 2598. The output will be [2, 5, 9, 8]. Let's see another example. Input: arr = [9, 9] Output: [1, 0, 0] It represents the number 99. Add 1 to the most significant bit, we get 100. The output will be [1, 0, 0]. Solution to The Problem Naive Approach The simple approach is that first convert the array into a number, add one to it, and return the result in the form of an array. But the approach is not applicable to the large array. So, we will process each digit one by one. Begin from the least significant bit and process each digit till the most significant bit. If the current digit is smaller than 9, add 1 to the current digit and return the array else assign zero to the current digit. If the last element is processed and it was also equal to 9, it means that all the digits were 9. So, we will increase the size of the array by one and assign 1 to the MSB. Return the resultant array. Plus One to Array Java Program PlusOneArray.java 
import java.util.Arrays; 
public class PlusOneArray
{
//function to add 1 to the array
public static int[] plusOne(int[] digits) 
{
int n = digits.length;
for(int i=n-1; i>=0; i--) 
{
if(digits[i] < 9) 
{
digits[i]++; 
return digits;
}
digits[i] = 0;
}
int[] newNumber = new int [n+1];
newNumber[0] = 1;
return newNumber;
}
//driver code
public static void main(String args[]) 
{
int [] arr = {6, 3, 8, 2}; 
//function calling
int[]ans=plusOne(arr); 
//prints the resultant array after adding 1 to MSB
System.out.println(Arrays.toString(ans));
}
}
 Output: [6, 3, 8, 3]
 Using Vector Another approach is using the vector. In this approach, we begin from the end of the vector. If the last element is 9, set it to 0, else exit from the loop. If all digits are 9, set 1 at starting, else increment the element at the position where the loop stopped. Note that no carry, division, and modulo is required. Let's implement the above approach in a Java program. PlusOneExample1.java 
import java.io.*;
import java.util.*;
public class PlusOneExample1
{
//function to add one to the array
static void plusOne(Vector<Integer> digits)
{
//initialize an index (digit of units)
int index= digits.size() - 1;
while (index >= 0 && digits.get(index) == 9)
{
//while the index is valid and the value at [index] == 9 set it as 0    
digits.set(index, 0);
//decement index by 1
index -= 1;
}
// if index < 0 (if all digits were 9)
if (index < 0)
{
//inserting 1 at the beginning of the vector 
digits.set(0, 1);
//adding an extra zero to the end of the vector 
digits.add(digits.size(),0);
}
//else increment the value at [index]
else
digits.set(index, digits.get(index) + 1);
}
//driver code
public static void main(String args[])
{
//creating an instance of the vector class and passing an array
Vector<Integer> digits = new Vector<Integer>(Arrays.asList(12, 45, 90, 34));
//function calling
plusOne(digits);
for (int digit : digits)
//prints the array after adding 1 to the array
System.out.print(digit + " ");
}
}
 Output: 12 45 90 35
 Let's see another approach. In this approach, first, we reverse the given array. After that take a carry variable to store the carry. Iterate over the array from starting and add 1. Carry to the value of that array at that index. Now check whether the value of that index is greater than equal to 9 or not. If yes, take the carry as the ten's value and the value at that index in the array will be the value present at the one place, else simply move on. 
if digits[i]>9 then carry = digits[i]/10 and digits[i]%=10
if digits[i]<=9 then carry = 0
 Repeat the above step until we reach the last element of the array. Note that if carry is not 0, simply add 1 to the array. At last, reverse the array, so that we can get the original array. Let's implement the above approach in a Java program. PlusOneExample2.java 
import java.io.*;
import java.util.*;
public class PlusOneExample2
{
//function to add one to the array    
public static void plusOne(Vector<Integer> digits, int n)
{
//revers the given array so that we can begin traversing from back
Collections.reverse(digits);
//defining a variable to store carry
int carry = 0;
for(int i = 0; i < n; i++)
{
//initially carry is 0, it is the base case
if(i == 0)
digits.set(i, digits.get(i) + 1 + carry);
//if carry is not equal to zero, add it to the array element at that position
else if(carry != 0)
digits.set(i, digits.get(i) + carry);
//now to get carry, i.e. if digits[i]>9 we get the value at tens place in carry or else if digits[i]<9 carry will be 0
carry = digits.get(i) / 10;
//now if carry is not equal to 0, so at that index, we should keep the value present at the ones place so we do digits[i]%10
if(carry != 0)digits.set(i, digits.get(i) % 10);
}
//after doing all that if carry is still there which means one more element is needed to be added to the array
if(carry != 0)
digits.set(digits.size() - 1, carry);
//again, revere the array so that we can get the original array
Collections.reverse(digits);
}
//driver code
public static void main (String args[])
{
//creating an instance of the vector class and passing an array
Vector<Integer> digits = new Vector<Integer>(Arrays.asList(9, 9, 9, 9, 9));
//determines the size of the array
int n = digits.size();
//function calling
plusOne(digits, n);
for(int i = 0; i < n; i++)
{
//prints the array after adding 1 to the array    
System.out.print(digits.get(i) + " ");
}
}
}
 Output: 1 0 0 0 0
 Complexity The time complexity of all the above approaches is O(n) because we have traversed over the array only once. Where n is the length of the array. The space complexity of the approach is O(1) if the array contains at least one digit smaller than 9, else O(n). Next TopicUnequal Adjacent Elements in Java ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/plus-one-to-array-problem-in-java Plus One to Array Problem in Java - Javatpoint ? SCROLL TO TOP Home Java Programs OOPs String Exception Multithreading Collections JavaFX JSP Spring Spring Boot Projects Interview Questions Java Tutorial What is Java History of Java Features of Java C++ vs Java Hello Java Program Program Internal How to set path? JDK, JRE and JVM JVM: Java Virtual Machine Java Variables Java Data Types Unicode System Operators Keywords Control Statements Java Control Statements Java If-else Java Switch Java For Loop Java While Loop Java Do While Loop Java Break Java Continue Java Comments Java Programs Java Object Class Java OOPs Concepts Naming Convention Object and Class Method Constructor static keyword this keyword Java Inheritance Inheritance(IS-A) Aggregation(HAS-A) Java Polymorphism Method Overloading Method Overriding Covariant Return Type super keyword Instance Initializer block final keyword Runtime Polymorphism Dynamic Binding instanceof operator Java Abstraction Abstract class Interface Abstract vs Interface Java Encapsulation Package Access Modifiers Encapsulation Java Array Java Array Java OOPs Misc Object class Object Cloning Math class Wrapper Class Java Recursion Call By Value strictfp keyword javadoc tool Command Line Arg Object vs Class Overloading vs Overriding Java String Java Regex Exception Handling Java Inner classes Java Multithreading Java I/O Java Networking Java AWT & Events Java Swing JavaFX Java Applet Java Reflection Java Date Java Conversion Java Collection Java JDBC Java Misc Java New Features RMI Internationalization Interview Questions Java MCQ next ? ? prev Plus One to Array Problem in Java It is a very interesting problem frequently asked in interviews of top IT companies like Google, Amazon, TCS, Accenture, Adobe, Apple, Infosys, etc. By solving the problem, one wants to check the logical ability, critical thinking, and problem-solving skill of the interviewee. So, in this section, we are going to add (plus) one to an array problem in Java with different approaches and logic. Also, we will create Java programs for the same. Problem Statement In this problem, we have given an array in which each element represents a digit and the complete array represents a number. The digits are ordered from MSB to LSB in left to right order. Assume that there is no leading 0's in the number. The task is to add 1 to the number and return the result in the form of an array of digits. Let's understand it through examples. Example Input: arr = [2, 5, 9, 7] Output: [2, 5, 9, 8] It represents the number 2597. Add 1 to the most significant bit, we get 2598. The output will be [2, 5, 9, 8]. Let's see another example. Input: arr = [9, 9] Output: [1, 0, 0] It represents the number 99. Add 1 to the most significant bit, we get 100. The output will be [1, 0, 0]. Solution to The Problem Naive Approach The simple approach is that first convert the array into a number, add one to it, and return the result in the form of an array. But the approach is not applicable to the large array. So, we will process each digit one by one. Begin from the least significant bit and process each digit till the most significant bit. If the current digit is smaller than 9, add 1 to the current digit and return the array else assign zero to the current digit. If the last element is processed and it was also equal to 9, it means that all the digits were 9. So, we will increase the size of the array by one and assign 1 to the MSB. Return the resultant array. Plus One to Array Java Program PlusOneArray.java 
import java.util.Arrays; 
public class PlusOneArray
{
//function to add 1 to the array
public static int[] plusOne(int[] digits) 
{
int n = digits.length;
for(int i=n-1; i>=0; i--) 
{
if(digits[i] < 9) 
{
digits[i]++; 
return digits;
}
digits[i] = 0;
}
int[] newNumber = new int [n+1];
newNumber[0] = 1;
return newNumber;
}
//driver code
public static void main(String args[]) 
{
int [] arr = {6, 3, 8, 2}; 
//function calling
int[]ans=plusOne(arr); 
//prints the resultant array after adding 1 to MSB
System.out.println(Arrays.toString(ans));
}
}
 Output: [6, 3, 8, 3]
 Using Vector Another approach is using the vector. In this approach, we begin from the end of the vector. If the last element is 9, set it to 0, else exit from the loop. If all digits are 9, set 1 at starting, else increment the element at the position where the loop stopped. Note that no carry, division, and modulo is required. Let's implement the above approach in a Java program. PlusOneExample1.java 
import java.io.*;
import java.util.*;
public class PlusOneExample1
{
//function to add one to the array
static void plusOne(Vector<Integer> digits)
{
//initialize an index (digit of units)
int index= digits.size() - 1;
while (index >= 0 && digits.get(index) == 9)
{
//while the index is valid and the value at [index] == 9 set it as 0    
digits.set(index, 0);
//decement index by 1
index -= 1;
}
// if index < 0 (if all digits were 9)
if (index < 0)
{
//inserting 1 at the beginning of the vector 
digits.set(0, 1);
//adding an extra zero to the end of the vector 
digits.add(digits.size(),0);
}
//else increment the value at [index]
else
digits.set(index, digits.get(index) + 1);
}
//driver code
public static void main(String args[])
{
//creating an instance of the vector class and passing an array
Vector<Integer> digits = new Vector<Integer>(Arrays.asList(12, 45, 90, 34));
//function calling
plusOne(digits);
for (int digit : digits)
//prints the array after adding 1 to the array
System.out.print(digit + " ");
}
}
 Output: 12 45 90 35
 Let's see another approach. In this approach, first, we reverse the given array. After that take a carry variable to store the carry. Iterate over the array from starting and add 1. Carry to the value of that array at that index. Now check whether the value of that index is greater than equal to 9 or not. If yes, take the carry as the ten's value and the value at that index in the array will be the value present at the one place, else simply move on. 
if digits[i]>9 then carry = digits[i]/10 and digits[i]%=10
if digits[i]<=9 then carry = 0
 Repeat the above step until we reach the last element of the array. Note that if carry is not 0, simply add 1 to the array. At last, reverse the array, so that we can get the original array. Let's implement the above approach in a Java program. PlusOneExample2.java 
import java.io.*;
import java.util.*;
public class PlusOneExample2
{
//function to add one to the array    
public static void plusOne(Vector<Integer> digits, int n)
{
//revers the given array so that we can begin traversing from back
Collections.reverse(digits);
//defining a variable to store carry
int carry = 0;
for(int i = 0; i < n; i++)
{
//initially carry is 0, it is the base case
if(i == 0)
digits.set(i, digits.get(i) + 1 + carry);
//if carry is not equal to zero, add it to the array element at that position
else if(carry != 0)
digits.set(i, digits.get(i) + carry);
//now to get carry, i.e. if digits[i]>9 we get the value at tens place in carry or else if digits[i]<9 carry will be 0
carry = digits.get(i) / 10;
//now if carry is not equal to 0, so at that index, we should keep the value present at the ones place so we do digits[i]%10
if(carry != 0)digits.set(i, digits.get(i) % 10);
}
//after doing all that if carry is still there which means one more element is needed to be added to the array
if(carry != 0)
digits.set(digits.size() - 1, carry);
//again, revere the array so that we can get the original array
Collections.reverse(digits);
}
//driver code
public static void main (String args[])
{
//creating an instance of the vector class and passing an array
Vector<Integer> digits = new Vector<Integer>(Arrays.asList(9, 9, 9, 9, 9));
//determines the size of the array
int n = digits.size();
//function calling
plusOne(digits, n);
for(int i = 0; i < n; i++)
{
//prints the array after adding 1 to the array    
System.out.print(digits.get(i) + " ");
}
}
}
 Output: 1 0 0 0 0
 Complexity The time complexity of all the above approaches is O(n) because we have traversed over the array only once. Where n is the length of the array. The space complexity of the approach is O(1) if the array contains at least one digit smaller than 9, else O(n). Next TopicUnequal Adjacent Elements in Java ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/plus-one-to-array-problem-in-java Plus One to Array Problem in Java - Javatpoint ? SCROLL TO TOP Home Java Programs OOPs String Exception Multithreading Collections JavaFX JSP Spring Spring Boot Projects Interview Questions Java Tutorial What is Java History of Java Features of Java C++ vs Java Hello Java Program Program Internal How to set path? JDK, JRE and JVM JVM: Java Virtual Machine Java Variables Java Data Types Unicode System Operators Keywords Control Statements Java Control Statements Java If-else Java Switch Java For Loop Java While Loop Java Do While Loop Java Break Java Continue Java Comments Java Programs Java Object Class Java OOPs Concepts Naming Convention Object and Class Method Constructor static keyword this keyword Java Inheritance Inheritance(IS-A) Aggregation(HAS-A) Java Polymorphism Method Overloading Method Overriding Covariant Return Type super keyword Instance Initializer block final keyword Runtime Polymorphism Dynamic Binding instanceof operator Java Abstraction Abstract class Interface Abstract vs Interface Java Encapsulation Package Access Modifiers Encapsulation Java Array Java Array Java OOPs Misc Object class Object Cloning Math class Wrapper Class Java Recursion Call By Value strictfp keyword javadoc tool Command Line Arg Object vs Class Overloading vs Overriding Java String Java Regex Exception Handling Java Inner classes Java Multithreading Java I/O Java Networking Java AWT & Events Java Swing JavaFX Java Applet Java Reflection Java Date Java Conversion Java Collection Java JDBC Java Misc Java New Features RMI Internationalization Interview Questions Java MCQ next ? ? prev Plus One to Array Problem in Java It is a very interesting problem frequently asked in interviews of top IT companies like Google, Amazon, TCS, Accenture, Adobe, Apple, Infosys, etc. By solving the problem, one wants to check the logical ability, critical thinking, and problem-solving skill of the interviewee. So, in this section, we are going to add (plus) one to an array problem in Java with different approaches and logic. Also, we will create Java programs for the same. Problem Statement In this problem, we have given an array in which each element represents a digit and the complete array represents a number. The digits are ordered from MSB to LSB in left to right order. Assume that there is no leading 0's in the number. The task is to add 1 to the number and return the result in the form of an array of digits. Let's understand it through examples. Example Input: arr = [2, 5, 9, 7] Output: [2, 5, 9, 8] It represents the number 2597. Add 1 to the most significant bit, we get 2598. The output will be [2, 5, 9, 8]. Let's see another example. Input: arr = [9, 9] Output: [1, 0, 0] It represents the number 99. Add 1 to the most significant bit, we get 100. The output will be [1, 0, 0]. Solution to The Problem Naive Approach The simple approach is that first convert the array into a number, add one to it, and return the result in the form of an array. But the approach is not applicable to the large array. So, we will process each digit one by one. Begin from the least significant bit and process each digit till the most significant bit. If the current digit is smaller than 9, add 1 to the current digit and return the array else assign zero to the current digit. If the last element is processed and it was also equal to 9, it means that all the digits were 9. So, we will increase the size of the array by one and assign 1 to the MSB. Return the resultant array. Plus One to Array Java Program PlusOneArray.java 
import java.util.Arrays; 
public class PlusOneArray
{
//function to add 1 to the array
public static int[] plusOne(int[] digits) 
{
int n = digits.length;
for(int i=n-1; i>=0; i--) 
{
if(digits[i] < 9) 
{
digits[i]++; 
return digits;
}
digits[i] = 0;
}
int[] newNumber = new int [n+1];
newNumber[0] = 1;
return newNumber;
}
//driver code
public static void main(String args[]) 
{
int [] arr = {6, 3, 8, 2}; 
//function calling
int[]ans=plusOne(arr); 
//prints the resultant array after adding 1 to MSB
System.out.println(Arrays.toString(ans));
}
}
 Output: [6, 3, 8, 3]
 Using Vector Another approach is using the vector. In this approach, we begin from the end of the vector. If the last element is 9, set it to 0, else exit from the loop. If all digits are 9, set 1 at starting, else increment the element at the position where the loop stopped. Note that no carry, division, and modulo is required. Let's implement the above approach in a Java program. PlusOneExample1.java 
import java.io.*;
import java.util.*;
public class PlusOneExample1
{
//function to add one to the array
static void plusOne(Vector<Integer> digits)
{
//initialize an index (digit of units)
int index= digits.size() - 1;
while (index >= 0 && digits.get(index) == 9)
{
//while the index is valid and the value at [index] == 9 set it as 0    
digits.set(index, 0);
//decement index by 1
index -= 1;
}
// if index < 0 (if all digits were 9)
if (index < 0)
{
//inserting 1 at the beginning of the vector 
digits.set(0, 1);
//adding an extra zero to the end of the vector 
digits.add(digits.size(),0);
}
//else increment the value at [index]
else
digits.set(index, digits.get(index) + 1);
}
//driver code
public static void main(String args[])
{
//creating an instance of the vector class and passing an array
Vector<Integer> digits = new Vector<Integer>(Arrays.asList(12, 45, 90, 34));
//function calling
plusOne(digits);
for (int digit : digits)
//prints the array after adding 1 to the array
System.out.print(digit + " ");
}
}
 Output: 12 45 90 35
 Let's see another approach. In this approach, first, we reverse the given array. After that take a carry variable to store the carry. Iterate over the array from starting and add 1. Carry to the value of that array at that index. Now check whether the value of that index is greater than equal to 9 or not. If yes, take the carry as the ten's value and the value at that index in the array will be the value present at the one place, else simply move on. 
if digits[i]>9 then carry = digits[i]/10 and digits[i]%=10
if digits[i]<=9 then carry = 0
 Repeat the above step until we reach the last element of the array. Note that if carry is not 0, simply add 1 to the array. At last, reverse the array, so that we can get the original array. Let's implement the above approach in a Java program. PlusOneExample2.java 
import java.io.*;
import java.util.*;
public class PlusOneExample2
{
//function to add one to the array    
public static void plusOne(Vector<Integer> digits, int n)
{
//revers the given array so that we can begin traversing from back
Collections.reverse(digits);
//defining a variable to store carry
int carry = 0;
for(int i = 0; i < n; i++)
{
//initially carry is 0, it is the base case
if(i == 0)
digits.set(i, digits.get(i) + 1 + carry);
//if carry is not equal to zero, add it to the array element at that position
else if(carry != 0)
digits.set(i, digits.get(i) + carry);
//now to get carry, i.e. if digits[i]>9 we get the value at tens place in carry or else if digits[i]<9 carry will be 0
carry = digits.get(i) / 10;
//now if carry is not equal to 0, so at that index, we should keep the value present at the ones place so we do digits[i]%10
if(carry != 0)digits.set(i, digits.get(i) % 10);
}
//after doing all that if carry is still there which means one more element is needed to be added to the array
if(carry != 0)
digits.set(digits.size() - 1, carry);
//again, revere the array so that we can get the original array
Collections.reverse(digits);
}
//driver code
public static void main (String args[])
{
//creating an instance of the vector class and passing an array
Vector<Integer> digits = new Vector<Integer>(Arrays.asList(9, 9, 9, 9, 9));
//determines the size of the array
int n = digits.size();
//function calling
plusOne(digits, n);
for(int i = 0; i < n; i++)
{
//prints the array after adding 1 to the array    
System.out.print(digits.get(i) + " ");
}
}
}
 Output: 1 0 0 0 0
 Complexity The time complexity of all the above approaches is O(n) because we have traversed over the array only once. Where n is the length of the array. The space complexity of the approach is O(1) if the array contains at least one digit smaller than 9, else O(n). Next TopicUnequal Adjacent Elements in Java ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/plus-one-to-array-problem-in-java Plus One to Array Problem in Java - Javatpoint ? SCROLL TO TOP Home Java Programs OOPs String Exception Multithreading Collections JavaFX JSP Spring Spring Boot Projects Interview Questions Java Tutorial What is Java History of Java Features of Java C++ vs Java Hello Java Program Program Internal How to set path? JDK, JRE and JVM JVM: Java Virtual Machine Java Variables Java Data Types Unicode System Operators Keywords Control Statements Java Control Statements Java If-else Java Switch Java For Loop Java While Loop Java Do While Loop Java Break Java Continue Java Comments Java Programs Java Object Class Java OOPs Concepts Naming Convention Object and Class Method Constructor static keyword this keyword Java Inheritance Inheritance(IS-A) Aggregation(HAS-A) Java Polymorphism Method Overloading Method Overriding Covariant Return Type super keyword Instance Initializer block final keyword Runtime Polymorphism Dynamic Binding instanceof operator Java Abstraction Abstract class Interface Abstract vs Interface Java Encapsulation Package Access Modifiers Encapsulation Java Array Java Array Java OOPs Misc Object class Object Cloning Math class Wrapper Class Java Recursion Call By Value strictfp keyword javadoc tool Command Line Arg Object vs Class Overloading vs Overriding Java String Java Regex Exception Handling Java Inner classes Java Multithreading Java I/O Java Networking Java AWT & Events Java Swing JavaFX Java Applet Java Reflection Java Date Java Conversion Java Collection Java JDBC Java Misc Java New Features RMI Internationalization Interview Questions Java MCQ next ? ? prev Plus One to Array Problem in Java It is a very interesting problem frequently asked in interviews of top IT companies like Google, Amazon, TCS, Accenture, Adobe, Apple, Infosys, etc. By solving the problem, one wants to check the logical ability, critical thinking, and problem-solving skill of the interviewee. So, in this section, we are going to add (plus) one to an array problem in Java with different approaches and logic. Also, we will create Java programs for the same. Problem Statement In this problem, we have given an array in which each element represents a digit and the complete array represents a number. The digits are ordered from MSB to LSB in left to right order. Assume that there is no leading 0's in the number. The task is to add 1 to the number and return the result in the form of an array of digits. Let's understand it through examples. Example Input: arr = [2, 5, 9, 7] Output: [2, 5, 9, 8] It represents the number 2597. Add 1 to the most significant bit, we get 2598. The output will be [2, 5, 9, 8]. Let's see another example. Input: arr = [9, 9] Output: [1, 0, 0] It represents the number 99. Add 1 to the most significant bit, we get 100. The output will be [1, 0, 0]. Solution to The Problem Naive Approach The simple approach is that first convert the array into a number, add one to it, and return the result in the form of an array. But the approach is not applicable to the large array. So, we will process each digit one by one. Begin from the least significant bit and process each digit till the most significant bit. If the current digit is smaller than 9, add 1 to the current digit and return the array else assign zero to the current digit. If the last element is processed and it was also equal to 9, it means that all the digits were 9. So, we will increase the size of the array by one and assign 1 to the MSB. Return the resultant array. Plus One to Array Java Program PlusOneArray.java 
import java.util.Arrays; 
public class PlusOneArray
{
//function to add 1 to the array
public static int[] plusOne(int[] digits) 
{
int n = digits.length;
for(int i=n-1; i>=0; i--) 
{
if(digits[i] < 9) 
{
digits[i]++; 
return digits;
}
digits[i] = 0;
}
int[] newNumber = new int [n+1];
newNumber[0] = 1;
return newNumber;
}
//driver code
public static void main(String args[]) 
{
int [] arr = {6, 3, 8, 2}; 
//function calling
int[]ans=plusOne(arr); 
//prints the resultant array after adding 1 to MSB
System.out.println(Arrays.toString(ans));
}
}
 Output: [6, 3, 8, 3]
 Using Vector Another approach is using the vector. In this approach, we begin from the end of the vector. If the last element is 9, set it to 0, else exit from the loop. If all digits are 9, set 1 at starting, else increment the element at the position where the loop stopped. Note that no carry, division, and modulo is required. Let's implement the above approach in a Java program. PlusOneExample1.java 
import java.io.*;
import java.util.*;
public class PlusOneExample1
{
//function to add one to the array
static void plusOne(Vector<Integer> digits)
{
//initialize an index (digit of units)
int index= digits.size() - 1;
while (index >= 0 && digits.get(index) == 9)
{
//while the index is valid and the value at [index] == 9 set it as 0    
digits.set(index, 0);
//decement index by 1
index -= 1;
}
// if index < 0 (if all digits were 9)
if (index < 0)
{
//inserting 1 at the beginning of the vector 
digits.set(0, 1);
//adding an extra zero to the end of the vector 
digits.add(digits.size(),0);
}
//else increment the value at [index]
else
digits.set(index, digits.get(index) + 1);
}
//driver code
public static void main(String args[])
{
//creating an instance of the vector class and passing an array
Vector<Integer> digits = new Vector<Integer>(Arrays.asList(12, 45, 90, 34));
//function calling
plusOne(digits);
for (int digit : digits)
//prints the array after adding 1 to the array
System.out.print(digit + " ");
}
}
 Output: 12 45 90 35
 Let's see another approach. In this approach, first, we reverse the given array. After that take a carry variable to store the carry. Iterate over the array from starting and add 1. Carry to the value of that array at that index. Now check whether the value of that index is greater than equal to 9 or not. If yes, take the carry as the ten's value and the value at that index in the array will be the value present at the one place, else simply move on. 
if digits[i]>9 then carry = digits[i]/10 and digits[i]%=10
if digits[i]<=9 then carry = 0
 Repeat the above step until we reach the last element of the array. Note that if carry is not 0, simply add 1 to the array. At last, reverse the array, so that we can get the original array. Let's implement the above approach in a Java program. PlusOneExample2.java 
import java.io.*;
import java.util.*;
public class PlusOneExample2
{
//function to add one to the array    
public static void plusOne(Vector<Integer> digits, int n)
{
//revers the given array so that we can begin traversing from back
Collections.reverse(digits);
//defining a variable to store carry
int carry = 0;
for(int i = 0; i < n; i++)
{
//initially carry is 0, it is the base case
if(i == 0)
digits.set(i, digits.get(i) + 1 + carry);
//if carry is not equal to zero, add it to the array element at that position
else if(carry != 0)
digits.set(i, digits.get(i) + carry);
//now to get carry, i.e. if digits[i]>9 we get the value at tens place in carry or else if digits[i]<9 carry will be 0
carry = digits.get(i) / 10;
//now if carry is not equal to 0, so at that index, we should keep the value present at the ones place so we do digits[i]%10
if(carry != 0)digits.set(i, digits.get(i) % 10);
}
//after doing all that if carry is still there which means one more element is needed to be added to the array
if(carry != 0)
digits.set(digits.size() - 1, carry);
//again, revere the array so that we can get the original array
Collections.reverse(digits);
}
//driver code
public static void main (String args[])
{
//creating an instance of the vector class and passing an array
Vector<Integer> digits = new Vector<Integer>(Arrays.asList(9, 9, 9, 9, 9));
//determines the size of the array
int n = digits.size();
//function calling
plusOne(digits, n);
for(int i = 0; i < n; i++)
{
//prints the array after adding 1 to the array    
System.out.print(digits.get(i) + " ");
}
}
}
 Output: 1 0 0 0 0
 Complexity The time complexity of all the above approaches is O(n) because we have traversed over the array only once. Where n is the length of the array. The space complexity of the approach is O(1) if the array contains at least one digit smaller than 9, else O(n). Next TopicUnequal Adjacent Elements in Java ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.