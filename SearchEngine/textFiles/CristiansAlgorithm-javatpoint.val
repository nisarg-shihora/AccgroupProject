https://www.javatpoint.com/cristians-algorithm Cristian's Algorithm - javatpoint ? SCROLL TO TOP Home Computer Network DBMS DS DAA Operating Systems Computer Fundamentals Java Python HTML Selenium JavaScript jQuery Interview Q Computer Network Tutorial Introduction Features Architecture Components Computer Network Types Topologies Transmission Modes Models Models OSI Model TCP/IP Model Physical Layer Digital Transmission Transmission Media Guided Media UnGuided Media Multiplexing Switching Switching Modes Switching Techniques Data Link layer Data Link layer Error Detection Error Correction Data Link Controls Network Layer Network Layer Network Addressing Routing Network Layer Protocols Routing Algorithm Routing Algorithm Distance Vector Link State Routing Transport Layer Transport Layer Transport Layer Protocols Application Layer Application Layer Client & Server Model Application Protocols DNS FTP Telnet SMTP SNMP HTTP Network Security Security Privacy Digital Signature PGP Misc What is Router OSI vs TCP/IP TCP vs UDP TCP TCP Port IPv4 vs IPv6 ARP Packet Format ARP Table Working of ARP FTP Client FTP Commands FTP Server I2P Protocol Sliding Window Protocol SNMP SPI Protocol IP ARP Commands ARP Request ARP - Address Resolution Protocol ARP and its types TCP Retransmission CAN Protocol HTTP Status Codes HTTP vs HTTPS RIP Protocol UDP Protocol ICMP Protocol MQTT Protocol OSPF Protocol Stop & Wait Protocol IMAP Protocol POP Protocol CIFS DAS DIMM iSCSI NAS NFS NVMe SAN BGP Go-Back-N ARQ RJ Cable Connection-Oriented vs Connectionless Service CDMA vs GSM What is MAC Address Modem vs Router Switch vs Router USB 2.0 vs USB 3.0 CSMA CA vs CSMA CD Multiple Access Protocols URI vs URL IMAP vs. POP3 SSH Meaning UTP vs STP Status Code 400 MIME Protocol IP address What is a proxy server and how does it work How to set up and use a proxy server What is network security WWW is based on which model Proxy Server List Fundamentals of Computer Networking IP Address Format and Table Bus topology vs Ring topology Bus topology vs Star topology Circuit Switching vs Packet switching star vs ring topology Router vs Bridge TCP Connection Termination Image Steganography Network Neutrality Onion Routing ASA features Relabel-to-front Algorithm Types of Server Virtualization in Computer Network Access Lists (ACL) Digital Subscriber Line (DSL) Operating system based Virtualization Context based Access Control (CBAC) Cristian's Algorithm Service Set Identifier (SSID) in Computer Network Voice over Internet Protocol (VoIP) MCQ Computer Network MCQ Computer Network MCQ Part2 Interview Questions Networking Questions next ? ? prev Cristian's Algorithm Client processes synchronise time with a time server using Cristian's Algorithm, a clock synchronisation algorithm. While redundancy-prone distributed systems and applications do not work well with this algorithm, low-latency networks where round trip time is short relative to accuracy do. The time interval between the beginning of a Request and the conclusion of the corresponding Response is referred to as Round Trip Time in this context. An example mimicking the operation of Cristian's algorithm is provided below: Algorithm: The process on the client machine sends the clock server a request at time T 0 for the clock time (time at the server). In response to the client process's request, the clock server listens and responds with clock server time. The client process retrieves the response from the clock server at time T1 and uses the formula below to determine the synchronised client clock time. TCLIENT = TSERVER plus (T1 - T0)/2. where TCLIENT denotes the synchronised clock time, TSERVER denotes the clock time returned by the server, T0 denotes the time at which the client process sent the request, and T1 denotes the time at which the client process received the response The formula above is valid and reliable: Assuming that the network latency T0 and T1 are roughly equal, T1 - T0 denotes the total amount of time required by the network and server to transfer the request to the server, process it, and return the result to the client process. The difference between client-side and real-time time is no more than (T1 - T0)/2 seconds. We can infer from the aforementioned statement that the synchronisation error can only be (T1 - T0)/2 seconds at most. Hence, Error E [-(T 1 - T 0)/2, (T 1 - T 0)/2] The Python codes below demonstrate how Cristian's algorithm functions. To start a clock server prototype on a local machine, enter the following code: Python 
# Python3 program imitating a clock server

import socket
import datetime

# function used to initiate the Clock Server
def initiateClockServer():

	s = socket.socket()
	print("Socket successfully created")
	
	# Server port
	port = 8000

	s.bind(('', port))
	
	# Start listening to requests
	s.listen(5)	
	print("Socket is listening...")
	
	# Clock Server Running forever
	while True:
	
	# Establish connection with client
	connection, address = s.accept()	
	print('Server connected to', address)
	
	# Respond the client with server clock time
	connection.send(str(
					datetime.datetime.now()).encode())
	
	# Close the connection with the client process
	connection.close()


# Driver function
if __name__ == '__main__':

	# Trigger the Clock Server
	initiateClockServer()
 Output: Socket successfully created
Socket is listening...
 On the local machine, the following code runs a client process prototype: Python 
# Python3 program imitating a client process

import socket
import datetime
from dateutil import parser
from timeit import default_timer as timer

# function used to Synchronize client process time
def synchronizeTime():

	s = socket.socket()		
	
	# Server port
	port = 8000	
	
	# connect to the clock server on local computer
	s.connect(('127.0.0.1', port))

	request_time = timer()

	# receive data from the server
	server_time = parser.parse(s.recv(1024).decode())
	response_time = timer()
	actual_time = datetime.datetime.now()

	print("Time returned by server: " + str(server_time))

	process_delay_latency = response_time - request_time

	print("Process Delay latency: " \
		+ str(process_delay_latency) \
		+ " seconds")

	print("Actual clock time at client side: " \
		+ str(actual_time))

	# synchronize process client clock time
	client_time = server_time \
					+ datetime.timedelta(seconds = \
							(process_delay_latency) / 2)

	print("Synchronized process client time: " \
										+ str(client_time))

	# calculate synchronization error
	error = actual_time - client_time
	print("Synchronization error : "
				+ str(error.total_seconds()) + " seconds")

	s.close()	


# Driver function
if __name__ == '__main__':

	# synchronize time using clock server
	synchronizeTime()
 Output: Time returned by server: 2018-11-07 17:56:43.302379
Process Delay latency: 0.0005150819997652434 seconds
Actual clock time at client side: 2018-11-07 17:56:43.302756
Synchronized process client time: 2018-11-07 17:56:43.302637
Synchronization error : 0.000119 seconds
 We can define a minimum transfer time that we can use to create an improved synchronisation clock time through iterative testing over the network (less synchronisation error). The server time will always be generated after T0 + T min in this case, and TSERVER will always be generated before T1 - Tmin, where T min is the minimum transfer time, which is the minimum value of TREQUEST and TRESPONSE during several iterative tests. Here, a formulation of the synchronisation error is as follows: Error E [-((T1 - T0)/2-Tmin), ((T1 - T0)/2-Tmin)] Similar to this, if TREQUEST and TRESPONSE differ by a significant amount of time, TMIN1 and TMIN2 may be used in place of TMIN1 and TMIN2, respectively, where TMIN1 denotes the minimum observed request time and TMIN2 denotes the minimum observed response time over the network. In this scenario, the synchronised clock time can be calculated as follows: (T1 - T0)/2 + (Tmin2 - Tmin1)/2 +TSERVER = TCLIENT Therefore, we can improve clock time synchronisation and subsequently reduce the overall synchronisation error by simply introducing response and request time as separate time latencies. The total clock drift that is seen will determine how many iterative tests need to be performed. Next TopicService Set Identifier (SSID) in Computer Network ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/cristians-algorithm Cristian's Algorithm - javatpoint ? SCROLL TO TOP Home Computer Network DBMS DS DAA Operating Systems Computer Fundamentals Java Python HTML Selenium JavaScript jQuery Interview Q Computer Network Tutorial Introduction Features Architecture Components Computer Network Types Topologies Transmission Modes Models Models OSI Model TCP/IP Model Physical Layer Digital Transmission Transmission Media Guided Media UnGuided Media Multiplexing Switching Switching Modes Switching Techniques Data Link layer Data Link layer Error Detection Error Correction Data Link Controls Network Layer Network Layer Network Addressing Routing Network Layer Protocols Routing Algorithm Routing Algorithm Distance Vector Link State Routing Transport Layer Transport Layer Transport Layer Protocols Application Layer Application Layer Client & Server Model Application Protocols DNS FTP Telnet SMTP SNMP HTTP Network Security Security Privacy Digital Signature PGP Misc What is Router OSI vs TCP/IP TCP vs UDP TCP TCP Port IPv4 vs IPv6 ARP Packet Format ARP Table Working of ARP FTP Client FTP Commands FTP Server I2P Protocol Sliding Window Protocol SNMP SPI Protocol IP ARP Commands ARP Request ARP - Address Resolution Protocol ARP and its types TCP Retransmission CAN Protocol HTTP Status Codes HTTP vs HTTPS RIP Protocol UDP Protocol ICMP Protocol MQTT Protocol OSPF Protocol Stop & Wait Protocol IMAP Protocol POP Protocol CIFS DAS DIMM iSCSI NAS NFS NVMe SAN BGP Go-Back-N ARQ RJ Cable Connection-Oriented vs Connectionless Service CDMA vs GSM What is MAC Address Modem vs Router Switch vs Router USB 2.0 vs USB 3.0 CSMA CA vs CSMA CD Multiple Access Protocols URI vs URL IMAP vs. POP3 SSH Meaning UTP vs STP Status Code 400 MIME Protocol IP address What is a proxy server and how does it work How to set up and use a proxy server What is network security WWW is based on which model Proxy Server List Fundamentals of Computer Networking IP Address Format and Table Bus topology vs Ring topology Bus topology vs Star topology Circuit Switching vs Packet switching star vs ring topology Router vs Bridge TCP Connection Termination Image Steganography Network Neutrality Onion Routing ASA features Relabel-to-front Algorithm Types of Server Virtualization in Computer Network Access Lists (ACL) Digital Subscriber Line (DSL) Operating system based Virtualization Context based Access Control (CBAC) Cristian's Algorithm Service Set Identifier (SSID) in Computer Network Voice over Internet Protocol (VoIP) MCQ Computer Network MCQ Computer Network MCQ Part2 Interview Questions Networking Questions next ? ? prev Cristian's Algorithm Client processes synchronise time with a time server using Cristian's Algorithm, a clock synchronisation algorithm. While redundancy-prone distributed systems and applications do not work well with this algorithm, low-latency networks where round trip time is short relative to accuracy do. The time interval between the beginning of a Request and the conclusion of the corresponding Response is referred to as Round Trip Time in this context. An example mimicking the operation of Cristian's algorithm is provided below: Algorithm: The process on the client machine sends the clock server a request at time T 0 for the clock time (time at the server). In response to the client process's request, the clock server listens and responds with clock server time. The client process retrieves the response from the clock server at time T1 and uses the formula below to determine the synchronised client clock time. TCLIENT = TSERVER plus (T1 - T0)/2. where TCLIENT denotes the synchronised clock time, TSERVER denotes the clock time returned by the server, T0 denotes the time at which the client process sent the request, and T1 denotes the time at which the client process received the response The formula above is valid and reliable: Assuming that the network latency T0 and T1 are roughly equal, T1 - T0 denotes the total amount of time required by the network and server to transfer the request to the server, process it, and return the result to the client process. The difference between client-side and real-time time is no more than (T1 - T0)/2 seconds. We can infer from the aforementioned statement that the synchronisation error can only be (T1 - T0)/2 seconds at most. Hence, Error E [-(T 1 - T 0)/2, (T 1 - T 0)/2] The Python codes below demonstrate how Cristian's algorithm functions. To start a clock server prototype on a local machine, enter the following code: Python 
# Python3 program imitating a clock server

import socket
import datetime

# function used to initiate the Clock Server
def initiateClockServer():

	s = socket.socket()
	print("Socket successfully created")
	
	# Server port
	port = 8000

	s.bind(('', port))
	
	# Start listening to requests
	s.listen(5)	
	print("Socket is listening...")
	
	# Clock Server Running forever
	while True:
	
	# Establish connection with client
	connection, address = s.accept()	
	print('Server connected to', address)
	
	# Respond the client with server clock time
	connection.send(str(
					datetime.datetime.now()).encode())
	
	# Close the connection with the client process
	connection.close()


# Driver function
if __name__ == '__main__':

	# Trigger the Clock Server
	initiateClockServer()
 Output: Socket successfully created
Socket is listening...
 On the local machine, the following code runs a client process prototype: Python 
# Python3 program imitating a client process

import socket
import datetime
from dateutil import parser
from timeit import default_timer as timer

# function used to Synchronize client process time
def synchronizeTime():

	s = socket.socket()		
	
	# Server port
	port = 8000	
	
	# connect to the clock server on local computer
	s.connect(('127.0.0.1', port))

	request_time = timer()

	# receive data from the server
	server_time = parser.parse(s.recv(1024).decode())
	response_time = timer()
	actual_time = datetime.datetime.now()

	print("Time returned by server: " + str(server_time))

	process_delay_latency = response_time - request_time

	print("Process Delay latency: " \
		+ str(process_delay_latency) \
		+ " seconds")

	print("Actual clock time at client side: " \
		+ str(actual_time))

	# synchronize process client clock time
	client_time = server_time \
					+ datetime.timedelta(seconds = \
							(process_delay_latency) / 2)

	print("Synchronized process client time: " \
										+ str(client_time))

	# calculate synchronization error
	error = actual_time - client_time
	print("Synchronization error : "
				+ str(error.total_seconds()) + " seconds")

	s.close()	


# Driver function
if __name__ == '__main__':

	# synchronize time using clock server
	synchronizeTime()
 Output: Time returned by server: 2018-11-07 17:56:43.302379
Process Delay latency: 0.0005150819997652434 seconds
Actual clock time at client side: 2018-11-07 17:56:43.302756
Synchronized process client time: 2018-11-07 17:56:43.302637
Synchronization error : 0.000119 seconds
 We can define a minimum transfer time that we can use to create an improved synchronisation clock time through iterative testing over the network (less synchronisation error). The server time will always be generated after T0 + T min in this case, and TSERVER will always be generated before T1 - Tmin, where T min is the minimum transfer time, which is the minimum value of TREQUEST and TRESPONSE during several iterative tests. Here, a formulation of the synchronisation error is as follows: Error E [-((T1 - T0)/2-Tmin), ((T1 - T0)/2-Tmin)] Similar to this, if TREQUEST and TRESPONSE differ by a significant amount of time, TMIN1 and TMIN2 may be used in place of TMIN1 and TMIN2, respectively, where TMIN1 denotes the minimum observed request time and TMIN2 denotes the minimum observed response time over the network. In this scenario, the synchronised clock time can be calculated as follows: (T1 - T0)/2 + (Tmin2 - Tmin1)/2 +TSERVER = TCLIENT Therefore, we can improve clock time synchronisation and subsequently reduce the overall synchronisation error by simply introducing response and request time as separate time latencies. The total clock drift that is seen will determine how many iterative tests need to be performed. Next TopicService Set Identifier (SSID) in Computer Network ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/cristians-algorithm Cristian's Algorithm - javatpoint ? SCROLL TO TOP Home Computer Network DBMS DS DAA Operating Systems Computer Fundamentals Java Python HTML Selenium JavaScript jQuery Interview Q Computer Network Tutorial Introduction Features Architecture Components Computer Network Types Topologies Transmission Modes Models Models OSI Model TCP/IP Model Physical Layer Digital Transmission Transmission Media Guided Media UnGuided Media Multiplexing Switching Switching Modes Switching Techniques Data Link layer Data Link layer Error Detection Error Correction Data Link Controls Network Layer Network Layer Network Addressing Routing Network Layer Protocols Routing Algorithm Routing Algorithm Distance Vector Link State Routing Transport Layer Transport Layer Transport Layer Protocols Application Layer Application Layer Client & Server Model Application Protocols DNS FTP Telnet SMTP SNMP HTTP Network Security Security Privacy Digital Signature PGP Misc What is Router OSI vs TCP/IP TCP vs UDP TCP TCP Port IPv4 vs IPv6 ARP Packet Format ARP Table Working of ARP FTP Client FTP Commands FTP Server I2P Protocol Sliding Window Protocol SNMP SPI Protocol IP ARP Commands ARP Request ARP - Address Resolution Protocol ARP and its types TCP Retransmission CAN Protocol HTTP Status Codes HTTP vs HTTPS RIP Protocol UDP Protocol ICMP Protocol MQTT Protocol OSPF Protocol Stop & Wait Protocol IMAP Protocol POP Protocol CIFS DAS DIMM iSCSI NAS NFS NVMe SAN BGP Go-Back-N ARQ RJ Cable Connection-Oriented vs Connectionless Service CDMA vs GSM What is MAC Address Modem vs Router Switch vs Router USB 2.0 vs USB 3.0 CSMA CA vs CSMA CD Multiple Access Protocols URI vs URL IMAP vs. POP3 SSH Meaning UTP vs STP Status Code 400 MIME Protocol IP address What is a proxy server and how does it work How to set up and use a proxy server What is network security WWW is based on which model Proxy Server List Fundamentals of Computer Networking IP Address Format and Table Bus topology vs Ring topology Bus topology vs Star topology Circuit Switching vs Packet switching star vs ring topology Router vs Bridge TCP Connection Termination Image Steganography Network Neutrality Onion Routing ASA features Relabel-to-front Algorithm Types of Server Virtualization in Computer Network Access Lists (ACL) Digital Subscriber Line (DSL) Operating system based Virtualization Context based Access Control (CBAC) Cristian's Algorithm Service Set Identifier (SSID) in Computer Network Voice over Internet Protocol (VoIP) MCQ Computer Network MCQ Computer Network MCQ Part2 Interview Questions Networking Questions next ? ? prev Cristian's Algorithm Client processes synchronise time with a time server using Cristian's Algorithm, a clock synchronisation algorithm. While redundancy-prone distributed systems and applications do not work well with this algorithm, low-latency networks where round trip time is short relative to accuracy do. The time interval between the beginning of a Request and the conclusion of the corresponding Response is referred to as Round Trip Time in this context. An example mimicking the operation of Cristian's algorithm is provided below: Algorithm: The process on the client machine sends the clock server a request at time T 0 for the clock time (time at the server). In response to the client process's request, the clock server listens and responds with clock server time. The client process retrieves the response from the clock server at time T1 and uses the formula below to determine the synchronised client clock time. TCLIENT = TSERVER plus (T1 - T0)/2. where TCLIENT denotes the synchronised clock time, TSERVER denotes the clock time returned by the server, T0 denotes the time at which the client process sent the request, and T1 denotes the time at which the client process received the response The formula above is valid and reliable: Assuming that the network latency T0 and T1 are roughly equal, T1 - T0 denotes the total amount of time required by the network and server to transfer the request to the server, process it, and return the result to the client process. The difference between client-side and real-time time is no more than (T1 - T0)/2 seconds. We can infer from the aforementioned statement that the synchronisation error can only be (T1 - T0)/2 seconds at most. Hence, Error E [-(T 1 - T 0)/2, (T 1 - T 0)/2] The Python codes below demonstrate how Cristian's algorithm functions. To start a clock server prototype on a local machine, enter the following code: Python 
# Python3 program imitating a clock server

import socket
import datetime

# function used to initiate the Clock Server
def initiateClockServer():

	s = socket.socket()
	print("Socket successfully created")
	
	# Server port
	port = 8000

	s.bind(('', port))
	
	# Start listening to requests
	s.listen(5)	
	print("Socket is listening...")
	
	# Clock Server Running forever
	while True:
	
	# Establish connection with client
	connection, address = s.accept()	
	print('Server connected to', address)
	
	# Respond the client with server clock time
	connection.send(str(
					datetime.datetime.now()).encode())
	
	# Close the connection with the client process
	connection.close()


# Driver function
if __name__ == '__main__':

	# Trigger the Clock Server
	initiateClockServer()
 Output: Socket successfully created
Socket is listening...
 On the local machine, the following code runs a client process prototype: Python 
# Python3 program imitating a client process

import socket
import datetime
from dateutil import parser
from timeit import default_timer as timer

# function used to Synchronize client process time
def synchronizeTime():

	s = socket.socket()		
	
	# Server port
	port = 8000	
	
	# connect to the clock server on local computer
	s.connect(('127.0.0.1', port))

	request_time = timer()

	# receive data from the server
	server_time = parser.parse(s.recv(1024).decode())
	response_time = timer()
	actual_time = datetime.datetime.now()

	print("Time returned by server: " + str(server_time))

	process_delay_latency = response_time - request_time

	print("Process Delay latency: " \
		+ str(process_delay_latency) \
		+ " seconds")

	print("Actual clock time at client side: " \
		+ str(actual_time))

	# synchronize process client clock time
	client_time = server_time \
					+ datetime.timedelta(seconds = \
							(process_delay_latency) / 2)

	print("Synchronized process client time: " \
										+ str(client_time))

	# calculate synchronization error
	error = actual_time - client_time
	print("Synchronization error : "
				+ str(error.total_seconds()) + " seconds")

	s.close()	


# Driver function
if __name__ == '__main__':

	# synchronize time using clock server
	synchronizeTime()
 Output: Time returned by server: 2018-11-07 17:56:43.302379
Process Delay latency: 0.0005150819997652434 seconds
Actual clock time at client side: 2018-11-07 17:56:43.302756
Synchronized process client time: 2018-11-07 17:56:43.302637
Synchronization error : 0.000119 seconds
 We can define a minimum transfer time that we can use to create an improved synchronisation clock time through iterative testing over the network (less synchronisation error). The server time will always be generated after T0 + T min in this case, and TSERVER will always be generated before T1 - Tmin, where T min is the minimum transfer time, which is the minimum value of TREQUEST and TRESPONSE during several iterative tests. Here, a formulation of the synchronisation error is as follows: Error E [-((T1 - T0)/2-Tmin), ((T1 - T0)/2-Tmin)] Similar to this, if TREQUEST and TRESPONSE differ by a significant amount of time, TMIN1 and TMIN2 may be used in place of TMIN1 and TMIN2, respectively, where TMIN1 denotes the minimum observed request time and TMIN2 denotes the minimum observed response time over the network. In this scenario, the synchronised clock time can be calculated as follows: (T1 - T0)/2 + (Tmin2 - Tmin1)/2 +TSERVER = TCLIENT Therefore, we can improve clock time synchronisation and subsequently reduce the overall synchronisation error by simply introducing response and request time as separate time latencies. The total clock drift that is seen will determine how many iterative tests need to be performed. Next TopicService Set Identifier (SSID) in Computer Network ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/cristians-algorithm Cristian's Algorithm - javatpoint ? SCROLL TO TOP Home Computer Network DBMS DS DAA Operating Systems Computer Fundamentals Java Python HTML Selenium JavaScript jQuery Interview Q Computer Network Tutorial Introduction Features Architecture Components Computer Network Types Topologies Transmission Modes Models Models OSI Model TCP/IP Model Physical Layer Digital Transmission Transmission Media Guided Media UnGuided Media Multiplexing Switching Switching Modes Switching Techniques Data Link layer Data Link layer Error Detection Error Correction Data Link Controls Network Layer Network Layer Network Addressing Routing Network Layer Protocols Routing Algorithm Routing Algorithm Distance Vector Link State Routing Transport Layer Transport Layer Transport Layer Protocols Application Layer Application Layer Client & Server Model Application Protocols DNS FTP Telnet SMTP SNMP HTTP Network Security Security Privacy Digital Signature PGP Misc What is Router OSI vs TCP/IP TCP vs UDP TCP TCP Port IPv4 vs IPv6 ARP Packet Format ARP Table Working of ARP FTP Client FTP Commands FTP Server I2P Protocol Sliding Window Protocol SNMP SPI Protocol IP ARP Commands ARP Request ARP - Address Resolution Protocol ARP and its types TCP Retransmission CAN Protocol HTTP Status Codes HTTP vs HTTPS RIP Protocol UDP Protocol ICMP Protocol MQTT Protocol OSPF Protocol Stop & Wait Protocol IMAP Protocol POP Protocol CIFS DAS DIMM iSCSI NAS NFS NVMe SAN BGP Go-Back-N ARQ RJ Cable Connection-Oriented vs Connectionless Service CDMA vs GSM What is MAC Address Modem vs Router Switch vs Router USB 2.0 vs USB 3.0 CSMA CA vs CSMA CD Multiple Access Protocols URI vs URL IMAP vs. POP3 SSH Meaning UTP vs STP Status Code 400 MIME Protocol IP address What is a proxy server and how does it work How to set up and use a proxy server What is network security WWW is based on which model Proxy Server List Fundamentals of Computer Networking IP Address Format and Table Bus topology vs Ring topology Bus topology vs Star topology Circuit Switching vs Packet switching star vs ring topology Router vs Bridge TCP Connection Termination Image Steganography Network Neutrality Onion Routing ASA features Relabel-to-front Algorithm Types of Server Virtualization in Computer Network Access Lists (ACL) Digital Subscriber Line (DSL) Operating system based Virtualization Context based Access Control (CBAC) Cristian's Algorithm Service Set Identifier (SSID) in Computer Network Voice over Internet Protocol (VoIP) MCQ Computer Network MCQ Computer Network MCQ Part2 Interview Questions Networking Questions next ? ? prev Cristian's Algorithm Client processes synchronise time with a time server using Cristian's Algorithm, a clock synchronisation algorithm. While redundancy-prone distributed systems and applications do not work well with this algorithm, low-latency networks where round trip time is short relative to accuracy do. The time interval between the beginning of a Request and the conclusion of the corresponding Response is referred to as Round Trip Time in this context. An example mimicking the operation of Cristian's algorithm is provided below: Algorithm: The process on the client machine sends the clock server a request at time T 0 for the clock time (time at the server). In response to the client process's request, the clock server listens and responds with clock server time. The client process retrieves the response from the clock server at time T1 and uses the formula below to determine the synchronised client clock time. TCLIENT = TSERVER plus (T1 - T0)/2. where TCLIENT denotes the synchronised clock time, TSERVER denotes the clock time returned by the server, T0 denotes the time at which the client process sent the request, and T1 denotes the time at which the client process received the response The formula above is valid and reliable: Assuming that the network latency T0 and T1 are roughly equal, T1 - T0 denotes the total amount of time required by the network and server to transfer the request to the server, process it, and return the result to the client process. The difference between client-side and real-time time is no more than (T1 - T0)/2 seconds. We can infer from the aforementioned statement that the synchronisation error can only be (T1 - T0)/2 seconds at most. Hence, Error E [-(T 1 - T 0)/2, (T 1 - T 0)/2] The Python codes below demonstrate how Cristian's algorithm functions. To start a clock server prototype on a local machine, enter the following code: Python 
# Python3 program imitating a clock server

import socket
import datetime

# function used to initiate the Clock Server
def initiateClockServer():

	s = socket.socket()
	print("Socket successfully created")
	
	# Server port
	port = 8000

	s.bind(('', port))
	
	# Start listening to requests
	s.listen(5)	
	print("Socket is listening...")
	
	# Clock Server Running forever
	while True:
	
	# Establish connection with client
	connection, address = s.accept()	
	print('Server connected to', address)
	
	# Respond the client with server clock time
	connection.send(str(
					datetime.datetime.now()).encode())
	
	# Close the connection with the client process
	connection.close()


# Driver function
if __name__ == '__main__':

	# Trigger the Clock Server
	initiateClockServer()
 Output: Socket successfully created
Socket is listening...
 On the local machine, the following code runs a client process prototype: Python 
# Python3 program imitating a client process

import socket
import datetime
from dateutil import parser
from timeit import default_timer as timer

# function used to Synchronize client process time
def synchronizeTime():

	s = socket.socket()		
	
	# Server port
	port = 8000	
	
	# connect to the clock server on local computer
	s.connect(('127.0.0.1', port))

	request_time = timer()

	# receive data from the server
	server_time = parser.parse(s.recv(1024).decode())
	response_time = timer()
	actual_time = datetime.datetime.now()

	print("Time returned by server: " + str(server_time))

	process_delay_latency = response_time - request_time

	print("Process Delay latency: " \
		+ str(process_delay_latency) \
		+ " seconds")

	print("Actual clock time at client side: " \
		+ str(actual_time))

	# synchronize process client clock time
	client_time = server_time \
					+ datetime.timedelta(seconds = \
							(process_delay_latency) / 2)

	print("Synchronized process client time: " \
										+ str(client_time))

	# calculate synchronization error
	error = actual_time - client_time
	print("Synchronization error : "
				+ str(error.total_seconds()) + " seconds")

	s.close()	


# Driver function
if __name__ == '__main__':

	# synchronize time using clock server
	synchronizeTime()
 Output: Time returned by server: 2018-11-07 17:56:43.302379
Process Delay latency: 0.0005150819997652434 seconds
Actual clock time at client side: 2018-11-07 17:56:43.302756
Synchronized process client time: 2018-11-07 17:56:43.302637
Synchronization error : 0.000119 seconds
 We can define a minimum transfer time that we can use to create an improved synchronisation clock time through iterative testing over the network (less synchronisation error). The server time will always be generated after T0 + T min in this case, and TSERVER will always be generated before T1 - Tmin, where T min is the minimum transfer time, which is the minimum value of TREQUEST and TRESPONSE during several iterative tests. Here, a formulation of the synchronisation error is as follows: Error E [-((T1 - T0)/2-Tmin), ((T1 - T0)/2-Tmin)] Similar to this, if TREQUEST and TRESPONSE differ by a significant amount of time, TMIN1 and TMIN2 may be used in place of TMIN1 and TMIN2, respectively, where TMIN1 denotes the minimum observed request time and TMIN2 denotes the minimum observed response time over the network. In this scenario, the synchronised clock time can be calculated as follows: (T1 - T0)/2 + (Tmin2 - Tmin1)/2 +TSERVER = TCLIENT Therefore, we can improve clock time synchronisation and subsequently reduce the overall synchronisation error by simply introducing response and request time as separate time latencies. The total clock drift that is seen will determine how many iterative tests need to be performed. Next TopicService Set Identifier (SSID) in Computer Network ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/cristians-algorithm Cristian's Algorithm - javatpoint ? SCROLL TO TOP Home Computer Network DBMS DS DAA Operating Systems Computer Fundamentals Java Python HTML Selenium JavaScript jQuery Interview Q Computer Network Tutorial Introduction Features Architecture Components Computer Network Types Topologies Transmission Modes Models Models OSI Model TCP/IP Model Physical Layer Digital Transmission Transmission Media Guided Media UnGuided Media Multiplexing Switching Switching Modes Switching Techniques Data Link layer Data Link layer Error Detection Error Correction Data Link Controls Network Layer Network Layer Network Addressing Routing Network Layer Protocols Routing Algorithm Routing Algorithm Distance Vector Link State Routing Transport Layer Transport Layer Transport Layer Protocols Application Layer Application Layer Client & Server Model Application Protocols DNS FTP Telnet SMTP SNMP HTTP Network Security Security Privacy Digital Signature PGP Misc What is Router OSI vs TCP/IP TCP vs UDP TCP TCP Port IPv4 vs IPv6 ARP Packet Format ARP Table Working of ARP FTP Client FTP Commands FTP Server I2P Protocol Sliding Window Protocol SNMP SPI Protocol IP ARP Commands ARP Request ARP - Address Resolution Protocol ARP and its types TCP Retransmission CAN Protocol HTTP Status Codes HTTP vs HTTPS RIP Protocol UDP Protocol ICMP Protocol MQTT Protocol OSPF Protocol Stop & Wait Protocol IMAP Protocol POP Protocol CIFS DAS DIMM iSCSI NAS NFS NVMe SAN BGP Go-Back-N ARQ RJ Cable Connection-Oriented vs Connectionless Service CDMA vs GSM What is MAC Address Modem vs Router Switch vs Router USB 2.0 vs USB 3.0 CSMA CA vs CSMA CD Multiple Access Protocols URI vs URL IMAP vs. POP3 SSH Meaning UTP vs STP Status Code 400 MIME Protocol IP address What is a proxy server and how does it work How to set up and use a proxy server What is network security WWW is based on which model Proxy Server List Fundamentals of Computer Networking IP Address Format and Table Bus topology vs Ring topology Bus topology vs Star topology Circuit Switching vs Packet switching star vs ring topology Router vs Bridge TCP Connection Termination Image Steganography Network Neutrality Onion Routing ASA features Relabel-to-front Algorithm Types of Server Virtualization in Computer Network Access Lists (ACL) Digital Subscriber Line (DSL) Operating system based Virtualization Context based Access Control (CBAC) Cristian's Algorithm Service Set Identifier (SSID) in Computer Network Voice over Internet Protocol (VoIP) MCQ Computer Network MCQ Computer Network MCQ Part2 Interview Questions Networking Questions next ? ? prev Cristian's Algorithm Client processes synchronise time with a time server using Cristian's Algorithm, a clock synchronisation algorithm. While redundancy-prone distributed systems and applications do not work well with this algorithm, low-latency networks where round trip time is short relative to accuracy do. The time interval between the beginning of a Request and the conclusion of the corresponding Response is referred to as Round Trip Time in this context. An example mimicking the operation of Cristian's algorithm is provided below: Algorithm: The process on the client machine sends the clock server a request at time T 0 for the clock time (time at the server). In response to the client process's request, the clock server listens and responds with clock server time. The client process retrieves the response from the clock server at time T1 and uses the formula below to determine the synchronised client clock time. TCLIENT = TSERVER plus (T1 - T0)/2. where TCLIENT denotes the synchronised clock time, TSERVER denotes the clock time returned by the server, T0 denotes the time at which the client process sent the request, and T1 denotes the time at which the client process received the response The formula above is valid and reliable: Assuming that the network latency T0 and T1 are roughly equal, T1 - T0 denotes the total amount of time required by the network and server to transfer the request to the server, process it, and return the result to the client process. The difference between client-side and real-time time is no more than (T1 - T0)/2 seconds. We can infer from the aforementioned statement that the synchronisation error can only be (T1 - T0)/2 seconds at most. Hence, Error E [-(T 1 - T 0)/2, (T 1 - T 0)/2] The Python codes below demonstrate how Cristian's algorithm functions. To start a clock server prototype on a local machine, enter the following code: Python 
# Python3 program imitating a clock server

import socket
import datetime

# function used to initiate the Clock Server
def initiateClockServer():

	s = socket.socket()
	print("Socket successfully created")
	
	# Server port
	port = 8000

	s.bind(('', port))
	
	# Start listening to requests
	s.listen(5)	
	print("Socket is listening...")
	
	# Clock Server Running forever
	while True:
	
	# Establish connection with client
	connection, address = s.accept()	
	print('Server connected to', address)
	
	# Respond the client with server clock time
	connection.send(str(
					datetime.datetime.now()).encode())
	
	# Close the connection with the client process
	connection.close()


# Driver function
if __name__ == '__main__':

	# Trigger the Clock Server
	initiateClockServer()
 Output: Socket successfully created
Socket is listening...
 On the local machine, the following code runs a client process prototype: Python 
# Python3 program imitating a client process

import socket
import datetime
from dateutil import parser
from timeit import default_timer as timer

# function used to Synchronize client process time
def synchronizeTime():

	s = socket.socket()		
	
	# Server port
	port = 8000	
	
	# connect to the clock server on local computer
	s.connect(('127.0.0.1', port))

	request_time = timer()

	# receive data from the server
	server_time = parser.parse(s.recv(1024).decode())
	response_time = timer()
	actual_time = datetime.datetime.now()

	print("Time returned by server: " + str(server_time))

	process_delay_latency = response_time - request_time

	print("Process Delay latency: " \
		+ str(process_delay_latency) \
		+ " seconds")

	print("Actual clock time at client side: " \
		+ str(actual_time))

	# synchronize process client clock time
	client_time = server_time \
					+ datetime.timedelta(seconds = \
							(process_delay_latency) / 2)

	print("Synchronized process client time: " \
										+ str(client_time))

	# calculate synchronization error
	error = actual_time - client_time
	print("Synchronization error : "
				+ str(error.total_seconds()) + " seconds")

	s.close()	


# Driver function
if __name__ == '__main__':

	# synchronize time using clock server
	synchronizeTime()
 Output: Time returned by server: 2018-11-07 17:56:43.302379
Process Delay latency: 0.0005150819997652434 seconds
Actual clock time at client side: 2018-11-07 17:56:43.302756
Synchronized process client time: 2018-11-07 17:56:43.302637
Synchronization error : 0.000119 seconds
 We can define a minimum transfer time that we can use to create an improved synchronisation clock time through iterative testing over the network (less synchronisation error). The server time will always be generated after T0 + T min in this case, and TSERVER will always be generated before T1 - Tmin, where T min is the minimum transfer time, which is the minimum value of TREQUEST and TRESPONSE during several iterative tests. Here, a formulation of the synchronisation error is as follows: Error E [-((T1 - T0)/2-Tmin), ((T1 - T0)/2-Tmin)] Similar to this, if TREQUEST and TRESPONSE differ by a significant amount of time, TMIN1 and TMIN2 may be used in place of TMIN1 and TMIN2, respectively, where TMIN1 denotes the minimum observed request time and TMIN2 denotes the minimum observed response time over the network. In this scenario, the synchronised clock time can be calculated as follows: (T1 - T0)/2 + (Tmin2 - Tmin1)/2 +TSERVER = TCLIENT Therefore, we can improve clock time synchronisation and subsequently reduce the overall synchronisation error by simply introducing response and request time as separate time latencies. The total clock drift that is seen will determine how many iterative tests need to be performed. Next TopicService Set Identifier (SSID) in Computer Network ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/cristians-algorithm Cristian's Algorithm - javatpoint ? SCROLL TO TOP Home Computer Network DBMS DS DAA Operating Systems Computer Fundamentals Java Python HTML Selenium JavaScript jQuery Interview Q Computer Network Tutorial Introduction Features Architecture Components Computer Network Types Topologies Transmission Modes Models Models OSI Model TCP/IP Model Physical Layer Digital Transmission Transmission Media Guided Media UnGuided Media Multiplexing Switching Switching Modes Switching Techniques Data Link layer Data Link layer Error Detection Error Correction Data Link Controls Network Layer Network Layer Network Addressing Routing Network Layer Protocols Routing Algorithm Routing Algorithm Distance Vector Link State Routing Transport Layer Transport Layer Transport Layer Protocols Application Layer Application Layer Client & Server Model Application Protocols DNS FTP Telnet SMTP SNMP HTTP Network Security Security Privacy Digital Signature PGP Misc What is Router OSI vs TCP/IP TCP vs UDP TCP TCP Port IPv4 vs IPv6 ARP Packet Format ARP Table Working of ARP FTP Client FTP Commands FTP Server I2P Protocol Sliding Window Protocol SNMP SPI Protocol IP ARP Commands ARP Request ARP - Address Resolution Protocol ARP and its types TCP Retransmission CAN Protocol HTTP Status Codes HTTP vs HTTPS RIP Protocol UDP Protocol ICMP Protocol MQTT Protocol OSPF Protocol Stop & Wait Protocol IMAP Protocol POP Protocol CIFS DAS DIMM iSCSI NAS NFS NVMe SAN BGP Go-Back-N ARQ RJ Cable Connection-Oriented vs Connectionless Service CDMA vs GSM What is MAC Address Modem vs Router Switch vs Router USB 2.0 vs USB 3.0 CSMA CA vs CSMA CD Multiple Access Protocols URI vs URL IMAP vs. POP3 SSH Meaning UTP vs STP Status Code 400 MIME Protocol IP address What is a proxy server and how does it work How to set up and use a proxy server What is network security WWW is based on which model Proxy Server List Fundamentals of Computer Networking IP Address Format and Table Bus topology vs Ring topology Bus topology vs Star topology Circuit Switching vs Packet switching star vs ring topology Router vs Bridge TCP Connection Termination Image Steganography Network Neutrality Onion Routing ASA features Relabel-to-front Algorithm Types of Server Virtualization in Computer Network Access Lists (ACL) Digital Subscriber Line (DSL) Operating system based Virtualization Context based Access Control (CBAC) Cristian's Algorithm Service Set Identifier (SSID) in Computer Network Voice over Internet Protocol (VoIP) MCQ Computer Network MCQ Computer Network MCQ Part2 Interview Questions Networking Questions next ? ? prev Cristian's Algorithm Client processes synchronise time with a time server using Cristian's Algorithm, a clock synchronisation algorithm. While redundancy-prone distributed systems and applications do not work well with this algorithm, low-latency networks where round trip time is short relative to accuracy do. The time interval between the beginning of a Request and the conclusion of the corresponding Response is referred to as Round Trip Time in this context. An example mimicking the operation of Cristian's algorithm is provided below: Algorithm: The process on the client machine sends the clock server a request at time T 0 for the clock time (time at the server). In response to the client process's request, the clock server listens and responds with clock server time. The client process retrieves the response from the clock server at time T1 and uses the formula below to determine the synchronised client clock time. TCLIENT = TSERVER plus (T1 - T0)/2. where TCLIENT denotes the synchronised clock time, TSERVER denotes the clock time returned by the server, T0 denotes the time at which the client process sent the request, and T1 denotes the time at which the client process received the response The formula above is valid and reliable: Assuming that the network latency T0 and T1 are roughly equal, T1 - T0 denotes the total amount of time required by the network and server to transfer the request to the server, process it, and return the result to the client process. The difference between client-side and real-time time is no more than (T1 - T0)/2 seconds. We can infer from the aforementioned statement that the synchronisation error can only be (T1 - T0)/2 seconds at most. Hence, Error E [-(T 1 - T 0)/2, (T 1 - T 0)/2] The Python codes below demonstrate how Cristian's algorithm functions. To start a clock server prototype on a local machine, enter the following code: Python 
# Python3 program imitating a clock server

import socket
import datetime

# function used to initiate the Clock Server
def initiateClockServer():

	s = socket.socket()
	print("Socket successfully created")
	
	# Server port
	port = 8000

	s.bind(('', port))
	
	# Start listening to requests
	s.listen(5)	
	print("Socket is listening...")
	
	# Clock Server Running forever
	while True:
	
	# Establish connection with client
	connection, address = s.accept()	
	print('Server connected to', address)
	
	# Respond the client with server clock time
	connection.send(str(
					datetime.datetime.now()).encode())
	
	# Close the connection with the client process
	connection.close()


# Driver function
if __name__ == '__main__':

	# Trigger the Clock Server
	initiateClockServer()
 Output: Socket successfully created
Socket is listening...
 On the local machine, the following code runs a client process prototype: Python 
# Python3 program imitating a client process

import socket
import datetime
from dateutil import parser
from timeit import default_timer as timer

# function used to Synchronize client process time
def synchronizeTime():

	s = socket.socket()		
	
	# Server port
	port = 8000	
	
	# connect to the clock server on local computer
	s.connect(('127.0.0.1', port))

	request_time = timer()

	# receive data from the server
	server_time = parser.parse(s.recv(1024).decode())
	response_time = timer()
	actual_time = datetime.datetime.now()

	print("Time returned by server: " + str(server_time))

	process_delay_latency = response_time - request_time

	print("Process Delay latency: " \
		+ str(process_delay_latency) \
		+ " seconds")

	print("Actual clock time at client side: " \
		+ str(actual_time))

	# synchronize process client clock time
	client_time = server_time \
					+ datetime.timedelta(seconds = \
							(process_delay_latency) / 2)

	print("Synchronized process client time: " \
										+ str(client_time))

	# calculate synchronization error
	error = actual_time - client_time
	print("Synchronization error : "
				+ str(error.total_seconds()) + " seconds")

	s.close()	


# Driver function
if __name__ == '__main__':

	# synchronize time using clock server
	synchronizeTime()
 Output: Time returned by server: 2018-11-07 17:56:43.302379
Process Delay latency: 0.0005150819997652434 seconds
Actual clock time at client side: 2018-11-07 17:56:43.302756
Synchronized process client time: 2018-11-07 17:56:43.302637
Synchronization error : 0.000119 seconds
 We can define a minimum transfer time that we can use to create an improved synchronisation clock time through iterative testing over the network (less synchronisation error). The server time will always be generated after T0 + T min in this case, and TSERVER will always be generated before T1 - Tmin, where T min is the minimum transfer time, which is the minimum value of TREQUEST and TRESPONSE during several iterative tests. Here, a formulation of the synchronisation error is as follows: Error E [-((T1 - T0)/2-Tmin), ((T1 - T0)/2-Tmin)] Similar to this, if TREQUEST and TRESPONSE differ by a significant amount of time, TMIN1 and TMIN2 may be used in place of TMIN1 and TMIN2, respectively, where TMIN1 denotes the minimum observed request time and TMIN2 denotes the minimum observed response time over the network. In this scenario, the synchronised clock time can be calculated as follows: (T1 - T0)/2 + (Tmin2 - Tmin1)/2 +TSERVER = TCLIENT Therefore, we can improve clock time synchronisation and subsequently reduce the overall synchronisation error by simply introducing response and request time as separate time latencies. The total clock drift that is seen will determine how many iterative tests need to be performed. Next TopicService Set Identifier (SSID) in Computer Network ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/cristians-algorithm Cristian's Algorithm - javatpoint ? SCROLL TO TOP Home Computer Network DBMS DS DAA Operating Systems Computer Fundamentals Java Python HTML Selenium JavaScript jQuery Interview Q Computer Network Tutorial Introduction Features Architecture Components Computer Network Types Topologies Transmission Modes Models Models OSI Model TCP/IP Model Physical Layer Digital Transmission Transmission Media Guided Media UnGuided Media Multiplexing Switching Switching Modes Switching Techniques Data Link layer Data Link layer Error Detection Error Correction Data Link Controls Network Layer Network Layer Network Addressing Routing Network Layer Protocols Routing Algorithm Routing Algorithm Distance Vector Link State Routing Transport Layer Transport Layer Transport Layer Protocols Application Layer Application Layer Client & Server Model Application Protocols DNS FTP Telnet SMTP SNMP HTTP Network Security Security Privacy Digital Signature PGP Misc What is Router OSI vs TCP/IP TCP vs UDP TCP TCP Port IPv4 vs IPv6 ARP Packet Format ARP Table Working of ARP FTP Client FTP Commands FTP Server I2P Protocol Sliding Window Protocol SNMP SPI Protocol IP ARP Commands ARP Request ARP - Address Resolution Protocol ARP and its types TCP Retransmission CAN Protocol HTTP Status Codes HTTP vs HTTPS RIP Protocol UDP Protocol ICMP Protocol MQTT Protocol OSPF Protocol Stop & Wait Protocol IMAP Protocol POP Protocol CIFS DAS DIMM iSCSI NAS NFS NVMe SAN BGP Go-Back-N ARQ RJ Cable Connection-Oriented vs Connectionless Service CDMA vs GSM What is MAC Address Modem vs Router Switch vs Router USB 2.0 vs USB 3.0 CSMA CA vs CSMA CD Multiple Access Protocols URI vs URL IMAP vs. POP3 SSH Meaning UTP vs STP Status Code 400 MIME Protocol IP address What is a proxy server and how does it work How to set up and use a proxy server What is network security WWW is based on which model Proxy Server List Fundamentals of Computer Networking IP Address Format and Table Bus topology vs Ring topology Bus topology vs Star topology Circuit Switching vs Packet switching star vs ring topology Router vs Bridge TCP Connection Termination Image Steganography Network Neutrality Onion Routing ASA features Relabel-to-front Algorithm Types of Server Virtualization in Computer Network Access Lists (ACL) Digital Subscriber Line (DSL) Operating system based Virtualization Context based Access Control (CBAC) Cristian's Algorithm Service Set Identifier (SSID) in Computer Network Voice over Internet Protocol (VoIP) MCQ Computer Network MCQ Computer Network MCQ Part2 Interview Questions Networking Questions next ? ? prev Cristian's Algorithm Client processes synchronise time with a time server using Cristian's Algorithm, a clock synchronisation algorithm. While redundancy-prone distributed systems and applications do not work well with this algorithm, low-latency networks where round trip time is short relative to accuracy do. The time interval between the beginning of a Request and the conclusion of the corresponding Response is referred to as Round Trip Time in this context. An example mimicking the operation of Cristian's algorithm is provided below: Algorithm: The process on the client machine sends the clock server a request at time T 0 for the clock time (time at the server). In response to the client process's request, the clock server listens and responds with clock server time. The client process retrieves the response from the clock server at time T1 and uses the formula below to determine the synchronised client clock time. TCLIENT = TSERVER plus (T1 - T0)/2. where TCLIENT denotes the synchronised clock time, TSERVER denotes the clock time returned by the server, T0 denotes the time at which the client process sent the request, and T1 denotes the time at which the client process received the response The formula above is valid and reliable: Assuming that the network latency T0 and T1 are roughly equal, T1 - T0 denotes the total amount of time required by the network and server to transfer the request to the server, process it, and return the result to the client process. The difference between client-side and real-time time is no more than (T1 - T0)/2 seconds. We can infer from the aforementioned statement that the synchronisation error can only be (T1 - T0)/2 seconds at most. Hence, Error E [-(T 1 - T 0)/2, (T 1 - T 0)/2] The Python codes below demonstrate how Cristian's algorithm functions. To start a clock server prototype on a local machine, enter the following code: Python 
# Python3 program imitating a clock server

import socket
import datetime

# function used to initiate the Clock Server
def initiateClockServer():

	s = socket.socket()
	print("Socket successfully created")
	
	# Server port
	port = 8000

	s.bind(('', port))
	
	# Start listening to requests
	s.listen(5)	
	print("Socket is listening...")
	
	# Clock Server Running forever
	while True:
	
	# Establish connection with client
	connection, address = s.accept()	
	print('Server connected to', address)
	
	# Respond the client with server clock time
	connection.send(str(
					datetime.datetime.now()).encode())
	
	# Close the connection with the client process
	connection.close()


# Driver function
if __name__ == '__main__':

	# Trigger the Clock Server
	initiateClockServer()
 Output: Socket successfully created
Socket is listening...
 On the local machine, the following code runs a client process prototype: Python 
# Python3 program imitating a client process

import socket
import datetime
from dateutil import parser
from timeit import default_timer as timer

# function used to Synchronize client process time
def synchronizeTime():

	s = socket.socket()		
	
	# Server port
	port = 8000	
	
	# connect to the clock server on local computer
	s.connect(('127.0.0.1', port))

	request_time = timer()

	# receive data from the server
	server_time = parser.parse(s.recv(1024).decode())
	response_time = timer()
	actual_time = datetime.datetime.now()

	print("Time returned by server: " + str(server_time))

	process_delay_latency = response_time - request_time

	print("Process Delay latency: " \
		+ str(process_delay_latency) \
		+ " seconds")

	print("Actual clock time at client side: " \
		+ str(actual_time))

	# synchronize process client clock time
	client_time = server_time \
					+ datetime.timedelta(seconds = \
							(process_delay_latency) / 2)

	print("Synchronized process client time: " \
										+ str(client_time))

	# calculate synchronization error
	error = actual_time - client_time
	print("Synchronization error : "
				+ str(error.total_seconds()) + " seconds")

	s.close()	


# Driver function
if __name__ == '__main__':

	# synchronize time using clock server
	synchronizeTime()
 Output: Time returned by server: 2018-11-07 17:56:43.302379
Process Delay latency: 0.0005150819997652434 seconds
Actual clock time at client side: 2018-11-07 17:56:43.302756
Synchronized process client time: 2018-11-07 17:56:43.302637
Synchronization error : 0.000119 seconds
 We can define a minimum transfer time that we can use to create an improved synchronisation clock time through iterative testing over the network (less synchronisation error). The server time will always be generated after T0 + T min in this case, and TSERVER will always be generated before T1 - Tmin, where T min is the minimum transfer time, which is the minimum value of TREQUEST and TRESPONSE during several iterative tests. Here, a formulation of the synchronisation error is as follows: Error E [-((T1 - T0)/2-Tmin), ((T1 - T0)/2-Tmin)] Similar to this, if TREQUEST and TRESPONSE differ by a significant amount of time, TMIN1 and TMIN2 may be used in place of TMIN1 and TMIN2, respectively, where TMIN1 denotes the minimum observed request time and TMIN2 denotes the minimum observed response time over the network. In this scenario, the synchronised clock time can be calculated as follows: (T1 - T0)/2 + (Tmin2 - Tmin1)/2 +TSERVER = TCLIENT Therefore, we can improve clock time synchronisation and subsequently reduce the overall synchronisation error by simply introducing response and request time as separate time latencies. The total clock drift that is seen will determine how many iterative tests need to be performed. Next TopicService Set Identifier (SSID) in Computer Network ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/cristians-algorithm Cristian's Algorithm - javatpoint ? SCROLL TO TOP Home Computer Network DBMS DS DAA Operating Systems Computer Fundamentals Java Python HTML Selenium JavaScript jQuery Interview Q Computer Network Tutorial Introduction Features Architecture Components Computer Network Types Topologies Transmission Modes Models Models OSI Model TCP/IP Model Physical Layer Digital Transmission Transmission Media Guided Media UnGuided Media Multiplexing Switching Switching Modes Switching Techniques Data Link layer Data Link layer Error Detection Error Correction Data Link Controls Network Layer Network Layer Network Addressing Routing Network Layer Protocols Routing Algorithm Routing Algorithm Distance Vector Link State Routing Transport Layer Transport Layer Transport Layer Protocols Application Layer Application Layer Client & Server Model Application Protocols DNS FTP Telnet SMTP SNMP HTTP Network Security Security Privacy Digital Signature PGP Misc What is Router OSI vs TCP/IP TCP vs UDP TCP TCP Port IPv4 vs IPv6 ARP Packet Format ARP Table Working of ARP FTP Client FTP Commands FTP Server I2P Protocol Sliding Window Protocol SNMP SPI Protocol IP ARP Commands ARP Request ARP - Address Resolution Protocol ARP and its types TCP Retransmission CAN Protocol HTTP Status Codes HTTP vs HTTPS RIP Protocol UDP Protocol ICMP Protocol MQTT Protocol OSPF Protocol Stop & Wait Protocol IMAP Protocol POP Protocol CIFS DAS DIMM iSCSI NAS NFS NVMe SAN BGP Go-Back-N ARQ RJ Cable Connection-Oriented vs Connectionless Service CDMA vs GSM What is MAC Address Modem vs Router Switch vs Router USB 2.0 vs USB 3.0 CSMA CA vs CSMA CD Multiple Access Protocols URI vs URL IMAP vs. POP3 SSH Meaning UTP vs STP Status Code 400 MIME Protocol IP address What is a proxy server and how does it work How to set up and use a proxy server What is network security WWW is based on which model Proxy Server List Fundamentals of Computer Networking IP Address Format and Table Bus topology vs Ring topology Bus topology vs Star topology Circuit Switching vs Packet switching star vs ring topology Router vs Bridge TCP Connection Termination Image Steganography Network Neutrality Onion Routing ASA features Relabel-to-front Algorithm Types of Server Virtualization in Computer Network Access Lists (ACL) Digital Subscriber Line (DSL) Operating system based Virtualization Context based Access Control (CBAC) Cristian's Algorithm Service Set Identifier (SSID) in Computer Network Voice over Internet Protocol (VoIP) MCQ Computer Network MCQ Computer Network MCQ Part2 Interview Questions Networking Questions next ? ? prev Cristian's Algorithm Client processes synchronise time with a time server using Cristian's Algorithm, a clock synchronisation algorithm. While redundancy-prone distributed systems and applications do not work well with this algorithm, low-latency networks where round trip time is short relative to accuracy do. The time interval between the beginning of a Request and the conclusion of the corresponding Response is referred to as Round Trip Time in this context. An example mimicking the operation of Cristian's algorithm is provided below: Algorithm: The process on the client machine sends the clock server a request at time T 0 for the clock time (time at the server). In response to the client process's request, the clock server listens and responds with clock server time. The client process retrieves the response from the clock server at time T1 and uses the formula below to determine the synchronised client clock time. TCLIENT = TSERVER plus (T1 - T0)/2. where TCLIENT denotes the synchronised clock time, TSERVER denotes the clock time returned by the server, T0 denotes the time at which the client process sent the request, and T1 denotes the time at which the client process received the response The formula above is valid and reliable: Assuming that the network latency T0 and T1 are roughly equal, T1 - T0 denotes the total amount of time required by the network and server to transfer the request to the server, process it, and return the result to the client process. The difference between client-side and real-time time is no more than (T1 - T0)/2 seconds. We can infer from the aforementioned statement that the synchronisation error can only be (T1 - T0)/2 seconds at most. Hence, Error E [-(T 1 - T 0)/2, (T 1 - T 0)/2] The Python codes below demonstrate how Cristian's algorithm functions. To start a clock server prototype on a local machine, enter the following code: Python 
# Python3 program imitating a clock server

import socket
import datetime

# function used to initiate the Clock Server
def initiateClockServer():

	s = socket.socket()
	print("Socket successfully created")
	
	# Server port
	port = 8000

	s.bind(('', port))
	
	# Start listening to requests
	s.listen(5)	
	print("Socket is listening...")
	
	# Clock Server Running forever
	while True:
	
	# Establish connection with client
	connection, address = s.accept()	
	print('Server connected to', address)
	
	# Respond the client with server clock time
	connection.send(str(
					datetime.datetime.now()).encode())
	
	# Close the connection with the client process
	connection.close()


# Driver function
if __name__ == '__main__':

	# Trigger the Clock Server
	initiateClockServer()
 Output: Socket successfully created
Socket is listening...
 On the local machine, the following code runs a client process prototype: Python 
# Python3 program imitating a client process

import socket
import datetime
from dateutil import parser
from timeit import default_timer as timer

# function used to Synchronize client process time
def synchronizeTime():

	s = socket.socket()		
	
	# Server port
	port = 8000	
	
	# connect to the clock server on local computer
	s.connect(('127.0.0.1', port))

	request_time = timer()

	# receive data from the server
	server_time = parser.parse(s.recv(1024).decode())
	response_time = timer()
	actual_time = datetime.datetime.now()

	print("Time returned by server: " + str(server_time))

	process_delay_latency = response_time - request_time

	print("Process Delay latency: " \
		+ str(process_delay_latency) \
		+ " seconds")

	print("Actual clock time at client side: " \
		+ str(actual_time))

	# synchronize process client clock time
	client_time = server_time \
					+ datetime.timedelta(seconds = \
							(process_delay_latency) / 2)

	print("Synchronized process client time: " \
										+ str(client_time))

	# calculate synchronization error
	error = actual_time - client_time
	print("Synchronization error : "
				+ str(error.total_seconds()) + " seconds")

	s.close()	


# Driver function
if __name__ == '__main__':

	# synchronize time using clock server
	synchronizeTime()
 Output: Time returned by server: 2018-11-07 17:56:43.302379
Process Delay latency: 0.0005150819997652434 seconds
Actual clock time at client side: 2018-11-07 17:56:43.302756
Synchronized process client time: 2018-11-07 17:56:43.302637
Synchronization error : 0.000119 seconds
 We can define a minimum transfer time that we can use to create an improved synchronisation clock time through iterative testing over the network (less synchronisation error). The server time will always be generated after T0 + T min in this case, and TSERVER will always be generated before T1 - Tmin, where T min is the minimum transfer time, which is the minimum value of TREQUEST and TRESPONSE during several iterative tests. Here, a formulation of the synchronisation error is as follows: Error E [-((T1 - T0)/2-Tmin), ((T1 - T0)/2-Tmin)] Similar to this, if TREQUEST and TRESPONSE differ by a significant amount of time, TMIN1 and TMIN2 may be used in place of TMIN1 and TMIN2, respectively, where TMIN1 denotes the minimum observed request time and TMIN2 denotes the minimum observed response time over the network. In this scenario, the synchronised clock time can be calculated as follows: (T1 - T0)/2 + (Tmin2 - Tmin1)/2 +TSERVER = TCLIENT Therefore, we can improve clock time synchronisation and subsequently reduce the overall synchronisation error by simply introducing response and request time as separate time latencies. The total clock drift that is seen will determine how many iterative tests need to be performed. Next TopicService Set Identifier (SSID) in Computer Network ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/cristians-algorithm Cristian's Algorithm - javatpoint ? SCROLL TO TOP Home Computer Network DBMS DS DAA Operating Systems Computer Fundamentals Java Python HTML Selenium JavaScript jQuery Interview Q Computer Network Tutorial Introduction Features Architecture Components Computer Network Types Topologies Transmission Modes Models Models OSI Model TCP/IP Model Physical Layer Digital Transmission Transmission Media Guided Media UnGuided Media Multiplexing Switching Switching Modes Switching Techniques Data Link layer Data Link layer Error Detection Error Correction Data Link Controls Network Layer Network Layer Network Addressing Routing Network Layer Protocols Routing Algorithm Routing Algorithm Distance Vector Link State Routing Transport Layer Transport Layer Transport Layer Protocols Application Layer Application Layer Client & Server Model Application Protocols DNS FTP Telnet SMTP SNMP HTTP Network Security Security Privacy Digital Signature PGP Misc What is Router OSI vs TCP/IP TCP vs UDP TCP TCP Port IPv4 vs IPv6 ARP Packet Format ARP Table Working of ARP FTP Client FTP Commands FTP Server I2P Protocol Sliding Window Protocol SNMP SPI Protocol IP ARP Commands ARP Request ARP - Address Resolution Protocol ARP and its types TCP Retransmission CAN Protocol HTTP Status Codes HTTP vs HTTPS RIP Protocol UDP Protocol ICMP Protocol MQTT Protocol OSPF Protocol Stop & Wait Protocol IMAP Protocol POP Protocol CIFS DAS DIMM iSCSI NAS NFS NVMe SAN BGP Go-Back-N ARQ RJ Cable Connection-Oriented vs Connectionless Service CDMA vs GSM What is MAC Address Modem vs Router Switch vs Router USB 2.0 vs USB 3.0 CSMA CA vs CSMA CD Multiple Access Protocols URI vs URL IMAP vs. POP3 SSH Meaning UTP vs STP Status Code 400 MIME Protocol IP address What is a proxy server and how does it work How to set up and use a proxy server What is network security WWW is based on which model Proxy Server List Fundamentals of Computer Networking IP Address Format and Table Bus topology vs Ring topology Bus topology vs Star topology Circuit Switching vs Packet switching star vs ring topology Router vs Bridge TCP Connection Termination Image Steganography Network Neutrality Onion Routing ASA features Relabel-to-front Algorithm Types of Server Virtualization in Computer Network Access Lists (ACL) Digital Subscriber Line (DSL) Operating system based Virtualization Context based Access Control (CBAC) Cristian's Algorithm Service Set Identifier (SSID) in Computer Network Voice over Internet Protocol (VoIP) MCQ Computer Network MCQ Computer Network MCQ Part2 Interview Questions Networking Questions next ? ? prev Cristian's Algorithm Client processes synchronise time with a time server using Cristian's Algorithm, a clock synchronisation algorithm. While redundancy-prone distributed systems and applications do not work well with this algorithm, low-latency networks where round trip time is short relative to accuracy do. The time interval between the beginning of a Request and the conclusion of the corresponding Response is referred to as Round Trip Time in this context. An example mimicking the operation of Cristian's algorithm is provided below: Algorithm: The process on the client machine sends the clock server a request at time T 0 for the clock time (time at the server). In response to the client process's request, the clock server listens and responds with clock server time. The client process retrieves the response from the clock server at time T1 and uses the formula below to determine the synchronised client clock time. TCLIENT = TSERVER plus (T1 - T0)/2. where TCLIENT denotes the synchronised clock time, TSERVER denotes the clock time returned by the server, T0 denotes the time at which the client process sent the request, and T1 denotes the time at which the client process received the response The formula above is valid and reliable: Assuming that the network latency T0 and T1 are roughly equal, T1 - T0 denotes the total amount of time required by the network and server to transfer the request to the server, process it, and return the result to the client process. The difference between client-side and real-time time is no more than (T1 - T0)/2 seconds. We can infer from the aforementioned statement that the synchronisation error can only be (T1 - T0)/2 seconds at most. Hence, Error E [-(T 1 - T 0)/2, (T 1 - T 0)/2] The Python codes below demonstrate how Cristian's algorithm functions. To start a clock server prototype on a local machine, enter the following code: Python 
# Python3 program imitating a clock server

import socket
import datetime

# function used to initiate the Clock Server
def initiateClockServer():

	s = socket.socket()
	print("Socket successfully created")
	
	# Server port
	port = 8000

	s.bind(('', port))
	
	# Start listening to requests
	s.listen(5)	
	print("Socket is listening...")
	
	# Clock Server Running forever
	while True:
	
	# Establish connection with client
	connection, address = s.accept()	
	print('Server connected to', address)
	
	# Respond the client with server clock time
	connection.send(str(
					datetime.datetime.now()).encode())
	
	# Close the connection with the client process
	connection.close()


# Driver function
if __name__ == '__main__':

	# Trigger the Clock Server
	initiateClockServer()
 Output: Socket successfully created
Socket is listening...
 On the local machine, the following code runs a client process prototype: Python 
# Python3 program imitating a client process

import socket
import datetime
from dateutil import parser
from timeit import default_timer as timer

# function used to Synchronize client process time
def synchronizeTime():

	s = socket.socket()		
	
	# Server port
	port = 8000	
	
	# connect to the clock server on local computer
	s.connect(('127.0.0.1', port))

	request_time = timer()

	# receive data from the server
	server_time = parser.parse(s.recv(1024).decode())
	response_time = timer()
	actual_time = datetime.datetime.now()

	print("Time returned by server: " + str(server_time))

	process_delay_latency = response_time - request_time

	print("Process Delay latency: " \
		+ str(process_delay_latency) \
		+ " seconds")

	print("Actual clock time at client side: " \
		+ str(actual_time))

	# synchronize process client clock time
	client_time = server_time \
					+ datetime.timedelta(seconds = \
							(process_delay_latency) / 2)

	print("Synchronized process client time: " \
										+ str(client_time))

	# calculate synchronization error
	error = actual_time - client_time
	print("Synchronization error : "
				+ str(error.total_seconds()) + " seconds")

	s.close()	


# Driver function
if __name__ == '__main__':

	# synchronize time using clock server
	synchronizeTime()
 Output: Time returned by server: 2018-11-07 17:56:43.302379
Process Delay latency: 0.0005150819997652434 seconds
Actual clock time at client side: 2018-11-07 17:56:43.302756
Synchronized process client time: 2018-11-07 17:56:43.302637
Synchronization error : 0.000119 seconds
 We can define a minimum transfer time that we can use to create an improved synchronisation clock time through iterative testing over the network (less synchronisation error). The server time will always be generated after T0 + T min in this case, and TSERVER will always be generated before T1 - Tmin, where T min is the minimum transfer time, which is the minimum value of TREQUEST and TRESPONSE during several iterative tests. Here, a formulation of the synchronisation error is as follows: Error E [-((T1 - T0)/2-Tmin), ((T1 - T0)/2-Tmin)] Similar to this, if TREQUEST and TRESPONSE differ by a significant amount of time, TMIN1 and TMIN2 may be used in place of TMIN1 and TMIN2, respectively, where TMIN1 denotes the minimum observed request time and TMIN2 denotes the minimum observed response time over the network. In this scenario, the synchronised clock time can be calculated as follows: (T1 - T0)/2 + (Tmin2 - Tmin1)/2 +TSERVER = TCLIENT Therefore, we can improve clock time synchronisation and subsequently reduce the overall synchronisation error by simply introducing response and request time as separate time latencies. The total clock drift that is seen will determine how many iterative tests need to be performed. Next TopicService Set Identifier (SSID) in Computer Network ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/cristians-algorithm Cristian's Algorithm - javatpoint ? SCROLL TO TOP Home Computer Network DBMS DS DAA Operating Systems Computer Fundamentals Java Python HTML Selenium JavaScript jQuery Interview Q Computer Network Tutorial Introduction Features Architecture Components Computer Network Types Topologies Transmission Modes Models Models OSI Model TCP/IP Model Physical Layer Digital Transmission Transmission Media Guided Media UnGuided Media Multiplexing Switching Switching Modes Switching Techniques Data Link layer Data Link layer Error Detection Error Correction Data Link Controls Network Layer Network Layer Network Addressing Routing Network Layer Protocols Routing Algorithm Routing Algorithm Distance Vector Link State Routing Transport Layer Transport Layer Transport Layer Protocols Application Layer Application Layer Client & Server Model Application Protocols DNS FTP Telnet SMTP SNMP HTTP Network Security Security Privacy Digital Signature PGP Misc What is Router OSI vs TCP/IP TCP vs UDP TCP TCP Port IPv4 vs IPv6 ARP Packet Format ARP Table Working of ARP FTP Client FTP Commands FTP Server I2P Protocol Sliding Window Protocol SNMP SPI Protocol IP ARP Commands ARP Request ARP - Address Resolution Protocol ARP and its types TCP Retransmission CAN Protocol HTTP Status Codes HTTP vs HTTPS RIP Protocol UDP Protocol ICMP Protocol MQTT Protocol OSPF Protocol Stop & Wait Protocol IMAP Protocol POP Protocol CIFS DAS DIMM iSCSI NAS NFS NVMe SAN BGP Go-Back-N ARQ RJ Cable Connection-Oriented vs Connectionless Service CDMA vs GSM What is MAC Address Modem vs Router Switch vs Router USB 2.0 vs USB 3.0 CSMA CA vs CSMA CD Multiple Access Protocols URI vs URL IMAP vs. POP3 SSH Meaning UTP vs STP Status Code 400 MIME Protocol IP address What is a proxy server and how does it work How to set up and use a proxy server What is network security WWW is based on which model Proxy Server List Fundamentals of Computer Networking IP Address Format and Table Bus topology vs Ring topology Bus topology vs Star topology Circuit Switching vs Packet switching star vs ring topology Router vs Bridge TCP Connection Termination Image Steganography Network Neutrality Onion Routing ASA features Relabel-to-front Algorithm Types of Server Virtualization in Computer Network Access Lists (ACL) Digital Subscriber Line (DSL) Operating system based Virtualization Context based Access Control (CBAC) Cristian's Algorithm Service Set Identifier (SSID) in Computer Network Voice over Internet Protocol (VoIP) MCQ Computer Network MCQ Computer Network MCQ Part2 Interview Questions Networking Questions next ? ? prev Cristian's Algorithm Client processes synchronise time with a time server using Cristian's Algorithm, a clock synchronisation algorithm. While redundancy-prone distributed systems and applications do not work well with this algorithm, low-latency networks where round trip time is short relative to accuracy do. The time interval between the beginning of a Request and the conclusion of the corresponding Response is referred to as Round Trip Time in this context. An example mimicking the operation of Cristian's algorithm is provided below: Algorithm: The process on the client machine sends the clock server a request at time T 0 for the clock time (time at the server). In response to the client process's request, the clock server listens and responds with clock server time. The client process retrieves the response from the clock server at time T1 and uses the formula below to determine the synchronised client clock time. TCLIENT = TSERVER plus (T1 - T0)/2. where TCLIENT denotes the synchronised clock time, TSERVER denotes the clock time returned by the server, T0 denotes the time at which the client process sent the request, and T1 denotes the time at which the client process received the response The formula above is valid and reliable: Assuming that the network latency T0 and T1 are roughly equal, T1 - T0 denotes the total amount of time required by the network and server to transfer the request to the server, process it, and return the result to the client process. The difference between client-side and real-time time is no more than (T1 - T0)/2 seconds. We can infer from the aforementioned statement that the synchronisation error can only be (T1 - T0)/2 seconds at most. Hence, Error E [-(T 1 - T 0)/2, (T 1 - T 0)/2] The Python codes below demonstrate how Cristian's algorithm functions. To start a clock server prototype on a local machine, enter the following code: Python 
# Python3 program imitating a clock server

import socket
import datetime

# function used to initiate the Clock Server
def initiateClockServer():

	s = socket.socket()
	print("Socket successfully created")
	
	# Server port
	port = 8000

	s.bind(('', port))
	
	# Start listening to requests
	s.listen(5)	
	print("Socket is listening...")
	
	# Clock Server Running forever
	while True:
	
	# Establish connection with client
	connection, address = s.accept()	
	print('Server connected to', address)
	
	# Respond the client with server clock time
	connection.send(str(
					datetime.datetime.now()).encode())
	
	# Close the connection with the client process
	connection.close()


# Driver function
if __name__ == '__main__':

	# Trigger the Clock Server
	initiateClockServer()
 Output: Socket successfully created
Socket is listening...
 On the local machine, the following code runs a client process prototype: Python 
# Python3 program imitating a client process

import socket
import datetime
from dateutil import parser
from timeit import default_timer as timer

# function used to Synchronize client process time
def synchronizeTime():

	s = socket.socket()		
	
	# Server port
	port = 8000	
	
	# connect to the clock server on local computer
	s.connect(('127.0.0.1', port))

	request_time = timer()

	# receive data from the server
	server_time = parser.parse(s.recv(1024).decode())
	response_time = timer()
	actual_time = datetime.datetime.now()

	print("Time returned by server: " + str(server_time))

	process_delay_latency = response_time - request_time

	print("Process Delay latency: " \
		+ str(process_delay_latency) \
		+ " seconds")

	print("Actual clock time at client side: " \
		+ str(actual_time))

	# synchronize process client clock time
	client_time = server_time \
					+ datetime.timedelta(seconds = \
							(process_delay_latency) / 2)

	print("Synchronized process client time: " \
										+ str(client_time))

	# calculate synchronization error
	error = actual_time - client_time
	print("Synchronization error : "
				+ str(error.total_seconds()) + " seconds")

	s.close()	


# Driver function
if __name__ == '__main__':

	# synchronize time using clock server
	synchronizeTime()
 Output: Time returned by server: 2018-11-07 17:56:43.302379
Process Delay latency: 0.0005150819997652434 seconds
Actual clock time at client side: 2018-11-07 17:56:43.302756
Synchronized process client time: 2018-11-07 17:56:43.302637
Synchronization error : 0.000119 seconds
 We can define a minimum transfer time that we can use to create an improved synchronisation clock time through iterative testing over the network (less synchronisation error). The server time will always be generated after T0 + T min in this case, and TSERVER will always be generated before T1 - Tmin, where T min is the minimum transfer time, which is the minimum value of TREQUEST and TRESPONSE during several iterative tests. Here, a formulation of the synchronisation error is as follows: Error E [-((T1 - T0)/2-Tmin), ((T1 - T0)/2-Tmin)] Similar to this, if TREQUEST and TRESPONSE differ by a significant amount of time, TMIN1 and TMIN2 may be used in place of TMIN1 and TMIN2, respectively, where TMIN1 denotes the minimum observed request time and TMIN2 denotes the minimum observed response time over the network. In this scenario, the synchronised clock time can be calculated as follows: (T1 - T0)/2 + (Tmin2 - Tmin1)/2 +TSERVER = TCLIENT Therefore, we can improve clock time synchronisation and subsequently reduce the overall synchronisation error by simply introducing response and request time as separate time latencies. The total clock drift that is seen will determine how many iterative tests need to be performed. Next TopicService Set Identifier (SSID) in Computer Network ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/cristians-algorithm Cristian's Algorithm - javatpoint ? SCROLL TO TOP Home Computer Network DBMS DS DAA Operating Systems Computer Fundamentals Java Python HTML Selenium JavaScript jQuery Interview Q Computer Network Tutorial Introduction Features Architecture Components Computer Network Types Topologies Transmission Modes Models Models OSI Model TCP/IP Model Physical Layer Digital Transmission Transmission Media Guided Media UnGuided Media Multiplexing Switching Switching Modes Switching Techniques Data Link layer Data Link layer Error Detection Error Correction Data Link Controls Network Layer Network Layer Network Addressing Routing Network Layer Protocols Routing Algorithm Routing Algorithm Distance Vector Link State Routing Transport Layer Transport Layer Transport Layer Protocols Application Layer Application Layer Client & Server Model Application Protocols DNS FTP Telnet SMTP SNMP HTTP Network Security Security Privacy Digital Signature PGP Misc What is Router OSI vs TCP/IP TCP vs UDP TCP TCP Port IPv4 vs IPv6 ARP Packet Format ARP Table Working of ARP FTP Client FTP Commands FTP Server I2P Protocol Sliding Window Protocol SNMP SPI Protocol IP ARP Commands ARP Request ARP - Address Resolution Protocol ARP and its types TCP Retransmission CAN Protocol HTTP Status Codes HTTP vs HTTPS RIP Protocol UDP Protocol ICMP Protocol MQTT Protocol OSPF Protocol Stop & Wait Protocol IMAP Protocol POP Protocol CIFS DAS DIMM iSCSI NAS NFS NVMe SAN BGP Go-Back-N ARQ RJ Cable Connection-Oriented vs Connectionless Service CDMA vs GSM What is MAC Address Modem vs Router Switch vs Router USB 2.0 vs USB 3.0 CSMA CA vs CSMA CD Multiple Access Protocols URI vs URL IMAP vs. POP3 SSH Meaning UTP vs STP Status Code 400 MIME Protocol IP address What is a proxy server and how does it work How to set up and use a proxy server What is network security WWW is based on which model Proxy Server List Fundamentals of Computer Networking IP Address Format and Table Bus topology vs Ring topology Bus topology vs Star topology Circuit Switching vs Packet switching star vs ring topology Router vs Bridge TCP Connection Termination Image Steganography Network Neutrality Onion Routing ASA features Relabel-to-front Algorithm Types of Server Virtualization in Computer Network Access Lists (ACL) Digital Subscriber Line (DSL) Operating system based Virtualization Context based Access Control (CBAC) Cristian's Algorithm Service Set Identifier (SSID) in Computer Network Voice over Internet Protocol (VoIP) MCQ Computer Network MCQ Computer Network MCQ Part2 Interview Questions Networking Questions next ? ? prev Cristian's Algorithm Client processes synchronise time with a time server using Cristian's Algorithm, a clock synchronisation algorithm. While redundancy-prone distributed systems and applications do not work well with this algorithm, low-latency networks where round trip time is short relative to accuracy do. The time interval between the beginning of a Request and the conclusion of the corresponding Response is referred to as Round Trip Time in this context. An example mimicking the operation of Cristian's algorithm is provided below: Algorithm: The process on the client machine sends the clock server a request at time T 0 for the clock time (time at the server). In response to the client process's request, the clock server listens and responds with clock server time. The client process retrieves the response from the clock server at time T1 and uses the formula below to determine the synchronised client clock time. TCLIENT = TSERVER plus (T1 - T0)/2. where TCLIENT denotes the synchronised clock time, TSERVER denotes the clock time returned by the server, T0 denotes the time at which the client process sent the request, and T1 denotes the time at which the client process received the response The formula above is valid and reliable: Assuming that the network latency T0 and T1 are roughly equal, T1 - T0 denotes the total amount of time required by the network and server to transfer the request to the server, process it, and return the result to the client process. The difference between client-side and real-time time is no more than (T1 - T0)/2 seconds. We can infer from the aforementioned statement that the synchronisation error can only be (T1 - T0)/2 seconds at most. Hence, Error E [-(T 1 - T 0)/2, (T 1 - T 0)/2] The Python codes below demonstrate how Cristian's algorithm functions. To start a clock server prototype on a local machine, enter the following code: Python 
# Python3 program imitating a clock server

import socket
import datetime

# function used to initiate the Clock Server
def initiateClockServer():

	s = socket.socket()
	print("Socket successfully created")
	
	# Server port
	port = 8000

	s.bind(('', port))
	
	# Start listening to requests
	s.listen(5)	
	print("Socket is listening...")
	
	# Clock Server Running forever
	while True:
	
	# Establish connection with client
	connection, address = s.accept()	
	print('Server connected to', address)
	
	# Respond the client with server clock time
	connection.send(str(
					datetime.datetime.now()).encode())
	
	# Close the connection with the client process
	connection.close()


# Driver function
if __name__ == '__main__':

	# Trigger the Clock Server
	initiateClockServer()
 Output: Socket successfully created
Socket is listening...
 On the local machine, the following code runs a client process prototype: Python 
# Python3 program imitating a client process

import socket
import datetime
from dateutil import parser
from timeit import default_timer as timer

# function used to Synchronize client process time
def synchronizeTime():

	s = socket.socket()		
	
	# Server port
	port = 8000	
	
	# connect to the clock server on local computer
	s.connect(('127.0.0.1', port))

	request_time = timer()

	# receive data from the server
	server_time = parser.parse(s.recv(1024).decode())
	response_time = timer()
	actual_time = datetime.datetime.now()

	print("Time returned by server: " + str(server_time))

	process_delay_latency = response_time - request_time

	print("Process Delay latency: " \
		+ str(process_delay_latency) \
		+ " seconds")

	print("Actual clock time at client side: " \
		+ str(actual_time))

	# synchronize process client clock time
	client_time = server_time \
					+ datetime.timedelta(seconds = \
							(process_delay_latency) / 2)

	print("Synchronized process client time: " \
										+ str(client_time))

	# calculate synchronization error
	error = actual_time - client_time
	print("Synchronization error : "
				+ str(error.total_seconds()) + " seconds")

	s.close()	


# Driver function
if __name__ == '__main__':

	# synchronize time using clock server
	synchronizeTime()
 Output: Time returned by server: 2018-11-07 17:56:43.302379
Process Delay latency: 0.0005150819997652434 seconds
Actual clock time at client side: 2018-11-07 17:56:43.302756
Synchronized process client time: 2018-11-07 17:56:43.302637
Synchronization error : 0.000119 seconds
 We can define a minimum transfer time that we can use to create an improved synchronisation clock time through iterative testing over the network (less synchronisation error). The server time will always be generated after T0 + T min in this case, and TSERVER will always be generated before T1 - Tmin, where T min is the minimum transfer time, which is the minimum value of TREQUEST and TRESPONSE during several iterative tests. Here, a formulation of the synchronisation error is as follows: Error E [-((T1 - T0)/2-Tmin), ((T1 - T0)/2-Tmin)] Similar to this, if TREQUEST and TRESPONSE differ by a significant amount of time, TMIN1 and TMIN2 may be used in place of TMIN1 and TMIN2, respectively, where TMIN1 denotes the minimum observed request time and TMIN2 denotes the minimum observed response time over the network. In this scenario, the synchronised clock time can be calculated as follows: (T1 - T0)/2 + (Tmin2 - Tmin1)/2 +TSERVER = TCLIENT Therefore, we can improve clock time synchronisation and subsequently reduce the overall synchronisation error by simply introducing response and request time as separate time latencies. The total clock drift that is seen will determine how many iterative tests need to be performed. Next TopicService Set Identifier (SSID) in Computer Network ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/cristians-algorithm Cristian's Algorithm - javatpoint ? SCROLL TO TOP Home Computer Network DBMS DS DAA Operating Systems Computer Fundamentals Java Python HTML Selenium JavaScript jQuery Interview Q Computer Network Tutorial Introduction Features Architecture Components Computer Network Types Topologies Transmission Modes Models Models OSI Model TCP/IP Model Physical Layer Digital Transmission Transmission Media Guided Media UnGuided Media Multiplexing Switching Switching Modes Switching Techniques Data Link layer Data Link layer Error Detection Error Correction Data Link Controls Network Layer Network Layer Network Addressing Routing Network Layer Protocols Routing Algorithm Routing Algorithm Distance Vector Link State Routing Transport Layer Transport Layer Transport Layer Protocols Application Layer Application Layer Client & Server Model Application Protocols DNS FTP Telnet SMTP SNMP HTTP Network Security Security Privacy Digital Signature PGP Misc What is Router OSI vs TCP/IP TCP vs UDP TCP TCP Port IPv4 vs IPv6 ARP Packet Format ARP Table Working of ARP FTP Client FTP Commands FTP Server I2P Protocol Sliding Window Protocol SNMP SPI Protocol IP ARP Commands ARP Request ARP - Address Resolution Protocol ARP and its types TCP Retransmission CAN Protocol HTTP Status Codes HTTP vs HTTPS RIP Protocol UDP Protocol ICMP Protocol MQTT Protocol OSPF Protocol Stop & Wait Protocol IMAP Protocol POP Protocol CIFS DAS DIMM iSCSI NAS NFS NVMe SAN BGP Go-Back-N ARQ RJ Cable Connection-Oriented vs Connectionless Service CDMA vs GSM What is MAC Address Modem vs Router Switch vs Router USB 2.0 vs USB 3.0 CSMA CA vs CSMA CD Multiple Access Protocols URI vs URL IMAP vs. POP3 SSH Meaning UTP vs STP Status Code 400 MIME Protocol IP address What is a proxy server and how does it work How to set up and use a proxy server What is network security WWW is based on which model Proxy Server List Fundamentals of Computer Networking IP Address Format and Table Bus topology vs Ring topology Bus topology vs Star topology Circuit Switching vs Packet switching star vs ring topology Router vs Bridge TCP Connection Termination Image Steganography Network Neutrality Onion Routing ASA features Relabel-to-front Algorithm Types of Server Virtualization in Computer Network Access Lists (ACL) Digital Subscriber Line (DSL) Operating system based Virtualization Context based Access Control (CBAC) Cristian's Algorithm Service Set Identifier (SSID) in Computer Network Voice over Internet Protocol (VoIP) MCQ Computer Network MCQ Computer Network MCQ Part2 Interview Questions Networking Questions next ? ? prev Cristian's Algorithm Client processes synchronise time with a time server using Cristian's Algorithm, a clock synchronisation algorithm. While redundancy-prone distributed systems and applications do not work well with this algorithm, low-latency networks where round trip time is short relative to accuracy do. The time interval between the beginning of a Request and the conclusion of the corresponding Response is referred to as Round Trip Time in this context. An example mimicking the operation of Cristian's algorithm is provided below: Algorithm: The process on the client machine sends the clock server a request at time T 0 for the clock time (time at the server). In response to the client process's request, the clock server listens and responds with clock server time. The client process retrieves the response from the clock server at time T1 and uses the formula below to determine the synchronised client clock time. TCLIENT = TSERVER plus (T1 - T0)/2. where TCLIENT denotes the synchronised clock time, TSERVER denotes the clock time returned by the server, T0 denotes the time at which the client process sent the request, and T1 denotes the time at which the client process received the response The formula above is valid and reliable: Assuming that the network latency T0 and T1 are roughly equal, T1 - T0 denotes the total amount of time required by the network and server to transfer the request to the server, process it, and return the result to the client process. The difference between client-side and real-time time is no more than (T1 - T0)/2 seconds. We can infer from the aforementioned statement that the synchronisation error can only be (T1 - T0)/2 seconds at most. Hence, Error E [-(T 1 - T 0)/2, (T 1 - T 0)/2] The Python codes below demonstrate how Cristian's algorithm functions. To start a clock server prototype on a local machine, enter the following code: Python 
# Python3 program imitating a clock server

import socket
import datetime

# function used to initiate the Clock Server
def initiateClockServer():

	s = socket.socket()
	print("Socket successfully created")
	
	# Server port
	port = 8000

	s.bind(('', port))
	
	# Start listening to requests
	s.listen(5)	
	print("Socket is listening...")
	
	# Clock Server Running forever
	while True:
	
	# Establish connection with client
	connection, address = s.accept()	
	print('Server connected to', address)
	
	# Respond the client with server clock time
	connection.send(str(
					datetime.datetime.now()).encode())
	
	# Close the connection with the client process
	connection.close()


# Driver function
if __name__ == '__main__':

	# Trigger the Clock Server
	initiateClockServer()
 Output: Socket successfully created
Socket is listening...
 On the local machine, the following code runs a client process prototype: Python 
# Python3 program imitating a client process

import socket
import datetime
from dateutil import parser
from timeit import default_timer as timer

# function used to Synchronize client process time
def synchronizeTime():

	s = socket.socket()		
	
	# Server port
	port = 8000	
	
	# connect to the clock server on local computer
	s.connect(('127.0.0.1', port))

	request_time = timer()

	# receive data from the server
	server_time = parser.parse(s.recv(1024).decode())
	response_time = timer()
	actual_time = datetime.datetime.now()

	print("Time returned by server: " + str(server_time))

	process_delay_latency = response_time - request_time

	print("Process Delay latency: " \
		+ str(process_delay_latency) \
		+ " seconds")

	print("Actual clock time at client side: " \
		+ str(actual_time))

	# synchronize process client clock time
	client_time = server_time \
					+ datetime.timedelta(seconds = \
							(process_delay_latency) / 2)

	print("Synchronized process client time: " \
										+ str(client_time))

	# calculate synchronization error
	error = actual_time - client_time
	print("Synchronization error : "
				+ str(error.total_seconds()) + " seconds")

	s.close()	


# Driver function
if __name__ == '__main__':

	# synchronize time using clock server
	synchronizeTime()
 Output: Time returned by server: 2018-11-07 17:56:43.302379
Process Delay latency: 0.0005150819997652434 seconds
Actual clock time at client side: 2018-11-07 17:56:43.302756
Synchronized process client time: 2018-11-07 17:56:43.302637
Synchronization error : 0.000119 seconds
 We can define a minimum transfer time that we can use to create an improved synchronisation clock time through iterative testing over the network (less synchronisation error). The server time will always be generated after T0 + T min in this case, and TSERVER will always be generated before T1 - Tmin, where T min is the minimum transfer time, which is the minimum value of TREQUEST and TRESPONSE during several iterative tests. Here, a formulation of the synchronisation error is as follows: Error E [-((T1 - T0)/2-Tmin), ((T1 - T0)/2-Tmin)] Similar to this, if TREQUEST and TRESPONSE differ by a significant amount of time, TMIN1 and TMIN2 may be used in place of TMIN1 and TMIN2, respectively, where TMIN1 denotes the minimum observed request time and TMIN2 denotes the minimum observed response time over the network. In this scenario, the synchronised clock time can be calculated as follows: (T1 - T0)/2 + (Tmin2 - Tmin1)/2 +TSERVER = TCLIENT Therefore, we can improve clock time synchronisation and subsequently reduce the overall synchronisation error by simply introducing response and request time as separate time latencies. The total clock drift that is seen will determine how many iterative tests need to be performed. Next TopicService Set Identifier (SSID) in Computer Network ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/cristians-algorithm Cristian's Algorithm - javatpoint ? SCROLL TO TOP Home Computer Network DBMS DS DAA Operating Systems Computer Fundamentals Java Python HTML Selenium JavaScript jQuery Interview Q Computer Network Tutorial Introduction Features Architecture Components Computer Network Types Topologies Transmission Modes Models Models OSI Model TCP/IP Model Physical Layer Digital Transmission Transmission Media Guided Media UnGuided Media Multiplexing Switching Switching Modes Switching Techniques Data Link layer Data Link layer Error Detection Error Correction Data Link Controls Network Layer Network Layer Network Addressing Routing Network Layer Protocols Routing Algorithm Routing Algorithm Distance Vector Link State Routing Transport Layer Transport Layer Transport Layer Protocols Application Layer Application Layer Client & Server Model Application Protocols DNS FTP Telnet SMTP SNMP HTTP Network Security Security Privacy Digital Signature PGP Misc What is Router OSI vs TCP/IP TCP vs UDP TCP TCP Port IPv4 vs IPv6 ARP Packet Format ARP Table Working of ARP FTP Client FTP Commands FTP Server I2P Protocol Sliding Window Protocol SNMP SPI Protocol IP ARP Commands ARP Request ARP - Address Resolution Protocol ARP and its types TCP Retransmission CAN Protocol HTTP Status Codes HTTP vs HTTPS RIP Protocol UDP Protocol ICMP Protocol MQTT Protocol OSPF Protocol Stop & Wait Protocol IMAP Protocol POP Protocol CIFS DAS DIMM iSCSI NAS NFS NVMe SAN BGP Go-Back-N ARQ RJ Cable Connection-Oriented vs Connectionless Service CDMA vs GSM What is MAC Address Modem vs Router Switch vs Router USB 2.0 vs USB 3.0 CSMA CA vs CSMA CD Multiple Access Protocols URI vs URL IMAP vs. POP3 SSH Meaning UTP vs STP Status Code 400 MIME Protocol IP address What is a proxy server and how does it work How to set up and use a proxy server What is network security WWW is based on which model Proxy Server List Fundamentals of Computer Networking IP Address Format and Table Bus topology vs Ring topology Bus topology vs Star topology Circuit Switching vs Packet switching star vs ring topology Router vs Bridge TCP Connection Termination Image Steganography Network Neutrality Onion Routing ASA features Relabel-to-front Algorithm Types of Server Virtualization in Computer Network Access Lists (ACL) Digital Subscriber Line (DSL) Operating system based Virtualization Context based Access Control (CBAC) Cristian's Algorithm Service Set Identifier (SSID) in Computer Network Voice over Internet Protocol (VoIP) MCQ Computer Network MCQ Computer Network MCQ Part2 Interview Questions Networking Questions next ? ? prev Cristian's Algorithm Client processes synchronise time with a time server using Cristian's Algorithm, a clock synchronisation algorithm. While redundancy-prone distributed systems and applications do not work well with this algorithm, low-latency networks where round trip time is short relative to accuracy do. The time interval between the beginning of a Request and the conclusion of the corresponding Response is referred to as Round Trip Time in this context. An example mimicking the operation of Cristian's algorithm is provided below: Algorithm: The process on the client machine sends the clock server a request at time T 0 for the clock time (time at the server). In response to the client process's request, the clock server listens and responds with clock server time. The client process retrieves the response from the clock server at time T1 and uses the formula below to determine the synchronised client clock time. TCLIENT = TSERVER plus (T1 - T0)/2. where TCLIENT denotes the synchronised clock time, TSERVER denotes the clock time returned by the server, T0 denotes the time at which the client process sent the request, and T1 denotes the time at which the client process received the response The formula above is valid and reliable: Assuming that the network latency T0 and T1 are roughly equal, T1 - T0 denotes the total amount of time required by the network and server to transfer the request to the server, process it, and return the result to the client process. The difference between client-side and real-time time is no more than (T1 - T0)/2 seconds. We can infer from the aforementioned statement that the synchronisation error can only be (T1 - T0)/2 seconds at most. Hence, Error E [-(T 1 - T 0)/2, (T 1 - T 0)/2] The Python codes below demonstrate how Cristian's algorithm functions. To start a clock server prototype on a local machine, enter the following code: Python 
# Python3 program imitating a clock server

import socket
import datetime

# function used to initiate the Clock Server
def initiateClockServer():

	s = socket.socket()
	print("Socket successfully created")
	
	# Server port
	port = 8000

	s.bind(('', port))
	
	# Start listening to requests
	s.listen(5)	
	print("Socket is listening...")
	
	# Clock Server Running forever
	while True:
	
	# Establish connection with client
	connection, address = s.accept()	
	print('Server connected to', address)
	
	# Respond the client with server clock time
	connection.send(str(
					datetime.datetime.now()).encode())
	
	# Close the connection with the client process
	connection.close()


# Driver function
if __name__ == '__main__':

	# Trigger the Clock Server
	initiateClockServer()
 Output: Socket successfully created
Socket is listening...
 On the local machine, the following code runs a client process prototype: Python 
# Python3 program imitating a client process

import socket
import datetime
from dateutil import parser
from timeit import default_timer as timer

# function used to Synchronize client process time
def synchronizeTime():

	s = socket.socket()		
	
	# Server port
	port = 8000	
	
	# connect to the clock server on local computer
	s.connect(('127.0.0.1', port))

	request_time = timer()

	# receive data from the server
	server_time = parser.parse(s.recv(1024).decode())
	response_time = timer()
	actual_time = datetime.datetime.now()

	print("Time returned by server: " + str(server_time))

	process_delay_latency = response_time - request_time

	print("Process Delay latency: " \
		+ str(process_delay_latency) \
		+ " seconds")

	print("Actual clock time at client side: " \
		+ str(actual_time))

	# synchronize process client clock time
	client_time = server_time \
					+ datetime.timedelta(seconds = \
							(process_delay_latency) / 2)

	print("Synchronized process client time: " \
										+ str(client_time))

	# calculate synchronization error
	error = actual_time - client_time
	print("Synchronization error : "
				+ str(error.total_seconds()) + " seconds")

	s.close()	


# Driver function
if __name__ == '__main__':

	# synchronize time using clock server
	synchronizeTime()
 Output: Time returned by server: 2018-11-07 17:56:43.302379
Process Delay latency: 0.0005150819997652434 seconds
Actual clock time at client side: 2018-11-07 17:56:43.302756
Synchronized process client time: 2018-11-07 17:56:43.302637
Synchronization error : 0.000119 seconds
 We can define a minimum transfer time that we can use to create an improved synchronisation clock time through iterative testing over the network (less synchronisation error). The server time will always be generated after T0 + T min in this case, and TSERVER will always be generated before T1 - Tmin, where T min is the minimum transfer time, which is the minimum value of TREQUEST and TRESPONSE during several iterative tests. Here, a formulation of the synchronisation error is as follows: Error E [-((T1 - T0)/2-Tmin), ((T1 - T0)/2-Tmin)] Similar to this, if TREQUEST and TRESPONSE differ by a significant amount of time, TMIN1 and TMIN2 may be used in place of TMIN1 and TMIN2, respectively, where TMIN1 denotes the minimum observed request time and TMIN2 denotes the minimum observed response time over the network. In this scenario, the synchronised clock time can be calculated as follows: (T1 - T0)/2 + (Tmin2 - Tmin1)/2 +TSERVER = TCLIENT Therefore, we can improve clock time synchronisation and subsequently reduce the overall synchronisation error by simply introducing response and request time as separate time latencies. The total clock drift that is seen will determine how many iterative tests need to be performed. Next TopicService Set Identifier (SSID) in Computer Network ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/cristians-algorithm Cristian's Algorithm - javatpoint ? SCROLL TO TOP Home Computer Network DBMS DS DAA Operating Systems Computer Fundamentals Java Python HTML Selenium JavaScript jQuery Interview Q Computer Network Tutorial Introduction Features Architecture Components Computer Network Types Topologies Transmission Modes Models Models OSI Model TCP/IP Model Physical Layer Digital Transmission Transmission Media Guided Media UnGuided Media Multiplexing Switching Switching Modes Switching Techniques Data Link layer Data Link layer Error Detection Error Correction Data Link Controls Network Layer Network Layer Network Addressing Routing Network Layer Protocols Routing Algorithm Routing Algorithm Distance Vector Link State Routing Transport Layer Transport Layer Transport Layer Protocols Application Layer Application Layer Client & Server Model Application Protocols DNS FTP Telnet SMTP SNMP HTTP Network Security Security Privacy Digital Signature PGP Misc What is Router OSI vs TCP/IP TCP vs UDP TCP TCP Port IPv4 vs IPv6 ARP Packet Format ARP Table Working of ARP FTP Client FTP Commands FTP Server I2P Protocol Sliding Window Protocol SNMP SPI Protocol IP ARP Commands ARP Request ARP - Address Resolution Protocol ARP and its types TCP Retransmission CAN Protocol HTTP Status Codes HTTP vs HTTPS RIP Protocol UDP Protocol ICMP Protocol MQTT Protocol OSPF Protocol Stop & Wait Protocol IMAP Protocol POP Protocol CIFS DAS DIMM iSCSI NAS NFS NVMe SAN BGP Go-Back-N ARQ RJ Cable Connection-Oriented vs Connectionless Service CDMA vs GSM What is MAC Address Modem vs Router Switch vs Router USB 2.0 vs USB 3.0 CSMA CA vs CSMA CD Multiple Access Protocols URI vs URL IMAP vs. POP3 SSH Meaning UTP vs STP Status Code 400 MIME Protocol IP address What is a proxy server and how does it work How to set up and use a proxy server What is network security WWW is based on which model Proxy Server List Fundamentals of Computer Networking IP Address Format and Table Bus topology vs Ring topology Bus topology vs Star topology Circuit Switching vs Packet switching star vs ring topology Router vs Bridge TCP Connection Termination Image Steganography Network Neutrality Onion Routing ASA features Relabel-to-front Algorithm Types of Server Virtualization in Computer Network Access Lists (ACL) Digital Subscriber Line (DSL) Operating system based Virtualization Context based Access Control (CBAC) Cristian's Algorithm Service Set Identifier (SSID) in Computer Network Voice over Internet Protocol (VoIP) MCQ Computer Network MCQ Computer Network MCQ Part2 Interview Questions Networking Questions next ? ? prev Cristian's Algorithm Client processes synchronise time with a time server using Cristian's Algorithm, a clock synchronisation algorithm. While redundancy-prone distributed systems and applications do not work well with this algorithm, low-latency networks where round trip time is short relative to accuracy do. The time interval between the beginning of a Request and the conclusion of the corresponding Response is referred to as Round Trip Time in this context. An example mimicking the operation of Cristian's algorithm is provided below: Algorithm: The process on the client machine sends the clock server a request at time T 0 for the clock time (time at the server). In response to the client process's request, the clock server listens and responds with clock server time. The client process retrieves the response from the clock server at time T1 and uses the formula below to determine the synchronised client clock time. TCLIENT = TSERVER plus (T1 - T0)/2. where TCLIENT denotes the synchronised clock time, TSERVER denotes the clock time returned by the server, T0 denotes the time at which the client process sent the request, and T1 denotes the time at which the client process received the response The formula above is valid and reliable: Assuming that the network latency T0 and T1 are roughly equal, T1 - T0 denotes the total amount of time required by the network and server to transfer the request to the server, process it, and return the result to the client process. The difference between client-side and real-time time is no more than (T1 - T0)/2 seconds. We can infer from the aforementioned statement that the synchronisation error can only be (T1 - T0)/2 seconds at most. Hence, Error E [-(T 1 - T 0)/2, (T 1 - T 0)/2] The Python codes below demonstrate how Cristian's algorithm functions. To start a clock server prototype on a local machine, enter the following code: Python 
# Python3 program imitating a clock server

import socket
import datetime

# function used to initiate the Clock Server
def initiateClockServer():

	s = socket.socket()
	print("Socket successfully created")
	
	# Server port
	port = 8000

	s.bind(('', port))
	
	# Start listening to requests
	s.listen(5)	
	print("Socket is listening...")
	
	# Clock Server Running forever
	while True:
	
	# Establish connection with client
	connection, address = s.accept()	
	print('Server connected to', address)
	
	# Respond the client with server clock time
	connection.send(str(
					datetime.datetime.now()).encode())
	
	# Close the connection with the client process
	connection.close()


# Driver function
if __name__ == '__main__':

	# Trigger the Clock Server
	initiateClockServer()
 Output: Socket successfully created
Socket is listening...
 On the local machine, the following code runs a client process prototype: Python 
# Python3 program imitating a client process

import socket
import datetime
from dateutil import parser
from timeit import default_timer as timer

# function used to Synchronize client process time
def synchronizeTime():

	s = socket.socket()		
	
	# Server port
	port = 8000	
	
	# connect to the clock server on local computer
	s.connect(('127.0.0.1', port))

	request_time = timer()

	# receive data from the server
	server_time = parser.parse(s.recv(1024).decode())
	response_time = timer()
	actual_time = datetime.datetime.now()

	print("Time returned by server: " + str(server_time))

	process_delay_latency = response_time - request_time

	print("Process Delay latency: " \
		+ str(process_delay_latency) \
		+ " seconds")

	print("Actual clock time at client side: " \
		+ str(actual_time))

	# synchronize process client clock time
	client_time = server_time \
					+ datetime.timedelta(seconds = \
							(process_delay_latency) / 2)

	print("Synchronized process client time: " \
										+ str(client_time))

	# calculate synchronization error
	error = actual_time - client_time
	print("Synchronization error : "
				+ str(error.total_seconds()) + " seconds")

	s.close()	


# Driver function
if __name__ == '__main__':

	# synchronize time using clock server
	synchronizeTime()
 Output: Time returned by server: 2018-11-07 17:56:43.302379
Process Delay latency: 0.0005150819997652434 seconds
Actual clock time at client side: 2018-11-07 17:56:43.302756
Synchronized process client time: 2018-11-07 17:56:43.302637
Synchronization error : 0.000119 seconds
 We can define a minimum transfer time that we can use to create an improved synchronisation clock time through iterative testing over the network (less synchronisation error). The server time will always be generated after T0 + T min in this case, and TSERVER will always be generated before T1 - Tmin, where T min is the minimum transfer time, which is the minimum value of TREQUEST and TRESPONSE during several iterative tests. Here, a formulation of the synchronisation error is as follows: Error E [-((T1 - T0)/2-Tmin), ((T1 - T0)/2-Tmin)] Similar to this, if TREQUEST and TRESPONSE differ by a significant amount of time, TMIN1 and TMIN2 may be used in place of TMIN1 and TMIN2, respectively, where TMIN1 denotes the minimum observed request time and TMIN2 denotes the minimum observed response time over the network. In this scenario, the synchronised clock time can be calculated as follows: (T1 - T0)/2 + (Tmin2 - Tmin1)/2 +TSERVER = TCLIENT Therefore, we can improve clock time synchronisation and subsequently reduce the overall synchronisation error by simply introducing response and request time as separate time latencies. The total clock drift that is seen will determine how many iterative tests need to be performed. Next TopicService Set Identifier (SSID) in Computer Network ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/cristians-algorithm Cristian's Algorithm - javatpoint ? SCROLL TO TOP Home Computer Network DBMS DS DAA Operating Systems Computer Fundamentals Java Python HTML Selenium JavaScript jQuery Interview Q Computer Network Tutorial Introduction Features Architecture Components Computer Network Types Topologies Transmission Modes Models Models OSI Model TCP/IP Model Physical Layer Digital Transmission Transmission Media Guided Media UnGuided Media Multiplexing Switching Switching Modes Switching Techniques Data Link layer Data Link layer Error Detection Error Correction Data Link Controls Network Layer Network Layer Network Addressing Routing Network Layer Protocols Routing Algorithm Routing Algorithm Distance Vector Link State Routing Transport Layer Transport Layer Transport Layer Protocols Application Layer Application Layer Client & Server Model Application Protocols DNS FTP Telnet SMTP SNMP HTTP Network Security Security Privacy Digital Signature PGP Misc What is Router OSI vs TCP/IP TCP vs UDP TCP TCP Port IPv4 vs IPv6 ARP Packet Format ARP Table Working of ARP FTP Client FTP Commands FTP Server I2P Protocol Sliding Window Protocol SNMP SPI Protocol IP ARP Commands ARP Request ARP - Address Resolution Protocol ARP and its types TCP Retransmission CAN Protocol HTTP Status Codes HTTP vs HTTPS RIP Protocol UDP Protocol ICMP Protocol MQTT Protocol OSPF Protocol Stop & Wait Protocol IMAP Protocol POP Protocol CIFS DAS DIMM iSCSI NAS NFS NVMe SAN BGP Go-Back-N ARQ RJ Cable Connection-Oriented vs Connectionless Service CDMA vs GSM What is MAC Address Modem vs Router Switch vs Router USB 2.0 vs USB 3.0 CSMA CA vs CSMA CD Multiple Access Protocols URI vs URL IMAP vs. POP3 SSH Meaning UTP vs STP Status Code 400 MIME Protocol IP address What is a proxy server and how does it work How to set up and use a proxy server What is network security WWW is based on which model Proxy Server List Fundamentals of Computer Networking IP Address Format and Table Bus topology vs Ring topology Bus topology vs Star topology Circuit Switching vs Packet switching star vs ring topology Router vs Bridge TCP Connection Termination Image Steganography Network Neutrality Onion Routing ASA features Relabel-to-front Algorithm Types of Server Virtualization in Computer Network Access Lists (ACL) Digital Subscriber Line (DSL) Operating system based Virtualization Context based Access Control (CBAC) Cristian's Algorithm Service Set Identifier (SSID) in Computer Network Voice over Internet Protocol (VoIP) MCQ Computer Network MCQ Computer Network MCQ Part2 Interview Questions Networking Questions next ? ? prev Cristian's Algorithm Client processes synchronise time with a time server using Cristian's Algorithm, a clock synchronisation algorithm. While redundancy-prone distributed systems and applications do not work well with this algorithm, low-latency networks where round trip time is short relative to accuracy do. The time interval between the beginning of a Request and the conclusion of the corresponding Response is referred to as Round Trip Time in this context. An example mimicking the operation of Cristian's algorithm is provided below: Algorithm: The process on the client machine sends the clock server a request at time T 0 for the clock time (time at the server). In response to the client process's request, the clock server listens and responds with clock server time. The client process retrieves the response from the clock server at time T1 and uses the formula below to determine the synchronised client clock time. TCLIENT = TSERVER plus (T1 - T0)/2. where TCLIENT denotes the synchronised clock time, TSERVER denotes the clock time returned by the server, T0 denotes the time at which the client process sent the request, and T1 denotes the time at which the client process received the response The formula above is valid and reliable: Assuming that the network latency T0 and T1 are roughly equal, T1 - T0 denotes the total amount of time required by the network and server to transfer the request to the server, process it, and return the result to the client process. The difference between client-side and real-time time is no more than (T1 - T0)/2 seconds. We can infer from the aforementioned statement that the synchronisation error can only be (T1 - T0)/2 seconds at most. Hence, Error E [-(T 1 - T 0)/2, (T 1 - T 0)/2] The Python codes below demonstrate how Cristian's algorithm functions. To start a clock server prototype on a local machine, enter the following code: Python 
# Python3 program imitating a clock server

import socket
import datetime

# function used to initiate the Clock Server
def initiateClockServer():

	s = socket.socket()
	print("Socket successfully created")
	
	# Server port
	port = 8000

	s.bind(('', port))
	
	# Start listening to requests
	s.listen(5)	
	print("Socket is listening...")
	
	# Clock Server Running forever
	while True:
	
	# Establish connection with client
	connection, address = s.accept()	
	print('Server connected to', address)
	
	# Respond the client with server clock time
	connection.send(str(
					datetime.datetime.now()).encode())
	
	# Close the connection with the client process
	connection.close()


# Driver function
if __name__ == '__main__':

	# Trigger the Clock Server
	initiateClockServer()
 Output: Socket successfully created
Socket is listening...
 On the local machine, the following code runs a client process prototype: Python 
# Python3 program imitating a client process

import socket
import datetime
from dateutil import parser
from timeit import default_timer as timer

# function used to Synchronize client process time
def synchronizeTime():

	s = socket.socket()		
	
	# Server port
	port = 8000	
	
	# connect to the clock server on local computer
	s.connect(('127.0.0.1', port))

	request_time = timer()

	# receive data from the server
	server_time = parser.parse(s.recv(1024).decode())
	response_time = timer()
	actual_time = datetime.datetime.now()

	print("Time returned by server: " + str(server_time))

	process_delay_latency = response_time - request_time

	print("Process Delay latency: " \
		+ str(process_delay_latency) \
		+ " seconds")

	print("Actual clock time at client side: " \
		+ str(actual_time))

	# synchronize process client clock time
	client_time = server_time \
					+ datetime.timedelta(seconds = \
							(process_delay_latency) / 2)

	print("Synchronized process client time: " \
										+ str(client_time))

	# calculate synchronization error
	error = actual_time - client_time
	print("Synchronization error : "
				+ str(error.total_seconds()) + " seconds")

	s.close()	


# Driver function
if __name__ == '__main__':

	# synchronize time using clock server
	synchronizeTime()
 Output: Time returned by server: 2018-11-07 17:56:43.302379
Process Delay latency: 0.0005150819997652434 seconds
Actual clock time at client side: 2018-11-07 17:56:43.302756
Synchronized process client time: 2018-11-07 17:56:43.302637
Synchronization error : 0.000119 seconds
 We can define a minimum transfer time that we can use to create an improved synchronisation clock time through iterative testing over the network (less synchronisation error). The server time will always be generated after T0 + T min in this case, and TSERVER will always be generated before T1 - Tmin, where T min is the minimum transfer time, which is the minimum value of TREQUEST and TRESPONSE during several iterative tests. Here, a formulation of the synchronisation error is as follows: Error E [-((T1 - T0)/2-Tmin), ((T1 - T0)/2-Tmin)] Similar to this, if TREQUEST and TRESPONSE differ by a significant amount of time, TMIN1 and TMIN2 may be used in place of TMIN1 and TMIN2, respectively, where TMIN1 denotes the minimum observed request time and TMIN2 denotes the minimum observed response time over the network. In this scenario, the synchronised clock time can be calculated as follows: (T1 - T0)/2 + (Tmin2 - Tmin1)/2 +TSERVER = TCLIENT Therefore, we can improve clock time synchronisation and subsequently reduce the overall synchronisation error by simply introducing response and request time as separate time latencies. The total clock drift that is seen will determine how many iterative tests need to be performed. Next TopicService Set Identifier (SSID) in Computer Network ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/cristians-algorithm Cristian's Algorithm - javatpoint ? SCROLL TO TOP Home Computer Network DBMS DS DAA Operating Systems Computer Fundamentals Java Python HTML Selenium JavaScript jQuery Interview Q Computer Network Tutorial Introduction Features Architecture Components Computer Network Types Topologies Transmission Modes Models Models OSI Model TCP/IP Model Physical Layer Digital Transmission Transmission Media Guided Media UnGuided Media Multiplexing Switching Switching Modes Switching Techniques Data Link layer Data Link layer Error Detection Error Correction Data Link Controls Network Layer Network Layer Network Addressing Routing Network Layer Protocols Routing Algorithm Routing Algorithm Distance Vector Link State Routing Transport Layer Transport Layer Transport Layer Protocols Application Layer Application Layer Client & Server Model Application Protocols DNS FTP Telnet SMTP SNMP HTTP Network Security Security Privacy Digital Signature PGP Misc What is Router OSI vs TCP/IP TCP vs UDP TCP TCP Port IPv4 vs IPv6 ARP Packet Format ARP Table Working of ARP FTP Client FTP Commands FTP Server I2P Protocol Sliding Window Protocol SNMP SPI Protocol IP ARP Commands ARP Request ARP - Address Resolution Protocol ARP and its types TCP Retransmission CAN Protocol HTTP Status Codes HTTP vs HTTPS RIP Protocol UDP Protocol ICMP Protocol MQTT Protocol OSPF Protocol Stop & Wait Protocol IMAP Protocol POP Protocol CIFS DAS DIMM iSCSI NAS NFS NVMe SAN BGP Go-Back-N ARQ RJ Cable Connection-Oriented vs Connectionless Service CDMA vs GSM What is MAC Address Modem vs Router Switch vs Router USB 2.0 vs USB 3.0 CSMA CA vs CSMA CD Multiple Access Protocols URI vs URL IMAP vs. POP3 SSH Meaning UTP vs STP Status Code 400 MIME Protocol IP address What is a proxy server and how does it work How to set up and use a proxy server What is network security WWW is based on which model Proxy Server List Fundamentals of Computer Networking IP Address Format and Table Bus topology vs Ring topology Bus topology vs Star topology Circuit Switching vs Packet switching star vs ring topology Router vs Bridge TCP Connection Termination Image Steganography Network Neutrality Onion Routing ASA features Relabel-to-front Algorithm Types of Server Virtualization in Computer Network Access Lists (ACL) Digital Subscriber Line (DSL) Operating system based Virtualization Context based Access Control (CBAC) Cristian's Algorithm Service Set Identifier (SSID) in Computer Network Voice over Internet Protocol (VoIP) MCQ Computer Network MCQ Computer Network MCQ Part2 Interview Questions Networking Questions next ? ? prev Cristian's Algorithm Client processes synchronise time with a time server using Cristian's Algorithm, a clock synchronisation algorithm. While redundancy-prone distributed systems and applications do not work well with this algorithm, low-latency networks where round trip time is short relative to accuracy do. The time interval between the beginning of a Request and the conclusion of the corresponding Response is referred to as Round Trip Time in this context. An example mimicking the operation of Cristian's algorithm is provided below: Algorithm: The process on the client machine sends the clock server a request at time T 0 for the clock time (time at the server). In response to the client process's request, the clock server listens and responds with clock server time. The client process retrieves the response from the clock server at time T1 and uses the formula below to determine the synchronised client clock time. TCLIENT = TSERVER plus (T1 - T0)/2. where TCLIENT denotes the synchronised clock time, TSERVER denotes the clock time returned by the server, T0 denotes the time at which the client process sent the request, and T1 denotes the time at which the client process received the response The formula above is valid and reliable: Assuming that the network latency T0 and T1 are roughly equal, T1 - T0 denotes the total amount of time required by the network and server to transfer the request to the server, process it, and return the result to the client process. The difference between client-side and real-time time is no more than (T1 - T0)/2 seconds. We can infer from the aforementioned statement that the synchronisation error can only be (T1 - T0)/2 seconds at most. Hence, Error E [-(T 1 - T 0)/2, (T 1 - T 0)/2] The Python codes below demonstrate how Cristian's algorithm functions. To start a clock server prototype on a local machine, enter the following code: Python 
# Python3 program imitating a clock server

import socket
import datetime

# function used to initiate the Clock Server
def initiateClockServer():

	s = socket.socket()
	print("Socket successfully created")
	
	# Server port
	port = 8000

	s.bind(('', port))
	
	# Start listening to requests
	s.listen(5)	
	print("Socket is listening...")
	
	# Clock Server Running forever
	while True:
	
	# Establish connection with client
	connection, address = s.accept()	
	print('Server connected to', address)
	
	# Respond the client with server clock time
	connection.send(str(
					datetime.datetime.now()).encode())
	
	# Close the connection with the client process
	connection.close()


# Driver function
if __name__ == '__main__':

	# Trigger the Clock Server
	initiateClockServer()
 Output: Socket successfully created
Socket is listening...
 On the local machine, the following code runs a client process prototype: Python 
# Python3 program imitating a client process

import socket
import datetime
from dateutil import parser
from timeit import default_timer as timer

# function used to Synchronize client process time
def synchronizeTime():

	s = socket.socket()		
	
	# Server port
	port = 8000	
	
	# connect to the clock server on local computer
	s.connect(('127.0.0.1', port))

	request_time = timer()

	# receive data from the server
	server_time = parser.parse(s.recv(1024).decode())
	response_time = timer()
	actual_time = datetime.datetime.now()

	print("Time returned by server: " + str(server_time))

	process_delay_latency = response_time - request_time

	print("Process Delay latency: " \
		+ str(process_delay_latency) \
		+ " seconds")

	print("Actual clock time at client side: " \
		+ str(actual_time))

	# synchronize process client clock time
	client_time = server_time \
					+ datetime.timedelta(seconds = \
							(process_delay_latency) / 2)

	print("Synchronized process client time: " \
										+ str(client_time))

	# calculate synchronization error
	error = actual_time - client_time
	print("Synchronization error : "
				+ str(error.total_seconds()) + " seconds")

	s.close()	


# Driver function
if __name__ == '__main__':

	# synchronize time using clock server
	synchronizeTime()
 Output: Time returned by server: 2018-11-07 17:56:43.302379
Process Delay latency: 0.0005150819997652434 seconds
Actual clock time at client side: 2018-11-07 17:56:43.302756
Synchronized process client time: 2018-11-07 17:56:43.302637
Synchronization error : 0.000119 seconds
 We can define a minimum transfer time that we can use to create an improved synchronisation clock time through iterative testing over the network (less synchronisation error). The server time will always be generated after T0 + T min in this case, and TSERVER will always be generated before T1 - Tmin, where T min is the minimum transfer time, which is the minimum value of TREQUEST and TRESPONSE during several iterative tests. Here, a formulation of the synchronisation error is as follows: Error E [-((T1 - T0)/2-Tmin), ((T1 - T0)/2-Tmin)] Similar to this, if TREQUEST and TRESPONSE differ by a significant amount of time, TMIN1 and TMIN2 may be used in place of TMIN1 and TMIN2, respectively, where TMIN1 denotes the minimum observed request time and TMIN2 denotes the minimum observed response time over the network. In this scenario, the synchronised clock time can be calculated as follows: (T1 - T0)/2 + (Tmin2 - Tmin1)/2 +TSERVER = TCLIENT Therefore, we can improve clock time synchronisation and subsequently reduce the overall synchronisation error by simply introducing response and request time as separate time latencies. The total clock drift that is seen will determine how many iterative tests need to be performed. Next TopicService Set Identifier (SSID) in Computer Network ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/cristians-algorithm Cristian's Algorithm - javatpoint ? SCROLL TO TOP Home Computer Network DBMS DS DAA Operating Systems Computer Fundamentals Java Python HTML Selenium JavaScript jQuery Interview Q Computer Network Tutorial Introduction Features Architecture Components Computer Network Types Topologies Transmission Modes Models Models OSI Model TCP/IP Model Physical Layer Digital Transmission Transmission Media Guided Media UnGuided Media Multiplexing Switching Switching Modes Switching Techniques Data Link layer Data Link layer Error Detection Error Correction Data Link Controls Network Layer Network Layer Network Addressing Routing Network Layer Protocols Routing Algorithm Routing Algorithm Distance Vector Link State Routing Transport Layer Transport Layer Transport Layer Protocols Application Layer Application Layer Client & Server Model Application Protocols DNS FTP Telnet SMTP SNMP HTTP Network Security Security Privacy Digital Signature PGP Misc What is Router OSI vs TCP/IP TCP vs UDP TCP TCP Port IPv4 vs IPv6 ARP Packet Format ARP Table Working of ARP FTP Client FTP Commands FTP Server I2P Protocol Sliding Window Protocol SNMP SPI Protocol IP ARP Commands ARP Request ARP - Address Resolution Protocol ARP and its types TCP Retransmission CAN Protocol HTTP Status Codes HTTP vs HTTPS RIP Protocol UDP Protocol ICMP Protocol MQTT Protocol OSPF Protocol Stop & Wait Protocol IMAP Protocol POP Protocol CIFS DAS DIMM iSCSI NAS NFS NVMe SAN BGP Go-Back-N ARQ RJ Cable Connection-Oriented vs Connectionless Service CDMA vs GSM What is MAC Address Modem vs Router Switch vs Router USB 2.0 vs USB 3.0 CSMA CA vs CSMA CD Multiple Access Protocols URI vs URL IMAP vs. POP3 SSH Meaning UTP vs STP Status Code 400 MIME Protocol IP address What is a proxy server and how does it work How to set up and use a proxy server What is network security WWW is based on which model Proxy Server List Fundamentals of Computer Networking IP Address Format and Table Bus topology vs Ring topology Bus topology vs Star topology Circuit Switching vs Packet switching star vs ring topology Router vs Bridge TCP Connection Termination Image Steganography Network Neutrality Onion Routing ASA features Relabel-to-front Algorithm Types of Server Virtualization in Computer Network Access Lists (ACL) Digital Subscriber Line (DSL) Operating system based Virtualization Context based Access Control (CBAC) Cristian's Algorithm Service Set Identifier (SSID) in Computer Network Voice over Internet Protocol (VoIP) MCQ Computer Network MCQ Computer Network MCQ Part2 Interview Questions Networking Questions next ? ? prev Cristian's Algorithm Client processes synchronise time with a time server using Cristian's Algorithm, a clock synchronisation algorithm. While redundancy-prone distributed systems and applications do not work well with this algorithm, low-latency networks where round trip time is short relative to accuracy do. The time interval between the beginning of a Request and the conclusion of the corresponding Response is referred to as Round Trip Time in this context. An example mimicking the operation of Cristian's algorithm is provided below: Algorithm: The process on the client machine sends the clock server a request at time T 0 for the clock time (time at the server). In response to the client process's request, the clock server listens and responds with clock server time. The client process retrieves the response from the clock server at time T1 and uses the formula below to determine the synchronised client clock time. TCLIENT = TSERVER plus (T1 - T0)/2. where TCLIENT denotes the synchronised clock time, TSERVER denotes the clock time returned by the server, T0 denotes the time at which the client process sent the request, and T1 denotes the time at which the client process received the response The formula above is valid and reliable: Assuming that the network latency T0 and T1 are roughly equal, T1 - T0 denotes the total amount of time required by the network and server to transfer the request to the server, process it, and return the result to the client process. The difference between client-side and real-time time is no more than (T1 - T0)/2 seconds. We can infer from the aforementioned statement that the synchronisation error can only be (T1 - T0)/2 seconds at most. Hence, Error E [-(T 1 - T 0)/2, (T 1 - T 0)/2] The Python codes below demonstrate how Cristian's algorithm functions. To start a clock server prototype on a local machine, enter the following code: Python 
# Python3 program imitating a clock server

import socket
import datetime

# function used to initiate the Clock Server
def initiateClockServer():

	s = socket.socket()
	print("Socket successfully created")
	
	# Server port
	port = 8000

	s.bind(('', port))
	
	# Start listening to requests
	s.listen(5)	
	print("Socket is listening...")
	
	# Clock Server Running forever
	while True:
	
	# Establish connection with client
	connection, address = s.accept()	
	print('Server connected to', address)
	
	# Respond the client with server clock time
	connection.send(str(
					datetime.datetime.now()).encode())
	
	# Close the connection with the client process
	connection.close()


# Driver function
if __name__ == '__main__':

	# Trigger the Clock Server
	initiateClockServer()
 Output: Socket successfully created
Socket is listening...
 On the local machine, the following code runs a client process prototype: Python 
# Python3 program imitating a client process

import socket
import datetime
from dateutil import parser
from timeit import default_timer as timer

# function used to Synchronize client process time
def synchronizeTime():

	s = socket.socket()		
	
	# Server port
	port = 8000	
	
	# connect to the clock server on local computer
	s.connect(('127.0.0.1', port))

	request_time = timer()

	# receive data from the server
	server_time = parser.parse(s.recv(1024).decode())
	response_time = timer()
	actual_time = datetime.datetime.now()

	print("Time returned by server: " + str(server_time))

	process_delay_latency = response_time - request_time

	print("Process Delay latency: " \
		+ str(process_delay_latency) \
		+ " seconds")

	print("Actual clock time at client side: " \
		+ str(actual_time))

	# synchronize process client clock time
	client_time = server_time \
					+ datetime.timedelta(seconds = \
							(process_delay_latency) / 2)

	print("Synchronized process client time: " \
										+ str(client_time))

	# calculate synchronization error
	error = actual_time - client_time
	print("Synchronization error : "
				+ str(error.total_seconds()) + " seconds")

	s.close()	


# Driver function
if __name__ == '__main__':

	# synchronize time using clock server
	synchronizeTime()
 Output: Time returned by server: 2018-11-07 17:56:43.302379
Process Delay latency: 0.0005150819997652434 seconds
Actual clock time at client side: 2018-11-07 17:56:43.302756
Synchronized process client time: 2018-11-07 17:56:43.302637
Synchronization error : 0.000119 seconds
 We can define a minimum transfer time that we can use to create an improved synchronisation clock time through iterative testing over the network (less synchronisation error). The server time will always be generated after T0 + T min in this case, and TSERVER will always be generated before T1 - Tmin, where T min is the minimum transfer time, which is the minimum value of TREQUEST and TRESPONSE during several iterative tests. Here, a formulation of the synchronisation error is as follows: Error E [-((T1 - T0)/2-Tmin), ((T1 - T0)/2-Tmin)] Similar to this, if TREQUEST and TRESPONSE differ by a significant amount of time, TMIN1 and TMIN2 may be used in place of TMIN1 and TMIN2, respectively, where TMIN1 denotes the minimum observed request time and TMIN2 denotes the minimum observed response time over the network. In this scenario, the synchronised clock time can be calculated as follows: (T1 - T0)/2 + (Tmin2 - Tmin1)/2 +TSERVER = TCLIENT Therefore, we can improve clock time synchronisation and subsequently reduce the overall synchronisation error by simply introducing response and request time as separate time latencies. The total clock drift that is seen will determine how many iterative tests need to be performed. Next TopicService Set Identifier (SSID) in Computer Network ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/cristians-algorithm Cristian's Algorithm - javatpoint ? SCROLL TO TOP Home Computer Network DBMS DS DAA Operating Systems Computer Fundamentals Java Python HTML Selenium JavaScript jQuery Interview Q Computer Network Tutorial Introduction Features Architecture Components Computer Network Types Topologies Transmission Modes Models Models OSI Model TCP/IP Model Physical Layer Digital Transmission Transmission Media Guided Media UnGuided Media Multiplexing Switching Switching Modes Switching Techniques Data Link layer Data Link layer Error Detection Error Correction Data Link Controls Network Layer Network Layer Network Addressing Routing Network Layer Protocols Routing Algorithm Routing Algorithm Distance Vector Link State Routing Transport Layer Transport Layer Transport Layer Protocols Application Layer Application Layer Client & Server Model Application Protocols DNS FTP Telnet SMTP SNMP HTTP Network Security Security Privacy Digital Signature PGP Misc What is Router OSI vs TCP/IP TCP vs UDP TCP TCP Port IPv4 vs IPv6 ARP Packet Format ARP Table Working of ARP FTP Client FTP Commands FTP Server I2P Protocol Sliding Window Protocol SNMP SPI Protocol IP ARP Commands ARP Request ARP - Address Resolution Protocol ARP and its types TCP Retransmission CAN Protocol HTTP Status Codes HTTP vs HTTPS RIP Protocol UDP Protocol ICMP Protocol MQTT Protocol OSPF Protocol Stop & Wait Protocol IMAP Protocol POP Protocol CIFS DAS DIMM iSCSI NAS NFS NVMe SAN BGP Go-Back-N ARQ RJ Cable Connection-Oriented vs Connectionless Service CDMA vs GSM What is MAC Address Modem vs Router Switch vs Router USB 2.0 vs USB 3.0 CSMA CA vs CSMA CD Multiple Access Protocols URI vs URL IMAP vs. POP3 SSH Meaning UTP vs STP Status Code 400 MIME Protocol IP address What is a proxy server and how does it work How to set up and use a proxy server What is network security WWW is based on which model Proxy Server List Fundamentals of Computer Networking IP Address Format and Table Bus topology vs Ring topology Bus topology vs Star topology Circuit Switching vs Packet switching star vs ring topology Router vs Bridge TCP Connection Termination Image Steganography Network Neutrality Onion Routing ASA features Relabel-to-front Algorithm Types of Server Virtualization in Computer Network Access Lists (ACL) Digital Subscriber Line (DSL) Operating system based Virtualization Context based Access Control (CBAC) Cristian's Algorithm Service Set Identifier (SSID) in Computer Network Voice over Internet Protocol (VoIP) MCQ Computer Network MCQ Computer Network MCQ Part2 Interview Questions Networking Questions next ? ? prev Cristian's Algorithm Client processes synchronise time with a time server using Cristian's Algorithm, a clock synchronisation algorithm. While redundancy-prone distributed systems and applications do not work well with this algorithm, low-latency networks where round trip time is short relative to accuracy do. The time interval between the beginning of a Request and the conclusion of the corresponding Response is referred to as Round Trip Time in this context. An example mimicking the operation of Cristian's algorithm is provided below: Algorithm: The process on the client machine sends the clock server a request at time T 0 for the clock time (time at the server). In response to the client process's request, the clock server listens and responds with clock server time. The client process retrieves the response from the clock server at time T1 and uses the formula below to determine the synchronised client clock time. TCLIENT = TSERVER plus (T1 - T0)/2. where TCLIENT denotes the synchronised clock time, TSERVER denotes the clock time returned by the server, T0 denotes the time at which the client process sent the request, and T1 denotes the time at which the client process received the response The formula above is valid and reliable: Assuming that the network latency T0 and T1 are roughly equal, T1 - T0 denotes the total amount of time required by the network and server to transfer the request to the server, process it, and return the result to the client process. The difference between client-side and real-time time is no more than (T1 - T0)/2 seconds. We can infer from the aforementioned statement that the synchronisation error can only be (T1 - T0)/2 seconds at most. Hence, Error E [-(T 1 - T 0)/2, (T 1 - T 0)/2] The Python codes below demonstrate how Cristian's algorithm functions. To start a clock server prototype on a local machine, enter the following code: Python 
# Python3 program imitating a clock server

import socket
import datetime

# function used to initiate the Clock Server
def initiateClockServer():

	s = socket.socket()
	print("Socket successfully created")
	
	# Server port
	port = 8000

	s.bind(('', port))
	
	# Start listening to requests
	s.listen(5)	
	print("Socket is listening...")
	
	# Clock Server Running forever
	while True:
	
	# Establish connection with client
	connection, address = s.accept()	
	print('Server connected to', address)
	
	# Respond the client with server clock time
	connection.send(str(
					datetime.datetime.now()).encode())
	
	# Close the connection with the client process
	connection.close()


# Driver function
if __name__ == '__main__':

	# Trigger the Clock Server
	initiateClockServer()
 Output: Socket successfully created
Socket is listening...
 On the local machine, the following code runs a client process prototype: Python 
# Python3 program imitating a client process

import socket
import datetime
from dateutil import parser
from timeit import default_timer as timer

# function used to Synchronize client process time
def synchronizeTime():

	s = socket.socket()		
	
	# Server port
	port = 8000	
	
	# connect to the clock server on local computer
	s.connect(('127.0.0.1', port))

	request_time = timer()

	# receive data from the server
	server_time = parser.parse(s.recv(1024).decode())
	response_time = timer()
	actual_time = datetime.datetime.now()

	print("Time returned by server: " + str(server_time))

	process_delay_latency = response_time - request_time

	print("Process Delay latency: " \
		+ str(process_delay_latency) \
		+ " seconds")

	print("Actual clock time at client side: " \
		+ str(actual_time))

	# synchronize process client clock time
	client_time = server_time \
					+ datetime.timedelta(seconds = \
							(process_delay_latency) / 2)

	print("Synchronized process client time: " \
										+ str(client_time))

	# calculate synchronization error
	error = actual_time - client_time
	print("Synchronization error : "
				+ str(error.total_seconds()) + " seconds")

	s.close()	


# Driver function
if __name__ == '__main__':

	# synchronize time using clock server
	synchronizeTime()
 Output: Time returned by server: 2018-11-07 17:56:43.302379
Process Delay latency: 0.0005150819997652434 seconds
Actual clock time at client side: 2018-11-07 17:56:43.302756
Synchronized process client time: 2018-11-07 17:56:43.302637
Synchronization error : 0.000119 seconds
 We can define a minimum transfer time that we can use to create an improved synchronisation clock time through iterative testing over the network (less synchronisation error). The server time will always be generated after T0 + T min in this case, and TSERVER will always be generated before T1 - Tmin, where T min is the minimum transfer time, which is the minimum value of TREQUEST and TRESPONSE during several iterative tests. Here, a formulation of the synchronisation error is as follows: Error E [-((T1 - T0)/2-Tmin), ((T1 - T0)/2-Tmin)] Similar to this, if TREQUEST and TRESPONSE differ by a significant amount of time, TMIN1 and TMIN2 may be used in place of TMIN1 and TMIN2, respectively, where TMIN1 denotes the minimum observed request time and TMIN2 denotes the minimum observed response time over the network. In this scenario, the synchronised clock time can be calculated as follows: (T1 - T0)/2 + (Tmin2 - Tmin1)/2 +TSERVER = TCLIENT Therefore, we can improve clock time synchronisation and subsequently reduce the overall synchronisation error by simply introducing response and request time as separate time latencies. The total clock drift that is seen will determine how many iterative tests need to be performed. Next TopicService Set Identifier (SSID) in Computer Network ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/cristians-algorithm Cristian's Algorithm - javatpoint ? SCROLL TO TOP Home Computer Network DBMS DS DAA Operating Systems Computer Fundamentals Java Python HTML Selenium JavaScript jQuery Interview Q Computer Network Tutorial Introduction Features Architecture Components Computer Network Types Topologies Transmission Modes Models Models OSI Model TCP/IP Model Physical Layer Digital Transmission Transmission Media Guided Media UnGuided Media Multiplexing Switching Switching Modes Switching Techniques Data Link layer Data Link layer Error Detection Error Correction Data Link Controls Network Layer Network Layer Network Addressing Routing Network Layer Protocols Routing Algorithm Routing Algorithm Distance Vector Link State Routing Transport Layer Transport Layer Transport Layer Protocols Application Layer Application Layer Client & Server Model Application Protocols DNS FTP Telnet SMTP SNMP HTTP Network Security Security Privacy Digital Signature PGP Misc What is Router OSI vs TCP/IP TCP vs UDP TCP TCP Port IPv4 vs IPv6 ARP Packet Format ARP Table Working of ARP FTP Client FTP Commands FTP Server I2P Protocol Sliding Window Protocol SNMP SPI Protocol IP ARP Commands ARP Request ARP - Address Resolution Protocol ARP and its types TCP Retransmission CAN Protocol HTTP Status Codes HTTP vs HTTPS RIP Protocol UDP Protocol ICMP Protocol MQTT Protocol OSPF Protocol Stop & Wait Protocol IMAP Protocol POP Protocol CIFS DAS DIMM iSCSI NAS NFS NVMe SAN BGP Go-Back-N ARQ RJ Cable Connection-Oriented vs Connectionless Service CDMA vs GSM What is MAC Address Modem vs Router Switch vs Router USB 2.0 vs USB 3.0 CSMA CA vs CSMA CD Multiple Access Protocols URI vs URL IMAP vs. POP3 SSH Meaning UTP vs STP Status Code 400 MIME Protocol IP address What is a proxy server and how does it work How to set up and use a proxy server What is network security WWW is based on which model Proxy Server List Fundamentals of Computer Networking IP Address Format and Table Bus topology vs Ring topology Bus topology vs Star topology Circuit Switching vs Packet switching star vs ring topology Router vs Bridge TCP Connection Termination Image Steganography Network Neutrality Onion Routing ASA features Relabel-to-front Algorithm Types of Server Virtualization in Computer Network Access Lists (ACL) Digital Subscriber Line (DSL) Operating system based Virtualization Context based Access Control (CBAC) Cristian's Algorithm Service Set Identifier (SSID) in Computer Network Voice over Internet Protocol (VoIP) MCQ Computer Network MCQ Computer Network MCQ Part2 Interview Questions Networking Questions next ? ? prev Cristian's Algorithm Client processes synchronise time with a time server using Cristian's Algorithm, a clock synchronisation algorithm. While redundancy-prone distributed systems and applications do not work well with this algorithm, low-latency networks where round trip time is short relative to accuracy do. The time interval between the beginning of a Request and the conclusion of the corresponding Response is referred to as Round Trip Time in this context. An example mimicking the operation of Cristian's algorithm is provided below: Algorithm: The process on the client machine sends the clock server a request at time T 0 for the clock time (time at the server). In response to the client process's request, the clock server listens and responds with clock server time. The client process retrieves the response from the clock server at time T1 and uses the formula below to determine the synchronised client clock time. TCLIENT = TSERVER plus (T1 - T0)/2. where TCLIENT denotes the synchronised clock time, TSERVER denotes the clock time returned by the server, T0 denotes the time at which the client process sent the request, and T1 denotes the time at which the client process received the response The formula above is valid and reliable: Assuming that the network latency T0 and T1 are roughly equal, T1 - T0 denotes the total amount of time required by the network and server to transfer the request to the server, process it, and return the result to the client process. The difference between client-side and real-time time is no more than (T1 - T0)/2 seconds. We can infer from the aforementioned statement that the synchronisation error can only be (T1 - T0)/2 seconds at most. Hence, Error E [-(T 1 - T 0)/2, (T 1 - T 0)/2] The Python codes below demonstrate how Cristian's algorithm functions. To start a clock server prototype on a local machine, enter the following code: Python 
# Python3 program imitating a clock server

import socket
import datetime

# function used to initiate the Clock Server
def initiateClockServer():

	s = socket.socket()
	print("Socket successfully created")
	
	# Server port
	port = 8000

	s.bind(('', port))
	
	# Start listening to requests
	s.listen(5)	
	print("Socket is listening...")
	
	# Clock Server Running forever
	while True:
	
	# Establish connection with client
	connection, address = s.accept()	
	print('Server connected to', address)
	
	# Respond the client with server clock time
	connection.send(str(
					datetime.datetime.now()).encode())
	
	# Close the connection with the client process
	connection.close()


# Driver function
if __name__ == '__main__':

	# Trigger the Clock Server
	initiateClockServer()
 Output: Socket successfully created
Socket is listening...
 On the local machine, the following code runs a client process prototype: Python 
# Python3 program imitating a client process

import socket
import datetime
from dateutil import parser
from timeit import default_timer as timer

# function used to Synchronize client process time
def synchronizeTime():

	s = socket.socket()		
	
	# Server port
	port = 8000	
	
	# connect to the clock server on local computer
	s.connect(('127.0.0.1', port))

	request_time = timer()

	# receive data from the server
	server_time = parser.parse(s.recv(1024).decode())
	response_time = timer()
	actual_time = datetime.datetime.now()

	print("Time returned by server: " + str(server_time))

	process_delay_latency = response_time - request_time

	print("Process Delay latency: " \
		+ str(process_delay_latency) \
		+ " seconds")

	print("Actual clock time at client side: " \
		+ str(actual_time))

	# synchronize process client clock time
	client_time = server_time \
					+ datetime.timedelta(seconds = \
							(process_delay_latency) / 2)

	print("Synchronized process client time: " \
										+ str(client_time))

	# calculate synchronization error
	error = actual_time - client_time
	print("Synchronization error : "
				+ str(error.total_seconds()) + " seconds")

	s.close()	


# Driver function
if __name__ == '__main__':

	# synchronize time using clock server
	synchronizeTime()
 Output: Time returned by server: 2018-11-07 17:56:43.302379
Process Delay latency: 0.0005150819997652434 seconds
Actual clock time at client side: 2018-11-07 17:56:43.302756
Synchronized process client time: 2018-11-07 17:56:43.302637
Synchronization error : 0.000119 seconds
 We can define a minimum transfer time that we can use to create an improved synchronisation clock time through iterative testing over the network (less synchronisation error). The server time will always be generated after T0 + T min in this case, and TSERVER will always be generated before T1 - Tmin, where T min is the minimum transfer time, which is the minimum value of TREQUEST and TRESPONSE during several iterative tests. Here, a formulation of the synchronisation error is as follows: Error E [-((T1 - T0)/2-Tmin), ((T1 - T0)/2-Tmin)] Similar to this, if TREQUEST and TRESPONSE differ by a significant amount of time, TMIN1 and TMIN2 may be used in place of TMIN1 and TMIN2, respectively, where TMIN1 denotes the minimum observed request time and TMIN2 denotes the minimum observed response time over the network. In this scenario, the synchronised clock time can be calculated as follows: (T1 - T0)/2 + (Tmin2 - Tmin1)/2 +TSERVER = TCLIENT Therefore, we can improve clock time synchronisation and subsequently reduce the overall synchronisation error by simply introducing response and request time as separate time latencies. The total clock drift that is seen will determine how many iterative tests need to be performed. Next TopicService Set Identifier (SSID) in Computer Network ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.