https://www.javatpoint.com/smart-pointer Smart Pointer - javatpoint ? SCROLL TO TOP Home C C++ C# Java PHP HTML CSS JavaScript jQuery XML JSON Ajax Node.js SQL Quiz Projects Interview Q Comment Forum Training C++ Tutorial C++ Tutorial C vs C++ C++ History C++ Features C++ Installation C++ Program C++ cout, cin, endl C++ Variable C++ Data types C++ Keywords C++ Operators C++ Identifiers C++ Expression C++ Control Statement C++ if-else C++ switch C++ For Loop C++ While Loop C++ Do-While Loop C++ Break Statement C++ Continue Statement C++ Goto Statement C++ Comments C++ Functions C++ Functions Call by value & reference C++ Recursion C++ Storage Classes C++ Arrays C++ Arrays C++ Array to Function Multidimensional Arrays C++ Pointers C++ Pointers sizeof() operator in C++ C++ Array of Pointers C++ Void Pointer C++ References Reference vs Pointer Function Pointer in C++ C++ Memory Management malloc() vs new in C++ free vs delete in C++ C++ Object Class C++ OOPs Concepts C++ Object Class C++ Constructor C++ Copy Constructor C++ Destructor C++ this Pointer C++ static C++ Structs C++ Enumeration C++ Friend Function C++ Math Functions C++ Inheritance C++ Inheritance C++ Aggregation C++ Polymorphism C++ Polymorphism C++ Overloading C++ Overriding C++ Virtual Function C++ Abstraction C++ Interfaces C++ Data Abstraction C++ Namespaces C++ Namespaces C++ Strings C++ Strings C++ Exceptions C++ Exception Handling C++ try/catch C++ User-Defined C++ Templates C++ Templates Signal Handling C++ Signal Handling C++ File & Stream C++ File & Stream C++ getline() C++ Misc C++ vs C# C++ int to string C++ vs Python Structure vs Class in C++ Virtual Destructor in C++ Constructor vs Destructor in C++ Bit manipulation C++ What is a reference variable Friend Function in C++ Snake Code in C++ Inline function in C++ Virtual function vs Pure virtual function in C++ How to Split strings in C++ Range-based for loop in C++ Type Conversion in C++ LCM of two numbers in C++ Convert string to integer in C++ C++ STL Tutorial C++ STL Components C++ Vector Initialize Vector in C++ C++ Deque C++ List C++ Set C++ Stack C++ Queue C++ Priority Queue C++ Map C++ Multimap C++ Map C++ Bitset C++ Algorithm C++ Iterators C++ Iterators C++ Bidirectional Iterator C++ Forward Iterator C++ Input Iterator C++ Output Iterator C++ Programs C++Programs Fibonacci Series Prime Number Palindrome Number Factorial Armstrong Number Sum of digits Reverse Number Swap Number Matrix Multiplication Decimal to Binary Number in Characters Alphabet Triangle Number Triangle Fibonacci Triangle Char array to string in C++ Calculator Program in C++ Program to convert infix to postfix expression in C++ using the Stack Data Structure C++ program to merge two unsorted arrays C++ coin change program C++ program to add two complex numbers using class C++ program to find the GCD of two numbers C++ program to find greatest of four numbers Delete Operator in C++ How to concatenate two strings in c++ Upcasting and Downcasting in C++ C++ Dijkstra Algorithm using the priority queue Constructor overloading in C++ Default arguments in C++ Dynamic binding in C++ Dynamic memory allocation in C++ Fast input and output in C++ Hierarchical inheritance in C++ Hybrid inheritance in C++ Multiple Inheritance in C++ C++ Bitwise XOR Operator Different Ways to Compare Strings in C++ Reverse an Array in C++ C++ date and time Copy elision in C++ Array of sets in C++ Smart pointers in C++ Types of polymorphism in C++ Implementing the sets without C++ STL containers Scope Resolution Operator in C++ Static Member Function in C++ Const keyword in C++ Memset in C++ Type Casting in C++ Binary Operator Overloading in C++ Binary Search in C++ Inheritance in C++ vs JAVA Static Keyword in C++ and JAVA Exception Handling in C++ and JAVA Foreach in C++ and JAVA C++ templates vs. Java generics Similarities and Differences in C++ and JAVA Default Virtual Behaviour in C++ and JAVA C++ hashing programme with chaining Largest subset whose all elements are Fibonacci numbers Opaque Pointer Pointers such as Dangling, Void, Null, and Wild When do we pass arguments by reference or pointer Find Member Function in Vector in C++ Smart Pointer Currency Converter in C++ Find max in Array Function C++ MCQ C++ MCQ C++ MCQ Part 2 Interview Question Interview Question next ? ? prev Smart Pointer Pointers are used to access resources outside of the programme, such as heap memory. As a result, pointers are used to access heap memory (if anything is created inside heap memory). We simply use a copy of any external resource when accessing it. We simply change it in the copied version if we make any changes. However, if we use a pointer to the resource, we can change the original resource. Issues with Normal Pointers Check out the code below. C++ Code 
#include <iostream>
using namespace std;

class Rectangle {
private:
	int length;
	int breadth;
};

void fun()
{
	// By taking a pointer p and
	// dynamically creating object
	// of class rectangle
	Rectangle* p = new Rectangle();
}

int main()
{
	// Infinite Loop
	while (1) {
		fun();
	}
}
 Function fun generates a pointer pointing to the Rectangle object. Rectangle is made up of two integers: length and breadth. Because p is a local variable, it will be destroyed when the function fun ends. However, because we forgot to use delete p; at the end of the function, the memory it consumed will not be deallocated. This means that the memory will not be available for use by other resources. However, we no longer require the variable, but rather the memory. Fun is called in an infinite loop in function main. That means it will continue to generate p. It will allocate more memory but will not free it because we did not deallocate it. The unused memory cannot be used again. This results in a memory leak. Because of this, the entire heap memory may become useless. Smart Pointer, a feature of C++11, provides a solution to this problem. Smart Pointers are being introduced. Unconsciously, not dealinglocating a pointer causes a memory leak, which may result in a programme crash. Garbage Collection Mechanisms are used in the languages Java and C# to intelligently deallocate unused memory so that it can be used again. The programmer does not have to be concerned about memory leaks. Smart Pointer is a mechanism developed by C++11. When the object is destroyed, the memory is also released. As a result, we don't need to delete it because Smart Pointer will handle it. A Smart Pointer is a pointer wrapper class that has operators like * and -> overloaded. The smart pointer class's objects resemble regular pointers. However, unlike Normal Pointers, it has the ability to deallocate and free destroyed object memory. Take a class that has a pointer, a destructor, and overloaded operators like * and ->. Because the destructor is automatically called when an object exits scope, the dynamically allocated memory would be deleted (or reference count can be decremented). Consider the SmartPtr class shown below. C++ Code 
#include <iostream>
using namespace std;

class SmartPtr {
	int* ptr; // Actual pointer
public:
	// for use of explicit keyword
	explicit SmartPtr(int* p = NULL) { ptr = p; }

	// Destructor
	~SmartPtr() { delete (ptr); }

	// Overloading dereferencing operator
	int& operator*() { return *ptr; }
};

int main()
{
	SmartPtr ptr(new int());
	*ptr = 20;
	cout << *ptr;

	// We don't need to call delete ptr: when the object
	// ptr goes out of scope, the destructor for it is automatically
	// called and destructor does delete ptr.

	return 0;
}
 Output: 20
 This only applies to int. So we'll need to make a Smart Pointer for each object? No, Template, there is a solution. As you can see in the code below, T can be of any type. Learn more about Template by clicking here. C++ Code 
#include <iostream>
using namespace std;

// A generic smart pointer class
template <class T>
class SmartPtr {
	T* ptr; // Actual pointer
public:
	// Constructor
	explicit SmartPtr(T* p = NULL) { ptr = p; }

	// Destructor
	~SmartPtr() { delete (ptr); }

	// Overloading dereferencing operator
	T& operator*() { return *ptr; }

	// Overloading arrow operator so that
	// members of T can be accessed
	// like a pointer (useful if T represents
	// a class or struct or union type)
	T* operator->() { return ptr; }
};

int main()
{
	SmartPtr<int> ptr(new int());
	*ptr = 20;
	cout << *ptr;
	return 0;
}
 Output: 20
 Note: Smart pointers can also be used to manage resources such as file handles or network sockets. Smart Pointer Types 1. unique ptr Only one pointer is stored in unique ptr. By removing the current object from the pointer, we can assign a different object. Take note of the code below. First, the unique_pointer is pointing to P1. However, we remove P1 and replace it with P2, so the pointer now points to P2. C++ Code 
#include <iostream>
using namespace std;
#include <memory>

class Rectangle {
	int length;
	int breadth;

public:
	Rectangle(int l, int b){
		length = l;
		breadth = b;
	}

	int area(){
		return length * breadth;
	}
};

int main(){

	unique_ptr<Rectangle> P1(new Rectangle(10, 5));
	cout << P1->area() << endl; // This'll print 50

	// unique_ptr<Rectangle> P2(P1);
	unique_ptr<Rectangle> P2;
	P2 = move(P1);

	// This'll print 50
	cout << P2->area() << endl;

	// cout<<P1->area()<<endl;
	return 0;
}
 Output: 50
50
 2. shared_ptr Using shared ptr, multiple pointers can point to the same object at the same time, and it will keep a reference counter using the use count() method. C++ Code 
#include <iostream>
using namespace std;
#include <memory>

class Rectangle {
	int length;
	int breadth;

public:
	Rectangle(int l, int b)
	{
		length = l;
		breadth = b;
	}

	int area()
	{
		return length * breadth;
	}
};

int main()
{

	shared_ptr<Rectangle> P1(new Rectangle(10, 5));
	// This'll print 50
	cout << P1->area() << endl;

	shared_ptr<Rectangle> P2;
	P2 = P1;

	// This'll print 50
	cout << P2->area() << endl;

	// This'll now not give an error,
	cout << P1->area() << endl;

	// This'll also print 50 now
	// This'll print 2 as Reference Counter is 2
	cout << P1.use_count() << endl;
	return 0;
}
 Output: 50
50
50
2
 3. weak_ptr It is very similar to shared ptr, except that it does not keep a Reference Counter. A pointer will not have a stronghold on the object in this case. The reason for this is that if pointers are holding the object while requesting other objects, they may form a deadlock. Next TopicCurrency Converter in C++ ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/smart-pointer Smart Pointer - javatpoint ? SCROLL TO TOP Home C C++ C# Java PHP HTML CSS JavaScript jQuery XML JSON Ajax Node.js SQL Quiz Projects Interview Q Comment Forum Training C++ Tutorial C++ Tutorial C vs C++ C++ History C++ Features C++ Installation C++ Program C++ cout, cin, endl C++ Variable C++ Data types C++ Keywords C++ Operators C++ Identifiers C++ Expression C++ Control Statement C++ if-else C++ switch C++ For Loop C++ While Loop C++ Do-While Loop C++ Break Statement C++ Continue Statement C++ Goto Statement C++ Comments C++ Functions C++ Functions Call by value & reference C++ Recursion C++ Storage Classes C++ Arrays C++ Arrays C++ Array to Function Multidimensional Arrays C++ Pointers C++ Pointers sizeof() operator in C++ C++ Array of Pointers C++ Void Pointer C++ References Reference vs Pointer Function Pointer in C++ C++ Memory Management malloc() vs new in C++ free vs delete in C++ C++ Object Class C++ OOPs Concepts C++ Object Class C++ Constructor C++ Copy Constructor C++ Destructor C++ this Pointer C++ static C++ Structs C++ Enumeration C++ Friend Function C++ Math Functions C++ Inheritance C++ Inheritance C++ Aggregation C++ Polymorphism C++ Polymorphism C++ Overloading C++ Overriding C++ Virtual Function C++ Abstraction C++ Interfaces C++ Data Abstraction C++ Namespaces C++ Namespaces C++ Strings C++ Strings C++ Exceptions C++ Exception Handling C++ try/catch C++ User-Defined C++ Templates C++ Templates Signal Handling C++ Signal Handling C++ File & Stream C++ File & Stream C++ getline() C++ Misc C++ vs C# C++ int to string C++ vs Python Structure vs Class in C++ Virtual Destructor in C++ Constructor vs Destructor in C++ Bit manipulation C++ What is a reference variable Friend Function in C++ Snake Code in C++ Inline function in C++ Virtual function vs Pure virtual function in C++ How to Split strings in C++ Range-based for loop in C++ Type Conversion in C++ LCM of two numbers in C++ Convert string to integer in C++ C++ STL Tutorial C++ STL Components C++ Vector Initialize Vector in C++ C++ Deque C++ List C++ Set C++ Stack C++ Queue C++ Priority Queue C++ Map C++ Multimap C++ Map C++ Bitset C++ Algorithm C++ Iterators C++ Iterators C++ Bidirectional Iterator C++ Forward Iterator C++ Input Iterator C++ Output Iterator C++ Programs C++Programs Fibonacci Series Prime Number Palindrome Number Factorial Armstrong Number Sum of digits Reverse Number Swap Number Matrix Multiplication Decimal to Binary Number in Characters Alphabet Triangle Number Triangle Fibonacci Triangle Char array to string in C++ Calculator Program in C++ Program to convert infix to postfix expression in C++ using the Stack Data Structure C++ program to merge two unsorted arrays C++ coin change program C++ program to add two complex numbers using class C++ program to find the GCD of two numbers C++ program to find greatest of four numbers Delete Operator in C++ How to concatenate two strings in c++ Upcasting and Downcasting in C++ C++ Dijkstra Algorithm using the priority queue Constructor overloading in C++ Default arguments in C++ Dynamic binding in C++ Dynamic memory allocation in C++ Fast input and output in C++ Hierarchical inheritance in C++ Hybrid inheritance in C++ Multiple Inheritance in C++ C++ Bitwise XOR Operator Different Ways to Compare Strings in C++ Reverse an Array in C++ C++ date and time Copy elision in C++ Array of sets in C++ Smart pointers in C++ Types of polymorphism in C++ Implementing the sets without C++ STL containers Scope Resolution Operator in C++ Static Member Function in C++ Const keyword in C++ Memset in C++ Type Casting in C++ Binary Operator Overloading in C++ Binary Search in C++ Inheritance in C++ vs JAVA Static Keyword in C++ and JAVA Exception Handling in C++ and JAVA Foreach in C++ and JAVA C++ templates vs. Java generics Similarities and Differences in C++ and JAVA Default Virtual Behaviour in C++ and JAVA C++ hashing programme with chaining Largest subset whose all elements are Fibonacci numbers Opaque Pointer Pointers such as Dangling, Void, Null, and Wild When do we pass arguments by reference or pointer Find Member Function in Vector in C++ Smart Pointer Currency Converter in C++ Find max in Array Function C++ MCQ C++ MCQ C++ MCQ Part 2 Interview Question Interview Question next ? ? prev Smart Pointer Pointers are used to access resources outside of the programme, such as heap memory. As a result, pointers are used to access heap memory (if anything is created inside heap memory). We simply use a copy of any external resource when accessing it. We simply change it in the copied version if we make any changes. However, if we use a pointer to the resource, we can change the original resource. Issues with Normal Pointers Check out the code below. C++ Code 
#include <iostream>
using namespace std;

class Rectangle {
private:
	int length;
	int breadth;
};

void fun()
{
	// By taking a pointer p and
	// dynamically creating object
	// of class rectangle
	Rectangle* p = new Rectangle();
}

int main()
{
	// Infinite Loop
	while (1) {
		fun();
	}
}
 Function fun generates a pointer pointing to the Rectangle object. Rectangle is made up of two integers: length and breadth. Because p is a local variable, it will be destroyed when the function fun ends. However, because we forgot to use delete p; at the end of the function, the memory it consumed will not be deallocated. This means that the memory will not be available for use by other resources. However, we no longer require the variable, but rather the memory. Fun is called in an infinite loop in function main. That means it will continue to generate p. It will allocate more memory but will not free it because we did not deallocate it. The unused memory cannot be used again. This results in a memory leak. Because of this, the entire heap memory may become useless. Smart Pointer, a feature of C++11, provides a solution to this problem. Smart Pointers are being introduced. Unconsciously, not dealinglocating a pointer causes a memory leak, which may result in a programme crash. Garbage Collection Mechanisms are used in the languages Java and C# to intelligently deallocate unused memory so that it can be used again. The programmer does not have to be concerned about memory leaks. Smart Pointer is a mechanism developed by C++11. When the object is destroyed, the memory is also released. As a result, we don't need to delete it because Smart Pointer will handle it. A Smart Pointer is a pointer wrapper class that has operators like * and -> overloaded. The smart pointer class's objects resemble regular pointers. However, unlike Normal Pointers, it has the ability to deallocate and free destroyed object memory. Take a class that has a pointer, a destructor, and overloaded operators like * and ->. Because the destructor is automatically called when an object exits scope, the dynamically allocated memory would be deleted (or reference count can be decremented). Consider the SmartPtr class shown below. C++ Code 
#include <iostream>
using namespace std;

class SmartPtr {
	int* ptr; // Actual pointer
public:
	// for use of explicit keyword
	explicit SmartPtr(int* p = NULL) { ptr = p; }

	// Destructor
	~SmartPtr() { delete (ptr); }

	// Overloading dereferencing operator
	int& operator*() { return *ptr; }
};

int main()
{
	SmartPtr ptr(new int());
	*ptr = 20;
	cout << *ptr;

	// We don't need to call delete ptr: when the object
	// ptr goes out of scope, the destructor for it is automatically
	// called and destructor does delete ptr.

	return 0;
}
 Output: 20
 This only applies to int. So we'll need to make a Smart Pointer for each object? No, Template, there is a solution. As you can see in the code below, T can be of any type. Learn more about Template by clicking here. C++ Code 
#include <iostream>
using namespace std;

// A generic smart pointer class
template <class T>
class SmartPtr {
	T* ptr; // Actual pointer
public:
	// Constructor
	explicit SmartPtr(T* p = NULL) { ptr = p; }

	// Destructor
	~SmartPtr() { delete (ptr); }

	// Overloading dereferencing operator
	T& operator*() { return *ptr; }

	// Overloading arrow operator so that
	// members of T can be accessed
	// like a pointer (useful if T represents
	// a class or struct or union type)
	T* operator->() { return ptr; }
};

int main()
{
	SmartPtr<int> ptr(new int());
	*ptr = 20;
	cout << *ptr;
	return 0;
}
 Output: 20
 Note: Smart pointers can also be used to manage resources such as file handles or network sockets. Smart Pointer Types 1. unique ptr Only one pointer is stored in unique ptr. By removing the current object from the pointer, we can assign a different object. Take note of the code below. First, the unique_pointer is pointing to P1. However, we remove P1 and replace it with P2, so the pointer now points to P2. C++ Code 
#include <iostream>
using namespace std;
#include <memory>

class Rectangle {
	int length;
	int breadth;

public:
	Rectangle(int l, int b){
		length = l;
		breadth = b;
	}

	int area(){
		return length * breadth;
	}
};

int main(){

	unique_ptr<Rectangle> P1(new Rectangle(10, 5));
	cout << P1->area() << endl; // This'll print 50

	// unique_ptr<Rectangle> P2(P1);
	unique_ptr<Rectangle> P2;
	P2 = move(P1);

	// This'll print 50
	cout << P2->area() << endl;

	// cout<<P1->area()<<endl;
	return 0;
}
 Output: 50
50
 2. shared_ptr Using shared ptr, multiple pointers can point to the same object at the same time, and it will keep a reference counter using the use count() method. C++ Code 
#include <iostream>
using namespace std;
#include <memory>

class Rectangle {
	int length;
	int breadth;

public:
	Rectangle(int l, int b)
	{
		length = l;
		breadth = b;
	}

	int area()
	{
		return length * breadth;
	}
};

int main()
{

	shared_ptr<Rectangle> P1(new Rectangle(10, 5));
	// This'll print 50
	cout << P1->area() << endl;

	shared_ptr<Rectangle> P2;
	P2 = P1;

	// This'll print 50
	cout << P2->area() << endl;

	// This'll now not give an error,
	cout << P1->area() << endl;

	// This'll also print 50 now
	// This'll print 2 as Reference Counter is 2
	cout << P1.use_count() << endl;
	return 0;
}
 Output: 50
50
50
2
 3. weak_ptr It is very similar to shared ptr, except that it does not keep a Reference Counter. A pointer will not have a stronghold on the object in this case. The reason for this is that if pointers are holding the object while requesting other objects, they may form a deadlock. Next TopicCurrency Converter in C++ ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/smart-pointer Smart Pointer - javatpoint ? SCROLL TO TOP Home C C++ C# Java PHP HTML CSS JavaScript jQuery XML JSON Ajax Node.js SQL Quiz Projects Interview Q Comment Forum Training C++ Tutorial C++ Tutorial C vs C++ C++ History C++ Features C++ Installation C++ Program C++ cout, cin, endl C++ Variable C++ Data types C++ Keywords C++ Operators C++ Identifiers C++ Expression C++ Control Statement C++ if-else C++ switch C++ For Loop C++ While Loop C++ Do-While Loop C++ Break Statement C++ Continue Statement C++ Goto Statement C++ Comments C++ Functions C++ Functions Call by value & reference C++ Recursion C++ Storage Classes C++ Arrays C++ Arrays C++ Array to Function Multidimensional Arrays C++ Pointers C++ Pointers sizeof() operator in C++ C++ Array of Pointers C++ Void Pointer C++ References Reference vs Pointer Function Pointer in C++ C++ Memory Management malloc() vs new in C++ free vs delete in C++ C++ Object Class C++ OOPs Concepts C++ Object Class C++ Constructor C++ Copy Constructor C++ Destructor C++ this Pointer C++ static C++ Structs C++ Enumeration C++ Friend Function C++ Math Functions C++ Inheritance C++ Inheritance C++ Aggregation C++ Polymorphism C++ Polymorphism C++ Overloading C++ Overriding C++ Virtual Function C++ Abstraction C++ Interfaces C++ Data Abstraction C++ Namespaces C++ Namespaces C++ Strings C++ Strings C++ Exceptions C++ Exception Handling C++ try/catch C++ User-Defined C++ Templates C++ Templates Signal Handling C++ Signal Handling C++ File & Stream C++ File & Stream C++ getline() C++ Misc C++ vs C# C++ int to string C++ vs Python Structure vs Class in C++ Virtual Destructor in C++ Constructor vs Destructor in C++ Bit manipulation C++ What is a reference variable Friend Function in C++ Snake Code in C++ Inline function in C++ Virtual function vs Pure virtual function in C++ How to Split strings in C++ Range-based for loop in C++ Type Conversion in C++ LCM of two numbers in C++ Convert string to integer in C++ C++ STL Tutorial C++ STL Components C++ Vector Initialize Vector in C++ C++ Deque C++ List C++ Set C++ Stack C++ Queue C++ Priority Queue C++ Map C++ Multimap C++ Map C++ Bitset C++ Algorithm C++ Iterators C++ Iterators C++ Bidirectional Iterator C++ Forward Iterator C++ Input Iterator C++ Output Iterator C++ Programs C++Programs Fibonacci Series Prime Number Palindrome Number Factorial Armstrong Number Sum of digits Reverse Number Swap Number Matrix Multiplication Decimal to Binary Number in Characters Alphabet Triangle Number Triangle Fibonacci Triangle Char array to string in C++ Calculator Program in C++ Program to convert infix to postfix expression in C++ using the Stack Data Structure C++ program to merge two unsorted arrays C++ coin change program C++ program to add two complex numbers using class C++ program to find the GCD of two numbers C++ program to find greatest of four numbers Delete Operator in C++ How to concatenate two strings in c++ Upcasting and Downcasting in C++ C++ Dijkstra Algorithm using the priority queue Constructor overloading in C++ Default arguments in C++ Dynamic binding in C++ Dynamic memory allocation in C++ Fast input and output in C++ Hierarchical inheritance in C++ Hybrid inheritance in C++ Multiple Inheritance in C++ C++ Bitwise XOR Operator Different Ways to Compare Strings in C++ Reverse an Array in C++ C++ date and time Copy elision in C++ Array of sets in C++ Smart pointers in C++ Types of polymorphism in C++ Implementing the sets without C++ STL containers Scope Resolution Operator in C++ Static Member Function in C++ Const keyword in C++ Memset in C++ Type Casting in C++ Binary Operator Overloading in C++ Binary Search in C++ Inheritance in C++ vs JAVA Static Keyword in C++ and JAVA Exception Handling in C++ and JAVA Foreach in C++ and JAVA C++ templates vs. Java generics Similarities and Differences in C++ and JAVA Default Virtual Behaviour in C++ and JAVA C++ hashing programme with chaining Largest subset whose all elements are Fibonacci numbers Opaque Pointer Pointers such as Dangling, Void, Null, and Wild When do we pass arguments by reference or pointer Find Member Function in Vector in C++ Smart Pointer Currency Converter in C++ Find max in Array Function C++ MCQ C++ MCQ C++ MCQ Part 2 Interview Question Interview Question next ? ? prev Smart Pointer Pointers are used to access resources outside of the programme, such as heap memory. As a result, pointers are used to access heap memory (if anything is created inside heap memory). We simply use a copy of any external resource when accessing it. We simply change it in the copied version if we make any changes. However, if we use a pointer to the resource, we can change the original resource. Issues with Normal Pointers Check out the code below. C++ Code 
#include <iostream>
using namespace std;

class Rectangle {
private:
	int length;
	int breadth;
};

void fun()
{
	// By taking a pointer p and
	// dynamically creating object
	// of class rectangle
	Rectangle* p = new Rectangle();
}

int main()
{
	// Infinite Loop
	while (1) {
		fun();
	}
}
 Function fun generates a pointer pointing to the Rectangle object. Rectangle is made up of two integers: length and breadth. Because p is a local variable, it will be destroyed when the function fun ends. However, because we forgot to use delete p; at the end of the function, the memory it consumed will not be deallocated. This means that the memory will not be available for use by other resources. However, we no longer require the variable, but rather the memory. Fun is called in an infinite loop in function main. That means it will continue to generate p. It will allocate more memory but will not free it because we did not deallocate it. The unused memory cannot be used again. This results in a memory leak. Because of this, the entire heap memory may become useless. Smart Pointer, a feature of C++11, provides a solution to this problem. Smart Pointers are being introduced. Unconsciously, not dealinglocating a pointer causes a memory leak, which may result in a programme crash. Garbage Collection Mechanisms are used in the languages Java and C# to intelligently deallocate unused memory so that it can be used again. The programmer does not have to be concerned about memory leaks. Smart Pointer is a mechanism developed by C++11. When the object is destroyed, the memory is also released. As a result, we don't need to delete it because Smart Pointer will handle it. A Smart Pointer is a pointer wrapper class that has operators like * and -> overloaded. The smart pointer class's objects resemble regular pointers. However, unlike Normal Pointers, it has the ability to deallocate and free destroyed object memory. Take a class that has a pointer, a destructor, and overloaded operators like * and ->. Because the destructor is automatically called when an object exits scope, the dynamically allocated memory would be deleted (or reference count can be decremented). Consider the SmartPtr class shown below. C++ Code 
#include <iostream>
using namespace std;

class SmartPtr {
	int* ptr; // Actual pointer
public:
	// for use of explicit keyword
	explicit SmartPtr(int* p = NULL) { ptr = p; }

	// Destructor
	~SmartPtr() { delete (ptr); }

	// Overloading dereferencing operator
	int& operator*() { return *ptr; }
};

int main()
{
	SmartPtr ptr(new int());
	*ptr = 20;
	cout << *ptr;

	// We don't need to call delete ptr: when the object
	// ptr goes out of scope, the destructor for it is automatically
	// called and destructor does delete ptr.

	return 0;
}
 Output: 20
 This only applies to int. So we'll need to make a Smart Pointer for each object? No, Template, there is a solution. As you can see in the code below, T can be of any type. Learn more about Template by clicking here. C++ Code 
#include <iostream>
using namespace std;

// A generic smart pointer class
template <class T>
class SmartPtr {
	T* ptr; // Actual pointer
public:
	// Constructor
	explicit SmartPtr(T* p = NULL) { ptr = p; }

	// Destructor
	~SmartPtr() { delete (ptr); }

	// Overloading dereferencing operator
	T& operator*() { return *ptr; }

	// Overloading arrow operator so that
	// members of T can be accessed
	// like a pointer (useful if T represents
	// a class or struct or union type)
	T* operator->() { return ptr; }
};

int main()
{
	SmartPtr<int> ptr(new int());
	*ptr = 20;
	cout << *ptr;
	return 0;
}
 Output: 20
 Note: Smart pointers can also be used to manage resources such as file handles or network sockets. Smart Pointer Types 1. unique ptr Only one pointer is stored in unique ptr. By removing the current object from the pointer, we can assign a different object. Take note of the code below. First, the unique_pointer is pointing to P1. However, we remove P1 and replace it with P2, so the pointer now points to P2. C++ Code 
#include <iostream>
using namespace std;
#include <memory>

class Rectangle {
	int length;
	int breadth;

public:
	Rectangle(int l, int b){
		length = l;
		breadth = b;
	}

	int area(){
		return length * breadth;
	}
};

int main(){

	unique_ptr<Rectangle> P1(new Rectangle(10, 5));
	cout << P1->area() << endl; // This'll print 50

	// unique_ptr<Rectangle> P2(P1);
	unique_ptr<Rectangle> P2;
	P2 = move(P1);

	// This'll print 50
	cout << P2->area() << endl;

	// cout<<P1->area()<<endl;
	return 0;
}
 Output: 50
50
 2. shared_ptr Using shared ptr, multiple pointers can point to the same object at the same time, and it will keep a reference counter using the use count() method. C++ Code 
#include <iostream>
using namespace std;
#include <memory>

class Rectangle {
	int length;
	int breadth;

public:
	Rectangle(int l, int b)
	{
		length = l;
		breadth = b;
	}

	int area()
	{
		return length * breadth;
	}
};

int main()
{

	shared_ptr<Rectangle> P1(new Rectangle(10, 5));
	// This'll print 50
	cout << P1->area() << endl;

	shared_ptr<Rectangle> P2;
	P2 = P1;

	// This'll print 50
	cout << P2->area() << endl;

	// This'll now not give an error,
	cout << P1->area() << endl;

	// This'll also print 50 now
	// This'll print 2 as Reference Counter is 2
	cout << P1.use_count() << endl;
	return 0;
}
 Output: 50
50
50
2
 3. weak_ptr It is very similar to shared ptr, except that it does not keep a Reference Counter. A pointer will not have a stronghold on the object in this case. The reason for this is that if pointers are holding the object while requesting other objects, they may form a deadlock. Next TopicCurrency Converter in C++ ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/smart-pointer Smart Pointer - javatpoint ? SCROLL TO TOP Home C C++ C# Java PHP HTML CSS JavaScript jQuery XML JSON Ajax Node.js SQL Quiz Projects Interview Q Comment Forum Training C++ Tutorial C++ Tutorial C vs C++ C++ History C++ Features C++ Installation C++ Program C++ cout, cin, endl C++ Variable C++ Data types C++ Keywords C++ Operators C++ Identifiers C++ Expression C++ Control Statement C++ if-else C++ switch C++ For Loop C++ While Loop C++ Do-While Loop C++ Break Statement C++ Continue Statement C++ Goto Statement C++ Comments C++ Functions C++ Functions Call by value & reference C++ Recursion C++ Storage Classes C++ Arrays C++ Arrays C++ Array to Function Multidimensional Arrays C++ Pointers C++ Pointers sizeof() operator in C++ C++ Array of Pointers C++ Void Pointer C++ References Reference vs Pointer Function Pointer in C++ C++ Memory Management malloc() vs new in C++ free vs delete in C++ C++ Object Class C++ OOPs Concepts C++ Object Class C++ Constructor C++ Copy Constructor C++ Destructor C++ this Pointer C++ static C++ Structs C++ Enumeration C++ Friend Function C++ Math Functions C++ Inheritance C++ Inheritance C++ Aggregation C++ Polymorphism C++ Polymorphism C++ Overloading C++ Overriding C++ Virtual Function C++ Abstraction C++ Interfaces C++ Data Abstraction C++ Namespaces C++ Namespaces C++ Strings C++ Strings C++ Exceptions C++ Exception Handling C++ try/catch C++ User-Defined C++ Templates C++ Templates Signal Handling C++ Signal Handling C++ File & Stream C++ File & Stream C++ getline() C++ Misc C++ vs C# C++ int to string C++ vs Python Structure vs Class in C++ Virtual Destructor in C++ Constructor vs Destructor in C++ Bit manipulation C++ What is a reference variable Friend Function in C++ Snake Code in C++ Inline function in C++ Virtual function vs Pure virtual function in C++ How to Split strings in C++ Range-based for loop in C++ Type Conversion in C++ LCM of two numbers in C++ Convert string to integer in C++ C++ STL Tutorial C++ STL Components C++ Vector Initialize Vector in C++ C++ Deque C++ List C++ Set C++ Stack C++ Queue C++ Priority Queue C++ Map C++ Multimap C++ Map C++ Bitset C++ Algorithm C++ Iterators C++ Iterators C++ Bidirectional Iterator C++ Forward Iterator C++ Input Iterator C++ Output Iterator C++ Programs C++Programs Fibonacci Series Prime Number Palindrome Number Factorial Armstrong Number Sum of digits Reverse Number Swap Number Matrix Multiplication Decimal to Binary Number in Characters Alphabet Triangle Number Triangle Fibonacci Triangle Char array to string in C++ Calculator Program in C++ Program to convert infix to postfix expression in C++ using the Stack Data Structure C++ program to merge two unsorted arrays C++ coin change program C++ program to add two complex numbers using class C++ program to find the GCD of two numbers C++ program to find greatest of four numbers Delete Operator in C++ How to concatenate two strings in c++ Upcasting and Downcasting in C++ C++ Dijkstra Algorithm using the priority queue Constructor overloading in C++ Default arguments in C++ Dynamic binding in C++ Dynamic memory allocation in C++ Fast input and output in C++ Hierarchical inheritance in C++ Hybrid inheritance in C++ Multiple Inheritance in C++ C++ Bitwise XOR Operator Different Ways to Compare Strings in C++ Reverse an Array in C++ C++ date and time Copy elision in C++ Array of sets in C++ Smart pointers in C++ Types of polymorphism in C++ Implementing the sets without C++ STL containers Scope Resolution Operator in C++ Static Member Function in C++ Const keyword in C++ Memset in C++ Type Casting in C++ Binary Operator Overloading in C++ Binary Search in C++ Inheritance in C++ vs JAVA Static Keyword in C++ and JAVA Exception Handling in C++ and JAVA Foreach in C++ and JAVA C++ templates vs. Java generics Similarities and Differences in C++ and JAVA Default Virtual Behaviour in C++ and JAVA C++ hashing programme with chaining Largest subset whose all elements are Fibonacci numbers Opaque Pointer Pointers such as Dangling, Void, Null, and Wild When do we pass arguments by reference or pointer Find Member Function in Vector in C++ Smart Pointer Currency Converter in C++ Find max in Array Function C++ MCQ C++ MCQ C++ MCQ Part 2 Interview Question Interview Question next ? ? prev Smart Pointer Pointers are used to access resources outside of the programme, such as heap memory. As a result, pointers are used to access heap memory (if anything is created inside heap memory). We simply use a copy of any external resource when accessing it. We simply change it in the copied version if we make any changes. However, if we use a pointer to the resource, we can change the original resource. Issues with Normal Pointers Check out the code below. C++ Code 
#include <iostream>
using namespace std;

class Rectangle {
private:
	int length;
	int breadth;
};

void fun()
{
	// By taking a pointer p and
	// dynamically creating object
	// of class rectangle
	Rectangle* p = new Rectangle();
}

int main()
{
	// Infinite Loop
	while (1) {
		fun();
	}
}
 Function fun generates a pointer pointing to the Rectangle object. Rectangle is made up of two integers: length and breadth. Because p is a local variable, it will be destroyed when the function fun ends. However, because we forgot to use delete p; at the end of the function, the memory it consumed will not be deallocated. This means that the memory will not be available for use by other resources. However, we no longer require the variable, but rather the memory. Fun is called in an infinite loop in function main. That means it will continue to generate p. It will allocate more memory but will not free it because we did not deallocate it. The unused memory cannot be used again. This results in a memory leak. Because of this, the entire heap memory may become useless. Smart Pointer, a feature of C++11, provides a solution to this problem. Smart Pointers are being introduced. Unconsciously, not dealinglocating a pointer causes a memory leak, which may result in a programme crash. Garbage Collection Mechanisms are used in the languages Java and C# to intelligently deallocate unused memory so that it can be used again. The programmer does not have to be concerned about memory leaks. Smart Pointer is a mechanism developed by C++11. When the object is destroyed, the memory is also released. As a result, we don't need to delete it because Smart Pointer will handle it. A Smart Pointer is a pointer wrapper class that has operators like * and -> overloaded. The smart pointer class's objects resemble regular pointers. However, unlike Normal Pointers, it has the ability to deallocate and free destroyed object memory. Take a class that has a pointer, a destructor, and overloaded operators like * and ->. Because the destructor is automatically called when an object exits scope, the dynamically allocated memory would be deleted (or reference count can be decremented). Consider the SmartPtr class shown below. C++ Code 
#include <iostream>
using namespace std;

class SmartPtr {
	int* ptr; // Actual pointer
public:
	// for use of explicit keyword
	explicit SmartPtr(int* p = NULL) { ptr = p; }

	// Destructor
	~SmartPtr() { delete (ptr); }

	// Overloading dereferencing operator
	int& operator*() { return *ptr; }
};

int main()
{
	SmartPtr ptr(new int());
	*ptr = 20;
	cout << *ptr;

	// We don't need to call delete ptr: when the object
	// ptr goes out of scope, the destructor for it is automatically
	// called and destructor does delete ptr.

	return 0;
}
 Output: 20
 This only applies to int. So we'll need to make a Smart Pointer for each object? No, Template, there is a solution. As you can see in the code below, T can be of any type. Learn more about Template by clicking here. C++ Code 
#include <iostream>
using namespace std;

// A generic smart pointer class
template <class T>
class SmartPtr {
	T* ptr; // Actual pointer
public:
	// Constructor
	explicit SmartPtr(T* p = NULL) { ptr = p; }

	// Destructor
	~SmartPtr() { delete (ptr); }

	// Overloading dereferencing operator
	T& operator*() { return *ptr; }

	// Overloading arrow operator so that
	// members of T can be accessed
	// like a pointer (useful if T represents
	// a class or struct or union type)
	T* operator->() { return ptr; }
};

int main()
{
	SmartPtr<int> ptr(new int());
	*ptr = 20;
	cout << *ptr;
	return 0;
}
 Output: 20
 Note: Smart pointers can also be used to manage resources such as file handles or network sockets. Smart Pointer Types 1. unique ptr Only one pointer is stored in unique ptr. By removing the current object from the pointer, we can assign a different object. Take note of the code below. First, the unique_pointer is pointing to P1. However, we remove P1 and replace it with P2, so the pointer now points to P2. C++ Code 
#include <iostream>
using namespace std;
#include <memory>

class Rectangle {
	int length;
	int breadth;

public:
	Rectangle(int l, int b){
		length = l;
		breadth = b;
	}

	int area(){
		return length * breadth;
	}
};

int main(){

	unique_ptr<Rectangle> P1(new Rectangle(10, 5));
	cout << P1->area() << endl; // This'll print 50

	// unique_ptr<Rectangle> P2(P1);
	unique_ptr<Rectangle> P2;
	P2 = move(P1);

	// This'll print 50
	cout << P2->area() << endl;

	// cout<<P1->area()<<endl;
	return 0;
}
 Output: 50
50
 2. shared_ptr Using shared ptr, multiple pointers can point to the same object at the same time, and it will keep a reference counter using the use count() method. C++ Code 
#include <iostream>
using namespace std;
#include <memory>

class Rectangle {
	int length;
	int breadth;

public:
	Rectangle(int l, int b)
	{
		length = l;
		breadth = b;
	}

	int area()
	{
		return length * breadth;
	}
};

int main()
{

	shared_ptr<Rectangle> P1(new Rectangle(10, 5));
	// This'll print 50
	cout << P1->area() << endl;

	shared_ptr<Rectangle> P2;
	P2 = P1;

	// This'll print 50
	cout << P2->area() << endl;

	// This'll now not give an error,
	cout << P1->area() << endl;

	// This'll also print 50 now
	// This'll print 2 as Reference Counter is 2
	cout << P1.use_count() << endl;
	return 0;
}
 Output: 50
50
50
2
 3. weak_ptr It is very similar to shared ptr, except that it does not keep a Reference Counter. A pointer will not have a stronghold on the object in this case. The reason for this is that if pointers are holding the object while requesting other objects, they may form a deadlock. Next TopicCurrency Converter in C++ ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/smart-pointer Smart Pointer - javatpoint ? SCROLL TO TOP Home C C++ C# Java PHP HTML CSS JavaScript jQuery XML JSON Ajax Node.js SQL Quiz Projects Interview Q Comment Forum Training C++ Tutorial C++ Tutorial C vs C++ C++ History C++ Features C++ Installation C++ Program C++ cout, cin, endl C++ Variable C++ Data types C++ Keywords C++ Operators C++ Identifiers C++ Expression C++ Control Statement C++ if-else C++ switch C++ For Loop C++ While Loop C++ Do-While Loop C++ Break Statement C++ Continue Statement C++ Goto Statement C++ Comments C++ Functions C++ Functions Call by value & reference C++ Recursion C++ Storage Classes C++ Arrays C++ Arrays C++ Array to Function Multidimensional Arrays C++ Pointers C++ Pointers sizeof() operator in C++ C++ Array of Pointers C++ Void Pointer C++ References Reference vs Pointer Function Pointer in C++ C++ Memory Management malloc() vs new in C++ free vs delete in C++ C++ Object Class C++ OOPs Concepts C++ Object Class C++ Constructor C++ Copy Constructor C++ Destructor C++ this Pointer C++ static C++ Structs C++ Enumeration C++ Friend Function C++ Math Functions C++ Inheritance C++ Inheritance C++ Aggregation C++ Polymorphism C++ Polymorphism C++ Overloading C++ Overriding C++ Virtual Function C++ Abstraction C++ Interfaces C++ Data Abstraction C++ Namespaces C++ Namespaces C++ Strings C++ Strings C++ Exceptions C++ Exception Handling C++ try/catch C++ User-Defined C++ Templates C++ Templates Signal Handling C++ Signal Handling C++ File & Stream C++ File & Stream C++ getline() C++ Misc C++ vs C# C++ int to string C++ vs Python Structure vs Class in C++ Virtual Destructor in C++ Constructor vs Destructor in C++ Bit manipulation C++ What is a reference variable Friend Function in C++ Snake Code in C++ Inline function in C++ Virtual function vs Pure virtual function in C++ How to Split strings in C++ Range-based for loop in C++ Type Conversion in C++ LCM of two numbers in C++ Convert string to integer in C++ C++ STL Tutorial C++ STL Components C++ Vector Initialize Vector in C++ C++ Deque C++ List C++ Set C++ Stack C++ Queue C++ Priority Queue C++ Map C++ Multimap C++ Map C++ Bitset C++ Algorithm C++ Iterators C++ Iterators C++ Bidirectional Iterator C++ Forward Iterator C++ Input Iterator C++ Output Iterator C++ Programs C++Programs Fibonacci Series Prime Number Palindrome Number Factorial Armstrong Number Sum of digits Reverse Number Swap Number Matrix Multiplication Decimal to Binary Number in Characters Alphabet Triangle Number Triangle Fibonacci Triangle Char array to string in C++ Calculator Program in C++ Program to convert infix to postfix expression in C++ using the Stack Data Structure C++ program to merge two unsorted arrays C++ coin change program C++ program to add two complex numbers using class C++ program to find the GCD of two numbers C++ program to find greatest of four numbers Delete Operator in C++ How to concatenate two strings in c++ Upcasting and Downcasting in C++ C++ Dijkstra Algorithm using the priority queue Constructor overloading in C++ Default arguments in C++ Dynamic binding in C++ Dynamic memory allocation in C++ Fast input and output in C++ Hierarchical inheritance in C++ Hybrid inheritance in C++ Multiple Inheritance in C++ C++ Bitwise XOR Operator Different Ways to Compare Strings in C++ Reverse an Array in C++ C++ date and time Copy elision in C++ Array of sets in C++ Smart pointers in C++ Types of polymorphism in C++ Implementing the sets without C++ STL containers Scope Resolution Operator in C++ Static Member Function in C++ Const keyword in C++ Memset in C++ Type Casting in C++ Binary Operator Overloading in C++ Binary Search in C++ Inheritance in C++ vs JAVA Static Keyword in C++ and JAVA Exception Handling in C++ and JAVA Foreach in C++ and JAVA C++ templates vs. Java generics Similarities and Differences in C++ and JAVA Default Virtual Behaviour in C++ and JAVA C++ hashing programme with chaining Largest subset whose all elements are Fibonacci numbers Opaque Pointer Pointers such as Dangling, Void, Null, and Wild When do we pass arguments by reference or pointer Find Member Function in Vector in C++ Smart Pointer Currency Converter in C++ Find max in Array Function C++ MCQ C++ MCQ C++ MCQ Part 2 Interview Question Interview Question next ? ? prev Smart Pointer Pointers are used to access resources outside of the programme, such as heap memory. As a result, pointers are used to access heap memory (if anything is created inside heap memory). We simply use a copy of any external resource when accessing it. We simply change it in the copied version if we make any changes. However, if we use a pointer to the resource, we can change the original resource. Issues with Normal Pointers Check out the code below. C++ Code 
#include <iostream>
using namespace std;

class Rectangle {
private:
	int length;
	int breadth;
};

void fun()
{
	// By taking a pointer p and
	// dynamically creating object
	// of class rectangle
	Rectangle* p = new Rectangle();
}

int main()
{
	// Infinite Loop
	while (1) {
		fun();
	}
}
 Function fun generates a pointer pointing to the Rectangle object. Rectangle is made up of two integers: length and breadth. Because p is a local variable, it will be destroyed when the function fun ends. However, because we forgot to use delete p; at the end of the function, the memory it consumed will not be deallocated. This means that the memory will not be available for use by other resources. However, we no longer require the variable, but rather the memory. Fun is called in an infinite loop in function main. That means it will continue to generate p. It will allocate more memory but will not free it because we did not deallocate it. The unused memory cannot be used again. This results in a memory leak. Because of this, the entire heap memory may become useless. Smart Pointer, a feature of C++11, provides a solution to this problem. Smart Pointers are being introduced. Unconsciously, not dealinglocating a pointer causes a memory leak, which may result in a programme crash. Garbage Collection Mechanisms are used in the languages Java and C# to intelligently deallocate unused memory so that it can be used again. The programmer does not have to be concerned about memory leaks. Smart Pointer is a mechanism developed by C++11. When the object is destroyed, the memory is also released. As a result, we don't need to delete it because Smart Pointer will handle it. A Smart Pointer is a pointer wrapper class that has operators like * and -> overloaded. The smart pointer class's objects resemble regular pointers. However, unlike Normal Pointers, it has the ability to deallocate and free destroyed object memory. Take a class that has a pointer, a destructor, and overloaded operators like * and ->. Because the destructor is automatically called when an object exits scope, the dynamically allocated memory would be deleted (or reference count can be decremented). Consider the SmartPtr class shown below. C++ Code 
#include <iostream>
using namespace std;

class SmartPtr {
	int* ptr; // Actual pointer
public:
	// for use of explicit keyword
	explicit SmartPtr(int* p = NULL) { ptr = p; }

	// Destructor
	~SmartPtr() { delete (ptr); }

	// Overloading dereferencing operator
	int& operator*() { return *ptr; }
};

int main()
{
	SmartPtr ptr(new int());
	*ptr = 20;
	cout << *ptr;

	// We don't need to call delete ptr: when the object
	// ptr goes out of scope, the destructor for it is automatically
	// called and destructor does delete ptr.

	return 0;
}
 Output: 20
 This only applies to int. So we'll need to make a Smart Pointer for each object? No, Template, there is a solution. As you can see in the code below, T can be of any type. Learn more about Template by clicking here. C++ Code 
#include <iostream>
using namespace std;

// A generic smart pointer class
template <class T>
class SmartPtr {
	T* ptr; // Actual pointer
public:
	// Constructor
	explicit SmartPtr(T* p = NULL) { ptr = p; }

	// Destructor
	~SmartPtr() { delete (ptr); }

	// Overloading dereferencing operator
	T& operator*() { return *ptr; }

	// Overloading arrow operator so that
	// members of T can be accessed
	// like a pointer (useful if T represents
	// a class or struct or union type)
	T* operator->() { return ptr; }
};

int main()
{
	SmartPtr<int> ptr(new int());
	*ptr = 20;
	cout << *ptr;
	return 0;
}
 Output: 20
 Note: Smart pointers can also be used to manage resources such as file handles or network sockets. Smart Pointer Types 1. unique ptr Only one pointer is stored in unique ptr. By removing the current object from the pointer, we can assign a different object. Take note of the code below. First, the unique_pointer is pointing to P1. However, we remove P1 and replace it with P2, so the pointer now points to P2. C++ Code 
#include <iostream>
using namespace std;
#include <memory>

class Rectangle {
	int length;
	int breadth;

public:
	Rectangle(int l, int b){
		length = l;
		breadth = b;
	}

	int area(){
		return length * breadth;
	}
};

int main(){

	unique_ptr<Rectangle> P1(new Rectangle(10, 5));
	cout << P1->area() << endl; // This'll print 50

	// unique_ptr<Rectangle> P2(P1);
	unique_ptr<Rectangle> P2;
	P2 = move(P1);

	// This'll print 50
	cout << P2->area() << endl;

	// cout<<P1->area()<<endl;
	return 0;
}
 Output: 50
50
 2. shared_ptr Using shared ptr, multiple pointers can point to the same object at the same time, and it will keep a reference counter using the use count() method. C++ Code 
#include <iostream>
using namespace std;
#include <memory>

class Rectangle {
	int length;
	int breadth;

public:
	Rectangle(int l, int b)
	{
		length = l;
		breadth = b;
	}

	int area()
	{
		return length * breadth;
	}
};

int main()
{

	shared_ptr<Rectangle> P1(new Rectangle(10, 5));
	// This'll print 50
	cout << P1->area() << endl;

	shared_ptr<Rectangle> P2;
	P2 = P1;

	// This'll print 50
	cout << P2->area() << endl;

	// This'll now not give an error,
	cout << P1->area() << endl;

	// This'll also print 50 now
	// This'll print 2 as Reference Counter is 2
	cout << P1.use_count() << endl;
	return 0;
}
 Output: 50
50
50
2
 3. weak_ptr It is very similar to shared ptr, except that it does not keep a Reference Counter. A pointer will not have a stronghold on the object in this case. The reason for this is that if pointers are holding the object while requesting other objects, they may form a deadlock. Next TopicCurrency Converter in C++ ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/smart-pointer Smart Pointer - javatpoint ? SCROLL TO TOP Home C C++ C# Java PHP HTML CSS JavaScript jQuery XML JSON Ajax Node.js SQL Quiz Projects Interview Q Comment Forum Training C++ Tutorial C++ Tutorial C vs C++ C++ History C++ Features C++ Installation C++ Program C++ cout, cin, endl C++ Variable C++ Data types C++ Keywords C++ Operators C++ Identifiers C++ Expression C++ Control Statement C++ if-else C++ switch C++ For Loop C++ While Loop C++ Do-While Loop C++ Break Statement C++ Continue Statement C++ Goto Statement C++ Comments C++ Functions C++ Functions Call by value & reference C++ Recursion C++ Storage Classes C++ Arrays C++ Arrays C++ Array to Function Multidimensional Arrays C++ Pointers C++ Pointers sizeof() operator in C++ C++ Array of Pointers C++ Void Pointer C++ References Reference vs Pointer Function Pointer in C++ C++ Memory Management malloc() vs new in C++ free vs delete in C++ C++ Object Class C++ OOPs Concepts C++ Object Class C++ Constructor C++ Copy Constructor C++ Destructor C++ this Pointer C++ static C++ Structs C++ Enumeration C++ Friend Function C++ Math Functions C++ Inheritance C++ Inheritance C++ Aggregation C++ Polymorphism C++ Polymorphism C++ Overloading C++ Overriding C++ Virtual Function C++ Abstraction C++ Interfaces C++ Data Abstraction C++ Namespaces C++ Namespaces C++ Strings C++ Strings C++ Exceptions C++ Exception Handling C++ try/catch C++ User-Defined C++ Templates C++ Templates Signal Handling C++ Signal Handling C++ File & Stream C++ File & Stream C++ getline() C++ Misc C++ vs C# C++ int to string C++ vs Python Structure vs Class in C++ Virtual Destructor in C++ Constructor vs Destructor in C++ Bit manipulation C++ What is a reference variable Friend Function in C++ Snake Code in C++ Inline function in C++ Virtual function vs Pure virtual function in C++ How to Split strings in C++ Range-based for loop in C++ Type Conversion in C++ LCM of two numbers in C++ Convert string to integer in C++ C++ STL Tutorial C++ STL Components C++ Vector Initialize Vector in C++ C++ Deque C++ List C++ Set C++ Stack C++ Queue C++ Priority Queue C++ Map C++ Multimap C++ Map C++ Bitset C++ Algorithm C++ Iterators C++ Iterators C++ Bidirectional Iterator C++ Forward Iterator C++ Input Iterator C++ Output Iterator C++ Programs C++Programs Fibonacci Series Prime Number Palindrome Number Factorial Armstrong Number Sum of digits Reverse Number Swap Number Matrix Multiplication Decimal to Binary Number in Characters Alphabet Triangle Number Triangle Fibonacci Triangle Char array to string in C++ Calculator Program in C++ Program to convert infix to postfix expression in C++ using the Stack Data Structure C++ program to merge two unsorted arrays C++ coin change program C++ program to add two complex numbers using class C++ program to find the GCD of two numbers C++ program to find greatest of four numbers Delete Operator in C++ How to concatenate two strings in c++ Upcasting and Downcasting in C++ C++ Dijkstra Algorithm using the priority queue Constructor overloading in C++ Default arguments in C++ Dynamic binding in C++ Dynamic memory allocation in C++ Fast input and output in C++ Hierarchical inheritance in C++ Hybrid inheritance in C++ Multiple Inheritance in C++ C++ Bitwise XOR Operator Different Ways to Compare Strings in C++ Reverse an Array in C++ C++ date and time Copy elision in C++ Array of sets in C++ Smart pointers in C++ Types of polymorphism in C++ Implementing the sets without C++ STL containers Scope Resolution Operator in C++ Static Member Function in C++ Const keyword in C++ Memset in C++ Type Casting in C++ Binary Operator Overloading in C++ Binary Search in C++ Inheritance in C++ vs JAVA Static Keyword in C++ and JAVA Exception Handling in C++ and JAVA Foreach in C++ and JAVA C++ templates vs. Java generics Similarities and Differences in C++ and JAVA Default Virtual Behaviour in C++ and JAVA C++ hashing programme with chaining Largest subset whose all elements are Fibonacci numbers Opaque Pointer Pointers such as Dangling, Void, Null, and Wild When do we pass arguments by reference or pointer Find Member Function in Vector in C++ Smart Pointer Currency Converter in C++ Find max in Array Function C++ MCQ C++ MCQ C++ MCQ Part 2 Interview Question Interview Question next ? ? prev Smart Pointer Pointers are used to access resources outside of the programme, such as heap memory. As a result, pointers are used to access heap memory (if anything is created inside heap memory). We simply use a copy of any external resource when accessing it. We simply change it in the copied version if we make any changes. However, if we use a pointer to the resource, we can change the original resource. Issues with Normal Pointers Check out the code below. C++ Code 
#include <iostream>
using namespace std;

class Rectangle {
private:
	int length;
	int breadth;
};

void fun()
{
	// By taking a pointer p and
	// dynamically creating object
	// of class rectangle
	Rectangle* p = new Rectangle();
}

int main()
{
	// Infinite Loop
	while (1) {
		fun();
	}
}
 Function fun generates a pointer pointing to the Rectangle object. Rectangle is made up of two integers: length and breadth. Because p is a local variable, it will be destroyed when the function fun ends. However, because we forgot to use delete p; at the end of the function, the memory it consumed will not be deallocated. This means that the memory will not be available for use by other resources. However, we no longer require the variable, but rather the memory. Fun is called in an infinite loop in function main. That means it will continue to generate p. It will allocate more memory but will not free it because we did not deallocate it. The unused memory cannot be used again. This results in a memory leak. Because of this, the entire heap memory may become useless. Smart Pointer, a feature of C++11, provides a solution to this problem. Smart Pointers are being introduced. Unconsciously, not dealinglocating a pointer causes a memory leak, which may result in a programme crash. Garbage Collection Mechanisms are used in the languages Java and C# to intelligently deallocate unused memory so that it can be used again. The programmer does not have to be concerned about memory leaks. Smart Pointer is a mechanism developed by C++11. When the object is destroyed, the memory is also released. As a result, we don't need to delete it because Smart Pointer will handle it. A Smart Pointer is a pointer wrapper class that has operators like * and -> overloaded. The smart pointer class's objects resemble regular pointers. However, unlike Normal Pointers, it has the ability to deallocate and free destroyed object memory. Take a class that has a pointer, a destructor, and overloaded operators like * and ->. Because the destructor is automatically called when an object exits scope, the dynamically allocated memory would be deleted (or reference count can be decremented). Consider the SmartPtr class shown below. C++ Code 
#include <iostream>
using namespace std;

class SmartPtr {
	int* ptr; // Actual pointer
public:
	// for use of explicit keyword
	explicit SmartPtr(int* p = NULL) { ptr = p; }

	// Destructor
	~SmartPtr() { delete (ptr); }

	// Overloading dereferencing operator
	int& operator*() { return *ptr; }
};

int main()
{
	SmartPtr ptr(new int());
	*ptr = 20;
	cout << *ptr;

	// We don't need to call delete ptr: when the object
	// ptr goes out of scope, the destructor for it is automatically
	// called and destructor does delete ptr.

	return 0;
}
 Output: 20
 This only applies to int. So we'll need to make a Smart Pointer for each object? No, Template, there is a solution. As you can see in the code below, T can be of any type. Learn more about Template by clicking here. C++ Code 
#include <iostream>
using namespace std;

// A generic smart pointer class
template <class T>
class SmartPtr {
	T* ptr; // Actual pointer
public:
	// Constructor
	explicit SmartPtr(T* p = NULL) { ptr = p; }

	// Destructor
	~SmartPtr() { delete (ptr); }

	// Overloading dereferencing operator
	T& operator*() { return *ptr; }

	// Overloading arrow operator so that
	// members of T can be accessed
	// like a pointer (useful if T represents
	// a class or struct or union type)
	T* operator->() { return ptr; }
};

int main()
{
	SmartPtr<int> ptr(new int());
	*ptr = 20;
	cout << *ptr;
	return 0;
}
 Output: 20
 Note: Smart pointers can also be used to manage resources such as file handles or network sockets. Smart Pointer Types 1. unique ptr Only one pointer is stored in unique ptr. By removing the current object from the pointer, we can assign a different object. Take note of the code below. First, the unique_pointer is pointing to P1. However, we remove P1 and replace it with P2, so the pointer now points to P2. C++ Code 
#include <iostream>
using namespace std;
#include <memory>

class Rectangle {
	int length;
	int breadth;

public:
	Rectangle(int l, int b){
		length = l;
		breadth = b;
	}

	int area(){
		return length * breadth;
	}
};

int main(){

	unique_ptr<Rectangle> P1(new Rectangle(10, 5));
	cout << P1->area() << endl; // This'll print 50

	// unique_ptr<Rectangle> P2(P1);
	unique_ptr<Rectangle> P2;
	P2 = move(P1);

	// This'll print 50
	cout << P2->area() << endl;

	// cout<<P1->area()<<endl;
	return 0;
}
 Output: 50
50
 2. shared_ptr Using shared ptr, multiple pointers can point to the same object at the same time, and it will keep a reference counter using the use count() method. C++ Code 
#include <iostream>
using namespace std;
#include <memory>

class Rectangle {
	int length;
	int breadth;

public:
	Rectangle(int l, int b)
	{
		length = l;
		breadth = b;
	}

	int area()
	{
		return length * breadth;
	}
};

int main()
{

	shared_ptr<Rectangle> P1(new Rectangle(10, 5));
	// This'll print 50
	cout << P1->area() << endl;

	shared_ptr<Rectangle> P2;
	P2 = P1;

	// This'll print 50
	cout << P2->area() << endl;

	// This'll now not give an error,
	cout << P1->area() << endl;

	// This'll also print 50 now
	// This'll print 2 as Reference Counter is 2
	cout << P1.use_count() << endl;
	return 0;
}
 Output: 50
50
50
2
 3. weak_ptr It is very similar to shared ptr, except that it does not keep a Reference Counter. A pointer will not have a stronghold on the object in this case. The reason for this is that if pointers are holding the object while requesting other objects, they may form a deadlock. Next TopicCurrency Converter in C++ ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/smart-pointer Smart Pointer - javatpoint ? SCROLL TO TOP Home C C++ C# Java PHP HTML CSS JavaScript jQuery XML JSON Ajax Node.js SQL Quiz Projects Interview Q Comment Forum Training C++ Tutorial C++ Tutorial C vs C++ C++ History C++ Features C++ Installation C++ Program C++ cout, cin, endl C++ Variable C++ Data types C++ Keywords C++ Operators C++ Identifiers C++ Expression C++ Control Statement C++ if-else C++ switch C++ For Loop C++ While Loop C++ Do-While Loop C++ Break Statement C++ Continue Statement C++ Goto Statement C++ Comments C++ Functions C++ Functions Call by value & reference C++ Recursion C++ Storage Classes C++ Arrays C++ Arrays C++ Array to Function Multidimensional Arrays C++ Pointers C++ Pointers sizeof() operator in C++ C++ Array of Pointers C++ Void Pointer C++ References Reference vs Pointer Function Pointer in C++ C++ Memory Management malloc() vs new in C++ free vs delete in C++ C++ Object Class C++ OOPs Concepts C++ Object Class C++ Constructor C++ Copy Constructor C++ Destructor C++ this Pointer C++ static C++ Structs C++ Enumeration C++ Friend Function C++ Math Functions C++ Inheritance C++ Inheritance C++ Aggregation C++ Polymorphism C++ Polymorphism C++ Overloading C++ Overriding C++ Virtual Function C++ Abstraction C++ Interfaces C++ Data Abstraction C++ Namespaces C++ Namespaces C++ Strings C++ Strings C++ Exceptions C++ Exception Handling C++ try/catch C++ User-Defined C++ Templates C++ Templates Signal Handling C++ Signal Handling C++ File & Stream C++ File & Stream C++ getline() C++ Misc C++ vs C# C++ int to string C++ vs Python Structure vs Class in C++ Virtual Destructor in C++ Constructor vs Destructor in C++ Bit manipulation C++ What is a reference variable Friend Function in C++ Snake Code in C++ Inline function in C++ Virtual function vs Pure virtual function in C++ How to Split strings in C++ Range-based for loop in C++ Type Conversion in C++ LCM of two numbers in C++ Convert string to integer in C++ C++ STL Tutorial C++ STL Components C++ Vector Initialize Vector in C++ C++ Deque C++ List C++ Set C++ Stack C++ Queue C++ Priority Queue C++ Map C++ Multimap C++ Map C++ Bitset C++ Algorithm C++ Iterators C++ Iterators C++ Bidirectional Iterator C++ Forward Iterator C++ Input Iterator C++ Output Iterator C++ Programs C++Programs Fibonacci Series Prime Number Palindrome Number Factorial Armstrong Number Sum of digits Reverse Number Swap Number Matrix Multiplication Decimal to Binary Number in Characters Alphabet Triangle Number Triangle Fibonacci Triangle Char array to string in C++ Calculator Program in C++ Program to convert infix to postfix expression in C++ using the Stack Data Structure C++ program to merge two unsorted arrays C++ coin change program C++ program to add two complex numbers using class C++ program to find the GCD of two numbers C++ program to find greatest of four numbers Delete Operator in C++ How to concatenate two strings in c++ Upcasting and Downcasting in C++ C++ Dijkstra Algorithm using the priority queue Constructor overloading in C++ Default arguments in C++ Dynamic binding in C++ Dynamic memory allocation in C++ Fast input and output in C++ Hierarchical inheritance in C++ Hybrid inheritance in C++ Multiple Inheritance in C++ C++ Bitwise XOR Operator Different Ways to Compare Strings in C++ Reverse an Array in C++ C++ date and time Copy elision in C++ Array of sets in C++ Smart pointers in C++ Types of polymorphism in C++ Implementing the sets without C++ STL containers Scope Resolution Operator in C++ Static Member Function in C++ Const keyword in C++ Memset in C++ Type Casting in C++ Binary Operator Overloading in C++ Binary Search in C++ Inheritance in C++ vs JAVA Static Keyword in C++ and JAVA Exception Handling in C++ and JAVA Foreach in C++ and JAVA C++ templates vs. Java generics Similarities and Differences in C++ and JAVA Default Virtual Behaviour in C++ and JAVA C++ hashing programme with chaining Largest subset whose all elements are Fibonacci numbers Opaque Pointer Pointers such as Dangling, Void, Null, and Wild When do we pass arguments by reference or pointer Find Member Function in Vector in C++ Smart Pointer Currency Converter in C++ Find max in Array Function C++ MCQ C++ MCQ C++ MCQ Part 2 Interview Question Interview Question next ? ? prev Smart Pointer Pointers are used to access resources outside of the programme, such as heap memory. As a result, pointers are used to access heap memory (if anything is created inside heap memory). We simply use a copy of any external resource when accessing it. We simply change it in the copied version if we make any changes. However, if we use a pointer to the resource, we can change the original resource. Issues with Normal Pointers Check out the code below. C++ Code 
#include <iostream>
using namespace std;

class Rectangle {
private:
	int length;
	int breadth;
};

void fun()
{
	// By taking a pointer p and
	// dynamically creating object
	// of class rectangle
	Rectangle* p = new Rectangle();
}

int main()
{
	// Infinite Loop
	while (1) {
		fun();
	}
}
 Function fun generates a pointer pointing to the Rectangle object. Rectangle is made up of two integers: length and breadth. Because p is a local variable, it will be destroyed when the function fun ends. However, because we forgot to use delete p; at the end of the function, the memory it consumed will not be deallocated. This means that the memory will not be available for use by other resources. However, we no longer require the variable, but rather the memory. Fun is called in an infinite loop in function main. That means it will continue to generate p. It will allocate more memory but will not free it because we did not deallocate it. The unused memory cannot be used again. This results in a memory leak. Because of this, the entire heap memory may become useless. Smart Pointer, a feature of C++11, provides a solution to this problem. Smart Pointers are being introduced. Unconsciously, not dealinglocating a pointer causes a memory leak, which may result in a programme crash. Garbage Collection Mechanisms are used in the languages Java and C# to intelligently deallocate unused memory so that it can be used again. The programmer does not have to be concerned about memory leaks. Smart Pointer is a mechanism developed by C++11. When the object is destroyed, the memory is also released. As a result, we don't need to delete it because Smart Pointer will handle it. A Smart Pointer is a pointer wrapper class that has operators like * and -> overloaded. The smart pointer class's objects resemble regular pointers. However, unlike Normal Pointers, it has the ability to deallocate and free destroyed object memory. Take a class that has a pointer, a destructor, and overloaded operators like * and ->. Because the destructor is automatically called when an object exits scope, the dynamically allocated memory would be deleted (or reference count can be decremented). Consider the SmartPtr class shown below. C++ Code 
#include <iostream>
using namespace std;

class SmartPtr {
	int* ptr; // Actual pointer
public:
	// for use of explicit keyword
	explicit SmartPtr(int* p = NULL) { ptr = p; }

	// Destructor
	~SmartPtr() { delete (ptr); }

	// Overloading dereferencing operator
	int& operator*() { return *ptr; }
};

int main()
{
	SmartPtr ptr(new int());
	*ptr = 20;
	cout << *ptr;

	// We don't need to call delete ptr: when the object
	// ptr goes out of scope, the destructor for it is automatically
	// called and destructor does delete ptr.

	return 0;
}
 Output: 20
 This only applies to int. So we'll need to make a Smart Pointer for each object? No, Template, there is a solution. As you can see in the code below, T can be of any type. Learn more about Template by clicking here. C++ Code 
#include <iostream>
using namespace std;

// A generic smart pointer class
template <class T>
class SmartPtr {
	T* ptr; // Actual pointer
public:
	// Constructor
	explicit SmartPtr(T* p = NULL) { ptr = p; }

	// Destructor
	~SmartPtr() { delete (ptr); }

	// Overloading dereferencing operator
	T& operator*() { return *ptr; }

	// Overloading arrow operator so that
	// members of T can be accessed
	// like a pointer (useful if T represents
	// a class or struct or union type)
	T* operator->() { return ptr; }
};

int main()
{
	SmartPtr<int> ptr(new int());
	*ptr = 20;
	cout << *ptr;
	return 0;
}
 Output: 20
 Note: Smart pointers can also be used to manage resources such as file handles or network sockets. Smart Pointer Types 1. unique ptr Only one pointer is stored in unique ptr. By removing the current object from the pointer, we can assign a different object. Take note of the code below. First, the unique_pointer is pointing to P1. However, we remove P1 and replace it with P2, so the pointer now points to P2. C++ Code 
#include <iostream>
using namespace std;
#include <memory>

class Rectangle {
	int length;
	int breadth;

public:
	Rectangle(int l, int b){
		length = l;
		breadth = b;
	}

	int area(){
		return length * breadth;
	}
};

int main(){

	unique_ptr<Rectangle> P1(new Rectangle(10, 5));
	cout << P1->area() << endl; // This'll print 50

	// unique_ptr<Rectangle> P2(P1);
	unique_ptr<Rectangle> P2;
	P2 = move(P1);

	// This'll print 50
	cout << P2->area() << endl;

	// cout<<P1->area()<<endl;
	return 0;
}
 Output: 50
50
 2. shared_ptr Using shared ptr, multiple pointers can point to the same object at the same time, and it will keep a reference counter using the use count() method. C++ Code 
#include <iostream>
using namespace std;
#include <memory>

class Rectangle {
	int length;
	int breadth;

public:
	Rectangle(int l, int b)
	{
		length = l;
		breadth = b;
	}

	int area()
	{
		return length * breadth;
	}
};

int main()
{

	shared_ptr<Rectangle> P1(new Rectangle(10, 5));
	// This'll print 50
	cout << P1->area() << endl;

	shared_ptr<Rectangle> P2;
	P2 = P1;

	// This'll print 50
	cout << P2->area() << endl;

	// This'll now not give an error,
	cout << P1->area() << endl;

	// This'll also print 50 now
	// This'll print 2 as Reference Counter is 2
	cout << P1.use_count() << endl;
	return 0;
}
 Output: 50
50
50
2
 3. weak_ptr It is very similar to shared ptr, except that it does not keep a Reference Counter. A pointer will not have a stronghold on the object in this case. The reason for this is that if pointers are holding the object while requesting other objects, they may form a deadlock. Next TopicCurrency Converter in C++ ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/smart-pointer Smart Pointer - javatpoint ? SCROLL TO TOP Home C C++ C# Java PHP HTML CSS JavaScript jQuery XML JSON Ajax Node.js SQL Quiz Projects Interview Q Comment Forum Training C++ Tutorial C++ Tutorial C vs C++ C++ History C++ Features C++ Installation C++ Program C++ cout, cin, endl C++ Variable C++ Data types C++ Keywords C++ Operators C++ Identifiers C++ Expression C++ Control Statement C++ if-else C++ switch C++ For Loop C++ While Loop C++ Do-While Loop C++ Break Statement C++ Continue Statement C++ Goto Statement C++ Comments C++ Functions C++ Functions Call by value & reference C++ Recursion C++ Storage Classes C++ Arrays C++ Arrays C++ Array to Function Multidimensional Arrays C++ Pointers C++ Pointers sizeof() operator in C++ C++ Array of Pointers C++ Void Pointer C++ References Reference vs Pointer Function Pointer in C++ C++ Memory Management malloc() vs new in C++ free vs delete in C++ C++ Object Class C++ OOPs Concepts C++ Object Class C++ Constructor C++ Copy Constructor C++ Destructor C++ this Pointer C++ static C++ Structs C++ Enumeration C++ Friend Function C++ Math Functions C++ Inheritance C++ Inheritance C++ Aggregation C++ Polymorphism C++ Polymorphism C++ Overloading C++ Overriding C++ Virtual Function C++ Abstraction C++ Interfaces C++ Data Abstraction C++ Namespaces C++ Namespaces C++ Strings C++ Strings C++ Exceptions C++ Exception Handling C++ try/catch C++ User-Defined C++ Templates C++ Templates Signal Handling C++ Signal Handling C++ File & Stream C++ File & Stream C++ getline() C++ Misc C++ vs C# C++ int to string C++ vs Python Structure vs Class in C++ Virtual Destructor in C++ Constructor vs Destructor in C++ Bit manipulation C++ What is a reference variable Friend Function in C++ Snake Code in C++ Inline function in C++ Virtual function vs Pure virtual function in C++ How to Split strings in C++ Range-based for loop in C++ Type Conversion in C++ LCM of two numbers in C++ Convert string to integer in C++ C++ STL Tutorial C++ STL Components C++ Vector Initialize Vector in C++ C++ Deque C++ List C++ Set C++ Stack C++ Queue C++ Priority Queue C++ Map C++ Multimap C++ Map C++ Bitset C++ Algorithm C++ Iterators C++ Iterators C++ Bidirectional Iterator C++ Forward Iterator C++ Input Iterator C++ Output Iterator C++ Programs C++Programs Fibonacci Series Prime Number Palindrome Number Factorial Armstrong Number Sum of digits Reverse Number Swap Number Matrix Multiplication Decimal to Binary Number in Characters Alphabet Triangle Number Triangle Fibonacci Triangle Char array to string in C++ Calculator Program in C++ Program to convert infix to postfix expression in C++ using the Stack Data Structure C++ program to merge two unsorted arrays C++ coin change program C++ program to add two complex numbers using class C++ program to find the GCD of two numbers C++ program to find greatest of four numbers Delete Operator in C++ How to concatenate two strings in c++ Upcasting and Downcasting in C++ C++ Dijkstra Algorithm using the priority queue Constructor overloading in C++ Default arguments in C++ Dynamic binding in C++ Dynamic memory allocation in C++ Fast input and output in C++ Hierarchical inheritance in C++ Hybrid inheritance in C++ Multiple Inheritance in C++ C++ Bitwise XOR Operator Different Ways to Compare Strings in C++ Reverse an Array in C++ C++ date and time Copy elision in C++ Array of sets in C++ Smart pointers in C++ Types of polymorphism in C++ Implementing the sets without C++ STL containers Scope Resolution Operator in C++ Static Member Function in C++ Const keyword in C++ Memset in C++ Type Casting in C++ Binary Operator Overloading in C++ Binary Search in C++ Inheritance in C++ vs JAVA Static Keyword in C++ and JAVA Exception Handling in C++ and JAVA Foreach in C++ and JAVA C++ templates vs. Java generics Similarities and Differences in C++ and JAVA Default Virtual Behaviour in C++ and JAVA C++ hashing programme with chaining Largest subset whose all elements are Fibonacci numbers Opaque Pointer Pointers such as Dangling, Void, Null, and Wild When do we pass arguments by reference or pointer Find Member Function in Vector in C++ Smart Pointer Currency Converter in C++ Find max in Array Function C++ MCQ C++ MCQ C++ MCQ Part 2 Interview Question Interview Question next ? ? prev Smart Pointer Pointers are used to access resources outside of the programme, such as heap memory. As a result, pointers are used to access heap memory (if anything is created inside heap memory). We simply use a copy of any external resource when accessing it. We simply change it in the copied version if we make any changes. However, if we use a pointer to the resource, we can change the original resource. Issues with Normal Pointers Check out the code below. C++ Code 
#include <iostream>
using namespace std;

class Rectangle {
private:
	int length;
	int breadth;
};

void fun()
{
	// By taking a pointer p and
	// dynamically creating object
	// of class rectangle
	Rectangle* p = new Rectangle();
}

int main()
{
	// Infinite Loop
	while (1) {
		fun();
	}
}
 Function fun generates a pointer pointing to the Rectangle object. Rectangle is made up of two integers: length and breadth. Because p is a local variable, it will be destroyed when the function fun ends. However, because we forgot to use delete p; at the end of the function, the memory it consumed will not be deallocated. This means that the memory will not be available for use by other resources. However, we no longer require the variable, but rather the memory. Fun is called in an infinite loop in function main. That means it will continue to generate p. It will allocate more memory but will not free it because we did not deallocate it. The unused memory cannot be used again. This results in a memory leak. Because of this, the entire heap memory may become useless. Smart Pointer, a feature of C++11, provides a solution to this problem. Smart Pointers are being introduced. Unconsciously, not dealinglocating a pointer causes a memory leak, which may result in a programme crash. Garbage Collection Mechanisms are used in the languages Java and C# to intelligently deallocate unused memory so that it can be used again. The programmer does not have to be concerned about memory leaks. Smart Pointer is a mechanism developed by C++11. When the object is destroyed, the memory is also released. As a result, we don't need to delete it because Smart Pointer will handle it. A Smart Pointer is a pointer wrapper class that has operators like * and -> overloaded. The smart pointer class's objects resemble regular pointers. However, unlike Normal Pointers, it has the ability to deallocate and free destroyed object memory. Take a class that has a pointer, a destructor, and overloaded operators like * and ->. Because the destructor is automatically called when an object exits scope, the dynamically allocated memory would be deleted (or reference count can be decremented). Consider the SmartPtr class shown below. C++ Code 
#include <iostream>
using namespace std;

class SmartPtr {
	int* ptr; // Actual pointer
public:
	// for use of explicit keyword
	explicit SmartPtr(int* p = NULL) { ptr = p; }

	// Destructor
	~SmartPtr() { delete (ptr); }

	// Overloading dereferencing operator
	int& operator*() { return *ptr; }
};

int main()
{
	SmartPtr ptr(new int());
	*ptr = 20;
	cout << *ptr;

	// We don't need to call delete ptr: when the object
	// ptr goes out of scope, the destructor for it is automatically
	// called and destructor does delete ptr.

	return 0;
}
 Output: 20
 This only applies to int. So we'll need to make a Smart Pointer for each object? No, Template, there is a solution. As you can see in the code below, T can be of any type. Learn more about Template by clicking here. C++ Code 
#include <iostream>
using namespace std;

// A generic smart pointer class
template <class T>
class SmartPtr {
	T* ptr; // Actual pointer
public:
	// Constructor
	explicit SmartPtr(T* p = NULL) { ptr = p; }

	// Destructor
	~SmartPtr() { delete (ptr); }

	// Overloading dereferencing operator
	T& operator*() { return *ptr; }

	// Overloading arrow operator so that
	// members of T can be accessed
	// like a pointer (useful if T represents
	// a class or struct or union type)
	T* operator->() { return ptr; }
};

int main()
{
	SmartPtr<int> ptr(new int());
	*ptr = 20;
	cout << *ptr;
	return 0;
}
 Output: 20
 Note: Smart pointers can also be used to manage resources such as file handles or network sockets. Smart Pointer Types 1. unique ptr Only one pointer is stored in unique ptr. By removing the current object from the pointer, we can assign a different object. Take note of the code below. First, the unique_pointer is pointing to P1. However, we remove P1 and replace it with P2, so the pointer now points to P2. C++ Code 
#include <iostream>
using namespace std;
#include <memory>

class Rectangle {
	int length;
	int breadth;

public:
	Rectangle(int l, int b){
		length = l;
		breadth = b;
	}

	int area(){
		return length * breadth;
	}
};

int main(){

	unique_ptr<Rectangle> P1(new Rectangle(10, 5));
	cout << P1->area() << endl; // This'll print 50

	// unique_ptr<Rectangle> P2(P1);
	unique_ptr<Rectangle> P2;
	P2 = move(P1);

	// This'll print 50
	cout << P2->area() << endl;

	// cout<<P1->area()<<endl;
	return 0;
}
 Output: 50
50
 2. shared_ptr Using shared ptr, multiple pointers can point to the same object at the same time, and it will keep a reference counter using the use count() method. C++ Code 
#include <iostream>
using namespace std;
#include <memory>

class Rectangle {
	int length;
	int breadth;

public:
	Rectangle(int l, int b)
	{
		length = l;
		breadth = b;
	}

	int area()
	{
		return length * breadth;
	}
};

int main()
{

	shared_ptr<Rectangle> P1(new Rectangle(10, 5));
	// This'll print 50
	cout << P1->area() << endl;

	shared_ptr<Rectangle> P2;
	P2 = P1;

	// This'll print 50
	cout << P2->area() << endl;

	// This'll now not give an error,
	cout << P1->area() << endl;

	// This'll also print 50 now
	// This'll print 2 as Reference Counter is 2
	cout << P1.use_count() << endl;
	return 0;
}
 Output: 50
50
50
2
 3. weak_ptr It is very similar to shared ptr, except that it does not keep a Reference Counter. A pointer will not have a stronghold on the object in this case. The reason for this is that if pointers are holding the object while requesting other objects, they may form a deadlock. Next TopicCurrency Converter in C++ ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/smart-pointer Smart Pointer - javatpoint ? SCROLL TO TOP Home C C++ C# Java PHP HTML CSS JavaScript jQuery XML JSON Ajax Node.js SQL Quiz Projects Interview Q Comment Forum Training C++ Tutorial C++ Tutorial C vs C++ C++ History C++ Features C++ Installation C++ Program C++ cout, cin, endl C++ Variable C++ Data types C++ Keywords C++ Operators C++ Identifiers C++ Expression C++ Control Statement C++ if-else C++ switch C++ For Loop C++ While Loop C++ Do-While Loop C++ Break Statement C++ Continue Statement C++ Goto Statement C++ Comments C++ Functions C++ Functions Call by value & reference C++ Recursion C++ Storage Classes C++ Arrays C++ Arrays C++ Array to Function Multidimensional Arrays C++ Pointers C++ Pointers sizeof() operator in C++ C++ Array of Pointers C++ Void Pointer C++ References Reference vs Pointer Function Pointer in C++ C++ Memory Management malloc() vs new in C++ free vs delete in C++ C++ Object Class C++ OOPs Concepts C++ Object Class C++ Constructor C++ Copy Constructor C++ Destructor C++ this Pointer C++ static C++ Structs C++ Enumeration C++ Friend Function C++ Math Functions C++ Inheritance C++ Inheritance C++ Aggregation C++ Polymorphism C++ Polymorphism C++ Overloading C++ Overriding C++ Virtual Function C++ Abstraction C++ Interfaces C++ Data Abstraction C++ Namespaces C++ Namespaces C++ Strings C++ Strings C++ Exceptions C++ Exception Handling C++ try/catch C++ User-Defined C++ Templates C++ Templates Signal Handling C++ Signal Handling C++ File & Stream C++ File & Stream C++ getline() C++ Misc C++ vs C# C++ int to string C++ vs Python Structure vs Class in C++ Virtual Destructor in C++ Constructor vs Destructor in C++ Bit manipulation C++ What is a reference variable Friend Function in C++ Snake Code in C++ Inline function in C++ Virtual function vs Pure virtual function in C++ How to Split strings in C++ Range-based for loop in C++ Type Conversion in C++ LCM of two numbers in C++ Convert string to integer in C++ C++ STL Tutorial C++ STL Components C++ Vector Initialize Vector in C++ C++ Deque C++ List C++ Set C++ Stack C++ Queue C++ Priority Queue C++ Map C++ Multimap C++ Map C++ Bitset C++ Algorithm C++ Iterators C++ Iterators C++ Bidirectional Iterator C++ Forward Iterator C++ Input Iterator C++ Output Iterator C++ Programs C++Programs Fibonacci Series Prime Number Palindrome Number Factorial Armstrong Number Sum of digits Reverse Number Swap Number Matrix Multiplication Decimal to Binary Number in Characters Alphabet Triangle Number Triangle Fibonacci Triangle Char array to string in C++ Calculator Program in C++ Program to convert infix to postfix expression in C++ using the Stack Data Structure C++ program to merge two unsorted arrays C++ coin change program C++ program to add two complex numbers using class C++ program to find the GCD of two numbers C++ program to find greatest of four numbers Delete Operator in C++ How to concatenate two strings in c++ Upcasting and Downcasting in C++ C++ Dijkstra Algorithm using the priority queue Constructor overloading in C++ Default arguments in C++ Dynamic binding in C++ Dynamic memory allocation in C++ Fast input and output in C++ Hierarchical inheritance in C++ Hybrid inheritance in C++ Multiple Inheritance in C++ C++ Bitwise XOR Operator Different Ways to Compare Strings in C++ Reverse an Array in C++ C++ date and time Copy elision in C++ Array of sets in C++ Smart pointers in C++ Types of polymorphism in C++ Implementing the sets without C++ STL containers Scope Resolution Operator in C++ Static Member Function in C++ Const keyword in C++ Memset in C++ Type Casting in C++ Binary Operator Overloading in C++ Binary Search in C++ Inheritance in C++ vs JAVA Static Keyword in C++ and JAVA Exception Handling in C++ and JAVA Foreach in C++ and JAVA C++ templates vs. Java generics Similarities and Differences in C++ and JAVA Default Virtual Behaviour in C++ and JAVA C++ hashing programme with chaining Largest subset whose all elements are Fibonacci numbers Opaque Pointer Pointers such as Dangling, Void, Null, and Wild When do we pass arguments by reference or pointer Find Member Function in Vector in C++ Smart Pointer Currency Converter in C++ Find max in Array Function C++ MCQ C++ MCQ C++ MCQ Part 2 Interview Question Interview Question next ? ? prev Smart Pointer Pointers are used to access resources outside of the programme, such as heap memory. As a result, pointers are used to access heap memory (if anything is created inside heap memory). We simply use a copy of any external resource when accessing it. We simply change it in the copied version if we make any changes. However, if we use a pointer to the resource, we can change the original resource. Issues with Normal Pointers Check out the code below. C++ Code 
#include <iostream>
using namespace std;

class Rectangle {
private:
	int length;
	int breadth;
};

void fun()
{
	// By taking a pointer p and
	// dynamically creating object
	// of class rectangle
	Rectangle* p = new Rectangle();
}

int main()
{
	// Infinite Loop
	while (1) {
		fun();
	}
}
 Function fun generates a pointer pointing to the Rectangle object. Rectangle is made up of two integers: length and breadth. Because p is a local variable, it will be destroyed when the function fun ends. However, because we forgot to use delete p; at the end of the function, the memory it consumed will not be deallocated. This means that the memory will not be available for use by other resources. However, we no longer require the variable, but rather the memory. Fun is called in an infinite loop in function main. That means it will continue to generate p. It will allocate more memory but will not free it because we did not deallocate it. The unused memory cannot be used again. This results in a memory leak. Because of this, the entire heap memory may become useless. Smart Pointer, a feature of C++11, provides a solution to this problem. Smart Pointers are being introduced. Unconsciously, not dealinglocating a pointer causes a memory leak, which may result in a programme crash. Garbage Collection Mechanisms are used in the languages Java and C# to intelligently deallocate unused memory so that it can be used again. The programmer does not have to be concerned about memory leaks. Smart Pointer is a mechanism developed by C++11. When the object is destroyed, the memory is also released. As a result, we don't need to delete it because Smart Pointer will handle it. A Smart Pointer is a pointer wrapper class that has operators like * and -> overloaded. The smart pointer class's objects resemble regular pointers. However, unlike Normal Pointers, it has the ability to deallocate and free destroyed object memory. Take a class that has a pointer, a destructor, and overloaded operators like * and ->. Because the destructor is automatically called when an object exits scope, the dynamically allocated memory would be deleted (or reference count can be decremented). Consider the SmartPtr class shown below. C++ Code 
#include <iostream>
using namespace std;

class SmartPtr {
	int* ptr; // Actual pointer
public:
	// for use of explicit keyword
	explicit SmartPtr(int* p = NULL) { ptr = p; }

	// Destructor
	~SmartPtr() { delete (ptr); }

	// Overloading dereferencing operator
	int& operator*() { return *ptr; }
};

int main()
{
	SmartPtr ptr(new int());
	*ptr = 20;
	cout << *ptr;

	// We don't need to call delete ptr: when the object
	// ptr goes out of scope, the destructor for it is automatically
	// called and destructor does delete ptr.

	return 0;
}
 Output: 20
 This only applies to int. So we'll need to make a Smart Pointer for each object? No, Template, there is a solution. As you can see in the code below, T can be of any type. Learn more about Template by clicking here. C++ Code 
#include <iostream>
using namespace std;

// A generic smart pointer class
template <class T>
class SmartPtr {
	T* ptr; // Actual pointer
public:
	// Constructor
	explicit SmartPtr(T* p = NULL) { ptr = p; }

	// Destructor
	~SmartPtr() { delete (ptr); }

	// Overloading dereferencing operator
	T& operator*() { return *ptr; }

	// Overloading arrow operator so that
	// members of T can be accessed
	// like a pointer (useful if T represents
	// a class or struct or union type)
	T* operator->() { return ptr; }
};

int main()
{
	SmartPtr<int> ptr(new int());
	*ptr = 20;
	cout << *ptr;
	return 0;
}
 Output: 20
 Note: Smart pointers can also be used to manage resources such as file handles or network sockets. Smart Pointer Types 1. unique ptr Only one pointer is stored in unique ptr. By removing the current object from the pointer, we can assign a different object. Take note of the code below. First, the unique_pointer is pointing to P1. However, we remove P1 and replace it with P2, so the pointer now points to P2. C++ Code 
#include <iostream>
using namespace std;
#include <memory>

class Rectangle {
	int length;
	int breadth;

public:
	Rectangle(int l, int b){
		length = l;
		breadth = b;
	}

	int area(){
		return length * breadth;
	}
};

int main(){

	unique_ptr<Rectangle> P1(new Rectangle(10, 5));
	cout << P1->area() << endl; // This'll print 50

	// unique_ptr<Rectangle> P2(P1);
	unique_ptr<Rectangle> P2;
	P2 = move(P1);

	// This'll print 50
	cout << P2->area() << endl;

	// cout<<P1->area()<<endl;
	return 0;
}
 Output: 50
50
 2. shared_ptr Using shared ptr, multiple pointers can point to the same object at the same time, and it will keep a reference counter using the use count() method. C++ Code 
#include <iostream>
using namespace std;
#include <memory>

class Rectangle {
	int length;
	int breadth;

public:
	Rectangle(int l, int b)
	{
		length = l;
		breadth = b;
	}

	int area()
	{
		return length * breadth;
	}
};

int main()
{

	shared_ptr<Rectangle> P1(new Rectangle(10, 5));
	// This'll print 50
	cout << P1->area() << endl;

	shared_ptr<Rectangle> P2;
	P2 = P1;

	// This'll print 50
	cout << P2->area() << endl;

	// This'll now not give an error,
	cout << P1->area() << endl;

	// This'll also print 50 now
	// This'll print 2 as Reference Counter is 2
	cout << P1.use_count() << endl;
	return 0;
}
 Output: 50
50
50
2
 3. weak_ptr It is very similar to shared ptr, except that it does not keep a Reference Counter. A pointer will not have a stronghold on the object in this case. The reason for this is that if pointers are holding the object while requesting other objects, they may form a deadlock. Next TopicCurrency Converter in C++ ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/smart-pointer Smart Pointer - javatpoint ? SCROLL TO TOP Home C C++ C# Java PHP HTML CSS JavaScript jQuery XML JSON Ajax Node.js SQL Quiz Projects Interview Q Comment Forum Training C++ Tutorial C++ Tutorial C vs C++ C++ History C++ Features C++ Installation C++ Program C++ cout, cin, endl C++ Variable C++ Data types C++ Keywords C++ Operators C++ Identifiers C++ Expression C++ Control Statement C++ if-else C++ switch C++ For Loop C++ While Loop C++ Do-While Loop C++ Break Statement C++ Continue Statement C++ Goto Statement C++ Comments C++ Functions C++ Functions Call by value & reference C++ Recursion C++ Storage Classes C++ Arrays C++ Arrays C++ Array to Function Multidimensional Arrays C++ Pointers C++ Pointers sizeof() operator in C++ C++ Array of Pointers C++ Void Pointer C++ References Reference vs Pointer Function Pointer in C++ C++ Memory Management malloc() vs new in C++ free vs delete in C++ C++ Object Class C++ OOPs Concepts C++ Object Class C++ Constructor C++ Copy Constructor C++ Destructor C++ this Pointer C++ static C++ Structs C++ Enumeration C++ Friend Function C++ Math Functions C++ Inheritance C++ Inheritance C++ Aggregation C++ Polymorphism C++ Polymorphism C++ Overloading C++ Overriding C++ Virtual Function C++ Abstraction C++ Interfaces C++ Data Abstraction C++ Namespaces C++ Namespaces C++ Strings C++ Strings C++ Exceptions C++ Exception Handling C++ try/catch C++ User-Defined C++ Templates C++ Templates Signal Handling C++ Signal Handling C++ File & Stream C++ File & Stream C++ getline() C++ Misc C++ vs C# C++ int to string C++ vs Python Structure vs Class in C++ Virtual Destructor in C++ Constructor vs Destructor in C++ Bit manipulation C++ What is a reference variable Friend Function in C++ Snake Code in C++ Inline function in C++ Virtual function vs Pure virtual function in C++ How to Split strings in C++ Range-based for loop in C++ Type Conversion in C++ LCM of two numbers in C++ Convert string to integer in C++ C++ STL Tutorial C++ STL Components C++ Vector Initialize Vector in C++ C++ Deque C++ List C++ Set C++ Stack C++ Queue C++ Priority Queue C++ Map C++ Multimap C++ Map C++ Bitset C++ Algorithm C++ Iterators C++ Iterators C++ Bidirectional Iterator C++ Forward Iterator C++ Input Iterator C++ Output Iterator C++ Programs C++Programs Fibonacci Series Prime Number Palindrome Number Factorial Armstrong Number Sum of digits Reverse Number Swap Number Matrix Multiplication Decimal to Binary Number in Characters Alphabet Triangle Number Triangle Fibonacci Triangle Char array to string in C++ Calculator Program in C++ Program to convert infix to postfix expression in C++ using the Stack Data Structure C++ program to merge two unsorted arrays C++ coin change program C++ program to add two complex numbers using class C++ program to find the GCD of two numbers C++ program to find greatest of four numbers Delete Operator in C++ How to concatenate two strings in c++ Upcasting and Downcasting in C++ C++ Dijkstra Algorithm using the priority queue Constructor overloading in C++ Default arguments in C++ Dynamic binding in C++ Dynamic memory allocation in C++ Fast input and output in C++ Hierarchical inheritance in C++ Hybrid inheritance in C++ Multiple Inheritance in C++ C++ Bitwise XOR Operator Different Ways to Compare Strings in C++ Reverse an Array in C++ C++ date and time Copy elision in C++ Array of sets in C++ Smart pointers in C++ Types of polymorphism in C++ Implementing the sets without C++ STL containers Scope Resolution Operator in C++ Static Member Function in C++ Const keyword in C++ Memset in C++ Type Casting in C++ Binary Operator Overloading in C++ Binary Search in C++ Inheritance in C++ vs JAVA Static Keyword in C++ and JAVA Exception Handling in C++ and JAVA Foreach in C++ and JAVA C++ templates vs. Java generics Similarities and Differences in C++ and JAVA Default Virtual Behaviour in C++ and JAVA C++ hashing programme with chaining Largest subset whose all elements are Fibonacci numbers Opaque Pointer Pointers such as Dangling, Void, Null, and Wild When do we pass arguments by reference or pointer Find Member Function in Vector in C++ Smart Pointer Currency Converter in C++ Find max in Array Function C++ MCQ C++ MCQ C++ MCQ Part 2 Interview Question Interview Question next ? ? prev Smart Pointer Pointers are used to access resources outside of the programme, such as heap memory. As a result, pointers are used to access heap memory (if anything is created inside heap memory). We simply use a copy of any external resource when accessing it. We simply change it in the copied version if we make any changes. However, if we use a pointer to the resource, we can change the original resource. Issues with Normal Pointers Check out the code below. C++ Code 
#include <iostream>
using namespace std;

class Rectangle {
private:
	int length;
	int breadth;
};

void fun()
{
	// By taking a pointer p and
	// dynamically creating object
	// of class rectangle
	Rectangle* p = new Rectangle();
}

int main()
{
	// Infinite Loop
	while (1) {
		fun();
	}
}
 Function fun generates a pointer pointing to the Rectangle object. Rectangle is made up of two integers: length and breadth. Because p is a local variable, it will be destroyed when the function fun ends. However, because we forgot to use delete p; at the end of the function, the memory it consumed will not be deallocated. This means that the memory will not be available for use by other resources. However, we no longer require the variable, but rather the memory. Fun is called in an infinite loop in function main. That means it will continue to generate p. It will allocate more memory but will not free it because we did not deallocate it. The unused memory cannot be used again. This results in a memory leak. Because of this, the entire heap memory may become useless. Smart Pointer, a feature of C++11, provides a solution to this problem. Smart Pointers are being introduced. Unconsciously, not dealinglocating a pointer causes a memory leak, which may result in a programme crash. Garbage Collection Mechanisms are used in the languages Java and C# to intelligently deallocate unused memory so that it can be used again. The programmer does not have to be concerned about memory leaks. Smart Pointer is a mechanism developed by C++11. When the object is destroyed, the memory is also released. As a result, we don't need to delete it because Smart Pointer will handle it. A Smart Pointer is a pointer wrapper class that has operators like * and -> overloaded. The smart pointer class's objects resemble regular pointers. However, unlike Normal Pointers, it has the ability to deallocate and free destroyed object memory. Take a class that has a pointer, a destructor, and overloaded operators like * and ->. Because the destructor is automatically called when an object exits scope, the dynamically allocated memory would be deleted (or reference count can be decremented). Consider the SmartPtr class shown below. C++ Code 
#include <iostream>
using namespace std;

class SmartPtr {
	int* ptr; // Actual pointer
public:
	// for use of explicit keyword
	explicit SmartPtr(int* p = NULL) { ptr = p; }

	// Destructor
	~SmartPtr() { delete (ptr); }

	// Overloading dereferencing operator
	int& operator*() { return *ptr; }
};

int main()
{
	SmartPtr ptr(new int());
	*ptr = 20;
	cout << *ptr;

	// We don't need to call delete ptr: when the object
	// ptr goes out of scope, the destructor for it is automatically
	// called and destructor does delete ptr.

	return 0;
}
 Output: 20
 This only applies to int. So we'll need to make a Smart Pointer for each object? No, Template, there is a solution. As you can see in the code below, T can be of any type. Learn more about Template by clicking here. C++ Code 
#include <iostream>
using namespace std;

// A generic smart pointer class
template <class T>
class SmartPtr {
	T* ptr; // Actual pointer
public:
	// Constructor
	explicit SmartPtr(T* p = NULL) { ptr = p; }

	// Destructor
	~SmartPtr() { delete (ptr); }

	// Overloading dereferencing operator
	T& operator*() { return *ptr; }

	// Overloading arrow operator so that
	// members of T can be accessed
	// like a pointer (useful if T represents
	// a class or struct or union type)
	T* operator->() { return ptr; }
};

int main()
{
	SmartPtr<int> ptr(new int());
	*ptr = 20;
	cout << *ptr;
	return 0;
}
 Output: 20
 Note: Smart pointers can also be used to manage resources such as file handles or network sockets. Smart Pointer Types 1. unique ptr Only one pointer is stored in unique ptr. By removing the current object from the pointer, we can assign a different object. Take note of the code below. First, the unique_pointer is pointing to P1. However, we remove P1 and replace it with P2, so the pointer now points to P2. C++ Code 
#include <iostream>
using namespace std;
#include <memory>

class Rectangle {
	int length;
	int breadth;

public:
	Rectangle(int l, int b){
		length = l;
		breadth = b;
	}

	int area(){
		return length * breadth;
	}
};

int main(){

	unique_ptr<Rectangle> P1(new Rectangle(10, 5));
	cout << P1->area() << endl; // This'll print 50

	// unique_ptr<Rectangle> P2(P1);
	unique_ptr<Rectangle> P2;
	P2 = move(P1);

	// This'll print 50
	cout << P2->area() << endl;

	// cout<<P1->area()<<endl;
	return 0;
}
 Output: 50
50
 2. shared_ptr Using shared ptr, multiple pointers can point to the same object at the same time, and it will keep a reference counter using the use count() method. C++ Code 
#include <iostream>
using namespace std;
#include <memory>

class Rectangle {
	int length;
	int breadth;

public:
	Rectangle(int l, int b)
	{
		length = l;
		breadth = b;
	}

	int area()
	{
		return length * breadth;
	}
};

int main()
{

	shared_ptr<Rectangle> P1(new Rectangle(10, 5));
	// This'll print 50
	cout << P1->area() << endl;

	shared_ptr<Rectangle> P2;
	P2 = P1;

	// This'll print 50
	cout << P2->area() << endl;

	// This'll now not give an error,
	cout << P1->area() << endl;

	// This'll also print 50 now
	// This'll print 2 as Reference Counter is 2
	cout << P1.use_count() << endl;
	return 0;
}
 Output: 50
50
50
2
 3. weak_ptr It is very similar to shared ptr, except that it does not keep a Reference Counter. A pointer will not have a stronghold on the object in this case. The reason for this is that if pointers are holding the object while requesting other objects, they may form a deadlock. Next TopicCurrency Converter in C++ ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/smart-pointer Smart Pointer - javatpoint ? SCROLL TO TOP Home C C++ C# Java PHP HTML CSS JavaScript jQuery XML JSON Ajax Node.js SQL Quiz Projects Interview Q Comment Forum Training C++ Tutorial C++ Tutorial C vs C++ C++ History C++ Features C++ Installation C++ Program C++ cout, cin, endl C++ Variable C++ Data types C++ Keywords C++ Operators C++ Identifiers C++ Expression C++ Control Statement C++ if-else C++ switch C++ For Loop C++ While Loop C++ Do-While Loop C++ Break Statement C++ Continue Statement C++ Goto Statement C++ Comments C++ Functions C++ Functions Call by value & reference C++ Recursion C++ Storage Classes C++ Arrays C++ Arrays C++ Array to Function Multidimensional Arrays C++ Pointers C++ Pointers sizeof() operator in C++ C++ Array of Pointers C++ Void Pointer C++ References Reference vs Pointer Function Pointer in C++ C++ Memory Management malloc() vs new in C++ free vs delete in C++ C++ Object Class C++ OOPs Concepts C++ Object Class C++ Constructor C++ Copy Constructor C++ Destructor C++ this Pointer C++ static C++ Structs C++ Enumeration C++ Friend Function C++ Math Functions C++ Inheritance C++ Inheritance C++ Aggregation C++ Polymorphism C++ Polymorphism C++ Overloading C++ Overriding C++ Virtual Function C++ Abstraction C++ Interfaces C++ Data Abstraction C++ Namespaces C++ Namespaces C++ Strings C++ Strings C++ Exceptions C++ Exception Handling C++ try/catch C++ User-Defined C++ Templates C++ Templates Signal Handling C++ Signal Handling C++ File & Stream C++ File & Stream C++ getline() C++ Misc C++ vs C# C++ int to string C++ vs Python Structure vs Class in C++ Virtual Destructor in C++ Constructor vs Destructor in C++ Bit manipulation C++ What is a reference variable Friend Function in C++ Snake Code in C++ Inline function in C++ Virtual function vs Pure virtual function in C++ How to Split strings in C++ Range-based for loop in C++ Type Conversion in C++ LCM of two numbers in C++ Convert string to integer in C++ C++ STL Tutorial C++ STL Components C++ Vector Initialize Vector in C++ C++ Deque C++ List C++ Set C++ Stack C++ Queue C++ Priority Queue C++ Map C++ Multimap C++ Map C++ Bitset C++ Algorithm C++ Iterators C++ Iterators C++ Bidirectional Iterator C++ Forward Iterator C++ Input Iterator C++ Output Iterator C++ Programs C++Programs Fibonacci Series Prime Number Palindrome Number Factorial Armstrong Number Sum of digits Reverse Number Swap Number Matrix Multiplication Decimal to Binary Number in Characters Alphabet Triangle Number Triangle Fibonacci Triangle Char array to string in C++ Calculator Program in C++ Program to convert infix to postfix expression in C++ using the Stack Data Structure C++ program to merge two unsorted arrays C++ coin change program C++ program to add two complex numbers using class C++ program to find the GCD of two numbers C++ program to find greatest of four numbers Delete Operator in C++ How to concatenate two strings in c++ Upcasting and Downcasting in C++ C++ Dijkstra Algorithm using the priority queue Constructor overloading in C++ Default arguments in C++ Dynamic binding in C++ Dynamic memory allocation in C++ Fast input and output in C++ Hierarchical inheritance in C++ Hybrid inheritance in C++ Multiple Inheritance in C++ C++ Bitwise XOR Operator Different Ways to Compare Strings in C++ Reverse an Array in C++ C++ date and time Copy elision in C++ Array of sets in C++ Smart pointers in C++ Types of polymorphism in C++ Implementing the sets without C++ STL containers Scope Resolution Operator in C++ Static Member Function in C++ Const keyword in C++ Memset in C++ Type Casting in C++ Binary Operator Overloading in C++ Binary Search in C++ Inheritance in C++ vs JAVA Static Keyword in C++ and JAVA Exception Handling in C++ and JAVA Foreach in C++ and JAVA C++ templates vs. Java generics Similarities and Differences in C++ and JAVA Default Virtual Behaviour in C++ and JAVA C++ hashing programme with chaining Largest subset whose all elements are Fibonacci numbers Opaque Pointer Pointers such as Dangling, Void, Null, and Wild When do we pass arguments by reference or pointer Find Member Function in Vector in C++ Smart Pointer Currency Converter in C++ Find max in Array Function C++ MCQ C++ MCQ C++ MCQ Part 2 Interview Question Interview Question next ? ? prev Smart Pointer Pointers are used to access resources outside of the programme, such as heap memory. As a result, pointers are used to access heap memory (if anything is created inside heap memory). We simply use a copy of any external resource when accessing it. We simply change it in the copied version if we make any changes. However, if we use a pointer to the resource, we can change the original resource. Issues with Normal Pointers Check out the code below. C++ Code 
#include <iostream>
using namespace std;

class Rectangle {
private:
	int length;
	int breadth;
};

void fun()
{
	// By taking a pointer p and
	// dynamically creating object
	// of class rectangle
	Rectangle* p = new Rectangle();
}

int main()
{
	// Infinite Loop
	while (1) {
		fun();
	}
}
 Function fun generates a pointer pointing to the Rectangle object. Rectangle is made up of two integers: length and breadth. Because p is a local variable, it will be destroyed when the function fun ends. However, because we forgot to use delete p; at the end of the function, the memory it consumed will not be deallocated. This means that the memory will not be available for use by other resources. However, we no longer require the variable, but rather the memory. Fun is called in an infinite loop in function main. That means it will continue to generate p. It will allocate more memory but will not free it because we did not deallocate it. The unused memory cannot be used again. This results in a memory leak. Because of this, the entire heap memory may become useless. Smart Pointer, a feature of C++11, provides a solution to this problem. Smart Pointers are being introduced. Unconsciously, not dealinglocating a pointer causes a memory leak, which may result in a programme crash. Garbage Collection Mechanisms are used in the languages Java and C# to intelligently deallocate unused memory so that it can be used again. The programmer does not have to be concerned about memory leaks. Smart Pointer is a mechanism developed by C++11. When the object is destroyed, the memory is also released. As a result, we don't need to delete it because Smart Pointer will handle it. A Smart Pointer is a pointer wrapper class that has operators like * and -> overloaded. The smart pointer class's objects resemble regular pointers. However, unlike Normal Pointers, it has the ability to deallocate and free destroyed object memory. Take a class that has a pointer, a destructor, and overloaded operators like * and ->. Because the destructor is automatically called when an object exits scope, the dynamically allocated memory would be deleted (or reference count can be decremented). Consider the SmartPtr class shown below. C++ Code 
#include <iostream>
using namespace std;

class SmartPtr {
	int* ptr; // Actual pointer
public:
	// for use of explicit keyword
	explicit SmartPtr(int* p = NULL) { ptr = p; }

	// Destructor
	~SmartPtr() { delete (ptr); }

	// Overloading dereferencing operator
	int& operator*() { return *ptr; }
};

int main()
{
	SmartPtr ptr(new int());
	*ptr = 20;
	cout << *ptr;

	// We don't need to call delete ptr: when the object
	// ptr goes out of scope, the destructor for it is automatically
	// called and destructor does delete ptr.

	return 0;
}
 Output: 20
 This only applies to int. So we'll need to make a Smart Pointer for each object? No, Template, there is a solution. As you can see in the code below, T can be of any type. Learn more about Template by clicking here. C++ Code 
#include <iostream>
using namespace std;

// A generic smart pointer class
template <class T>
class SmartPtr {
	T* ptr; // Actual pointer
public:
	// Constructor
	explicit SmartPtr(T* p = NULL) { ptr = p; }

	// Destructor
	~SmartPtr() { delete (ptr); }

	// Overloading dereferencing operator
	T& operator*() { return *ptr; }

	// Overloading arrow operator so that
	// members of T can be accessed
	// like a pointer (useful if T represents
	// a class or struct or union type)
	T* operator->() { return ptr; }
};

int main()
{
	SmartPtr<int> ptr(new int());
	*ptr = 20;
	cout << *ptr;
	return 0;
}
 Output: 20
 Note: Smart pointers can also be used to manage resources such as file handles or network sockets. Smart Pointer Types 1. unique ptr Only one pointer is stored in unique ptr. By removing the current object from the pointer, we can assign a different object. Take note of the code below. First, the unique_pointer is pointing to P1. However, we remove P1 and replace it with P2, so the pointer now points to P2. C++ Code 
#include <iostream>
using namespace std;
#include <memory>

class Rectangle {
	int length;
	int breadth;

public:
	Rectangle(int l, int b){
		length = l;
		breadth = b;
	}

	int area(){
		return length * breadth;
	}
};

int main(){

	unique_ptr<Rectangle> P1(new Rectangle(10, 5));
	cout << P1->area() << endl; // This'll print 50

	// unique_ptr<Rectangle> P2(P1);
	unique_ptr<Rectangle> P2;
	P2 = move(P1);

	// This'll print 50
	cout << P2->area() << endl;

	// cout<<P1->area()<<endl;
	return 0;
}
 Output: 50
50
 2. shared_ptr Using shared ptr, multiple pointers can point to the same object at the same time, and it will keep a reference counter using the use count() method. C++ Code 
#include <iostream>
using namespace std;
#include <memory>

class Rectangle {
	int length;
	int breadth;

public:
	Rectangle(int l, int b)
	{
		length = l;
		breadth = b;
	}

	int area()
	{
		return length * breadth;
	}
};

int main()
{

	shared_ptr<Rectangle> P1(new Rectangle(10, 5));
	// This'll print 50
	cout << P1->area() << endl;

	shared_ptr<Rectangle> P2;
	P2 = P1;

	// This'll print 50
	cout << P2->area() << endl;

	// This'll now not give an error,
	cout << P1->area() << endl;

	// This'll also print 50 now
	// This'll print 2 as Reference Counter is 2
	cout << P1.use_count() << endl;
	return 0;
}
 Output: 50
50
50
2
 3. weak_ptr It is very similar to shared ptr, except that it does not keep a Reference Counter. A pointer will not have a stronghold on the object in this case. The reason for this is that if pointers are holding the object while requesting other objects, they may form a deadlock. Next TopicCurrency Converter in C++ ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/smart-pointer Smart Pointer - javatpoint ? SCROLL TO TOP Home C C++ C# Java PHP HTML CSS JavaScript jQuery XML JSON Ajax Node.js SQL Quiz Projects Interview Q Comment Forum Training C++ Tutorial C++ Tutorial C vs C++ C++ History C++ Features C++ Installation C++ Program C++ cout, cin, endl C++ Variable C++ Data types C++ Keywords C++ Operators C++ Identifiers C++ Expression C++ Control Statement C++ if-else C++ switch C++ For Loop C++ While Loop C++ Do-While Loop C++ Break Statement C++ Continue Statement C++ Goto Statement C++ Comments C++ Functions C++ Functions Call by value & reference C++ Recursion C++ Storage Classes C++ Arrays C++ Arrays C++ Array to Function Multidimensional Arrays C++ Pointers C++ Pointers sizeof() operator in C++ C++ Array of Pointers C++ Void Pointer C++ References Reference vs Pointer Function Pointer in C++ C++ Memory Management malloc() vs new in C++ free vs delete in C++ C++ Object Class C++ OOPs Concepts C++ Object Class C++ Constructor C++ Copy Constructor C++ Destructor C++ this Pointer C++ static C++ Structs C++ Enumeration C++ Friend Function C++ Math Functions C++ Inheritance C++ Inheritance C++ Aggregation C++ Polymorphism C++ Polymorphism C++ Overloading C++ Overriding C++ Virtual Function C++ Abstraction C++ Interfaces C++ Data Abstraction C++ Namespaces C++ Namespaces C++ Strings C++ Strings C++ Exceptions C++ Exception Handling C++ try/catch C++ User-Defined C++ Templates C++ Templates Signal Handling C++ Signal Handling C++ File & Stream C++ File & Stream C++ getline() C++ Misc C++ vs C# C++ int to string C++ vs Python Structure vs Class in C++ Virtual Destructor in C++ Constructor vs Destructor in C++ Bit manipulation C++ What is a reference variable Friend Function in C++ Snake Code in C++ Inline function in C++ Virtual function vs Pure virtual function in C++ How to Split strings in C++ Range-based for loop in C++ Type Conversion in C++ LCM of two numbers in C++ Convert string to integer in C++ C++ STL Tutorial C++ STL Components C++ Vector Initialize Vector in C++ C++ Deque C++ List C++ Set C++ Stack C++ Queue C++ Priority Queue C++ Map C++ Multimap C++ Map C++ Bitset C++ Algorithm C++ Iterators C++ Iterators C++ Bidirectional Iterator C++ Forward Iterator C++ Input Iterator C++ Output Iterator C++ Programs C++Programs Fibonacci Series Prime Number Palindrome Number Factorial Armstrong Number Sum of digits Reverse Number Swap Number Matrix Multiplication Decimal to Binary Number in Characters Alphabet Triangle Number Triangle Fibonacci Triangle Char array to string in C++ Calculator Program in C++ Program to convert infix to postfix expression in C++ using the Stack Data Structure C++ program to merge two unsorted arrays C++ coin change program C++ program to add two complex numbers using class C++ program to find the GCD of two numbers C++ program to find greatest of four numbers Delete Operator in C++ How to concatenate two strings in c++ Upcasting and Downcasting in C++ C++ Dijkstra Algorithm using the priority queue Constructor overloading in C++ Default arguments in C++ Dynamic binding in C++ Dynamic memory allocation in C++ Fast input and output in C++ Hierarchical inheritance in C++ Hybrid inheritance in C++ Multiple Inheritance in C++ C++ Bitwise XOR Operator Different Ways to Compare Strings in C++ Reverse an Array in C++ C++ date and time Copy elision in C++ Array of sets in C++ Smart pointers in C++ Types of polymorphism in C++ Implementing the sets without C++ STL containers Scope Resolution Operator in C++ Static Member Function in C++ Const keyword in C++ Memset in C++ Type Casting in C++ Binary Operator Overloading in C++ Binary Search in C++ Inheritance in C++ vs JAVA Static Keyword in C++ and JAVA Exception Handling in C++ and JAVA Foreach in C++ and JAVA C++ templates vs. Java generics Similarities and Differences in C++ and JAVA Default Virtual Behaviour in C++ and JAVA C++ hashing programme with chaining Largest subset whose all elements are Fibonacci numbers Opaque Pointer Pointers such as Dangling, Void, Null, and Wild When do we pass arguments by reference or pointer Find Member Function in Vector in C++ Smart Pointer Currency Converter in C++ Find max in Array Function C++ MCQ C++ MCQ C++ MCQ Part 2 Interview Question Interview Question next ? ? prev Smart Pointer Pointers are used to access resources outside of the programme, such as heap memory. As a result, pointers are used to access heap memory (if anything is created inside heap memory). We simply use a copy of any external resource when accessing it. We simply change it in the copied version if we make any changes. However, if we use a pointer to the resource, we can change the original resource. Issues with Normal Pointers Check out the code below. C++ Code 
#include <iostream>
using namespace std;

class Rectangle {
private:
	int length;
	int breadth;
};

void fun()
{
	// By taking a pointer p and
	// dynamically creating object
	// of class rectangle
	Rectangle* p = new Rectangle();
}

int main()
{
	// Infinite Loop
	while (1) {
		fun();
	}
}
 Function fun generates a pointer pointing to the Rectangle object. Rectangle is made up of two integers: length and breadth. Because p is a local variable, it will be destroyed when the function fun ends. However, because we forgot to use delete p; at the end of the function, the memory it consumed will not be deallocated. This means that the memory will not be available for use by other resources. However, we no longer require the variable, but rather the memory. Fun is called in an infinite loop in function main. That means it will continue to generate p. It will allocate more memory but will not free it because we did not deallocate it. The unused memory cannot be used again. This results in a memory leak. Because of this, the entire heap memory may become useless. Smart Pointer, a feature of C++11, provides a solution to this problem. Smart Pointers are being introduced. Unconsciously, not dealinglocating a pointer causes a memory leak, which may result in a programme crash. Garbage Collection Mechanisms are used in the languages Java and C# to intelligently deallocate unused memory so that it can be used again. The programmer does not have to be concerned about memory leaks. Smart Pointer is a mechanism developed by C++11. When the object is destroyed, the memory is also released. As a result, we don't need to delete it because Smart Pointer will handle it. A Smart Pointer is a pointer wrapper class that has operators like * and -> overloaded. The smart pointer class's objects resemble regular pointers. However, unlike Normal Pointers, it has the ability to deallocate and free destroyed object memory. Take a class that has a pointer, a destructor, and overloaded operators like * and ->. Because the destructor is automatically called when an object exits scope, the dynamically allocated memory would be deleted (or reference count can be decremented). Consider the SmartPtr class shown below. C++ Code 
#include <iostream>
using namespace std;

class SmartPtr {
	int* ptr; // Actual pointer
public:
	// for use of explicit keyword
	explicit SmartPtr(int* p = NULL) { ptr = p; }

	// Destructor
	~SmartPtr() { delete (ptr); }

	// Overloading dereferencing operator
	int& operator*() { return *ptr; }
};

int main()
{
	SmartPtr ptr(new int());
	*ptr = 20;
	cout << *ptr;

	// We don't need to call delete ptr: when the object
	// ptr goes out of scope, the destructor for it is automatically
	// called and destructor does delete ptr.

	return 0;
}
 Output: 20
 This only applies to int. So we'll need to make a Smart Pointer for each object? No, Template, there is a solution. As you can see in the code below, T can be of any type. Learn more about Template by clicking here. C++ Code 
#include <iostream>
using namespace std;

// A generic smart pointer class
template <class T>
class SmartPtr {
	T* ptr; // Actual pointer
public:
	// Constructor
	explicit SmartPtr(T* p = NULL) { ptr = p; }

	// Destructor
	~SmartPtr() { delete (ptr); }

	// Overloading dereferencing operator
	T& operator*() { return *ptr; }

	// Overloading arrow operator so that
	// members of T can be accessed
	// like a pointer (useful if T represents
	// a class or struct or union type)
	T* operator->() { return ptr; }
};

int main()
{
	SmartPtr<int> ptr(new int());
	*ptr = 20;
	cout << *ptr;
	return 0;
}
 Output: 20
 Note: Smart pointers can also be used to manage resources such as file handles or network sockets. Smart Pointer Types 1. unique ptr Only one pointer is stored in unique ptr. By removing the current object from the pointer, we can assign a different object. Take note of the code below. First, the unique_pointer is pointing to P1. However, we remove P1 and replace it with P2, so the pointer now points to P2. C++ Code 
#include <iostream>
using namespace std;
#include <memory>

class Rectangle {
	int length;
	int breadth;

public:
	Rectangle(int l, int b){
		length = l;
		breadth = b;
	}

	int area(){
		return length * breadth;
	}
};

int main(){

	unique_ptr<Rectangle> P1(new Rectangle(10, 5));
	cout << P1->area() << endl; // This'll print 50

	// unique_ptr<Rectangle> P2(P1);
	unique_ptr<Rectangle> P2;
	P2 = move(P1);

	// This'll print 50
	cout << P2->area() << endl;

	// cout<<P1->area()<<endl;
	return 0;
}
 Output: 50
50
 2. shared_ptr Using shared ptr, multiple pointers can point to the same object at the same time, and it will keep a reference counter using the use count() method. C++ Code 
#include <iostream>
using namespace std;
#include <memory>

class Rectangle {
	int length;
	int breadth;

public:
	Rectangle(int l, int b)
	{
		length = l;
		breadth = b;
	}

	int area()
	{
		return length * breadth;
	}
};

int main()
{

	shared_ptr<Rectangle> P1(new Rectangle(10, 5));
	// This'll print 50
	cout << P1->area() << endl;

	shared_ptr<Rectangle> P2;
	P2 = P1;

	// This'll print 50
	cout << P2->area() << endl;

	// This'll now not give an error,
	cout << P1->area() << endl;

	// This'll also print 50 now
	// This'll print 2 as Reference Counter is 2
	cout << P1.use_count() << endl;
	return 0;
}
 Output: 50
50
50
2
 3. weak_ptr It is very similar to shared ptr, except that it does not keep a Reference Counter. A pointer will not have a stronghold on the object in this case. The reason for this is that if pointers are holding the object while requesting other objects, they may form a deadlock. Next TopicCurrency Converter in C++ ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/smart-pointer Smart Pointer - javatpoint ? SCROLL TO TOP Home C C++ C# Java PHP HTML CSS JavaScript jQuery XML JSON Ajax Node.js SQL Quiz Projects Interview Q Comment Forum Training C++ Tutorial C++ Tutorial C vs C++ C++ History C++ Features C++ Installation C++ Program C++ cout, cin, endl C++ Variable C++ Data types C++ Keywords C++ Operators C++ Identifiers C++ Expression C++ Control Statement C++ if-else C++ switch C++ For Loop C++ While Loop C++ Do-While Loop C++ Break Statement C++ Continue Statement C++ Goto Statement C++ Comments C++ Functions C++ Functions Call by value & reference C++ Recursion C++ Storage Classes C++ Arrays C++ Arrays C++ Array to Function Multidimensional Arrays C++ Pointers C++ Pointers sizeof() operator in C++ C++ Array of Pointers C++ Void Pointer C++ References Reference vs Pointer Function Pointer in C++ C++ Memory Management malloc() vs new in C++ free vs delete in C++ C++ Object Class C++ OOPs Concepts C++ Object Class C++ Constructor C++ Copy Constructor C++ Destructor C++ this Pointer C++ static C++ Structs C++ Enumeration C++ Friend Function C++ Math Functions C++ Inheritance C++ Inheritance C++ Aggregation C++ Polymorphism C++ Polymorphism C++ Overloading C++ Overriding C++ Virtual Function C++ Abstraction C++ Interfaces C++ Data Abstraction C++ Namespaces C++ Namespaces C++ Strings C++ Strings C++ Exceptions C++ Exception Handling C++ try/catch C++ User-Defined C++ Templates C++ Templates Signal Handling C++ Signal Handling C++ File & Stream C++ File & Stream C++ getline() C++ Misc C++ vs C# C++ int to string C++ vs Python Structure vs Class in C++ Virtual Destructor in C++ Constructor vs Destructor in C++ Bit manipulation C++ What is a reference variable Friend Function in C++ Snake Code in C++ Inline function in C++ Virtual function vs Pure virtual function in C++ How to Split strings in C++ Range-based for loop in C++ Type Conversion in C++ LCM of two numbers in C++ Convert string to integer in C++ C++ STL Tutorial C++ STL Components C++ Vector Initialize Vector in C++ C++ Deque C++ List C++ Set C++ Stack C++ Queue C++ Priority Queue C++ Map C++ Multimap C++ Map C++ Bitset C++ Algorithm C++ Iterators C++ Iterators C++ Bidirectional Iterator C++ Forward Iterator C++ Input Iterator C++ Output Iterator C++ Programs C++Programs Fibonacci Series Prime Number Palindrome Number Factorial Armstrong Number Sum of digits Reverse Number Swap Number Matrix Multiplication Decimal to Binary Number in Characters Alphabet Triangle Number Triangle Fibonacci Triangle Char array to string in C++ Calculator Program in C++ Program to convert infix to postfix expression in C++ using the Stack Data Structure C++ program to merge two unsorted arrays C++ coin change program C++ program to add two complex numbers using class C++ program to find the GCD of two numbers C++ program to find greatest of four numbers Delete Operator in C++ How to concatenate two strings in c++ Upcasting and Downcasting in C++ C++ Dijkstra Algorithm using the priority queue Constructor overloading in C++ Default arguments in C++ Dynamic binding in C++ Dynamic memory allocation in C++ Fast input and output in C++ Hierarchical inheritance in C++ Hybrid inheritance in C++ Multiple Inheritance in C++ C++ Bitwise XOR Operator Different Ways to Compare Strings in C++ Reverse an Array in C++ C++ date and time Copy elision in C++ Array of sets in C++ Smart pointers in C++ Types of polymorphism in C++ Implementing the sets without C++ STL containers Scope Resolution Operator in C++ Static Member Function in C++ Const keyword in C++ Memset in C++ Type Casting in C++ Binary Operator Overloading in C++ Binary Search in C++ Inheritance in C++ vs JAVA Static Keyword in C++ and JAVA Exception Handling in C++ and JAVA Foreach in C++ and JAVA C++ templates vs. Java generics Similarities and Differences in C++ and JAVA Default Virtual Behaviour in C++ and JAVA C++ hashing programme with chaining Largest subset whose all elements are Fibonacci numbers Opaque Pointer Pointers such as Dangling, Void, Null, and Wild When do we pass arguments by reference or pointer Find Member Function in Vector in C++ Smart Pointer Currency Converter in C++ Find max in Array Function C++ MCQ C++ MCQ C++ MCQ Part 2 Interview Question Interview Question next ? ? prev Smart Pointer Pointers are used to access resources outside of the programme, such as heap memory. As a result, pointers are used to access heap memory (if anything is created inside heap memory). We simply use a copy of any external resource when accessing it. We simply change it in the copied version if we make any changes. However, if we use a pointer to the resource, we can change the original resource. Issues with Normal Pointers Check out the code below. C++ Code 
#include <iostream>
using namespace std;

class Rectangle {
private:
	int length;
	int breadth;
};

void fun()
{
	// By taking a pointer p and
	// dynamically creating object
	// of class rectangle
	Rectangle* p = new Rectangle();
}

int main()
{
	// Infinite Loop
	while (1) {
		fun();
	}
}
 Function fun generates a pointer pointing to the Rectangle object. Rectangle is made up of two integers: length and breadth. Because p is a local variable, it will be destroyed when the function fun ends. However, because we forgot to use delete p; at the end of the function, the memory it consumed will not be deallocated. This means that the memory will not be available for use by other resources. However, we no longer require the variable, but rather the memory. Fun is called in an infinite loop in function main. That means it will continue to generate p. It will allocate more memory but will not free it because we did not deallocate it. The unused memory cannot be used again. This results in a memory leak. Because of this, the entire heap memory may become useless. Smart Pointer, a feature of C++11, provides a solution to this problem. Smart Pointers are being introduced. Unconsciously, not dealinglocating a pointer causes a memory leak, which may result in a programme crash. Garbage Collection Mechanisms are used in the languages Java and C# to intelligently deallocate unused memory so that it can be used again. The programmer does not have to be concerned about memory leaks. Smart Pointer is a mechanism developed by C++11. When the object is destroyed, the memory is also released. As a result, we don't need to delete it because Smart Pointer will handle it. A Smart Pointer is a pointer wrapper class that has operators like * and -> overloaded. The smart pointer class's objects resemble regular pointers. However, unlike Normal Pointers, it has the ability to deallocate and free destroyed object memory. Take a class that has a pointer, a destructor, and overloaded operators like * and ->. Because the destructor is automatically called when an object exits scope, the dynamically allocated memory would be deleted (or reference count can be decremented). Consider the SmartPtr class shown below. C++ Code 
#include <iostream>
using namespace std;

class SmartPtr {
	int* ptr; // Actual pointer
public:
	// for use of explicit keyword
	explicit SmartPtr(int* p = NULL) { ptr = p; }

	// Destructor
	~SmartPtr() { delete (ptr); }

	// Overloading dereferencing operator
	int& operator*() { return *ptr; }
};

int main()
{
	SmartPtr ptr(new int());
	*ptr = 20;
	cout << *ptr;

	// We don't need to call delete ptr: when the object
	// ptr goes out of scope, the destructor for it is automatically
	// called and destructor does delete ptr.

	return 0;
}
 Output: 20
 This only applies to int. So we'll need to make a Smart Pointer for each object? No, Template, there is a solution. As you can see in the code below, T can be of any type. Learn more about Template by clicking here. C++ Code 
#include <iostream>
using namespace std;

// A generic smart pointer class
template <class T>
class SmartPtr {
	T* ptr; // Actual pointer
public:
	// Constructor
	explicit SmartPtr(T* p = NULL) { ptr = p; }

	// Destructor
	~SmartPtr() { delete (ptr); }

	// Overloading dereferencing operator
	T& operator*() { return *ptr; }

	// Overloading arrow operator so that
	// members of T can be accessed
	// like a pointer (useful if T represents
	// a class or struct or union type)
	T* operator->() { return ptr; }
};

int main()
{
	SmartPtr<int> ptr(new int());
	*ptr = 20;
	cout << *ptr;
	return 0;
}
 Output: 20
 Note: Smart pointers can also be used to manage resources such as file handles or network sockets. Smart Pointer Types 1. unique ptr Only one pointer is stored in unique ptr. By removing the current object from the pointer, we can assign a different object. Take note of the code below. First, the unique_pointer is pointing to P1. However, we remove P1 and replace it with P2, so the pointer now points to P2. C++ Code 
#include <iostream>
using namespace std;
#include <memory>

class Rectangle {
	int length;
	int breadth;

public:
	Rectangle(int l, int b){
		length = l;
		breadth = b;
	}

	int area(){
		return length * breadth;
	}
};

int main(){

	unique_ptr<Rectangle> P1(new Rectangle(10, 5));
	cout << P1->area() << endl; // This'll print 50

	// unique_ptr<Rectangle> P2(P1);
	unique_ptr<Rectangle> P2;
	P2 = move(P1);

	// This'll print 50
	cout << P2->area() << endl;

	// cout<<P1->area()<<endl;
	return 0;
}
 Output: 50
50
 2. shared_ptr Using shared ptr, multiple pointers can point to the same object at the same time, and it will keep a reference counter using the use count() method. C++ Code 
#include <iostream>
using namespace std;
#include <memory>

class Rectangle {
	int length;
	int breadth;

public:
	Rectangle(int l, int b)
	{
		length = l;
		breadth = b;
	}

	int area()
	{
		return length * breadth;
	}
};

int main()
{

	shared_ptr<Rectangle> P1(new Rectangle(10, 5));
	// This'll print 50
	cout << P1->area() << endl;

	shared_ptr<Rectangle> P2;
	P2 = P1;

	// This'll print 50
	cout << P2->area() << endl;

	// This'll now not give an error,
	cout << P1->area() << endl;

	// This'll also print 50 now
	// This'll print 2 as Reference Counter is 2
	cout << P1.use_count() << endl;
	return 0;
}
 Output: 50
50
50
2
 3. weak_ptr It is very similar to shared ptr, except that it does not keep a Reference Counter. A pointer will not have a stronghold on the object in this case. The reason for this is that if pointers are holding the object while requesting other objects, they may form a deadlock. Next TopicCurrency Converter in C++ ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/smart-pointer Smart Pointer - javatpoint ? SCROLL TO TOP Home C C++ C# Java PHP HTML CSS JavaScript jQuery XML JSON Ajax Node.js SQL Quiz Projects Interview Q Comment Forum Training C++ Tutorial C++ Tutorial C vs C++ C++ History C++ Features C++ Installation C++ Program C++ cout, cin, endl C++ Variable C++ Data types C++ Keywords C++ Operators C++ Identifiers C++ Expression C++ Control Statement C++ if-else C++ switch C++ For Loop C++ While Loop C++ Do-While Loop C++ Break Statement C++ Continue Statement C++ Goto Statement C++ Comments C++ Functions C++ Functions Call by value & reference C++ Recursion C++ Storage Classes C++ Arrays C++ Arrays C++ Array to Function Multidimensional Arrays C++ Pointers C++ Pointers sizeof() operator in C++ C++ Array of Pointers C++ Void Pointer C++ References Reference vs Pointer Function Pointer in C++ C++ Memory Management malloc() vs new in C++ free vs delete in C++ C++ Object Class C++ OOPs Concepts C++ Object Class C++ Constructor C++ Copy Constructor C++ Destructor C++ this Pointer C++ static C++ Structs C++ Enumeration C++ Friend Function C++ Math Functions C++ Inheritance C++ Inheritance C++ Aggregation C++ Polymorphism C++ Polymorphism C++ Overloading C++ Overriding C++ Virtual Function C++ Abstraction C++ Interfaces C++ Data Abstraction C++ Namespaces C++ Namespaces C++ Strings C++ Strings C++ Exceptions C++ Exception Handling C++ try/catch C++ User-Defined C++ Templates C++ Templates Signal Handling C++ Signal Handling C++ File & Stream C++ File & Stream C++ getline() C++ Misc C++ vs C# C++ int to string C++ vs Python Structure vs Class in C++ Virtual Destructor in C++ Constructor vs Destructor in C++ Bit manipulation C++ What is a reference variable Friend Function in C++ Snake Code in C++ Inline function in C++ Virtual function vs Pure virtual function in C++ How to Split strings in C++ Range-based for loop in C++ Type Conversion in C++ LCM of two numbers in C++ Convert string to integer in C++ C++ STL Tutorial C++ STL Components C++ Vector Initialize Vector in C++ C++ Deque C++ List C++ Set C++ Stack C++ Queue C++ Priority Queue C++ Map C++ Multimap C++ Map C++ Bitset C++ Algorithm C++ Iterators C++ Iterators C++ Bidirectional Iterator C++ Forward Iterator C++ Input Iterator C++ Output Iterator C++ Programs C++Programs Fibonacci Series Prime Number Palindrome Number Factorial Armstrong Number Sum of digits Reverse Number Swap Number Matrix Multiplication Decimal to Binary Number in Characters Alphabet Triangle Number Triangle Fibonacci Triangle Char array to string in C++ Calculator Program in C++ Program to convert infix to postfix expression in C++ using the Stack Data Structure C++ program to merge two unsorted arrays C++ coin change program C++ program to add two complex numbers using class C++ program to find the GCD of two numbers C++ program to find greatest of four numbers Delete Operator in C++ How to concatenate two strings in c++ Upcasting and Downcasting in C++ C++ Dijkstra Algorithm using the priority queue Constructor overloading in C++ Default arguments in C++ Dynamic binding in C++ Dynamic memory allocation in C++ Fast input and output in C++ Hierarchical inheritance in C++ Hybrid inheritance in C++ Multiple Inheritance in C++ C++ Bitwise XOR Operator Different Ways to Compare Strings in C++ Reverse an Array in C++ C++ date and time Copy elision in C++ Array of sets in C++ Smart pointers in C++ Types of polymorphism in C++ Implementing the sets without C++ STL containers Scope Resolution Operator in C++ Static Member Function in C++ Const keyword in C++ Memset in C++ Type Casting in C++ Binary Operator Overloading in C++ Binary Search in C++ Inheritance in C++ vs JAVA Static Keyword in C++ and JAVA Exception Handling in C++ and JAVA Foreach in C++ and JAVA C++ templates vs. Java generics Similarities and Differences in C++ and JAVA Default Virtual Behaviour in C++ and JAVA C++ hashing programme with chaining Largest subset whose all elements are Fibonacci numbers Opaque Pointer Pointers such as Dangling, Void, Null, and Wild When do we pass arguments by reference or pointer Find Member Function in Vector in C++ Smart Pointer Currency Converter in C++ Find max in Array Function C++ MCQ C++ MCQ C++ MCQ Part 2 Interview Question Interview Question next ? ? prev Smart Pointer Pointers are used to access resources outside of the programme, such as heap memory. As a result, pointers are used to access heap memory (if anything is created inside heap memory). We simply use a copy of any external resource when accessing it. We simply change it in the copied version if we make any changes. However, if we use a pointer to the resource, we can change the original resource. Issues with Normal Pointers Check out the code below. C++ Code 
#include <iostream>
using namespace std;

class Rectangle {
private:
	int length;
	int breadth;
};

void fun()
{
	// By taking a pointer p and
	// dynamically creating object
	// of class rectangle
	Rectangle* p = new Rectangle();
}

int main()
{
	// Infinite Loop
	while (1) {
		fun();
	}
}
 Function fun generates a pointer pointing to the Rectangle object. Rectangle is made up of two integers: length and breadth. Because p is a local variable, it will be destroyed when the function fun ends. However, because we forgot to use delete p; at the end of the function, the memory it consumed will not be deallocated. This means that the memory will not be available for use by other resources. However, we no longer require the variable, but rather the memory. Fun is called in an infinite loop in function main. That means it will continue to generate p. It will allocate more memory but will not free it because we did not deallocate it. The unused memory cannot be used again. This results in a memory leak. Because of this, the entire heap memory may become useless. Smart Pointer, a feature of C++11, provides a solution to this problem. Smart Pointers are being introduced. Unconsciously, not dealinglocating a pointer causes a memory leak, which may result in a programme crash. Garbage Collection Mechanisms are used in the languages Java and C# to intelligently deallocate unused memory so that it can be used again. The programmer does not have to be concerned about memory leaks. Smart Pointer is a mechanism developed by C++11. When the object is destroyed, the memory is also released. As a result, we don't need to delete it because Smart Pointer will handle it. A Smart Pointer is a pointer wrapper class that has operators like * and -> overloaded. The smart pointer class's objects resemble regular pointers. However, unlike Normal Pointers, it has the ability to deallocate and free destroyed object memory. Take a class that has a pointer, a destructor, and overloaded operators like * and ->. Because the destructor is automatically called when an object exits scope, the dynamically allocated memory would be deleted (or reference count can be decremented). Consider the SmartPtr class shown below. C++ Code 
#include <iostream>
using namespace std;

class SmartPtr {
	int* ptr; // Actual pointer
public:
	// for use of explicit keyword
	explicit SmartPtr(int* p = NULL) { ptr = p; }

	// Destructor
	~SmartPtr() { delete (ptr); }

	// Overloading dereferencing operator
	int& operator*() { return *ptr; }
};

int main()
{
	SmartPtr ptr(new int());
	*ptr = 20;
	cout << *ptr;

	// We don't need to call delete ptr: when the object
	// ptr goes out of scope, the destructor for it is automatically
	// called and destructor does delete ptr.

	return 0;
}
 Output: 20
 This only applies to int. So we'll need to make a Smart Pointer for each object? No, Template, there is a solution. As you can see in the code below, T can be of any type. Learn more about Template by clicking here. C++ Code 
#include <iostream>
using namespace std;

// A generic smart pointer class
template <class T>
class SmartPtr {
	T* ptr; // Actual pointer
public:
	// Constructor
	explicit SmartPtr(T* p = NULL) { ptr = p; }

	// Destructor
	~SmartPtr() { delete (ptr); }

	// Overloading dereferencing operator
	T& operator*() { return *ptr; }

	// Overloading arrow operator so that
	// members of T can be accessed
	// like a pointer (useful if T represents
	// a class or struct or union type)
	T* operator->() { return ptr; }
};

int main()
{
	SmartPtr<int> ptr(new int());
	*ptr = 20;
	cout << *ptr;
	return 0;
}
 Output: 20
 Note: Smart pointers can also be used to manage resources such as file handles or network sockets. Smart Pointer Types 1. unique ptr Only one pointer is stored in unique ptr. By removing the current object from the pointer, we can assign a different object. Take note of the code below. First, the unique_pointer is pointing to P1. However, we remove P1 and replace it with P2, so the pointer now points to P2. C++ Code 
#include <iostream>
using namespace std;
#include <memory>

class Rectangle {
	int length;
	int breadth;

public:
	Rectangle(int l, int b){
		length = l;
		breadth = b;
	}

	int area(){
		return length * breadth;
	}
};

int main(){

	unique_ptr<Rectangle> P1(new Rectangle(10, 5));
	cout << P1->area() << endl; // This'll print 50

	// unique_ptr<Rectangle> P2(P1);
	unique_ptr<Rectangle> P2;
	P2 = move(P1);

	// This'll print 50
	cout << P2->area() << endl;

	// cout<<P1->area()<<endl;
	return 0;
}
 Output: 50
50
 2. shared_ptr Using shared ptr, multiple pointers can point to the same object at the same time, and it will keep a reference counter using the use count() method. C++ Code 
#include <iostream>
using namespace std;
#include <memory>

class Rectangle {
	int length;
	int breadth;

public:
	Rectangle(int l, int b)
	{
		length = l;
		breadth = b;
	}

	int area()
	{
		return length * breadth;
	}
};

int main()
{

	shared_ptr<Rectangle> P1(new Rectangle(10, 5));
	// This'll print 50
	cout << P1->area() << endl;

	shared_ptr<Rectangle> P2;
	P2 = P1;

	// This'll print 50
	cout << P2->area() << endl;

	// This'll now not give an error,
	cout << P1->area() << endl;

	// This'll also print 50 now
	// This'll print 2 as Reference Counter is 2
	cout << P1.use_count() << endl;
	return 0;
}
 Output: 50
50
50
2
 3. weak_ptr It is very similar to shared ptr, except that it does not keep a Reference Counter. A pointer will not have a stronghold on the object in this case. The reason for this is that if pointers are holding the object while requesting other objects, they may form a deadlock. Next TopicCurrency Converter in C++ ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/smart-pointer Smart Pointer - javatpoint ? SCROLL TO TOP Home C C++ C# Java PHP HTML CSS JavaScript jQuery XML JSON Ajax Node.js SQL Quiz Projects Interview Q Comment Forum Training C++ Tutorial C++ Tutorial C vs C++ C++ History C++ Features C++ Installation C++ Program C++ cout, cin, endl C++ Variable C++ Data types C++ Keywords C++ Operators C++ Identifiers C++ Expression C++ Control Statement C++ if-else C++ switch C++ For Loop C++ While Loop C++ Do-While Loop C++ Break Statement C++ Continue Statement C++ Goto Statement C++ Comments C++ Functions C++ Functions Call by value & reference C++ Recursion C++ Storage Classes C++ Arrays C++ Arrays C++ Array to Function Multidimensional Arrays C++ Pointers C++ Pointers sizeof() operator in C++ C++ Array of Pointers C++ Void Pointer C++ References Reference vs Pointer Function Pointer in C++ C++ Memory Management malloc() vs new in C++ free vs delete in C++ C++ Object Class C++ OOPs Concepts C++ Object Class C++ Constructor C++ Copy Constructor C++ Destructor C++ this Pointer C++ static C++ Structs C++ Enumeration C++ Friend Function C++ Math Functions C++ Inheritance C++ Inheritance C++ Aggregation C++ Polymorphism C++ Polymorphism C++ Overloading C++ Overriding C++ Virtual Function C++ Abstraction C++ Interfaces C++ Data Abstraction C++ Namespaces C++ Namespaces C++ Strings C++ Strings C++ Exceptions C++ Exception Handling C++ try/catch C++ User-Defined C++ Templates C++ Templates Signal Handling C++ Signal Handling C++ File & Stream C++ File & Stream C++ getline() C++ Misc C++ vs C# C++ int to string C++ vs Python Structure vs Class in C++ Virtual Destructor in C++ Constructor vs Destructor in C++ Bit manipulation C++ What is a reference variable Friend Function in C++ Snake Code in C++ Inline function in C++ Virtual function vs Pure virtual function in C++ How to Split strings in C++ Range-based for loop in C++ Type Conversion in C++ LCM of two numbers in C++ Convert string to integer in C++ C++ STL Tutorial C++ STL Components C++ Vector Initialize Vector in C++ C++ Deque C++ List C++ Set C++ Stack C++ Queue C++ Priority Queue C++ Map C++ Multimap C++ Map C++ Bitset C++ Algorithm C++ Iterators C++ Iterators C++ Bidirectional Iterator C++ Forward Iterator C++ Input Iterator C++ Output Iterator C++ Programs C++Programs Fibonacci Series Prime Number Palindrome Number Factorial Armstrong Number Sum of digits Reverse Number Swap Number Matrix Multiplication Decimal to Binary Number in Characters Alphabet Triangle Number Triangle Fibonacci Triangle Char array to string in C++ Calculator Program in C++ Program to convert infix to postfix expression in C++ using the Stack Data Structure C++ program to merge two unsorted arrays C++ coin change program C++ program to add two complex numbers using class C++ program to find the GCD of two numbers C++ program to find greatest of four numbers Delete Operator in C++ How to concatenate two strings in c++ Upcasting and Downcasting in C++ C++ Dijkstra Algorithm using the priority queue Constructor overloading in C++ Default arguments in C++ Dynamic binding in C++ Dynamic memory allocation in C++ Fast input and output in C++ Hierarchical inheritance in C++ Hybrid inheritance in C++ Multiple Inheritance in C++ C++ Bitwise XOR Operator Different Ways to Compare Strings in C++ Reverse an Array in C++ C++ date and time Copy elision in C++ Array of sets in C++ Smart pointers in C++ Types of polymorphism in C++ Implementing the sets without C++ STL containers Scope Resolution Operator in C++ Static Member Function in C++ Const keyword in C++ Memset in C++ Type Casting in C++ Binary Operator Overloading in C++ Binary Search in C++ Inheritance in C++ vs JAVA Static Keyword in C++ and JAVA Exception Handling in C++ and JAVA Foreach in C++ and JAVA C++ templates vs. Java generics Similarities and Differences in C++ and JAVA Default Virtual Behaviour in C++ and JAVA C++ hashing programme with chaining Largest subset whose all elements are Fibonacci numbers Opaque Pointer Pointers such as Dangling, Void, Null, and Wild When do we pass arguments by reference or pointer Find Member Function in Vector in C++ Smart Pointer Currency Converter in C++ Find max in Array Function C++ MCQ C++ MCQ C++ MCQ Part 2 Interview Question Interview Question next ? ? prev Smart Pointer Pointers are used to access resources outside of the programme, such as heap memory. As a result, pointers are used to access heap memory (if anything is created inside heap memory). We simply use a copy of any external resource when accessing it. We simply change it in the copied version if we make any changes. However, if we use a pointer to the resource, we can change the original resource. Issues with Normal Pointers Check out the code below. C++ Code 
#include <iostream>
using namespace std;

class Rectangle {
private:
	int length;
	int breadth;
};

void fun()
{
	// By taking a pointer p and
	// dynamically creating object
	// of class rectangle
	Rectangle* p = new Rectangle();
}

int main()
{
	// Infinite Loop
	while (1) {
		fun();
	}
}
 Function fun generates a pointer pointing to the Rectangle object. Rectangle is made up of two integers: length and breadth. Because p is a local variable, it will be destroyed when the function fun ends. However, because we forgot to use delete p; at the end of the function, the memory it consumed will not be deallocated. This means that the memory will not be available for use by other resources. However, we no longer require the variable, but rather the memory. Fun is called in an infinite loop in function main. That means it will continue to generate p. It will allocate more memory but will not free it because we did not deallocate it. The unused memory cannot be used again. This results in a memory leak. Because of this, the entire heap memory may become useless. Smart Pointer, a feature of C++11, provides a solution to this problem. Smart Pointers are being introduced. Unconsciously, not dealinglocating a pointer causes a memory leak, which may result in a programme crash. Garbage Collection Mechanisms are used in the languages Java and C# to intelligently deallocate unused memory so that it can be used again. The programmer does not have to be concerned about memory leaks. Smart Pointer is a mechanism developed by C++11. When the object is destroyed, the memory is also released. As a result, we don't need to delete it because Smart Pointer will handle it. A Smart Pointer is a pointer wrapper class that has operators like * and -> overloaded. The smart pointer class's objects resemble regular pointers. However, unlike Normal Pointers, it has the ability to deallocate and free destroyed object memory. Take a class that has a pointer, a destructor, and overloaded operators like * and ->. Because the destructor is automatically called when an object exits scope, the dynamically allocated memory would be deleted (or reference count can be decremented). Consider the SmartPtr class shown below. C++ Code 
#include <iostream>
using namespace std;

class SmartPtr {
	int* ptr; // Actual pointer
public:
	// for use of explicit keyword
	explicit SmartPtr(int* p = NULL) { ptr = p; }

	// Destructor
	~SmartPtr() { delete (ptr); }

	// Overloading dereferencing operator
	int& operator*() { return *ptr; }
};

int main()
{
	SmartPtr ptr(new int());
	*ptr = 20;
	cout << *ptr;

	// We don't need to call delete ptr: when the object
	// ptr goes out of scope, the destructor for it is automatically
	// called and destructor does delete ptr.

	return 0;
}
 Output: 20
 This only applies to int. So we'll need to make a Smart Pointer for each object? No, Template, there is a solution. As you can see in the code below, T can be of any type. Learn more about Template by clicking here. C++ Code 
#include <iostream>
using namespace std;

// A generic smart pointer class
template <class T>
class SmartPtr {
	T* ptr; // Actual pointer
public:
	// Constructor
	explicit SmartPtr(T* p = NULL) { ptr = p; }

	// Destructor
	~SmartPtr() { delete (ptr); }

	// Overloading dereferencing operator
	T& operator*() { return *ptr; }

	// Overloading arrow operator so that
	// members of T can be accessed
	// like a pointer (useful if T represents
	// a class or struct or union type)
	T* operator->() { return ptr; }
};

int main()
{
	SmartPtr<int> ptr(new int());
	*ptr = 20;
	cout << *ptr;
	return 0;
}
 Output: 20
 Note: Smart pointers can also be used to manage resources such as file handles or network sockets. Smart Pointer Types 1. unique ptr Only one pointer is stored in unique ptr. By removing the current object from the pointer, we can assign a different object. Take note of the code below. First, the unique_pointer is pointing to P1. However, we remove P1 and replace it with P2, so the pointer now points to P2. C++ Code 
#include <iostream>
using namespace std;
#include <memory>

class Rectangle {
	int length;
	int breadth;

public:
	Rectangle(int l, int b){
		length = l;
		breadth = b;
	}

	int area(){
		return length * breadth;
	}
};

int main(){

	unique_ptr<Rectangle> P1(new Rectangle(10, 5));
	cout << P1->area() << endl; // This'll print 50

	// unique_ptr<Rectangle> P2(P1);
	unique_ptr<Rectangle> P2;
	P2 = move(P1);

	// This'll print 50
	cout << P2->area() << endl;

	// cout<<P1->area()<<endl;
	return 0;
}
 Output: 50
50
 2. shared_ptr Using shared ptr, multiple pointers can point to the same object at the same time, and it will keep a reference counter using the use count() method. C++ Code 
#include <iostream>
using namespace std;
#include <memory>

class Rectangle {
	int length;
	int breadth;

public:
	Rectangle(int l, int b)
	{
		length = l;
		breadth = b;
	}

	int area()
	{
		return length * breadth;
	}
};

int main()
{

	shared_ptr<Rectangle> P1(new Rectangle(10, 5));
	// This'll print 50
	cout << P1->area() << endl;

	shared_ptr<Rectangle> P2;
	P2 = P1;

	// This'll print 50
	cout << P2->area() << endl;

	// This'll now not give an error,
	cout << P1->area() << endl;

	// This'll also print 50 now
	// This'll print 2 as Reference Counter is 2
	cout << P1.use_count() << endl;
	return 0;
}
 Output: 50
50
50
2
 3. weak_ptr It is very similar to shared ptr, except that it does not keep a Reference Counter. A pointer will not have a stronghold on the object in this case. The reason for this is that if pointers are holding the object while requesting other objects, they may form a deadlock. Next TopicCurrency Converter in C++ ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/smart-pointer Smart Pointer - javatpoint ? SCROLL TO TOP Home C C++ C# Java PHP HTML CSS JavaScript jQuery XML JSON Ajax Node.js SQL Quiz Projects Interview Q Comment Forum Training C++ Tutorial C++ Tutorial C vs C++ C++ History C++ Features C++ Installation C++ Program C++ cout, cin, endl C++ Variable C++ Data types C++ Keywords C++ Operators C++ Identifiers C++ Expression C++ Control Statement C++ if-else C++ switch C++ For Loop C++ While Loop C++ Do-While Loop C++ Break Statement C++ Continue Statement C++ Goto Statement C++ Comments C++ Functions C++ Functions Call by value & reference C++ Recursion C++ Storage Classes C++ Arrays C++ Arrays C++ Array to Function Multidimensional Arrays C++ Pointers C++ Pointers sizeof() operator in C++ C++ Array of Pointers C++ Void Pointer C++ References Reference vs Pointer Function Pointer in C++ C++ Memory Management malloc() vs new in C++ free vs delete in C++ C++ Object Class C++ OOPs Concepts C++ Object Class C++ Constructor C++ Copy Constructor C++ Destructor C++ this Pointer C++ static C++ Structs C++ Enumeration C++ Friend Function C++ Math Functions C++ Inheritance C++ Inheritance C++ Aggregation C++ Polymorphism C++ Polymorphism C++ Overloading C++ Overriding C++ Virtual Function C++ Abstraction C++ Interfaces C++ Data Abstraction C++ Namespaces C++ Namespaces C++ Strings C++ Strings C++ Exceptions C++ Exception Handling C++ try/catch C++ User-Defined C++ Templates C++ Templates Signal Handling C++ Signal Handling C++ File & Stream C++ File & Stream C++ getline() C++ Misc C++ vs C# C++ int to string C++ vs Python Structure vs Class in C++ Virtual Destructor in C++ Constructor vs Destructor in C++ Bit manipulation C++ What is a reference variable Friend Function in C++ Snake Code in C++ Inline function in C++ Virtual function vs Pure virtual function in C++ How to Split strings in C++ Range-based for loop in C++ Type Conversion in C++ LCM of two numbers in C++ Convert string to integer in C++ C++ STL Tutorial C++ STL Components C++ Vector Initialize Vector in C++ C++ Deque C++ List C++ Set C++ Stack C++ Queue C++ Priority Queue C++ Map C++ Multimap C++ Map C++ Bitset C++ Algorithm C++ Iterators C++ Iterators C++ Bidirectional Iterator C++ Forward Iterator C++ Input Iterator C++ Output Iterator C++ Programs C++Programs Fibonacci Series Prime Number Palindrome Number Factorial Armstrong Number Sum of digits Reverse Number Swap Number Matrix Multiplication Decimal to Binary Number in Characters Alphabet Triangle Number Triangle Fibonacci Triangle Char array to string in C++ Calculator Program in C++ Program to convert infix to postfix expression in C++ using the Stack Data Structure C++ program to merge two unsorted arrays C++ coin change program C++ program to add two complex numbers using class C++ program to find the GCD of two numbers C++ program to find greatest of four numbers Delete Operator in C++ How to concatenate two strings in c++ Upcasting and Downcasting in C++ C++ Dijkstra Algorithm using the priority queue Constructor overloading in C++ Default arguments in C++ Dynamic binding in C++ Dynamic memory allocation in C++ Fast input and output in C++ Hierarchical inheritance in C++ Hybrid inheritance in C++ Multiple Inheritance in C++ C++ Bitwise XOR Operator Different Ways to Compare Strings in C++ Reverse an Array in C++ C++ date and time Copy elision in C++ Array of sets in C++ Smart pointers in C++ Types of polymorphism in C++ Implementing the sets without C++ STL containers Scope Resolution Operator in C++ Static Member Function in C++ Const keyword in C++ Memset in C++ Type Casting in C++ Binary Operator Overloading in C++ Binary Search in C++ Inheritance in C++ vs JAVA Static Keyword in C++ and JAVA Exception Handling in C++ and JAVA Foreach in C++ and JAVA C++ templates vs. Java generics Similarities and Differences in C++ and JAVA Default Virtual Behaviour in C++ and JAVA C++ hashing programme with chaining Largest subset whose all elements are Fibonacci numbers Opaque Pointer Pointers such as Dangling, Void, Null, and Wild When do we pass arguments by reference or pointer Find Member Function in Vector in C++ Smart Pointer Currency Converter in C++ Find max in Array Function C++ MCQ C++ MCQ C++ MCQ Part 2 Interview Question Interview Question next ? ? prev Smart Pointer Pointers are used to access resources outside of the programme, such as heap memory. As a result, pointers are used to access heap memory (if anything is created inside heap memory). We simply use a copy of any external resource when accessing it. We simply change it in the copied version if we make any changes. However, if we use a pointer to the resource, we can change the original resource. Issues with Normal Pointers Check out the code below. C++ Code 
#include <iostream>
using namespace std;

class Rectangle {
private:
	int length;
	int breadth;
};

void fun()
{
	// By taking a pointer p and
	// dynamically creating object
	// of class rectangle
	Rectangle* p = new Rectangle();
}

int main()
{
	// Infinite Loop
	while (1) {
		fun();
	}
}
 Function fun generates a pointer pointing to the Rectangle object. Rectangle is made up of two integers: length and breadth. Because p is a local variable, it will be destroyed when the function fun ends. However, because we forgot to use delete p; at the end of the function, the memory it consumed will not be deallocated. This means that the memory will not be available for use by other resources. However, we no longer require the variable, but rather the memory. Fun is called in an infinite loop in function main. That means it will continue to generate p. It will allocate more memory but will not free it because we did not deallocate it. The unused memory cannot be used again. This results in a memory leak. Because of this, the entire heap memory may become useless. Smart Pointer, a feature of C++11, provides a solution to this problem. Smart Pointers are being introduced. Unconsciously, not dealinglocating a pointer causes a memory leak, which may result in a programme crash. Garbage Collection Mechanisms are used in the languages Java and C# to intelligently deallocate unused memory so that it can be used again. The programmer does not have to be concerned about memory leaks. Smart Pointer is a mechanism developed by C++11. When the object is destroyed, the memory is also released. As a result, we don't need to delete it because Smart Pointer will handle it. A Smart Pointer is a pointer wrapper class that has operators like * and -> overloaded. The smart pointer class's objects resemble regular pointers. However, unlike Normal Pointers, it has the ability to deallocate and free destroyed object memory. Take a class that has a pointer, a destructor, and overloaded operators like * and ->. Because the destructor is automatically called when an object exits scope, the dynamically allocated memory would be deleted (or reference count can be decremented). Consider the SmartPtr class shown below. C++ Code 
#include <iostream>
using namespace std;

class SmartPtr {
	int* ptr; // Actual pointer
public:
	// for use of explicit keyword
	explicit SmartPtr(int* p = NULL) { ptr = p; }

	// Destructor
	~SmartPtr() { delete (ptr); }

	// Overloading dereferencing operator
	int& operator*() { return *ptr; }
};

int main()
{
	SmartPtr ptr(new int());
	*ptr = 20;
	cout << *ptr;

	// We don't need to call delete ptr: when the object
	// ptr goes out of scope, the destructor for it is automatically
	// called and destructor does delete ptr.

	return 0;
}
 Output: 20
 This only applies to int. So we'll need to make a Smart Pointer for each object? No, Template, there is a solution. As you can see in the code below, T can be of any type. Learn more about Template by clicking here. C++ Code 
#include <iostream>
using namespace std;

// A generic smart pointer class
template <class T>
class SmartPtr {
	T* ptr; // Actual pointer
public:
	// Constructor
	explicit SmartPtr(T* p = NULL) { ptr = p; }

	// Destructor
	~SmartPtr() { delete (ptr); }

	// Overloading dereferencing operator
	T& operator*() { return *ptr; }

	// Overloading arrow operator so that
	// members of T can be accessed
	// like a pointer (useful if T represents
	// a class or struct or union type)
	T* operator->() { return ptr; }
};

int main()
{
	SmartPtr<int> ptr(new int());
	*ptr = 20;
	cout << *ptr;
	return 0;
}
 Output: 20
 Note: Smart pointers can also be used to manage resources such as file handles or network sockets. Smart Pointer Types 1. unique ptr Only one pointer is stored in unique ptr. By removing the current object from the pointer, we can assign a different object. Take note of the code below. First, the unique_pointer is pointing to P1. However, we remove P1 and replace it with P2, so the pointer now points to P2. C++ Code 
#include <iostream>
using namespace std;
#include <memory>

class Rectangle {
	int length;
	int breadth;

public:
	Rectangle(int l, int b){
		length = l;
		breadth = b;
	}

	int area(){
		return length * breadth;
	}
};

int main(){

	unique_ptr<Rectangle> P1(new Rectangle(10, 5));
	cout << P1->area() << endl; // This'll print 50

	// unique_ptr<Rectangle> P2(P1);
	unique_ptr<Rectangle> P2;
	P2 = move(P1);

	// This'll print 50
	cout << P2->area() << endl;

	// cout<<P1->area()<<endl;
	return 0;
}
 Output: 50
50
 2. shared_ptr Using shared ptr, multiple pointers can point to the same object at the same time, and it will keep a reference counter using the use count() method. C++ Code 
#include <iostream>
using namespace std;
#include <memory>

class Rectangle {
	int length;
	int breadth;

public:
	Rectangle(int l, int b)
	{
		length = l;
		breadth = b;
	}

	int area()
	{
		return length * breadth;
	}
};

int main()
{

	shared_ptr<Rectangle> P1(new Rectangle(10, 5));
	// This'll print 50
	cout << P1->area() << endl;

	shared_ptr<Rectangle> P2;
	P2 = P1;

	// This'll print 50
	cout << P2->area() << endl;

	// This'll now not give an error,
	cout << P1->area() << endl;

	// This'll also print 50 now
	// This'll print 2 as Reference Counter is 2
	cout << P1.use_count() << endl;
	return 0;
}
 Output: 50
50
50
2
 3. weak_ptr It is very similar to shared ptr, except that it does not keep a Reference Counter. A pointer will not have a stronghold on the object in this case. The reason for this is that if pointers are holding the object while requesting other objects, they may form a deadlock. Next TopicCurrency Converter in C++ ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/smart-pointer Smart Pointer - javatpoint ? SCROLL TO TOP Home C C++ C# Java PHP HTML CSS JavaScript jQuery XML JSON Ajax Node.js SQL Quiz Projects Interview Q Comment Forum Training C++ Tutorial C++ Tutorial C vs C++ C++ History C++ Features C++ Installation C++ Program C++ cout, cin, endl C++ Variable C++ Data types C++ Keywords C++ Operators C++ Identifiers C++ Expression C++ Control Statement C++ if-else C++ switch C++ For Loop C++ While Loop C++ Do-While Loop C++ Break Statement C++ Continue Statement C++ Goto Statement C++ Comments C++ Functions C++ Functions Call by value & reference C++ Recursion C++ Storage Classes C++ Arrays C++ Arrays C++ Array to Function Multidimensional Arrays C++ Pointers C++ Pointers sizeof() operator in C++ C++ Array of Pointers C++ Void Pointer C++ References Reference vs Pointer Function Pointer in C++ C++ Memory Management malloc() vs new in C++ free vs delete in C++ C++ Object Class C++ OOPs Concepts C++ Object Class C++ Constructor C++ Copy Constructor C++ Destructor C++ this Pointer C++ static C++ Structs C++ Enumeration C++ Friend Function C++ Math Functions C++ Inheritance C++ Inheritance C++ Aggregation C++ Polymorphism C++ Polymorphism C++ Overloading C++ Overriding C++ Virtual Function C++ Abstraction C++ Interfaces C++ Data Abstraction C++ Namespaces C++ Namespaces C++ Strings C++ Strings C++ Exceptions C++ Exception Handling C++ try/catch C++ User-Defined C++ Templates C++ Templates Signal Handling C++ Signal Handling C++ File & Stream C++ File & Stream C++ getline() C++ Misc C++ vs C# C++ int to string C++ vs Python Structure vs Class in C++ Virtual Destructor in C++ Constructor vs Destructor in C++ Bit manipulation C++ What is a reference variable Friend Function in C++ Snake Code in C++ Inline function in C++ Virtual function vs Pure virtual function in C++ How to Split strings in C++ Range-based for loop in C++ Type Conversion in C++ LCM of two numbers in C++ Convert string to integer in C++ C++ STL Tutorial C++ STL Components C++ Vector Initialize Vector in C++ C++ Deque C++ List C++ Set C++ Stack C++ Queue C++ Priority Queue C++ Map C++ Multimap C++ Map C++ Bitset C++ Algorithm C++ Iterators C++ Iterators C++ Bidirectional Iterator C++ Forward Iterator C++ Input Iterator C++ Output Iterator C++ Programs C++Programs Fibonacci Series Prime Number Palindrome Number Factorial Armstrong Number Sum of digits Reverse Number Swap Number Matrix Multiplication Decimal to Binary Number in Characters Alphabet Triangle Number Triangle Fibonacci Triangle Char array to string in C++ Calculator Program in C++ Program to convert infix to postfix expression in C++ using the Stack Data Structure C++ program to merge two unsorted arrays C++ coin change program C++ program to add two complex numbers using class C++ program to find the GCD of two numbers C++ program to find greatest of four numbers Delete Operator in C++ How to concatenate two strings in c++ Upcasting and Downcasting in C++ C++ Dijkstra Algorithm using the priority queue Constructor overloading in C++ Default arguments in C++ Dynamic binding in C++ Dynamic memory allocation in C++ Fast input and output in C++ Hierarchical inheritance in C++ Hybrid inheritance in C++ Multiple Inheritance in C++ C++ Bitwise XOR Operator Different Ways to Compare Strings in C++ Reverse an Array in C++ C++ date and time Copy elision in C++ Array of sets in C++ Smart pointers in C++ Types of polymorphism in C++ Implementing the sets without C++ STL containers Scope Resolution Operator in C++ Static Member Function in C++ Const keyword in C++ Memset in C++ Type Casting in C++ Binary Operator Overloading in C++ Binary Search in C++ Inheritance in C++ vs JAVA Static Keyword in C++ and JAVA Exception Handling in C++ and JAVA Foreach in C++ and JAVA C++ templates vs. Java generics Similarities and Differences in C++ and JAVA Default Virtual Behaviour in C++ and JAVA C++ hashing programme with chaining Largest subset whose all elements are Fibonacci numbers Opaque Pointer Pointers such as Dangling, Void, Null, and Wild When do we pass arguments by reference or pointer Find Member Function in Vector in C++ Smart Pointer Currency Converter in C++ Find max in Array Function C++ MCQ C++ MCQ C++ MCQ Part 2 Interview Question Interview Question next ? ? prev Smart Pointer Pointers are used to access resources outside of the programme, such as heap memory. As a result, pointers are used to access heap memory (if anything is created inside heap memory). We simply use a copy of any external resource when accessing it. We simply change it in the copied version if we make any changes. However, if we use a pointer to the resource, we can change the original resource. Issues with Normal Pointers Check out the code below. C++ Code 
#include <iostream>
using namespace std;

class Rectangle {
private:
	int length;
	int breadth;
};

void fun()
{
	// By taking a pointer p and
	// dynamically creating object
	// of class rectangle
	Rectangle* p = new Rectangle();
}

int main()
{
	// Infinite Loop
	while (1) {
		fun();
	}
}
 Function fun generates a pointer pointing to the Rectangle object. Rectangle is made up of two integers: length and breadth. Because p is a local variable, it will be destroyed when the function fun ends. However, because we forgot to use delete p; at the end of the function, the memory it consumed will not be deallocated. This means that the memory will not be available for use by other resources. However, we no longer require the variable, but rather the memory. Fun is called in an infinite loop in function main. That means it will continue to generate p. It will allocate more memory but will not free it because we did not deallocate it. The unused memory cannot be used again. This results in a memory leak. Because of this, the entire heap memory may become useless. Smart Pointer, a feature of C++11, provides a solution to this problem. Smart Pointers are being introduced. Unconsciously, not dealinglocating a pointer causes a memory leak, which may result in a programme crash. Garbage Collection Mechanisms are used in the languages Java and C# to intelligently deallocate unused memory so that it can be used again. The programmer does not have to be concerned about memory leaks. Smart Pointer is a mechanism developed by C++11. When the object is destroyed, the memory is also released. As a result, we don't need to delete it because Smart Pointer will handle it. A Smart Pointer is a pointer wrapper class that has operators like * and -> overloaded. The smart pointer class's objects resemble regular pointers. However, unlike Normal Pointers, it has the ability to deallocate and free destroyed object memory. Take a class that has a pointer, a destructor, and overloaded operators like * and ->. Because the destructor is automatically called when an object exits scope, the dynamically allocated memory would be deleted (or reference count can be decremented). Consider the SmartPtr class shown below. C++ Code 
#include <iostream>
using namespace std;

class SmartPtr {
	int* ptr; // Actual pointer
public:
	// for use of explicit keyword
	explicit SmartPtr(int* p = NULL) { ptr = p; }

	// Destructor
	~SmartPtr() { delete (ptr); }

	// Overloading dereferencing operator
	int& operator*() { return *ptr; }
};

int main()
{
	SmartPtr ptr(new int());
	*ptr = 20;
	cout << *ptr;

	// We don't need to call delete ptr: when the object
	// ptr goes out of scope, the destructor for it is automatically
	// called and destructor does delete ptr.

	return 0;
}
 Output: 20
 This only applies to int. So we'll need to make a Smart Pointer for each object? No, Template, there is a solution. As you can see in the code below, T can be of any type. Learn more about Template by clicking here. C++ Code 
#include <iostream>
using namespace std;

// A generic smart pointer class
template <class T>
class SmartPtr {
	T* ptr; // Actual pointer
public:
	// Constructor
	explicit SmartPtr(T* p = NULL) { ptr = p; }

	// Destructor
	~SmartPtr() { delete (ptr); }

	// Overloading dereferencing operator
	T& operator*() { return *ptr; }

	// Overloading arrow operator so that
	// members of T can be accessed
	// like a pointer (useful if T represents
	// a class or struct or union type)
	T* operator->() { return ptr; }
};

int main()
{
	SmartPtr<int> ptr(new int());
	*ptr = 20;
	cout << *ptr;
	return 0;
}
 Output: 20
 Note: Smart pointers can also be used to manage resources such as file handles or network sockets. Smart Pointer Types 1. unique ptr Only one pointer is stored in unique ptr. By removing the current object from the pointer, we can assign a different object. Take note of the code below. First, the unique_pointer is pointing to P1. However, we remove P1 and replace it with P2, so the pointer now points to P2. C++ Code 
#include <iostream>
using namespace std;
#include <memory>

class Rectangle {
	int length;
	int breadth;

public:
	Rectangle(int l, int b){
		length = l;
		breadth = b;
	}

	int area(){
		return length * breadth;
	}
};

int main(){

	unique_ptr<Rectangle> P1(new Rectangle(10, 5));
	cout << P1->area() << endl; // This'll print 50

	// unique_ptr<Rectangle> P2(P1);
	unique_ptr<Rectangle> P2;
	P2 = move(P1);

	// This'll print 50
	cout << P2->area() << endl;

	// cout<<P1->area()<<endl;
	return 0;
}
 Output: 50
50
 2. shared_ptr Using shared ptr, multiple pointers can point to the same object at the same time, and it will keep a reference counter using the use count() method. C++ Code 
#include <iostream>
using namespace std;
#include <memory>

class Rectangle {
	int length;
	int breadth;

public:
	Rectangle(int l, int b)
	{
		length = l;
		breadth = b;
	}

	int area()
	{
		return length * breadth;
	}
};

int main()
{

	shared_ptr<Rectangle> P1(new Rectangle(10, 5));
	// This'll print 50
	cout << P1->area() << endl;

	shared_ptr<Rectangle> P2;
	P2 = P1;

	// This'll print 50
	cout << P2->area() << endl;

	// This'll now not give an error,
	cout << P1->area() << endl;

	// This'll also print 50 now
	// This'll print 2 as Reference Counter is 2
	cout << P1.use_count() << endl;
	return 0;
}
 Output: 50
50
50
2
 3. weak_ptr It is very similar to shared ptr, except that it does not keep a Reference Counter. A pointer will not have a stronghold on the object in this case. The reason for this is that if pointers are holding the object while requesting other objects, they may form a deadlock. Next TopicCurrency Converter in C++ ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/smart-pointer Smart Pointer - javatpoint ? SCROLL TO TOP Home C C++ C# Java PHP HTML CSS JavaScript jQuery XML JSON Ajax Node.js SQL Quiz Projects Interview Q Comment Forum Training C++ Tutorial C++ Tutorial C vs C++ C++ History C++ Features C++ Installation C++ Program C++ cout, cin, endl C++ Variable C++ Data types C++ Keywords C++ Operators C++ Identifiers C++ Expression C++ Control Statement C++ if-else C++ switch C++ For Loop C++ While Loop C++ Do-While Loop C++ Break Statement C++ Continue Statement C++ Goto Statement C++ Comments C++ Functions C++ Functions Call by value & reference C++ Recursion C++ Storage Classes C++ Arrays C++ Arrays C++ Array to Function Multidimensional Arrays C++ Pointers C++ Pointers sizeof() operator in C++ C++ Array of Pointers C++ Void Pointer C++ References Reference vs Pointer Function Pointer in C++ C++ Memory Management malloc() vs new in C++ free vs delete in C++ C++ Object Class C++ OOPs Concepts C++ Object Class C++ Constructor C++ Copy Constructor C++ Destructor C++ this Pointer C++ static C++ Structs C++ Enumeration C++ Friend Function C++ Math Functions C++ Inheritance C++ Inheritance C++ Aggregation C++ Polymorphism C++ Polymorphism C++ Overloading C++ Overriding C++ Virtual Function C++ Abstraction C++ Interfaces C++ Data Abstraction C++ Namespaces C++ Namespaces C++ Strings C++ Strings C++ Exceptions C++ Exception Handling C++ try/catch C++ User-Defined C++ Templates C++ Templates Signal Handling C++ Signal Handling C++ File & Stream C++ File & Stream C++ getline() C++ Misc C++ vs C# C++ int to string C++ vs Python Structure vs Class in C++ Virtual Destructor in C++ Constructor vs Destructor in C++ Bit manipulation C++ What is a reference variable Friend Function in C++ Snake Code in C++ Inline function in C++ Virtual function vs Pure virtual function in C++ How to Split strings in C++ Range-based for loop in C++ Type Conversion in C++ LCM of two numbers in C++ Convert string to integer in C++ C++ STL Tutorial C++ STL Components C++ Vector Initialize Vector in C++ C++ Deque C++ List C++ Set C++ Stack C++ Queue C++ Priority Queue C++ Map C++ Multimap C++ Map C++ Bitset C++ Algorithm C++ Iterators C++ Iterators C++ Bidirectional Iterator C++ Forward Iterator C++ Input Iterator C++ Output Iterator C++ Programs C++Programs Fibonacci Series Prime Number Palindrome Number Factorial Armstrong Number Sum of digits Reverse Number Swap Number Matrix Multiplication Decimal to Binary Number in Characters Alphabet Triangle Number Triangle Fibonacci Triangle Char array to string in C++ Calculator Program in C++ Program to convert infix to postfix expression in C++ using the Stack Data Structure C++ program to merge two unsorted arrays C++ coin change program C++ program to add two complex numbers using class C++ program to find the GCD of two numbers C++ program to find greatest of four numbers Delete Operator in C++ How to concatenate two strings in c++ Upcasting and Downcasting in C++ C++ Dijkstra Algorithm using the priority queue Constructor overloading in C++ Default arguments in C++ Dynamic binding in C++ Dynamic memory allocation in C++ Fast input and output in C++ Hierarchical inheritance in C++ Hybrid inheritance in C++ Multiple Inheritance in C++ C++ Bitwise XOR Operator Different Ways to Compare Strings in C++ Reverse an Array in C++ C++ date and time Copy elision in C++ Array of sets in C++ Smart pointers in C++ Types of polymorphism in C++ Implementing the sets without C++ STL containers Scope Resolution Operator in C++ Static Member Function in C++ Const keyword in C++ Memset in C++ Type Casting in C++ Binary Operator Overloading in C++ Binary Search in C++ Inheritance in C++ vs JAVA Static Keyword in C++ and JAVA Exception Handling in C++ and JAVA Foreach in C++ and JAVA C++ templates vs. Java generics Similarities and Differences in C++ and JAVA Default Virtual Behaviour in C++ and JAVA C++ hashing programme with chaining Largest subset whose all elements are Fibonacci numbers Opaque Pointer Pointers such as Dangling, Void, Null, and Wild When do we pass arguments by reference or pointer Find Member Function in Vector in C++ Smart Pointer Currency Converter in C++ Find max in Array Function C++ MCQ C++ MCQ C++ MCQ Part 2 Interview Question Interview Question next ? ? prev Smart Pointer Pointers are used to access resources outside of the programme, such as heap memory. As a result, pointers are used to access heap memory (if anything is created inside heap memory). We simply use a copy of any external resource when accessing it. We simply change it in the copied version if we make any changes. However, if we use a pointer to the resource, we can change the original resource. Issues with Normal Pointers Check out the code below. C++ Code 
#include <iostream>
using namespace std;

class Rectangle {
private:
	int length;
	int breadth;
};

void fun()
{
	// By taking a pointer p and
	// dynamically creating object
	// of class rectangle
	Rectangle* p = new Rectangle();
}

int main()
{
	// Infinite Loop
	while (1) {
		fun();
	}
}
 Function fun generates a pointer pointing to the Rectangle object. Rectangle is made up of two integers: length and breadth. Because p is a local variable, it will be destroyed when the function fun ends. However, because we forgot to use delete p; at the end of the function, the memory it consumed will not be deallocated. This means that the memory will not be available for use by other resources. However, we no longer require the variable, but rather the memory. Fun is called in an infinite loop in function main. That means it will continue to generate p. It will allocate more memory but will not free it because we did not deallocate it. The unused memory cannot be used again. This results in a memory leak. Because of this, the entire heap memory may become useless. Smart Pointer, a feature of C++11, provides a solution to this problem. Smart Pointers are being introduced. Unconsciously, not dealinglocating a pointer causes a memory leak, which may result in a programme crash. Garbage Collection Mechanisms are used in the languages Java and C# to intelligently deallocate unused memory so that it can be used again. The programmer does not have to be concerned about memory leaks. Smart Pointer is a mechanism developed by C++11. When the object is destroyed, the memory is also released. As a result, we don't need to delete it because Smart Pointer will handle it. A Smart Pointer is a pointer wrapper class that has operators like * and -> overloaded. The smart pointer class's objects resemble regular pointers. However, unlike Normal Pointers, it has the ability to deallocate and free destroyed object memory. Take a class that has a pointer, a destructor, and overloaded operators like * and ->. Because the destructor is automatically called when an object exits scope, the dynamically allocated memory would be deleted (or reference count can be decremented). Consider the SmartPtr class shown below. C++ Code 
#include <iostream>
using namespace std;

class SmartPtr {
	int* ptr; // Actual pointer
public:
	// for use of explicit keyword
	explicit SmartPtr(int* p = NULL) { ptr = p; }

	// Destructor
	~SmartPtr() { delete (ptr); }

	// Overloading dereferencing operator
	int& operator*() { return *ptr; }
};

int main()
{
	SmartPtr ptr(new int());
	*ptr = 20;
	cout << *ptr;

	// We don't need to call delete ptr: when the object
	// ptr goes out of scope, the destructor for it is automatically
	// called and destructor does delete ptr.

	return 0;
}
 Output: 20
 This only applies to int. So we'll need to make a Smart Pointer for each object? No, Template, there is a solution. As you can see in the code below, T can be of any type. Learn more about Template by clicking here. C++ Code 
#include <iostream>
using namespace std;

// A generic smart pointer class
template <class T>
class SmartPtr {
	T* ptr; // Actual pointer
public:
	// Constructor
	explicit SmartPtr(T* p = NULL) { ptr = p; }

	// Destructor
	~SmartPtr() { delete (ptr); }

	// Overloading dereferencing operator
	T& operator*() { return *ptr; }

	// Overloading arrow operator so that
	// members of T can be accessed
	// like a pointer (useful if T represents
	// a class or struct or union type)
	T* operator->() { return ptr; }
};

int main()
{
	SmartPtr<int> ptr(new int());
	*ptr = 20;
	cout << *ptr;
	return 0;
}
 Output: 20
 Note: Smart pointers can also be used to manage resources such as file handles or network sockets. Smart Pointer Types 1. unique ptr Only one pointer is stored in unique ptr. By removing the current object from the pointer, we can assign a different object. Take note of the code below. First, the unique_pointer is pointing to P1. However, we remove P1 and replace it with P2, so the pointer now points to P2. C++ Code 
#include <iostream>
using namespace std;
#include <memory>

class Rectangle {
	int length;
	int breadth;

public:
	Rectangle(int l, int b){
		length = l;
		breadth = b;
	}

	int area(){
		return length * breadth;
	}
};

int main(){

	unique_ptr<Rectangle> P1(new Rectangle(10, 5));
	cout << P1->area() << endl; // This'll print 50

	// unique_ptr<Rectangle> P2(P1);
	unique_ptr<Rectangle> P2;
	P2 = move(P1);

	// This'll print 50
	cout << P2->area() << endl;

	// cout<<P1->area()<<endl;
	return 0;
}
 Output: 50
50
 2. shared_ptr Using shared ptr, multiple pointers can point to the same object at the same time, and it will keep a reference counter using the use count() method. C++ Code 
#include <iostream>
using namespace std;
#include <memory>

class Rectangle {
	int length;
	int breadth;

public:
	Rectangle(int l, int b)
	{
		length = l;
		breadth = b;
	}

	int area()
	{
		return length * breadth;
	}
};

int main()
{

	shared_ptr<Rectangle> P1(new Rectangle(10, 5));
	// This'll print 50
	cout << P1->area() << endl;

	shared_ptr<Rectangle> P2;
	P2 = P1;

	// This'll print 50
	cout << P2->area() << endl;

	// This'll now not give an error,
	cout << P1->area() << endl;

	// This'll also print 50 now
	// This'll print 2 as Reference Counter is 2
	cout << P1.use_count() << endl;
	return 0;
}
 Output: 50
50
50
2
 3. weak_ptr It is very similar to shared ptr, except that it does not keep a Reference Counter. A pointer will not have a stronghold on the object in this case. The reason for this is that if pointers are holding the object while requesting other objects, they may form a deadlock. Next TopicCurrency Converter in C++ ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/smart-pointer Smart Pointer - javatpoint ? SCROLL TO TOP Home C C++ C# Java PHP HTML CSS JavaScript jQuery XML JSON Ajax Node.js SQL Quiz Projects Interview Q Comment Forum Training C++ Tutorial C++ Tutorial C vs C++ C++ History C++ Features C++ Installation C++ Program C++ cout, cin, endl C++ Variable C++ Data types C++ Keywords C++ Operators C++ Identifiers C++ Expression C++ Control Statement C++ if-else C++ switch C++ For Loop C++ While Loop C++ Do-While Loop C++ Break Statement C++ Continue Statement C++ Goto Statement C++ Comments C++ Functions C++ Functions Call by value & reference C++ Recursion C++ Storage Classes C++ Arrays C++ Arrays C++ Array to Function Multidimensional Arrays C++ Pointers C++ Pointers sizeof() operator in C++ C++ Array of Pointers C++ Void Pointer C++ References Reference vs Pointer Function Pointer in C++ C++ Memory Management malloc() vs new in C++ free vs delete in C++ C++ Object Class C++ OOPs Concepts C++ Object Class C++ Constructor C++ Copy Constructor C++ Destructor C++ this Pointer C++ static C++ Structs C++ Enumeration C++ Friend Function C++ Math Functions C++ Inheritance C++ Inheritance C++ Aggregation C++ Polymorphism C++ Polymorphism C++ Overloading C++ Overriding C++ Virtual Function C++ Abstraction C++ Interfaces C++ Data Abstraction C++ Namespaces C++ Namespaces C++ Strings C++ Strings C++ Exceptions C++ Exception Handling C++ try/catch C++ User-Defined C++ Templates C++ Templates Signal Handling C++ Signal Handling C++ File & Stream C++ File & Stream C++ getline() C++ Misc C++ vs C# C++ int to string C++ vs Python Structure vs Class in C++ Virtual Destructor in C++ Constructor vs Destructor in C++ Bit manipulation C++ What is a reference variable Friend Function in C++ Snake Code in C++ Inline function in C++ Virtual function vs Pure virtual function in C++ How to Split strings in C++ Range-based for loop in C++ Type Conversion in C++ LCM of two numbers in C++ Convert string to integer in C++ C++ STL Tutorial C++ STL Components C++ Vector Initialize Vector in C++ C++ Deque C++ List C++ Set C++ Stack C++ Queue C++ Priority Queue C++ Map C++ Multimap C++ Map C++ Bitset C++ Algorithm C++ Iterators C++ Iterators C++ Bidirectional Iterator C++ Forward Iterator C++ Input Iterator C++ Output Iterator C++ Programs C++Programs Fibonacci Series Prime Number Palindrome Number Factorial Armstrong Number Sum of digits Reverse Number Swap Number Matrix Multiplication Decimal to Binary Number in Characters Alphabet Triangle Number Triangle Fibonacci Triangle Char array to string in C++ Calculator Program in C++ Program to convert infix to postfix expression in C++ using the Stack Data Structure C++ program to merge two unsorted arrays C++ coin change program C++ program to add two complex numbers using class C++ program to find the GCD of two numbers C++ program to find greatest of four numbers Delete Operator in C++ How to concatenate two strings in c++ Upcasting and Downcasting in C++ C++ Dijkstra Algorithm using the priority queue Constructor overloading in C++ Default arguments in C++ Dynamic binding in C++ Dynamic memory allocation in C++ Fast input and output in C++ Hierarchical inheritance in C++ Hybrid inheritance in C++ Multiple Inheritance in C++ C++ Bitwise XOR Operator Different Ways to Compare Strings in C++ Reverse an Array in C++ C++ date and time Copy elision in C++ Array of sets in C++ Smart pointers in C++ Types of polymorphism in C++ Implementing the sets without C++ STL containers Scope Resolution Operator in C++ Static Member Function in C++ Const keyword in C++ Memset in C++ Type Casting in C++ Binary Operator Overloading in C++ Binary Search in C++ Inheritance in C++ vs JAVA Static Keyword in C++ and JAVA Exception Handling in C++ and JAVA Foreach in C++ and JAVA C++ templates vs. Java generics Similarities and Differences in C++ and JAVA Default Virtual Behaviour in C++ and JAVA C++ hashing programme with chaining Largest subset whose all elements are Fibonacci numbers Opaque Pointer Pointers such as Dangling, Void, Null, and Wild When do we pass arguments by reference or pointer Find Member Function in Vector in C++ Smart Pointer Currency Converter in C++ Find max in Array Function C++ MCQ C++ MCQ C++ MCQ Part 2 Interview Question Interview Question next ? ? prev Smart Pointer Pointers are used to access resources outside of the programme, such as heap memory. As a result, pointers are used to access heap memory (if anything is created inside heap memory). We simply use a copy of any external resource when accessing it. We simply change it in the copied version if we make any changes. However, if we use a pointer to the resource, we can change the original resource. Issues with Normal Pointers Check out the code below. C++ Code 
#include <iostream>
using namespace std;

class Rectangle {
private:
	int length;
	int breadth;
};

void fun()
{
	// By taking a pointer p and
	// dynamically creating object
	// of class rectangle
	Rectangle* p = new Rectangle();
}

int main()
{
	// Infinite Loop
	while (1) {
		fun();
	}
}
 Function fun generates a pointer pointing to the Rectangle object. Rectangle is made up of two integers: length and breadth. Because p is a local variable, it will be destroyed when the function fun ends. However, because we forgot to use delete p; at the end of the function, the memory it consumed will not be deallocated. This means that the memory will not be available for use by other resources. However, we no longer require the variable, but rather the memory. Fun is called in an infinite loop in function main. That means it will continue to generate p. It will allocate more memory but will not free it because we did not deallocate it. The unused memory cannot be used again. This results in a memory leak. Because of this, the entire heap memory may become useless. Smart Pointer, a feature of C++11, provides a solution to this problem. Smart Pointers are being introduced. Unconsciously, not dealinglocating a pointer causes a memory leak, which may result in a programme crash. Garbage Collection Mechanisms are used in the languages Java and C# to intelligently deallocate unused memory so that it can be used again. The programmer does not have to be concerned about memory leaks. Smart Pointer is a mechanism developed by C++11. When the object is destroyed, the memory is also released. As a result, we don't need to delete it because Smart Pointer will handle it. A Smart Pointer is a pointer wrapper class that has operators like * and -> overloaded. The smart pointer class's objects resemble regular pointers. However, unlike Normal Pointers, it has the ability to deallocate and free destroyed object memory. Take a class that has a pointer, a destructor, and overloaded operators like * and ->. Because the destructor is automatically called when an object exits scope, the dynamically allocated memory would be deleted (or reference count can be decremented). Consider the SmartPtr class shown below. C++ Code 
#include <iostream>
using namespace std;

class SmartPtr {
	int* ptr; // Actual pointer
public:
	// for use of explicit keyword
	explicit SmartPtr(int* p = NULL) { ptr = p; }

	// Destructor
	~SmartPtr() { delete (ptr); }

	// Overloading dereferencing operator
	int& operator*() { return *ptr; }
};

int main()
{
	SmartPtr ptr(new int());
	*ptr = 20;
	cout << *ptr;

	// We don't need to call delete ptr: when the object
	// ptr goes out of scope, the destructor for it is automatically
	// called and destructor does delete ptr.

	return 0;
}
 Output: 20
 This only applies to int. So we'll need to make a Smart Pointer for each object? No, Template, there is a solution. As you can see in the code below, T can be of any type. Learn more about Template by clicking here. C++ Code 
#include <iostream>
using namespace std;

// A generic smart pointer class
template <class T>
class SmartPtr {
	T* ptr; // Actual pointer
public:
	// Constructor
	explicit SmartPtr(T* p = NULL) { ptr = p; }

	// Destructor
	~SmartPtr() { delete (ptr); }

	// Overloading dereferencing operator
	T& operator*() { return *ptr; }

	// Overloading arrow operator so that
	// members of T can be accessed
	// like a pointer (useful if T represents
	// a class or struct or union type)
	T* operator->() { return ptr; }
};

int main()
{
	SmartPtr<int> ptr(new int());
	*ptr = 20;
	cout << *ptr;
	return 0;
}
 Output: 20
 Note: Smart pointers can also be used to manage resources such as file handles or network sockets. Smart Pointer Types 1. unique ptr Only one pointer is stored in unique ptr. By removing the current object from the pointer, we can assign a different object. Take note of the code below. First, the unique_pointer is pointing to P1. However, we remove P1 and replace it with P2, so the pointer now points to P2. C++ Code 
#include <iostream>
using namespace std;
#include <memory>

class Rectangle {
	int length;
	int breadth;

public:
	Rectangle(int l, int b){
		length = l;
		breadth = b;
	}

	int area(){
		return length * breadth;
	}
};

int main(){

	unique_ptr<Rectangle> P1(new Rectangle(10, 5));
	cout << P1->area() << endl; // This'll print 50

	// unique_ptr<Rectangle> P2(P1);
	unique_ptr<Rectangle> P2;
	P2 = move(P1);

	// This'll print 50
	cout << P2->area() << endl;

	// cout<<P1->area()<<endl;
	return 0;
}
 Output: 50
50
 2. shared_ptr Using shared ptr, multiple pointers can point to the same object at the same time, and it will keep a reference counter using the use count() method. C++ Code 
#include <iostream>
using namespace std;
#include <memory>

class Rectangle {
	int length;
	int breadth;

public:
	Rectangle(int l, int b)
	{
		length = l;
		breadth = b;
	}

	int area()
	{
		return length * breadth;
	}
};

int main()
{

	shared_ptr<Rectangle> P1(new Rectangle(10, 5));
	// This'll print 50
	cout << P1->area() << endl;

	shared_ptr<Rectangle> P2;
	P2 = P1;

	// This'll print 50
	cout << P2->area() << endl;

	// This'll now not give an error,
	cout << P1->area() << endl;

	// This'll also print 50 now
	// This'll print 2 as Reference Counter is 2
	cout << P1.use_count() << endl;
	return 0;
}
 Output: 50
50
50
2
 3. weak_ptr It is very similar to shared ptr, except that it does not keep a Reference Counter. A pointer will not have a stronghold on the object in this case. The reason for this is that if pointers are holding the object while requesting other objects, they may form a deadlock. Next TopicCurrency Converter in C++ ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/smart-pointer Smart Pointer - javatpoint ? SCROLL TO TOP Home C C++ C# Java PHP HTML CSS JavaScript jQuery XML JSON Ajax Node.js SQL Quiz Projects Interview Q Comment Forum Training C++ Tutorial C++ Tutorial C vs C++ C++ History C++ Features C++ Installation C++ Program C++ cout, cin, endl C++ Variable C++ Data types C++ Keywords C++ Operators C++ Identifiers C++ Expression C++ Control Statement C++ if-else C++ switch C++ For Loop C++ While Loop C++ Do-While Loop C++ Break Statement C++ Continue Statement C++ Goto Statement C++ Comments C++ Functions C++ Functions Call by value & reference C++ Recursion C++ Storage Classes C++ Arrays C++ Arrays C++ Array to Function Multidimensional Arrays C++ Pointers C++ Pointers sizeof() operator in C++ C++ Array of Pointers C++ Void Pointer C++ References Reference vs Pointer Function Pointer in C++ C++ Memory Management malloc() vs new in C++ free vs delete in C++ C++ Object Class C++ OOPs Concepts C++ Object Class C++ Constructor C++ Copy Constructor C++ Destructor C++ this Pointer C++ static C++ Structs C++ Enumeration C++ Friend Function C++ Math Functions C++ Inheritance C++ Inheritance C++ Aggregation C++ Polymorphism C++ Polymorphism C++ Overloading C++ Overriding C++ Virtual Function C++ Abstraction C++ Interfaces C++ Data Abstraction C++ Namespaces C++ Namespaces C++ Strings C++ Strings C++ Exceptions C++ Exception Handling C++ try/catch C++ User-Defined C++ Templates C++ Templates Signal Handling C++ Signal Handling C++ File & Stream C++ File & Stream C++ getline() C++ Misc C++ vs C# C++ int to string C++ vs Python Structure vs Class in C++ Virtual Destructor in C++ Constructor vs Destructor in C++ Bit manipulation C++ What is a reference variable Friend Function in C++ Snake Code in C++ Inline function in C++ Virtual function vs Pure virtual function in C++ How to Split strings in C++ Range-based for loop in C++ Type Conversion in C++ LCM of two numbers in C++ Convert string to integer in C++ C++ STL Tutorial C++ STL Components C++ Vector Initialize Vector in C++ C++ Deque C++ List C++ Set C++ Stack C++ Queue C++ Priority Queue C++ Map C++ Multimap C++ Map C++ Bitset C++ Algorithm C++ Iterators C++ Iterators C++ Bidirectional Iterator C++ Forward Iterator C++ Input Iterator C++ Output Iterator C++ Programs C++Programs Fibonacci Series Prime Number Palindrome Number Factorial Armstrong Number Sum of digits Reverse Number Swap Number Matrix Multiplication Decimal to Binary Number in Characters Alphabet Triangle Number Triangle Fibonacci Triangle Char array to string in C++ Calculator Program in C++ Program to convert infix to postfix expression in C++ using the Stack Data Structure C++ program to merge two unsorted arrays C++ coin change program C++ program to add two complex numbers using class C++ program to find the GCD of two numbers C++ program to find greatest of four numbers Delete Operator in C++ How to concatenate two strings in c++ Upcasting and Downcasting in C++ C++ Dijkstra Algorithm using the priority queue Constructor overloading in C++ Default arguments in C++ Dynamic binding in C++ Dynamic memory allocation in C++ Fast input and output in C++ Hierarchical inheritance in C++ Hybrid inheritance in C++ Multiple Inheritance in C++ C++ Bitwise XOR Operator Different Ways to Compare Strings in C++ Reverse an Array in C++ C++ date and time Copy elision in C++ Array of sets in C++ Smart pointers in C++ Types of polymorphism in C++ Implementing the sets without C++ STL containers Scope Resolution Operator in C++ Static Member Function in C++ Const keyword in C++ Memset in C++ Type Casting in C++ Binary Operator Overloading in C++ Binary Search in C++ Inheritance in C++ vs JAVA Static Keyword in C++ and JAVA Exception Handling in C++ and JAVA Foreach in C++ and JAVA C++ templates vs. Java generics Similarities and Differences in C++ and JAVA Default Virtual Behaviour in C++ and JAVA C++ hashing programme with chaining Largest subset whose all elements are Fibonacci numbers Opaque Pointer Pointers such as Dangling, Void, Null, and Wild When do we pass arguments by reference or pointer Find Member Function in Vector in C++ Smart Pointer Currency Converter in C++ Find max in Array Function C++ MCQ C++ MCQ C++ MCQ Part 2 Interview Question Interview Question next ? ? prev Smart Pointer Pointers are used to access resources outside of the programme, such as heap memory. As a result, pointers are used to access heap memory (if anything is created inside heap memory). We simply use a copy of any external resource when accessing it. We simply change it in the copied version if we make any changes. However, if we use a pointer to the resource, we can change the original resource. Issues with Normal Pointers Check out the code below. C++ Code 
#include <iostream>
using namespace std;

class Rectangle {
private:
	int length;
	int breadth;
};

void fun()
{
	// By taking a pointer p and
	// dynamically creating object
	// of class rectangle
	Rectangle* p = new Rectangle();
}

int main()
{
	// Infinite Loop
	while (1) {
		fun();
	}
}
 Function fun generates a pointer pointing to the Rectangle object. Rectangle is made up of two integers: length and breadth. Because p is a local variable, it will be destroyed when the function fun ends. However, because we forgot to use delete p; at the end of the function, the memory it consumed will not be deallocated. This means that the memory will not be available for use by other resources. However, we no longer require the variable, but rather the memory. Fun is called in an infinite loop in function main. That means it will continue to generate p. It will allocate more memory but will not free it because we did not deallocate it. The unused memory cannot be used again. This results in a memory leak. Because of this, the entire heap memory may become useless. Smart Pointer, a feature of C++11, provides a solution to this problem. Smart Pointers are being introduced. Unconsciously, not dealinglocating a pointer causes a memory leak, which may result in a programme crash. Garbage Collection Mechanisms are used in the languages Java and C# to intelligently deallocate unused memory so that it can be used again. The programmer does not have to be concerned about memory leaks. Smart Pointer is a mechanism developed by C++11. When the object is destroyed, the memory is also released. As a result, we don't need to delete it because Smart Pointer will handle it. A Smart Pointer is a pointer wrapper class that has operators like * and -> overloaded. The smart pointer class's objects resemble regular pointers. However, unlike Normal Pointers, it has the ability to deallocate and free destroyed object memory. Take a class that has a pointer, a destructor, and overloaded operators like * and ->. Because the destructor is automatically called when an object exits scope, the dynamically allocated memory would be deleted (or reference count can be decremented). Consider the SmartPtr class shown below. C++ Code 
#include <iostream>
using namespace std;

class SmartPtr {
	int* ptr; // Actual pointer
public:
	// for use of explicit keyword
	explicit SmartPtr(int* p = NULL) { ptr = p; }

	// Destructor
	~SmartPtr() { delete (ptr); }

	// Overloading dereferencing operator
	int& operator*() { return *ptr; }
};

int main()
{
	SmartPtr ptr(new int());
	*ptr = 20;
	cout << *ptr;

	// We don't need to call delete ptr: when the object
	// ptr goes out of scope, the destructor for it is automatically
	// called and destructor does delete ptr.

	return 0;
}
 Output: 20
 This only applies to int. So we'll need to make a Smart Pointer for each object? No, Template, there is a solution. As you can see in the code below, T can be of any type. Learn more about Template by clicking here. C++ Code 
#include <iostream>
using namespace std;

// A generic smart pointer class
template <class T>
class SmartPtr {
	T* ptr; // Actual pointer
public:
	// Constructor
	explicit SmartPtr(T* p = NULL) { ptr = p; }

	// Destructor
	~SmartPtr() { delete (ptr); }

	// Overloading dereferencing operator
	T& operator*() { return *ptr; }

	// Overloading arrow operator so that
	// members of T can be accessed
	// like a pointer (useful if T represents
	// a class or struct or union type)
	T* operator->() { return ptr; }
};

int main()
{
	SmartPtr<int> ptr(new int());
	*ptr = 20;
	cout << *ptr;
	return 0;
}
 Output: 20
 Note: Smart pointers can also be used to manage resources such as file handles or network sockets. Smart Pointer Types 1. unique ptr Only one pointer is stored in unique ptr. By removing the current object from the pointer, we can assign a different object. Take note of the code below. First, the unique_pointer is pointing to P1. However, we remove P1 and replace it with P2, so the pointer now points to P2. C++ Code 
#include <iostream>
using namespace std;
#include <memory>

class Rectangle {
	int length;
	int breadth;

public:
	Rectangle(int l, int b){
		length = l;
		breadth = b;
	}

	int area(){
		return length * breadth;
	}
};

int main(){

	unique_ptr<Rectangle> P1(new Rectangle(10, 5));
	cout << P1->area() << endl; // This'll print 50

	// unique_ptr<Rectangle> P2(P1);
	unique_ptr<Rectangle> P2;
	P2 = move(P1);

	// This'll print 50
	cout << P2->area() << endl;

	// cout<<P1->area()<<endl;
	return 0;
}
 Output: 50
50
 2. shared_ptr Using shared ptr, multiple pointers can point to the same object at the same time, and it will keep a reference counter using the use count() method. C++ Code 
#include <iostream>
using namespace std;
#include <memory>

class Rectangle {
	int length;
	int breadth;

public:
	Rectangle(int l, int b)
	{
		length = l;
		breadth = b;
	}

	int area()
	{
		return length * breadth;
	}
};

int main()
{

	shared_ptr<Rectangle> P1(new Rectangle(10, 5));
	// This'll print 50
	cout << P1->area() << endl;

	shared_ptr<Rectangle> P2;
	P2 = P1;

	// This'll print 50
	cout << P2->area() << endl;

	// This'll now not give an error,
	cout << P1->area() << endl;

	// This'll also print 50 now
	// This'll print 2 as Reference Counter is 2
	cout << P1.use_count() << endl;
	return 0;
}
 Output: 50
50
50
2
 3. weak_ptr It is very similar to shared ptr, except that it does not keep a Reference Counter. A pointer will not have a stronghold on the object in this case. The reason for this is that if pointers are holding the object while requesting other objects, they may form a deadlock. Next TopicCurrency Converter in C++ ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/smart-pointer Smart Pointer - javatpoint ? SCROLL TO TOP Home C C++ C# Java PHP HTML CSS JavaScript jQuery XML JSON Ajax Node.js SQL Quiz Projects Interview Q Comment Forum Training C++ Tutorial C++ Tutorial C vs C++ C++ History C++ Features C++ Installation C++ Program C++ cout, cin, endl C++ Variable C++ Data types C++ Keywords C++ Operators C++ Identifiers C++ Expression C++ Control Statement C++ if-else C++ switch C++ For Loop C++ While Loop C++ Do-While Loop C++ Break Statement C++ Continue Statement C++ Goto Statement C++ Comments C++ Functions C++ Functions Call by value & reference C++ Recursion C++ Storage Classes C++ Arrays C++ Arrays C++ Array to Function Multidimensional Arrays C++ Pointers C++ Pointers sizeof() operator in C++ C++ Array of Pointers C++ Void Pointer C++ References Reference vs Pointer Function Pointer in C++ C++ Memory Management malloc() vs new in C++ free vs delete in C++ C++ Object Class C++ OOPs Concepts C++ Object Class C++ Constructor C++ Copy Constructor C++ Destructor C++ this Pointer C++ static C++ Structs C++ Enumeration C++ Friend Function C++ Math Functions C++ Inheritance C++ Inheritance C++ Aggregation C++ Polymorphism C++ Polymorphism C++ Overloading C++ Overriding C++ Virtual Function C++ Abstraction C++ Interfaces C++ Data Abstraction C++ Namespaces C++ Namespaces C++ Strings C++ Strings C++ Exceptions C++ Exception Handling C++ try/catch C++ User-Defined C++ Templates C++ Templates Signal Handling C++ Signal Handling C++ File & Stream C++ File & Stream C++ getline() C++ Misc C++ vs C# C++ int to string C++ vs Python Structure vs Class in C++ Virtual Destructor in C++ Constructor vs Destructor in C++ Bit manipulation C++ What is a reference variable Friend Function in C++ Snake Code in C++ Inline function in C++ Virtual function vs Pure virtual function in C++ How to Split strings in C++ Range-based for loop in C++ Type Conversion in C++ LCM of two numbers in C++ Convert string to integer in C++ C++ STL Tutorial C++ STL Components C++ Vector Initialize Vector in C++ C++ Deque C++ List C++ Set C++ Stack C++ Queue C++ Priority Queue C++ Map C++ Multimap C++ Map C++ Bitset C++ Algorithm C++ Iterators C++ Iterators C++ Bidirectional Iterator C++ Forward Iterator C++ Input Iterator C++ Output Iterator C++ Programs C++Programs Fibonacci Series Prime Number Palindrome Number Factorial Armstrong Number Sum of digits Reverse Number Swap Number Matrix Multiplication Decimal to Binary Number in Characters Alphabet Triangle Number Triangle Fibonacci Triangle Char array to string in C++ Calculator Program in C++ Program to convert infix to postfix expression in C++ using the Stack Data Structure C++ program to merge two unsorted arrays C++ coin change program C++ program to add two complex numbers using class C++ program to find the GCD of two numbers C++ program to find greatest of four numbers Delete Operator in C++ How to concatenate two strings in c++ Upcasting and Downcasting in C++ C++ Dijkstra Algorithm using the priority queue Constructor overloading in C++ Default arguments in C++ Dynamic binding in C++ Dynamic memory allocation in C++ Fast input and output in C++ Hierarchical inheritance in C++ Hybrid inheritance in C++ Multiple Inheritance in C++ C++ Bitwise XOR Operator Different Ways to Compare Strings in C++ Reverse an Array in C++ C++ date and time Copy elision in C++ Array of sets in C++ Smart pointers in C++ Types of polymorphism in C++ Implementing the sets without C++ STL containers Scope Resolution Operator in C++ Static Member Function in C++ Const keyword in C++ Memset in C++ Type Casting in C++ Binary Operator Overloading in C++ Binary Search in C++ Inheritance in C++ vs JAVA Static Keyword in C++ and JAVA Exception Handling in C++ and JAVA Foreach in C++ and JAVA C++ templates vs. Java generics Similarities and Differences in C++ and JAVA Default Virtual Behaviour in C++ and JAVA C++ hashing programme with chaining Largest subset whose all elements are Fibonacci numbers Opaque Pointer Pointers such as Dangling, Void, Null, and Wild When do we pass arguments by reference or pointer Find Member Function in Vector in C++ Smart Pointer Currency Converter in C++ Find max in Array Function C++ MCQ C++ MCQ C++ MCQ Part 2 Interview Question Interview Question next ? ? prev Smart Pointer Pointers are used to access resources outside of the programme, such as heap memory. As a result, pointers are used to access heap memory (if anything is created inside heap memory). We simply use a copy of any external resource when accessing it. We simply change it in the copied version if we make any changes. However, if we use a pointer to the resource, we can change the original resource. Issues with Normal Pointers Check out the code below. C++ Code 
#include <iostream>
using namespace std;

class Rectangle {
private:
	int length;
	int breadth;
};

void fun()
{
	// By taking a pointer p and
	// dynamically creating object
	// of class rectangle
	Rectangle* p = new Rectangle();
}

int main()
{
	// Infinite Loop
	while (1) {
		fun();
	}
}
 Function fun generates a pointer pointing to the Rectangle object. Rectangle is made up of two integers: length and breadth. Because p is a local variable, it will be destroyed when the function fun ends. However, because we forgot to use delete p; at the end of the function, the memory it consumed will not be deallocated. This means that the memory will not be available for use by other resources. However, we no longer require the variable, but rather the memory. Fun is called in an infinite loop in function main. That means it will continue to generate p. It will allocate more memory but will not free it because we did not deallocate it. The unused memory cannot be used again. This results in a memory leak. Because of this, the entire heap memory may become useless. Smart Pointer, a feature of C++11, provides a solution to this problem. Smart Pointers are being introduced. Unconsciously, not dealinglocating a pointer causes a memory leak, which may result in a programme crash. Garbage Collection Mechanisms are used in the languages Java and C# to intelligently deallocate unused memory so that it can be used again. The programmer does not have to be concerned about memory leaks. Smart Pointer is a mechanism developed by C++11. When the object is destroyed, the memory is also released. As a result, we don't need to delete it because Smart Pointer will handle it. A Smart Pointer is a pointer wrapper class that has operators like * and -> overloaded. The smart pointer class's objects resemble regular pointers. However, unlike Normal Pointers, it has the ability to deallocate and free destroyed object memory. Take a class that has a pointer, a destructor, and overloaded operators like * and ->. Because the destructor is automatically called when an object exits scope, the dynamically allocated memory would be deleted (or reference count can be decremented). Consider the SmartPtr class shown below. C++ Code 
#include <iostream>
using namespace std;

class SmartPtr {
	int* ptr; // Actual pointer
public:
	// for use of explicit keyword
	explicit SmartPtr(int* p = NULL) { ptr = p; }

	// Destructor
	~SmartPtr() { delete (ptr); }

	// Overloading dereferencing operator
	int& operator*() { return *ptr; }
};

int main()
{
	SmartPtr ptr(new int());
	*ptr = 20;
	cout << *ptr;

	// We don't need to call delete ptr: when the object
	// ptr goes out of scope, the destructor for it is automatically
	// called and destructor does delete ptr.

	return 0;
}
 Output: 20
 This only applies to int. So we'll need to make a Smart Pointer for each object? No, Template, there is a solution. As you can see in the code below, T can be of any type. Learn more about Template by clicking here. C++ Code 
#include <iostream>
using namespace std;

// A generic smart pointer class
template <class T>
class SmartPtr {
	T* ptr; // Actual pointer
public:
	// Constructor
	explicit SmartPtr(T* p = NULL) { ptr = p; }

	// Destructor
	~SmartPtr() { delete (ptr); }

	// Overloading dereferencing operator
	T& operator*() { return *ptr; }

	// Overloading arrow operator so that
	// members of T can be accessed
	// like a pointer (useful if T represents
	// a class or struct or union type)
	T* operator->() { return ptr; }
};

int main()
{
	SmartPtr<int> ptr(new int());
	*ptr = 20;
	cout << *ptr;
	return 0;
}
 Output: 20
 Note: Smart pointers can also be used to manage resources such as file handles or network sockets. Smart Pointer Types 1. unique ptr Only one pointer is stored in unique ptr. By removing the current object from the pointer, we can assign a different object. Take note of the code below. First, the unique_pointer is pointing to P1. However, we remove P1 and replace it with P2, so the pointer now points to P2. C++ Code 
#include <iostream>
using namespace std;
#include <memory>

class Rectangle {
	int length;
	int breadth;

public:
	Rectangle(int l, int b){
		length = l;
		breadth = b;
	}

	int area(){
		return length * breadth;
	}
};

int main(){

	unique_ptr<Rectangle> P1(new Rectangle(10, 5));
	cout << P1->area() << endl; // This'll print 50

	// unique_ptr<Rectangle> P2(P1);
	unique_ptr<Rectangle> P2;
	P2 = move(P1);

	// This'll print 50
	cout << P2->area() << endl;

	// cout<<P1->area()<<endl;
	return 0;
}
 Output: 50
50
 2. shared_ptr Using shared ptr, multiple pointers can point to the same object at the same time, and it will keep a reference counter using the use count() method. C++ Code 
#include <iostream>
using namespace std;
#include <memory>

class Rectangle {
	int length;
	int breadth;

public:
	Rectangle(int l, int b)
	{
		length = l;
		breadth = b;
	}

	int area()
	{
		return length * breadth;
	}
};

int main()
{

	shared_ptr<Rectangle> P1(new Rectangle(10, 5));
	// This'll print 50
	cout << P1->area() << endl;

	shared_ptr<Rectangle> P2;
	P2 = P1;

	// This'll print 50
	cout << P2->area() << endl;

	// This'll now not give an error,
	cout << P1->area() << endl;

	// This'll also print 50 now
	// This'll print 2 as Reference Counter is 2
	cout << P1.use_count() << endl;
	return 0;
}
 Output: 50
50
50
2
 3. weak_ptr It is very similar to shared ptr, except that it does not keep a Reference Counter. A pointer will not have a stronghold on the object in this case. The reason for this is that if pointers are holding the object while requesting other objects, they may form a deadlock. Next TopicCurrency Converter in C++ ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.https://www.javatpoint.com/smart-pointer Smart Pointer - javatpoint ? SCROLL TO TOP Home C C++ C# Java PHP HTML CSS JavaScript jQuery XML JSON Ajax Node.js SQL Quiz Projects Interview Q Comment Forum Training C++ Tutorial C++ Tutorial C vs C++ C++ History C++ Features C++ Installation C++ Program C++ cout, cin, endl C++ Variable C++ Data types C++ Keywords C++ Operators C++ Identifiers C++ Expression C++ Control Statement C++ if-else C++ switch C++ For Loop C++ While Loop C++ Do-While Loop C++ Break Statement C++ Continue Statement C++ Goto Statement C++ Comments C++ Functions C++ Functions Call by value & reference C++ Recursion C++ Storage Classes C++ Arrays C++ Arrays C++ Array to Function Multidimensional Arrays C++ Pointers C++ Pointers sizeof() operator in C++ C++ Array of Pointers C++ Void Pointer C++ References Reference vs Pointer Function Pointer in C++ C++ Memory Management malloc() vs new in C++ free vs delete in C++ C++ Object Class C++ OOPs Concepts C++ Object Class C++ Constructor C++ Copy Constructor C++ Destructor C++ this Pointer C++ static C++ Structs C++ Enumeration C++ Friend Function C++ Math Functions C++ Inheritance C++ Inheritance C++ Aggregation C++ Polymorphism C++ Polymorphism C++ Overloading C++ Overriding C++ Virtual Function C++ Abstraction C++ Interfaces C++ Data Abstraction C++ Namespaces C++ Namespaces C++ Strings C++ Strings C++ Exceptions C++ Exception Handling C++ try/catch C++ User-Defined C++ Templates C++ Templates Signal Handling C++ Signal Handling C++ File & Stream C++ File & Stream C++ getline() C++ Misc C++ vs C# C++ int to string C++ vs Python Structure vs Class in C++ Virtual Destructor in C++ Constructor vs Destructor in C++ Bit manipulation C++ What is a reference variable Friend Function in C++ Snake Code in C++ Inline function in C++ Virtual function vs Pure virtual function in C++ How to Split strings in C++ Range-based for loop in C++ Type Conversion in C++ LCM of two numbers in C++ Convert string to integer in C++ C++ STL Tutorial C++ STL Components C++ Vector Initialize Vector in C++ C++ Deque C++ List C++ Set C++ Stack C++ Queue C++ Priority Queue C++ Map C++ Multimap C++ Map C++ Bitset C++ Algorithm C++ Iterators C++ Iterators C++ Bidirectional Iterator C++ Forward Iterator C++ Input Iterator C++ Output Iterator C++ Programs C++Programs Fibonacci Series Prime Number Palindrome Number Factorial Armstrong Number Sum of digits Reverse Number Swap Number Matrix Multiplication Decimal to Binary Number in Characters Alphabet Triangle Number Triangle Fibonacci Triangle Char array to string in C++ Calculator Program in C++ Program to convert infix to postfix expression in C++ using the Stack Data Structure C++ program to merge two unsorted arrays C++ coin change program C++ program to add two complex numbers using class C++ program to find the GCD of two numbers C++ program to find greatest of four numbers Delete Operator in C++ How to concatenate two strings in c++ Upcasting and Downcasting in C++ C++ Dijkstra Algorithm using the priority queue Constructor overloading in C++ Default arguments in C++ Dynamic binding in C++ Dynamic memory allocation in C++ Fast input and output in C++ Hierarchical inheritance in C++ Hybrid inheritance in C++ Multiple Inheritance in C++ C++ Bitwise XOR Operator Different Ways to Compare Strings in C++ Reverse an Array in C++ C++ date and time Copy elision in C++ Array of sets in C++ Smart pointers in C++ Types of polymorphism in C++ Implementing the sets without C++ STL containers Scope Resolution Operator in C++ Static Member Function in C++ Const keyword in C++ Memset in C++ Type Casting in C++ Binary Operator Overloading in C++ Binary Search in C++ Inheritance in C++ vs JAVA Static Keyword in C++ and JAVA Exception Handling in C++ and JAVA Foreach in C++ and JAVA C++ templates vs. Java generics Similarities and Differences in C++ and JAVA Default Virtual Behaviour in C++ and JAVA C++ hashing programme with chaining Largest subset whose all elements are Fibonacci numbers Opaque Pointer Pointers such as Dangling, Void, Null, and Wild When do we pass arguments by reference or pointer Find Member Function in Vector in C++ Smart Pointer Currency Converter in C++ Find max in Array Function C++ MCQ C++ MCQ C++ MCQ Part 2 Interview Question Interview Question next ? ? prev Smart Pointer Pointers are used to access resources outside of the programme, such as heap memory. As a result, pointers are used to access heap memory (if anything is created inside heap memory). We simply use a copy of any external resource when accessing it. We simply change it in the copied version if we make any changes. However, if we use a pointer to the resource, we can change the original resource. Issues with Normal Pointers Check out the code below. C++ Code 
#include <iostream>
using namespace std;

class Rectangle {
private:
	int length;
	int breadth;
};

void fun()
{
	// By taking a pointer p and
	// dynamically creating object
	// of class rectangle
	Rectangle* p = new Rectangle();
}

int main()
{
	// Infinite Loop
	while (1) {
		fun();
	}
}
 Function fun generates a pointer pointing to the Rectangle object. Rectangle is made up of two integers: length and breadth. Because p is a local variable, it will be destroyed when the function fun ends. However, because we forgot to use delete p; at the end of the function, the memory it consumed will not be deallocated. This means that the memory will not be available for use by other resources. However, we no longer require the variable, but rather the memory. Fun is called in an infinite loop in function main. That means it will continue to generate p. It will allocate more memory but will not free it because we did not deallocate it. The unused memory cannot be used again. This results in a memory leak. Because of this, the entire heap memory may become useless. Smart Pointer, a feature of C++11, provides a solution to this problem. Smart Pointers are being introduced. Unconsciously, not dealinglocating a pointer causes a memory leak, which may result in a programme crash. Garbage Collection Mechanisms are used in the languages Java and C# to intelligently deallocate unused memory so that it can be used again. The programmer does not have to be concerned about memory leaks. Smart Pointer is a mechanism developed by C++11. When the object is destroyed, the memory is also released. As a result, we don't need to delete it because Smart Pointer will handle it. A Smart Pointer is a pointer wrapper class that has operators like * and -> overloaded. The smart pointer class's objects resemble regular pointers. However, unlike Normal Pointers, it has the ability to deallocate and free destroyed object memory. Take a class that has a pointer, a destructor, and overloaded operators like * and ->. Because the destructor is automatically called when an object exits scope, the dynamically allocated memory would be deleted (or reference count can be decremented). Consider the SmartPtr class shown below. C++ Code 
#include <iostream>
using namespace std;

class SmartPtr {
	int* ptr; // Actual pointer
public:
	// for use of explicit keyword
	explicit SmartPtr(int* p = NULL) { ptr = p; }

	// Destructor
	~SmartPtr() { delete (ptr); }

	// Overloading dereferencing operator
	int& operator*() { return *ptr; }
};

int main()
{
	SmartPtr ptr(new int());
	*ptr = 20;
	cout << *ptr;

	// We don't need to call delete ptr: when the object
	// ptr goes out of scope, the destructor for it is automatically
	// called and destructor does delete ptr.

	return 0;
}
 Output: 20
 This only applies to int. So we'll need to make a Smart Pointer for each object? No, Template, there is a solution. As you can see in the code below, T can be of any type. Learn more about Template by clicking here. C++ Code 
#include <iostream>
using namespace std;

// A generic smart pointer class
template <class T>
class SmartPtr {
	T* ptr; // Actual pointer
public:
	// Constructor
	explicit SmartPtr(T* p = NULL) { ptr = p; }

	// Destructor
	~SmartPtr() { delete (ptr); }

	// Overloading dereferencing operator
	T& operator*() { return *ptr; }

	// Overloading arrow operator so that
	// members of T can be accessed
	// like a pointer (useful if T represents
	// a class or struct or union type)
	T* operator->() { return ptr; }
};

int main()
{
	SmartPtr<int> ptr(new int());
	*ptr = 20;
	cout << *ptr;
	return 0;
}
 Output: 20
 Note: Smart pointers can also be used to manage resources such as file handles or network sockets. Smart Pointer Types 1. unique ptr Only one pointer is stored in unique ptr. By removing the current object from the pointer, we can assign a different object. Take note of the code below. First, the unique_pointer is pointing to P1. However, we remove P1 and replace it with P2, so the pointer now points to P2. C++ Code 
#include <iostream>
using namespace std;
#include <memory>

class Rectangle {
	int length;
	int breadth;

public:
	Rectangle(int l, int b){
		length = l;
		breadth = b;
	}

	int area(){
		return length * breadth;
	}
};

int main(){

	unique_ptr<Rectangle> P1(new Rectangle(10, 5));
	cout << P1->area() << endl; // This'll print 50

	// unique_ptr<Rectangle> P2(P1);
	unique_ptr<Rectangle> P2;
	P2 = move(P1);

	// This'll print 50
	cout << P2->area() << endl;

	// cout<<P1->area()<<endl;
	return 0;
}
 Output: 50
50
 2. shared_ptr Using shared ptr, multiple pointers can point to the same object at the same time, and it will keep a reference counter using the use count() method. C++ Code 
#include <iostream>
using namespace std;
#include <memory>

class Rectangle {
	int length;
	int breadth;

public:
	Rectangle(int l, int b)
	{
		length = l;
		breadth = b;
	}

	int area()
	{
		return length * breadth;
	}
};

int main()
{

	shared_ptr<Rectangle> P1(new Rectangle(10, 5));
	// This'll print 50
	cout << P1->area() << endl;

	shared_ptr<Rectangle> P2;
	P2 = P1;

	// This'll print 50
	cout << P2->area() << endl;

	// This'll now not give an error,
	cout << P1->area() << endl;

	// This'll also print 50 now
	// This'll print 2 as Reference Counter is 2
	cout << P1.use_count() << endl;
	return 0;
}
 Output: 50
50
50
2
 3. weak_ptr It is very similar to shared ptr, except that it does not keep a Reference Counter. A pointer will not have a stronghold on the object in this case. The reason for this is that if pointers are holding the object while requesting other objects, they may form a deadlock. Next TopicCurrency Converter in C++ ? prev next ? For Videos Join Our Youtube Channel: Join Now Feedback Send your Feedback to [email protected] Help Others, Please Share Learn Latest Tutorials Splunk SPSS Swagger Transact-SQL Tumblr ReactJS Regex Reinforcement Learning R Programming RxJS React Native Python Design Patterns Python Pillow Python Turtle Keras Preparation Aptitude Reasoning Verbal Ability Interview Questions Company Questions Trending Technologies Artificial Intelligence AWS Selenium Cloud Computing Hadoop ReactJS Data Science Angular 7 Blockchain Git Machine Learning DevOps B.Tech / MCA DBMS Data Structures DAA Operating System Computer Network Compiler Design Computer Organization Discrete Mathematics Ethical Hacking Computer Graphics Software Engineering Web Technology Cyber Security Automata C Programming C++ Java .Net Python Programs Control System Data Mining Data Warehouse Javatpoint Services JavaTpoint offers too many high quality services. Mail us on [email protected], to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at [email protected] Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2021 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.